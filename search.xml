<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mysql事务</title>
    <url>/2023/07/14/Mysql%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="事务基础知识"><a href="#事务基础知识" class="headerlink" title="事务基础知识"></a>事务基础知识</h2><h3 id="数据库事务概述"><a href="#数据库事务概述" class="headerlink" title="数据库事务概述"></a>数据库事务概述</h3><h4 id="存储引擎支持情况"><a href="#存储引擎支持情况" class="headerlink" title="存储引擎支持情况"></a>存储引擎支持情况</h4><p><code>SHOW ENGINES</code> 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。</p>
<p><img src="image-20230801145959423.png" alt="image-20230801145959423"></p>
<p>能看出在 MySQL 中，只有InnoDB 是支持事务的。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>事务：</strong>一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p>
<p><strong>事务处理的原则：</strong>保证所有事务都作为 <code>一个工作单元</code> 来执行，即使出现了故障，都不能改变这种执行方 式。当在一个事务中执行多个操作时，要么所有的事务都被提交( <code>commit</code> )，那么这些修改就 <code>永久</code> 地保 <code>存下来</code>；要么数据库管理系统将 <code>放弃</code> 所作的所有 <code>修改</code> ，整个事务回滚( rollback )到最初状态。</p>
<h4 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h4><ul>
<li><p><strong>原子性（atomicity）：</strong></p>
<p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。即要么转账成功，要么转账失败，是不存在中间的状态。如果无法保证原子性会怎么样？就会出现数据不一致的情形，A账户减去100元，而B账户增加100元操作失败，系统将无故丢失100元。</p>
</li>
<li><p><strong>一致性（consistency）：</strong></p>
<p>（国内很多网站上对一致性的阐述有误，具体你可以参考 Wikipedia 对Consistency的阐述）</p>
<p>根据定义，一致性是指事务执行前后，数据从一个 <code>合法性状态</code> 变换到另外一个 <code>合法性状态</code> 。这种状态是 <code>语义上</code> 的而不是语法上的，跟具体的业务有关。</p>
<p>那什么是合法的数据状态呢？满足 <code>预定的约束</code> 的状态就叫做合法的状态。通俗一点，这状态是由你自己来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就 是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作 之前的状态。</p>
<p><strong>举例1：</strong>A账户有200元，转账300元出去，此时A账户余额为-100元。你自然就发现此时数据是不一致的，为什么呢？因为你定义了一个状态，余额这列必须&gt;&#x3D;0。</p>
<p><strong>举例2：</strong>A账户有200元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。你也知道此时的数据是不一致的，为什么呢？因为你定义了一个状态，要求A+B的总余额必须不变。</p>
<p><strong>举例3：</strong>在数据表中我们将<code>姓名</code>字段设置为<code>唯一性约束</code>，这时当事务进行提交或者事务发生回滚的时候，如果数据表的姓名不唯一，就破坏了事务的一致性要求。</p>
</li>
<li><p><strong>隔离型（isolation）：</strong></p>
<p>事务的隔离性是指一个事务的执行<code>不能被其他事务干扰</code>，即一个事务内部的操作及使用的数据对<code>并发</code>的其他事务是隔离的，并发执行的各个事务之间不能相互干扰。</p>
<p>如果无法保证隔离性会怎么样？假设A账户有200元，B账户0元。A账户往B账户转账两次，每次金额为50 元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">50</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;AA&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">50</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;BB&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230801150059629.png" alt="image-2023080115005962"></p>
</li>
<li><p><strong>持久性（durability）：</strong></p>
<p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是 永久性的 ，接下来的其他操作和数据库 故障不应该对其有任何影响。</p>
<p>持久性是通过 <code>事务日志</code> 来保证的。日志包括了 <code>重做日志</code> 和 <code>回滚日志</code> 。当我们通过事务对数据进行修改 的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做 的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执 行，从而使事务具有持久性。</p>
</li>
</ul>
<blockquote>
<p>总结</p>
<p>ACID是事务的四大特征，在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件， 而持久性是我们的目的。</p>
<p>数据库事务，其实就是数据库设计者为了方便起见，把需要保证<code>原子性</code>、<code>隔离性</code>、<code>一致性</code>和<code>持久性</code>的一个或多个数据库操作称为一个事务。</p>
</blockquote>
<h4 id="事务的状态"><a href="#事务的状态" class="headerlink" title="事务的状态"></a>事务的状态</h4><p>我们现在知道 <code>事务</code> 是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执 行的不同阶段把 <code>事务</code> 大致划分成几个状态：</p>
<ul>
<li><p><strong>活动的（active）</strong></p>
<p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在 <code>活动的</code> 状态。</p>
</li>
<li><p><strong>部分提交的（partially committed）</strong></p>
<p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并 <code>没有刷新到磁盘</code> 时，我们就说该事务处在 <code>部分提交的</code> 状态。</p>
</li>
<li><p><strong>失败的（failed）</strong></p>
<p>当事务处在 <code>活动的</code> 或者 部分提交的 状态时，可能遇到了某些错误（数据库自身的错误、操作系统 错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 失 败的 状态。</p>
</li>
<li><p><strong>中止的（aborted）</strong></p>
<p>如果事务执行了一部分而变为 <code>失败的</code> 状态，那么就需要把已经修改的事务中的操作还原到事务执 行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为 <code>回滚</code> 。当 <code>回滚</code> 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事 务处在了 <code>中止的</code> 状态。</p>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">50</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;AA&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">50</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;BB&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>提交的（committed）</strong></p>
<p>当一个处在 <code>部分提交的</code> 状态的事务将修改过的数据都 <code>同步到磁盘</code> 上之后，我们就可以说该事务处在了 <code>提交的</code> 状态。</p>
<p>一个基本的状态转换图如下所示：</p>
<p><img src="image-20230801151127716.png" alt="image-20230801151127716"></p>
<p>图中可见，只有当事务处于<code>提交的</code>或者<code>中止的</code>状态时，一个事务的生命周期才算是结束了。对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，对于处于中止状态的事务，该事务对数据库所做的所有修改都会被回滚到没执行该事务之前的状态。</p>
</li>
</ul>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>MySQL是一个 <code>客户端／服务器</code> 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每 个客户端与服务器连接上之后，就可以称为一个会话（ <code>Session</code> ）。每个客户端都可以在自己的会话中 向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。事务有 <code>隔离性</code> 的特性，理论上在某个事务 <code>对某个数据进行访问</code> 时，其他事务应该进行<code>排队</code> ，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对 <code>性能影响太大</code> ，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时 <code>性能尽量高些</code> ，那就看二者如何权衡取 舍了。</p>
<h4 id="数据并发问题"><a href="#数据并发问题" class="headerlink" title="数据并发问题"></a>数据并发问题</h4><p>针对事务的隔离性和并发性，我们怎么做取舍呢？先看一下访问相同数据的事务在 不保证串行执行 （也 就是执行完一个再执行另一个）的情况下可能会出现哪些问题：</p>
<p><strong>1. 脏写（ Dirty Write ）</strong></p>
<p>对于两个事务 Session A、Session B，如果事务Session A <code>修改了</code> 另一个 <code>未提交</code> 事务Session B <code>修改过</code> 的数据，那就意味着发生了 <code>脏写</code>，示意图如下：</p>
<p><img src="image-20230801153045743.png"></p>
<p>Session A 和 Session B 各开启了一个事务，Sesssion B 中的事务先将studentno列为1的记录的name列更新为’李四’，然后Session A中的事务接着又把这条studentno列为1的记录的name列更新为’张三’。如果之后Session B中的事务进行了回滚，那么Session A中的更新也将不复存在，这种现象称之为脏写。这时Session A中的事务就没有效果了，明明把数据更新了，最后也提交事务了，最后看到的数据什么变化也没有。这里大家对事务的隔离性比较了解的话，会发现默认隔离级别下，上面Session A中的更新语句会处于等待状态，这里只是跟大家说明一下会出现这样的现象。</p>
<p><strong>2. 脏读（ Dirty Read ）</strong></p>
<p>对于两个事务 Session A、Session B，Session A <code>读取</code> 了已经被 Session B <code>更新</code> 但还 <code>没有被提交</code> 的字段。 之后若 Session B <code>回滚</code> ，Session A <code>读取 </code>的内容就是 <code>临时且无效</code> 的。</p>
<p><img src="image-20230801160024416.png"></p>
<p>Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新 为’张三’，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为’张三’，而 Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象就称之为 <code>脏读</code> 。</p>
<p><strong>3. 不可重复读（ Non-Repeatable Read ）</strong></p>
<p>对于两个事务Session A、Session B，Session A <code>读取</code>了一个字段，然后 Session B <code>更新</code>了该字段。 之后 Session A <code>再次读取</code> 同一个字段， <code>值就不同</code> 了。那就意味着发生了不可重复读。</p>
<p><img src="image-20230801160104794.png"></p>
<p>我们在Session B中提交了几个 <code>隐式事务</code> （注意是隐式事务，意味着语句结束事务就提交了），这些事务 都修改了studentno列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看到最新的值，这种现象也被称之为 <code>不可重复读 </code>。</p>
<p><strong>4. 幻读（ Phantom ）</strong></p>
<p>对于两个事务Session A、Session B, Session A 从一个表中 <code>读取</code> 了一个字段, 然后 Session B 在该表中 插 入 了一些新的行。 之后, 如果 Session A <code>再次读取</code> 同一个表, 就会多几行。那就意味着发生了<code>幻读</code>。</p>
<p><img src="image-20230801160216122.png"></p>
<p>Session A中的事务先根据条件 studentno &gt; 0这个条件查询表student，得到了name列值为’张三’的记录； 之后Session B中提交了一个 <code>隐式事务</code> ，该事务向表student中插入了一条新记录；之后Session A中的事务 再根据相同的条件 studentno &gt; 0查询表student，得到的结果集中包含Session B中的事务新插入的那条记 录，这种现象也被称之为 幻读 。我们把新插入的那些记录称之为 <code>幻影记录</code> 。</p>
<p><img src="image-20230801160255913.png"></p>
<h4 id="SQL中的四种隔离级别"><a href="#SQL中的四种隔离级别" class="headerlink" title="SQL中的四种隔离级别"></a>SQL中的四种隔离级别</h4><p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题 按照严重性来排一下序：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</span><br></pre></td></tr></table></figure>

<p>我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并发问题发生的就越多。 <code>SQL标准</code> 中设立了4个 <code>隔离级别</code> ：</p>
<ul>
<li><code>READ UNCOMMITTED</code> ：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li>
<li><code>READ COMMITTED</code> ：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做 的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</li>
<li><code>REPEATABLE READ</code> ：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍 然存在。这是MySQL的默认隔离级别。</li>
<li><code>SERIALIZABLE</code> ：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止 其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避 免脏读、不可重复读和幻读。</li>
</ul>
<p><code>SQL标准</code> 中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：</p>
<p><img src="image-20230801160453525-1690877212549-3.png"></p>
<p><code>脏写 </code>怎么没涉及到？因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。</p>
<p>不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4 种事务隔离级别与并发性能的关系如下：</p>
<p><img src="image-20230801160530873.png"></p>
<h4 id="MySQL支持的四种隔离级别"><a href="#MySQL支持的四种隔离级别" class="headerlink" title="MySQL支持的四种隔离级别"></a>MySQL支持的四种隔离级别</h4><p><img src="image-20230801160902335.png" alt="image-20230801160902335"></p>
<p>MySQL的默认隔离级别为REPEATABLE READ，我们可以手动修改一下事务的隔离级别。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查看隔离级别，MySQL <span class="number">5.7</span><span class="number">.20</span>的版本之前：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;tx_isolation&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> tx_isolation  <span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"># MySQL <span class="number">5.7</span><span class="number">.20</span>版本之后，引入transaction_isolation来替换tx_isolation</span><br><span class="line"></span><br><span class="line"># 查看隔离级别，MySQL <span class="number">5.7</span><span class="number">.20</span>的版本及之后：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name         <span class="operator">|</span> <span class="keyword">Value</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> transaction_isolation <span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">#或者不同MySQL版本中都可以使用的：</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;</span><br></pre></td></tr></table></figure>

<h4 id="如何设置事务的隔离级别"><a href="#如何设置事务的隔离级别" class="headerlink" title="如何设置事务的隔离级别"></a>如何设置事务的隔离级别</h4><p><strong>通过下面的语句修改事务的隔离级别：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;</span><br><span class="line">#其中，隔离级别格式：</span><br><span class="line">&gt; READ UNCOMMITTED</span><br><span class="line">&gt; READ COMMITTED</span><br><span class="line">&gt; REPEATABLE READ</span><br><span class="line">&gt; SERIALIZABLE</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = &#x27;隔离级别&#x27;</span><br><span class="line">#其中，隔离级别格式：</span><br><span class="line">&gt; READ-UNCOMMITTED</span><br><span class="line">&gt; READ-COMMITTED</span><br><span class="line">&gt; REPEATABLE-READ</span><br><span class="line">&gt; SERIALIZABLE</span><br></pre></td></tr></table></figure>

<p><strong>关于设置时使用GLOBAL或SESSION的影响：</strong></p>
<ul>
<li><p>使用 GLOBAL 关键字（在全局范围影响）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">#或</span><br><span class="line">SET GLOBAL TRANSACTION_ISOLATION = &#x27;SERIALIZABLE&#x27;;</span><br></pre></td></tr></table></figure>

<p>则：</p>
<ul>
<li>当前已经存在的会话无效</li>
<li>只对执行完该语句之后产生的会话起作用</li>
</ul>
</li>
<li><p>使用 <code>SESSION</code> 关键字（在会话范围影响）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">#或</span><br><span class="line">SET SESSION TRANSACTION_ISOLATION = &#x27;SERIALIZABLE&#x27;;</span><br></pre></td></tr></table></figure>

<p>则：</p>
<ul>
<li>对当前会话的所有后续的事务有效</li>
<li>如果在事务之间执行，则对后续的事务有效</li>
<li>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</li>
</ul>
</li>
</ul>
<p>如果在服务器启动时想改变事务的默认隔离级别，可以修改启动参数<code>transaction_isolation</code>的值。比如，在启动服务器时指定了<code>transaction_isolation=SERIALIZABLE</code>，那么事务的默认隔离界别就从原来的<code>REPEATABLE-READ</code>变成了<code>SERIALIZABLE</code>。</p>
<blockquote>
<p>小结：</p>
<p>数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。</p>
</blockquote>
<h4 id="事务的常见分类"><a href="#事务的常见分类" class="headerlink" title="事务的常见分类"></a>事务的常见分类</h4><p>从事务理论的角度来看，可以把事务分为以下几种类型：</p>
<ul>
<li>扁平事务（Flat Transactions）</li>
<li>带有保存点的扁平事务（Flat Transactions with Savepoints）</li>
<li>链事务（Chained Transactions）</li>
<li>嵌套事务（Nested Transactions）</li>
<li>分布式事务（Distributed Transactions）</li>
</ul>
<h2 id="MySQL事务日志"><a href="#MySQL事务日志" class="headerlink" title="MySQL事务日志"></a>MySQL事务日志</h2><p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p>
<ul>
<li>事务的隔离性由 <code>锁机制</code> 实现。</li>
<li>而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。<ul>
<li>REDO LOG 称为 <code>重做日志 </code>，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</li>
<li>UNDO LOG 称为 <code>回滚日志</code> ，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li>
</ul>
</li>
</ul>
<p>有的DBA或许会认为 UNDO 是 REDO 的逆过程，其实不然。REDO 和 UNDO都可以视为是一种 <code>恢复操作</code>，但是：</p>
<ul>
<li>redo log: 是存储引擎层 (innodb) 生成的日志，记录的是<code>&quot;物理级别&quot;</code>上的页修改操作，比如页号xxx，偏移量yyy写入了’zzz’数据。主要为了保证数据的可靠性。</li>
<li>undo log: 是存储引擎层 (innodb) 生成的日志，记录的是 <code>逻辑操作</code> 日志，比如对某一行数据进行了INSERT语句操作，那么undo log就记录一条与之相反的DELETE操作。主要用于 <code>事务的回滚</code> (undo log 记录的是每个修改操作的 <code>逆操作</code>) 和 <code>一致性非锁定读</code> (undo log 回滚行记录到某种特定的版本——MVCC，即多版本并发控制)。</li>
</ul>
<h3 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h3><p>InnoDB存储引擎是以<code>页为单位</code>来管理存储空间的。在真正访问页面之前，需要把在<code>磁盘上</code>的页缓存到内存中的<code>Buffer Pool</code>之后才可以访问。所有的变更都必须<code>先更新缓冲池</code>中的数据，然后缓冲池中的<code>脏页</code>会以一定的频率被刷入磁盘 (<code>checkPoint</code>机制)，通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p>
<h4 id="为什么需要REDO日志"><a href="#为什么需要REDO日志" class="headerlink" title="为什么需要REDO日志"></a>为什么需要REDO日志</h4><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然 而由于checkpoint <code>并不是每次变更的时候就触发</code> 的，而是master线程隔一段时间去处理的。所以最坏的情 况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p>
<p>另一方面，事务包含 <code>持久性</code> 的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p>
<p>那么如何保证这个持久性呢？ <code>一个简单的做法</code> ：在事务提交完成之前把该事务所修改的所有页面都刷新 到磁盘，但是这个简单粗暴的做法有些问题:</p>
<ul>
<li><p><strong>修改量与刷新磁盘工作量严重不成比例</strong></p>
<p>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在InnoDB中是以页为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个默认页面时16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是小题大做了。</p>
</li>
<li><p><strong>随机IO刷新较慢</strong></p>
<p>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面<code>刷新到磁盘</code>时，需要进行很多的<code>随机IO</code>，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。</p>
</li>
</ul>
<p><code>另一个解决的思路</code> ：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系 统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内 存中修改过的全部页面刷新到磁盘，只需要把 修改 了哪些东西 记录一下 就好。比如，某个事务将系统 表空间中 第10号 页面中偏移量为 100 处的那个字节的值 1 改成 2 。我们只需要记录一下：将第0号表 空间的10号页面的偏移量为100处的值更新为 2</p>
<p>InnoDB引擎的事务采用了WAL技术 (<code>Write-Ahead Logging</code>)，这种技术的思想就是先写日志，再写磁盘，只有日志写入成功，才算事务提交成功，这里的日志就是redo log。当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID中的D，这就是redo log的作用。</p>
<p><img src="image-20230802144203432.png" alt="image-20230802144203432"></p>
<h4 id="REDO日志的好处、特点"><a href="#REDO日志的好处、特点" class="headerlink" title="REDO日志的好处、特点"></a>REDO日志的好处、特点</h4><h5 id="1-好处"><a href="#1-好处" class="headerlink" title="1. 好处"></a>1. 好处</h5><ul>
<li>redo日志降低了刷盘频率</li>
<li>redo日志占用的空间非常小</li>
</ul>
<p>存储表空间ID、页号、偏移量以及需要更新的值，所需的存储空间是很小的，刷盘快。</p>
<h5 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h5><ul>
<li><p><strong>redo日志是顺序写入磁盘的</strong></p>
<p>在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照<code>产生的顺序写入磁盘的</code>，也就是使用顺序ID，效率比随机IO快。</p>
</li>
<li><p><strong>事务执行过程中，redo log不断记录</strong></p>
<p>redo log跟bin log的区别，redo log是<code>存储引擎层</code>产生的，而bin log是<code>数据库层</code>产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。</p>
</li>
</ul>
<h4 id="redo的组成"><a href="#redo的组成" class="headerlink" title="redo的组成"></a>redo的组成</h4><p>Redo log可以简单分为以下两个部分：</p>
<ul>
<li><code>重做日志的缓冲 (redo log buffer)</code> ，保存在内存中，是易失的。</li>
</ul>
<p>在服务器启动时就会向操作系统申请了一大片称之为 redo log buffer 的 <code>连续内存</code> 空间，翻译成中文就是redo日志缓冲区。这片内存空间被划分为若干个连续的<code>redo log block</code>。一个redo log block占用<code>512字节</code>大小。</p>
<p><img src="image-20230802144427499.png" alt="image-20230802144427499"></p>
<p><strong>参数设置：innodb_log_buffer_size：</strong></p>
<p>redo log buffer 大小，默认 <code>16M</code> ，最大值是4096M，最小值为1M。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_log_buffer_size%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name          <span class="operator">|</span> <span class="keyword">Value</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> innodb_log_buffer_size <span class="operator">|</span> <span class="number">16777216</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>重做日志文件 (redo log file) </code>，保存在硬盘中，是持久的。</li>
</ul>
<p>REDO日志文件如图所示，其中<code>ib_logfile0</code>和<code>ib_logfile1</code>即为REDO日志。</p>
<p><img src="image-20230802144544464.png" alt="image-20230802144544464"></p>
<h4 id="redo的整体流程"><a href="#redo的整体流程" class="headerlink" title="redo的整体流程"></a>redo的整体流程</h4><p>以一个更新事务为例，redo log 流转过程，如下图所示：</p>
<p><img src="image-20230802144609384.png" alt="image-20230802144609384"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝</span><br><span class="line">第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值</span><br><span class="line">第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式</span><br><span class="line">第4步：定期将内存中修改的数据刷新到磁盘中</span><br></pre></td></tr></table></figure>

<blockquote>
<p>体会： Write-Ahead Log(预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化。</p>
</blockquote>
<h4 id="redo-log的刷盘策略"><a href="#redo-log的刷盘策略" class="headerlink" title="redo log的刷盘策略"></a>redo log的刷盘策略</h4><p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以<code>一 定的频率</code>刷入到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。</p>
<p><img src="image-20230802144727812.png" alt="image-20230802144727812"> </p>
<p>注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到 <code>文件系统缓存 （page cache）</code>中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同 步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p>
<p>针对这种情况，InnoDB给出 <code>innodb_flush_log_at_trx_commit</code> 参数，该参数控制 commit提交事务 时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p>
<ul>
<li><code>设置为0</code> ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步） 第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝 第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值 第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加 写的方式 第4步：定期将内存中修改的数据刷新到磁盘中</li>
<li><code>设置为1</code> ：表示每次事务提交时都将进行同步，刷盘操作（ 默认值 ）</li>
<li><code>设置为2</code> ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</li>
</ul>
<p><img src="image-20230802151248029.png" alt="image-20230802151248029"></p>
<p>另外，InnoDB存储引擎有一个后台线程，每隔<code>1秒</code>，就会把<code>redo log buffer</code>中的内容写到文件系统缓存(<code>page cache</code>)，然后调用刷盘操作。</p>
<p><img src="image-20230802151309371.png" alt="image-20230802151309371"></p>
<p>也就是说，一个没有提交事务的<code>redo log</code>记录，也可能会刷盘。因为在事务执行过程 redo log 记录是会写入 <code>redo log buffer</code>中，这些redo log 记录会被<code>后台线程</code>刷盘。</p>
<p><img src="image-20230802151545478.png" alt="image-20230802151545478"></p>
<p>除了后台线程每秒<code>1次</code>的轮询操作，还有一种情况，当<code>redo log buffer</code>占用的空间即将达到<code>innodb_log_buffer_size</code>（这个参数默认是16M）的一半的时候，后台线程会主动刷盘。</p>
<h4 id="不同刷盘策略演示"><a href="#不同刷盘策略演示" class="headerlink" title="不同刷盘策略演示"></a>不同刷盘策略演示</h4><p><img src="image-20230802151634999.png" alt="image-20230802151634999"></p>
<p><img src="image-20230802151711278.png" alt="image-20230802151711278"></p>
<p><img src="image-20230802151915472.png" alt="image-20230802151915472"></p>
<p><img src="image-20230802151937568.png" alt="image-20230802151937568"></p>
<p><img src="image-20230802152022293.png" alt="image-20230802152022293"></p>
<p><img src="image-20230802152042521.png" alt="image-20230802152042521"></p>
<h4 id="写入redo-log-buffer-过程"><a href="#写入redo-log-buffer-过程" class="headerlink" title="写入redo log buffer 过程"></a>写入redo log buffer 过程</h4><h5 id="补充概念：Mini-Transaction"><a href="#补充概念：Mini-Transaction" class="headerlink" title="补充概念：Mini-Transaction"></a>补充概念：Mini-Transaction</h5><p>MySQL把对底层页面中的一次原子访问过程称之为一个<code>Mini-Transaction</code>，简称<code>mtr</code>，比如，向某个索引对应的B+树中插入一条记录的过程就是一个<code>Mini-Transaction</code>。一个所谓的<code>mtr</code>可以包含一组redo日志，在进行崩溃恢复时这一组<code>redo</code>日志可以作为一个不可分割的整体。</p>
<p>一个事务可以包含若干条语句，每一条语句其实是由若干个 <code>mtr</code> 组成，每一个 <code>mtr</code> 又可以包含若干条 redo日志，画个图表示它们的关系就是这样：</p>
<h5 id="redo-日志写入log-buffer"><a href="#redo-日志写入log-buffer" class="headerlink" title="redo 日志写入log buffer"></a>redo 日志写入log buffer</h5><p><img src="image-20230802152403056.png" alt="image-20230802152403056"></p>
<p><img src="image-20230802152414127.png" alt="image-20230802152414127"></p>
<p><img src="image-20230802152426349.png" alt="image-20230802152426349"></p>
<p><img src="image-20230802152442003.png" alt="image-20230802152442003"></p>
<p>不同的事务可能是 <code>并发</code> 执行的，所以 T1 、 T2 之间的 mtr 可能是 <code>交替执行</code> 的。没当一个mtr执行完成时，伴随该mtr生成的一组redo日志就需要被复制到log buffer中，也就是说不同事务的mtr可能是交替写入log buffer的，我们画个示意图（为了美观，我们把一个mtr中产生的所有redo日志当做一个整体来画）：<img src="image-20230802152804545.png" alt="image-20230802152804545"></p>
<p>有的mtr产生的redo日志量非常大，比如<code>mtr_t1_2</code>产生的redo日志占用空间比较大，占用了3个block来存储。</p>
<h5 id="redo-log-block的结构图"><a href="#redo-log-block的结构图" class="headerlink" title="redo log block的结构图"></a>redo log block的结构图</h5><p>一个redo log block是由<code>日志头、日志体、日志尾</code>组成。日志头占用12字节，日志尾占用8字节，所以一个block真正能存储的数据是512-12-8&#x3D;492字节。</p>
<p><img src="image-20230802164532750.png" alt="image-20230802164532750"></p>
<p><img src="image-20230802164547458.png" alt="image-20230802164547458"></p>
<p>真正的redo日志都是存储到占用<code>496</code>字节大小的<code>log block body</code>中，图中的<code>log block header</code>和<code>log block trailer</code>存储的是一些管理信息。我们来看看这些所谓<code>管理信息</code>都有什么。</p>
<p><img src="image-20230802165339762.png" alt="image-20230802165339762"></p>
<p><img src="image-20230802165414545.png" alt="image-20230802165414545"></p>
<h4 id="redo-log-file"><a href="#redo-log-file" class="headerlink" title="redo log file"></a>redo log file</h4><h5 id="相关参数设置"><a href="#相关参数设置" class="headerlink" title="相关参数设置"></a>相关参数设置</h5><ul>
<li><p><code>innodb_log_group_home_dir</code> ：指定 redo log 文件组所在的路径，默认值为 <code>./</code> ，表示在数据库 的数据目录下。MySQL的默认数据目录（ <code>var/lib/mysql</code>）下默认有两个名为 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> 的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志 文件位置还可以修改。</p>
</li>
<li><p><code>innodb_log_files_in_group</code>：指明redo log file的个数，命名方式如：ib_logfile0，iblogfile1… iblogfilen。默认2个，最大100个。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_log_files_in_group&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name             <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_log_files_in_group <span class="operator">|</span> <span class="number">2</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line">#ib_logfile0</span><br><span class="line">#ib_logfile1</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>innodb_flush_log_at_trx_commit</code>：控制 redo log 刷新到磁盘的策略，默认为1。</p>
</li>
<li><p><code>innodb_log_file_size</code>：单个 redo log 文件设置大小，默认值为 <code>48M</code> 。最大值为512G，注意最大值 指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大 于最大值512G。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_log_file_size&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name        <span class="operator">|</span> <span class="keyword">Value</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> innodb_log_file_size <span class="operator">|</span> <span class="number">50331648</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>根据业务修改其大小，以便容纳较大的事务。编辑my.cnf文件并重启数据库生效，如下所示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/my.cnf</span><br><span class="line">innodb_log_file_size=200M</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在数据库实例更新比较频繁的情况下，可以适当加大 redo log 数组和大小。但也不推荐 redo log 设置过大，在MySQL崩溃时会重新执行REDO日志中的记录。</p>
</blockquote>
<h5 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h5><p><img src="image-20230802165553698.png" alt="image-20230802165553698"></p>
<p><img src="image-20230802165606190.png" alt="image-20230802165606190"></p>
<p>总共的redo日志文件大小其实就是： <code>innodb_log_file_size × innodb_log_files_in_group</code> 。</p>
<p>采用循环使用的方式向redo日志文件组里写数据的话，会导致后写入的redo日志覆盖掉前边写的redo日志？当然！所以InnoDB的设计者提出了checkpoint的概念。</p>
<h5 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h5><p>在整个日志文件组中还有两个重要的属性，分别是 write pos、checkpoint</p>
<ul>
<li><code>write pos</code>是当前记录的位置，一边写一边后移</li>
<li><code>checkpoint</code>是当前要擦除的位置，也是往后推移</li>
</ul>
<p>每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。每次MySQL加载日志文件组恢复数据时，会清空加载过的 redo log 记录，并把check point后移更新。write pos 和 checkpoint 之间的还空着的部分可以用来写入新的 redo log 记录。</p>
<p><img src="image-20230802165638010.png" alt="image-20230802165638010"></p>
<p>如果 write pos 追上 checkpoint ，表示<code>日志文件组</code>满了，这时候不能再写入新的 redo log记录，MySQL 得 停下来，清空一些记录，把 checkpoint 推进一下。</p>
<p><img src="image-20230802165653115.png" alt="image-20230802165653115"></p>
<h4 id="redo-log-小结"><a href="#redo-log-小结" class="headerlink" title="redo log 小结"></a>redo log 小结</h4><p><img src="image-20230802165719041.png" alt="image-20230802165719041"></p>
<h3 id="Undo日志"><a href="#Undo日志" class="headerlink" title="Undo日志"></a>Undo日志</h3><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中 <code>更新数据</code> 的 <code>前置操作</code> 其实是要先写入一个 <code>undo log</code> 。</p>
<h4 id="如何理解Undo日志"><a href="#如何理解Undo日志" class="headerlink" title="如何理解Undo日志"></a>如何理解Undo日志</h4><p>事务需要保证 <code>原子性 </code>，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p>
<ul>
<li>情况一：事务执行过程中可能遇到各种错误，比如<code> 服务器本身的错误</code> ， <code>操作系统错误</code> ，甚至是突然 <code>断电</code> 导致的错误。</li>
<li>情况二：程序员可以在事务执行过程中手动输入 <code>ROLLBACK</code> 语句结束当前事务的执行。</li>
</ul>
<p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为 <code>回滚</code> ，这样就可以造成一个假象：这 个事务看起来什么都没做，所以符合 <code>原子性</code> 要求。</p>
<p><img src="image-20230804110133593.png" alt="image-20230804110133593"></p>
<h4 id="Undo日志的作用"><a href="#Undo日志的作用" class="headerlink" title="Undo日志的作用"></a>Undo日志的作用</h4><ul>
<li><p><strong>作用1：回滚数据</strong></p>
<p><img src="image-20230804140345785.png" alt="image-20230804140345785"></p>
</li>
<li><p><strong>作用2：MVCC</strong></p>
<p>undo的另一个作用是MVCC，即在InnoDB存储引擎中MVCC的实现是通过undo来完成。当用户读取一行记录时，若该记录以及被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p>
</li>
</ul>
<h4 id="undo的存储结构"><a href="#undo的存储结构" class="headerlink" title="undo的存储结构"></a>undo的存储结构</h4><h5 id="回滚段与undo页"><a href="#回滚段与undo页" class="headerlink" title="回滚段与undo页"></a>回滚段与undo页</h5><p>InnoDB对undo log的管理采用段的方式，也就是 <code>回滚段（rollback segment）</code> 。每个回滚段记录了 <code>1024</code> 个 <code>undo log segment</code> ，而在每个undo log segment段中进行 <code>undo页</code> 的申请。</p>
<ul>
<li>在<code> InnoDB1.1版本之前</code> （不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为 <code>1024</code> 。虽然对绝大多数的应用来说都已经够用。</li>
<li>从1.1版本开始InnoDB支持最大 <code>128个rollback segment</code> ，故其支持同时在线的事务限制提高到 了 <code>128*1024</code> 。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_undo_logs&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_undo_logs <span class="operator">|</span> <span class="number">128</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br></pre></td></tr></table></figure>

<p><img src="image-20230804140834823.png" alt="image-20230804140834823"></p>
<p><img src="image-20230804140849621.png" alt="image-20230804140849621"></p>
<h5 id="回滚段与事务"><a href="#回滚段与事务" class="headerlink" title="回滚段与事务"></a>回滚段与事务</h5><ol>
<li><p>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p>
</li>
<li><p>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</p>
</li>
<li><p>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</p>
</li>
<li><p>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个 undo表空间。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_undo_tablespaces&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name           <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_undo_tablespaces <span class="operator">|</span> <span class="number">2</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"># undo log的数量，最少为<span class="number">2.</span> undo log的<span class="keyword">truncate</span>操作有purge协调线程发起。在<span class="keyword">truncate</span>某个undo log表空间的过程中，保证有一个可用的undo log可用。</span><br></pre></td></tr></table></figure>
</li>
<li><p>当事务提交时，InnoDB存储引擎会做以下两件事情：</p>
<ul>
<li>将undo log放入列表中，以供之后的purge操作</li>
<li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li>
</ul>
</li>
</ol>
<h5 id="回滚段中的数据分类"><a href="#回滚段中的数据分类" class="headerlink" title="回滚段中的数据分类"></a>回滚段中的数据分类</h5><ol>
<li><code>未提交的回滚数据(uncommitted undo information)</code>：该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。</li>
<li><code>已经提交但未过期的回滚数据(committed undo information)</code>：该数据关联的事务已经提交，但是仍受到undo retention参数的保持时间的影响。</li>
<li><code>事务已经提交并过期的数据(expired undo information)</code>：事务已经提交，而且数据保存时间已经超过 undo retention参数指定的时间，属于已经过期的数据。当回滚段满了之后，就优先覆盖“事务已经提交并过期的数据”。</li>
</ol>
<p>事务提交后不能马上删除undo log及undo log所在的页。这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo log放入一个链表中，是否可以最终删除undo log以undo log所在页由purge线程来判断。</p>
<h5 id="undo的类型"><a href="#undo的类型" class="headerlink" title="undo的类型"></a>undo的类型</h5><p>在InnoDB存储引擎中，undo log分为：</p>
<ul>
<li><p>insert undo log</p>
<p>insert undo log是指insert操作中产生的undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见（这是事务隔离性的要求），故该undo log可以在事务提交后直接删除。不需要进行purge操作。</p>
</li>
<li><p>update undo log</p>
<p>update undo log记录的是对delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p>
</li>
</ul>
<h4 id="undo-log的生命周期"><a href="#undo-log的生命周期" class="headerlink" title="undo log的生命周期"></a>undo log的生命周期</h4><h5 id="简要生成过程"><a href="#简要生成过程" class="headerlink" title="简要生成过程"></a>简要生成过程</h5><p>以下是undo+redo事务的简化过程</p>
<p>假设有两个数值，分别为A&#x3D;1和B&#x3D;2，然后将A修改为3，B修改为4</p>
<p><img src="image-20230804170909508.png" alt="image-20230804170909508"></p>
<p><strong>只有Buffer Pool的流程：</strong></p>
<p><img src="image-20230804170925792.png" alt="image-20230804170925792"></p>
<p><strong>有了Redo Log和Undo Log之后：</strong></p>
<p><img src="image-20230807153820127.png" alt="image-20230807153820127"></p>
<p>在更新Buffer Pool中的数据之前，我们需要先将该数据事务开始之前的状态写入Undo Log中。假设更新到一半出错了，我们就可以通过Undo Log来回滚到事务开始前。</p>
<h5 id="详细生成过程"><a href="#详细生成过程" class="headerlink" title="详细生成过程"></a>详细生成过程</h5><p><img src="image-20230807153922291.png" alt="image-20230807153922291"></p>
<p><strong>当我们执行INSERT时：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (name) <span class="keyword">VALUES</span> (&quot;tom&quot;);</span><br></pre></td></tr></table></figure>

<p>插入的数据都会生成一条insert undo log，并且数据的回滚指针会指向它。undo log会记录undo log的序号、插入主键的列和值…，那么在rollback的时候，通过主键直接把对应的数据删除即可。</p>
<p><img src="image-20230807154501926.png" alt="image-20230807154501926"></p>
<p><strong>当我们执行UPDATE时：</strong></p>
<p>对应更新的操作会产生update undo log，并且会分更新主键和不更新主键的，假设现在执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> name<span class="operator">=</span>&quot;Sun&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230807154539727.png" alt="image-20230807154539727"></p>
<p>这时会把老的记录写入新的undo log，让回滚指针指向新的undo log，它的undo no是1，并且新的undo log会指向老的undo log（undo no&#x3D;0）。</p>
<p>假设现在执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> id<span class="operator">=</span><span class="number">2</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230807154649214.png" alt="image-20230807154649214"></p>
<p>对于更新主键的操作，会先把原来的数据deletemark标识打开，这时并没有真正的删除数据，真正的删除会交给清理线程去判断，然后在后面插入一条新的数据，新的数据也会产生undo log，并且undo log的序号会递增。</p>
<p>可以发现每次对数据的变更都会产生一个undo log，当一条记录被变更多次时，那么就会产生多条undo log，undo log记录的是变更前的日志，并且每个undo log的序号是递增的，那么当要回滚的时候，按照序号<code>依次向前推</code>，就可以找到我们的原始数据了。</p>
<h5 id="undo-log是如何回滚的"><a href="#undo-log是如何回滚的" class="headerlink" title="undo log是如何回滚的"></a>undo log是如何回滚的</h5><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p>
<ol>
<li>通过undo no&#x3D;3的日志把id&#x3D;2的数据删除</li>
<li>通过undo no&#x3D;2的日志把id&#x3D;1的数据的deletemark还原成0</li>
<li>通过undo no&#x3D;1的日志把id&#x3D;1的数据的name还原成Tom</li>
<li>通过undo no&#x3D;0的日志把id&#x3D;1的数据删除</li>
</ol>
<h5 id="undo-log的删除"><a href="#undo-log的删除" class="headerlink" title="undo log的删除"></a>undo log的删除</h5><ul>
<li><p>针对于insert undo log</p>
<p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p>
</li>
<li><p>针对于update undo log</p>
<p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p>
</li>
</ul>
<blockquote>
<p>补充：</p>
<p>purge线程两个主要作用是：<code>清理undo页</code>和<code>清理page里面带有Delete_Bit标识的数据行</code>。在InnoDB中，事务中的Delete操作实际上并不是真正的删除掉数据行，而是一种Delete Mark操作，在记录上标识Delete_Bit，而不删除记录。是一种“假删除”，只是做了个标记，真正的删除工作需要后台purge线程去完成。</p>
</blockquote>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="image-20230807155239511.png" alt="image-20230807155239511"></p>
<p>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。</p>
<p>redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="image-20230807155344619.png" alt="image-20230807155344619"></p>
<p>在数据库中，除传统的计算资源（如CPU、RAM、I&#x2F;O等）的争用以外，数据也是一种供许多用户共享的 资源。为保证数据的一致性，需要对 <code>并发操作进行控制</code> ，因此产生了 <code>锁</code> 。同时 <code>锁机制</code> 也为实现MySQL 的各个隔离级别提供了保证。 <code>锁冲突</code> 也是影响数据库 <code>并发访问性能</code> 的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p>
<h3 id="MySQL并发事务访问相同记录"><a href="#MySQL并发事务访问相同记录" class="headerlink" title="MySQL并发事务访问相同记录"></a>MySQL并发事务访问相同记录</h3><p>并发事务访问相同记录的情况大致可以划分为3种：</p>
<h4 id="读-读情况"><a href="#读-读情况" class="headerlink" title="读-读情况"></a>读-读情况</h4><p><code>读-读</code>情况，即并发事务相继<code>读取相同的记录</code>。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p>
<h4 id="写-写情况"><a href="#写-写情况" class="headerlink" title="写-写情况"></a>写-写情况</h4><p><code>写-写</code> 情况，即并发事务相继对相同的记录做出改动。</p>
<p>在这种情况下会发生 <code>脏写</code> 的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们 <code>排队执行</code> ，这个排队的过程其实是通过 <code>锁</code> 来实现的。这个所谓的锁其实是一个内存中的结构 ，在事务执行前本来是没有锁的，也就是说一开始是没有 锁结构 和记录进 行关联的，如图所示：</p>
<p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 <code>锁结构</code> ，当没有的时候 就会在内存中生成一个 <code>锁结构</code> 与之关联。比如，事务<code> T1</code> 要对这条记录做改动，就需要生成一个 <code>锁结构</code> 与之关联：</p>
<p><img src="image-20230807160126966.png" alt="image-20230807160126966"></p>
<p>在<code>锁结构</code>里有很多信息，为了简化理解，只把两个比较重要的属性拿了出来：</p>
<ul>
<li><code>trx信息</code>：代表这个锁结构是哪个事务生成的。</li>
<li><code>is_waiting</code>：代表当前事务是否在等待。</li>
</ul>
<p>在事务<code>T1</code>改动了这条记录后，就生成了一个<code>锁结构</code>与该记录关联，因为之前没有别的事务为这条记录加锁，所以<code>is_waiting</code>属性就是<code>false</code>，我们把这个场景就称值为<code>获取锁成功</code>，或者<code>加锁成功</code>，然后就可以继续执行操作了。</p>
<p>在事务<code>T1</code>提交之前，另一个事务<code>T2</code>也想对该记录做改动，那么先看看有没有<code>锁结构</code>与这条记录关联，发现有一个<code>锁结构</code>与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的<code>is_waiting</code>属性值为<code>true</code>，表示当前事务需要等待，我们把这个场景就称之为<code>获取锁失败</code>，或者<code>加锁失败</code>，图示：</p>
<p><img src="image-20230807160821551.png" alt="image-20230807160821551"></p>
<p>在事务T1提交之后，就会把该事务生成的<code>锁结构释放</code>掉，然后看看还有没有别的事务在等待获取锁，发现了事务T2还在等待获取锁，所以把事务T2对应的锁结构的<code>is_waiting</code>属性设置为<code>false</code>，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2就算获取到锁了。效果就是这样。</p>
<p><img src="image-20230807160911177.png" alt="image-20230807160911177"></p>
<p>小结几种说法：</p>
<ul>
<li><p>不加锁</p>
<p>意思就是不需要在内存中生成对应的 <code>锁结构</code> ，可以直接执行操作。</p>
</li>
<li><p>获取锁成功，或者加锁成功</p>
<p>意思就是在内存中生成了对应的 <code>锁结构</code> ，而且锁结构的 <code>is_waiting</code> 属性为 <code>false</code> ，也就是事务 可以继续执行操作。</p>
</li>
<li><p>获取锁失败，或者加锁失败，或者没有获取到锁</p>
<p>意思就是在内存中生成了对应的 <code>锁结构</code> ，不过锁结构的 <code>is_waiting</code> 属性为 <code>true</code> ，也就是事务 需要等待，不可以继续执行操作。</p>
</li>
</ul>
<h4 id="读-写或写-读情况"><a href="#读-写或写-读情况" class="headerlink" title="读-写或写-读情况"></a>读-写或写-读情况</h4><p><code>读-写</code> 或 <code>写-读 </code>，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 <code>脏读 、 不可重复读 、 幻读</code> 的问题。</p>
<p>各个数据库厂商对 <code>SQL标准</code> 的支持都可能不一样。比如MySQL在 <code>REPEATABLE READ</code> 隔离级别上就已经解决了 <code>幻读</code> 问题。</p>
<h4 id="并发问题的解决方案"><a href="#并发问题的解决方案" class="headerlink" title="并发问题的解决方案"></a>并发问题的解决方案</h4><p>怎么解决 <code>脏读 、 不可重复读 、 幻读</code> 这些问题呢？其实有两种可选的解决方案：</p>
<ul>
<li><p>方案一：读操作利用多版本并发控制（ <code>MVCC</code> ，下章讲解），写操作进行 <code>加锁</code> 。c</p>
<p><img src="image-20230807161114342.png" alt="image-20230807161114342"></p>
<blockquote>
<p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p>
<ul>
<li>在 <code>READ COMMITTED</code> 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一 个ReadView，ReadView的存在本身就保证了<code>事务不可以读取到未提交的事务所做的更改</code> ，也就是避免了脏读现象；</li>
<li>在 <code>REPEATABLE READ</code> 隔离级别下，一个事务在执行过程中只有 <code>第一次执行SELECT操作</code> 才会生成一个ReadView，之后的SELECT操作都 <code>复用</code> 这个ReadView，这样也就避免了不可重复读和幻读的问题。</li>
</ul>
</blockquote>
</li>
<li><p>方案二：读、写操作都采用 <code>加锁</code> 的方式。</p>
<p><img src="image-20230807161411916.png" alt="image-20230807161411916"></p>
</li>
<li><p>小结对比发现：</p>
<ul>
<li>采用 <code>MVCC</code> 方式的话， 读-写 操作彼此并不冲突， 性能更高 。</li>
<li>采用 <code>加锁</code> 方式的话， 读-写 操作彼此需要 <code>排队执行</code> ，影响性能。</li>
</ul>
<p>一般情况下我们当然愿意采用 <code>MVCC</code> 来解决 <code>读-写</code> 操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用 <code>加锁 </code>的方式执行。下面就讲解下MySQL中不同类别的锁。</p>
</li>
</ul>
<h3 id="锁的不同角度分类"><a href="#锁的不同角度分类" class="headerlink" title="锁的不同角度分类"></a>锁的不同角度分类</h3><p>锁的分类图，如下：</p>
<p><img src="image-20230807161528383.png" alt="image-20230807161528383"></p>
<h4 id="从数据操作的类型划分：读锁、写锁"><a href="#从数据操作的类型划分：读锁、写锁" class="headerlink" title="从数据操作的类型划分：读锁、写锁"></a>从数据操作的类型划分：读锁、写锁</h4><p><img src="image-20230807161615858.png" alt="image-20230807161615858"></p>
<ul>
<li><code>读锁</code> ：也称为 <code>共享锁</code> 、英文用 S 表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</li>
<li><code>写锁</code> ：也称为 <code>排他锁</code> 、英文用 X 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样 就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</li>
</ul>
<p><strong>需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。</strong></p>
<p><img src="image-20230807162345138.png" alt="image-20230807162345138"></p>
<h5 id="1-锁定读"><a href="#1-锁定读" class="headerlink" title="1. 锁定读"></a>1. 锁定读</h5><p><img src="image-20230807162427943.png" alt="image-20230807162427943"></p>
<p><img src="image-20230808164451516.png" alt="image-20230808164451516"></p>
<p><img src="image-20230808164504215.png" alt="image-20230808164504215"></p>
<h5 id="2-写操作"><a href="#2-写操作" class="headerlink" title="2. 写操作"></a>2. 写操作</h5><p><img src="image-20230808164603728.png" alt="image-20230808164603728"></p>
<h4 id="从数据操作的粒度划分：表级锁、页级锁、行锁"><a href="#从数据操作的粒度划分：表级锁、页级锁、行锁" class="headerlink" title="从数据操作的粒度划分：表级锁、页级锁、行锁"></a>从数据操作的粒度划分：表级锁、页级锁、行锁</h4><p><img src="image-20230809093848994.png" alt="image-20230809093848994"></p>
<h5 id="1-表锁（Table-Lock）"><a href="#1-表锁（Table-Lock）" class="headerlink" title="1. 表锁（Table Lock）"></a>1. 表锁（Table Lock）</h5><p><img src="image-20230809093905411.png" alt="image-20230809093905411"></p>
<p><strong>① 表级别的S锁、X锁</strong></p>
<p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的 <code>S锁</code> 或者 <code>X锁</code> 的。在对某个表执行一些诸如 <code>ALTER TABLE 、 DROP TABLE</code> 这类的 DDL 语句时，其 他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行 <code>DDL</code> 语句也会 发生阻塞。这个过程其实是通过在 server层使用一种称之为 <code>元数据锁</code> （英文名： Metadata Locks ， 简称 MDL ）结构来实现的。</p>
<p>一般情况下，不会使用InnoDB存储引擎提供的表级别的 <code>S锁</code> 和 <code>X锁</code> 。只会在一些特殊情况下，比方说 <code>崩溃恢复</code> 过程中用到。比如，在系统变量 <code>autocommit=0，innodb_table_locks = 1</code> 时， 手动 获取 InnoDB存储引擎提供的表t 的 <code>S锁</code> 或者 <code>X锁</code> 可以这么写：</p>
<ul>
<li><code>LOCK TABLES t READ</code> ：InnoDB存储引擎会对表 t 加表级别的 <code>S锁 </code>。</li>
<li><code>LOCK TABLES t WRITE</code> ：InnoDB存储引擎会对表 t 加表级别的 <code>X锁</code> 。</li>
</ul>
<p>不过尽量避免在使用InnoDB存储引擎的表上使用 <code>LOCK TABLES</code> 这样的手动锁表语句，它们并不会提供 什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的 <code>行锁</code> ，关于 InnoDB表级别的 <code>S锁</code> 和<code> X锁</code> 大家了解一下就可以了。</p>
<p>总结：</p>
<p>MyISAM在执行查询语句（SELECT）前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。InnoDB存储引擎是不会为这个表添加表级别的读锁和写锁的。</p>
<p>MySQL的表级锁有两种模式：（以MyISAM表进行操作的演示）</p>
<ul>
<li>表共享读锁（Table Read Lock）</li>
<li>表独占写锁（Table Write Lock）</li>
</ul>
<p><img src="image-20230809142558898.png" alt="image-20230809142558898"></p>
<p><strong>② 意向锁 （intention lock）</strong></p>
<p>InnoDB 支持 <code>多粒度锁（multiple granularity locking）</code> ，它允许 <code>行级锁</code> 与 <code>表级锁</code> 共存，而<code>意向锁</code>就是其中的一种 <code>表锁</code> 。</p>
<ol>
<li>意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁和行锁）的锁并存。</li>
<li>意向锁是一种<code>不与行级锁冲突表级锁</code>，这一点非常重要。</li>
<li>表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</li>
</ol>
<p>意向锁分为两种：</p>
<ul>
<li><p><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span><br><span class="line">SELECT column FROM table ... LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span><br><span class="line">SELECT column FROM table ... FOR UPDATE;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>即：意向锁是由存储引擎 <code>自己维护的</code> ，用户无法手动操作意向锁，在为数据行加共享 &#x2F; 排他锁之前， InooDB 会先获取该数据行 <code>所在数据表的对应意向锁</code> 。</p>
<p><strong>意向锁要解决的问题</strong></p>
<p><img src="image-20230809142831662.png" alt="image-20230809142831662"></p>
<p><strong>小结</strong></p>
<ol>
<li>InnoDB 支持 <code>多粒度锁</code> ，特定场景下，行级锁可以与表级锁共存。</li>
<li>意向锁之间互不排斥，但除了 IS 与 S 兼容外， <code>意向锁会与 共享锁 / 排他锁 互斥</code> 。</li>
<li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</li>
<li>意向锁在保证并发性的前提下，实现了 <code>行锁和表锁共存</code> 且 <code>满足事务隔离性</code> 的要求。</li>
</ol>
<p><strong>③ 自增锁（AUTO-INC锁）</strong></p>
<p>所有插入数据的方式总共分为三类，分别是 “ <code>Simple inserts</code> ”，“ <code>Bulk inserts</code> ”和“ <code>Mixed-mode inserts </code>”。</p>
<p><strong>1. “Simple inserts” （简单插入）</strong></p>
<p>可以 <code>预先确定要插入的行数</code> （当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行<code>INSERT...VALUES()</code>和 <code>REPLACE</code> 语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行数。</p>
<p><strong>2. “Bulk inserts” （批量插入）</strong></p>
<p><code>事先不知道要插入的行数</code> （和所需自动递增值的数量）的语句。比如 <code>INSERT ... SELECT</code> ， <code>REPLACE ... SELECT</code> 和 <code>LOAD DATA</code> 语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列</p>
<p><strong>3. “Mixed-mode inserts” （混合模式插入）</strong></p>
<p>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如 <code>INSERT INTO teacher (id,name) VALUES (1,&#39;a&#39;), (NULL,&#39;b&#39;), (5,&#39;c&#39;), (NULL,&#39;d&#39;);</code> 只是指定了部分id的值。另一种类型的“混合模式插入”是 <code>INSERT ... ON DUPLICATE KEY UPDATE</code> 。</p>
<p><img src="image-20230810171437703.png" alt="image-20230810171437703"></p>
<p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）innodb_autoinc_lock_mode = 0(“传统”锁定模式)</span><br></pre></td></tr></table></figure>

<p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有 AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个 表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证 master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的 时候，对于AUTO-INC锁的争夺会 <code>限制并发</code> 能力。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（2）innodb_autoinc_lock_mode = 1(“连续”锁定模式)</span><br></pre></td></tr></table></figure>

<p>在 MySQL 8.0 之前，连续锁定模式是 <code>默认</code> 的。</p>
<p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT … SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。</p>
<p>对于“Simple inserts”（要插入的行数事先已知），则通过在 <code>mutex（轻量锁）</code> 的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（3）innodb_autoinc_lock_mode = 2(“交错”锁定模式)</span><br></pre></td></tr></table></figure>

<p>从 MySQL 8.0 开始，交错锁模式是 <code>默认</code> 设置。</p>
<p>在此锁定模式下，自动递增值 <code>保证</code> 在所有并发执行的所有类型的insert语句中是 <code>唯一</code> 且 <code>单调递增</code> 的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），<strong>为任何给定语句插入的行生成的值可能不是连续的。</strong></p>
<p>如果执行的语句是“simple inserts”，其中要插入的行数已提前知道，除了”Mixed-mode inserts”之外，为单个语句生成的数字不会有间隙。然后，当执行”bulk inserts”时，在由任何给定语句分配的自动递增值中可能存在间隙。</p>
<p><strong>④ 元数据锁（MDL锁）</strong></p>
<p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比 如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个 <code>表结构做变更</code> ，增加了一 列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p>
<p>因此，<strong>当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁</strong>。</p>
<p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删查改。读写锁之间、写锁之间都是互斥的，用来保证变更表结构操作的安全性，解决了DML和DDL操作之间的一致性问题。<code>不需要显式使用</code>，在访问一个表的时候会被自动加上。</p>
<h5 id="2-InnoDB中的行锁"><a href="#2-InnoDB中的行锁" class="headerlink" title="2. InnoDB中的行锁"></a>2. InnoDB中的行锁</h5><p>行锁（Row Lock）也称为记录锁，顾名思义，就是锁住某一行（某条记录 row）。需要注意的是，MySQL服务器层并没有实现行锁机制，<strong>行级锁只在存储引擎层实现</strong>。</p>
<p><strong>优点：</strong>锁定力度小，发生<code>锁冲突概率低</code>，可以实现的<code>并发度高</code>。</p>
<p><strong>缺点：</strong>对于<code>锁的开销比较大</code>，加锁会比较慢，容易出现<code>死锁</code>情况。</p>
<p>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。</p>
<p><strong>① 记录锁（Record Locks）</strong></p>
<p>记录锁也就是仅仅把一条记录锁，官方的类型名称为：<code>LOCK_REC_NOT_GAP</code>。比如我们把id值为8的那条记录加一个记录锁的示意图如果所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响。</p>
<p>记录锁是有S锁和X锁之分的，称之为 <code>S型记录锁</code> 和 <code>X型记录锁</code> 。</p>
<ul>
<li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</li>
<li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li>
</ul>
<p><strong>② 间隙锁（Gap Locks）</strong></p>
<p><code>MySQL</code> 在 <code>REPEATABLE READ</code> 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 <code>MVCC</code> 方 案解决，也可以采用 <code>加锁 </code>方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些 <code>幻影记录</code> 加上 <code>记录锁</code> 。InnoDB提出了一种称之为 <code>Gap Locks</code> 的锁，官方的类型名称为：<code> LOCK_GAP</code> ，我们可以简称为 <code>gap锁</code> 。比如，把id值为8的那条 记录加一个gap锁的示意图如下。</p>
<p><strong>③ 临键锁（Next-Key Locks）</strong></p>
<p>有时候我们既想 <code>锁住某条记录</code> ，又想 阻止 其他事务在该记录前边的 间隙插入新记录 ，所以InnoDB就提 出了一种称之为 Next-Key Locks 的锁，官方的类型名称为： LOCK_ORDINARY ，我们也可以简称为 next-key锁 。Next-Key Locks是在存储引擎 innodb 、事务级别在 可重复读 的情况下使用的数据库锁， innodb默认的锁就是Next-Key locks。比如，我们把id值为8的那条记录加一个next-key锁的示意图如下：</p>
<p><img src="image-20230811104538766.png" alt="image-20230811104538766"></p>
<p><code>next-key锁</code>的本质就是一个<code>记录锁</code>和一个<code>gap锁</code>的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的<code>间隙</code>。</p>
<p><img src="image-20230811104946313.png" alt="image-20230811104946313"></p>
<p><img src="image-20230811105106576.png" alt="image-20230811105106576"></p>
<p><img src="image-20230811105122692.png" alt="image-20230811105122692"></p>
<p><img src="image-20230811105144724.png" alt="image-20230811105144724"></p>
<h5 id="3-页锁"><a href="#3-页锁" class="headerlink" title="3. 页锁"></a>3. 页锁</h5><p>页锁就是在 <code>页的粒度</code> 上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我 们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。<strong>页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</strong></p>
<p>每个层级的锁数量是有限制的，因为锁会占用内存空间， <code>锁空间的大小是有限的</code> 。当某个层级的锁数量 超过了这个层级的阈值时，就会进行 <code>锁升级</code> 。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如 InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了</p>
<h4 id="从对待锁的态度划分-乐观锁、悲观锁"><a href="#从对待锁的态度划分-乐观锁、悲观锁" class="headerlink" title="从对待锁的态度划分:乐观锁、悲观锁"></a>从对待锁的态度划分:乐观锁、悲观锁</h4><p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待 <code>数据并发的思维方式</code> 。需要注意的是，乐观锁和悲观锁并不是锁，而是锁的 <code>设计思想</code> 。</p>
<h5 id="1-悲观锁（Pessimistic-Locking）"><a href="#1-悲观锁（Pessimistic-Locking）" class="headerlink" title="1. 悲观锁（Pessimistic Locking）"></a>1. 悲观锁（Pessimistic Locking）</h5><p>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。</p>
<p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 <code>阻塞</code> 直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞， 用完后再把资源转让给其它线程</strong>）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中 <code>synchronized</code> 和 <code>ReentrantLock</code> 等独占锁就是悲观锁思想的实现。</p>
<h5 id="2-乐观锁（Optimistic-Locking）"><a href="#2-乐观锁（Optimistic-Locking）" class="headerlink" title="2. 乐观锁（Optimistic Locking）"></a>2. 乐观锁（Optimistic Locking）</h5><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是<strong>不采用数据库自身的锁机制，而是通过程序来实现</strong>。在程序上，我们可以采用 <code>版本号机制</code> 或者 <code>CAS机制</code> 实现。<strong>乐观锁适用于多读的应用类型， 这样可以提高吞吐量</strong>。在Java中<code> java.util.concurrent.atomic</code> 包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。</p>
<p><strong>1. 乐观锁的版本号机制</strong></p>
<p>在表中设计一个 <code>版本字段 version</code> ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行 <code>UPDATE ... SET version=version+1 WHERE version=version</code> 。此时 如果已经有事务对这条数据进行了更改，修改就不会成功。</p>
<p>这种方式类似我们熟悉的SVN、CVS版本管理系统，当我们修改了代码进行提交时，首先会检查当前版本号与服务器上的版本号是否一致，如果一致就可以直接提交，如果不一致就需要更新服务器上的最新代码，然后再进行提交。</p>
<p><strong>2. 乐观锁的时间戳机制</strong></p>
<p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行 比较，如果两者一致则更新成功，否则就是版本冲突。</p>
<p>你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或 者时间戳），从而证明当前拿到的数据是否最新。</p>
<p><strong>3. 两种锁的适用场景</strong></p>
<p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：</p>
<ol>
<li><code>乐观锁</code> 适合 <code>读操作多</code> 的场景，相对来说写的操作比较少。它的优点在于 <code>程序实现</code> ， <code>不存在死锁</code> 问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</li>
<li><code>悲观锁</code> 适合 <code>写操作多</code> 的场景，因为写的操作具有 <code>排它性</code> 。采用悲观锁的方式，可以在数据库层 面阻止其他事务对该数据的操作权限，防止 <code>读 - 写</code> 和 <code>写 - 写</code> 的冲突。</li>
</ol>
<p><img src="image-20230811105707578.png" alt="image-20230811105707578"></p>
<h4 id="按加锁的方式划分：显式锁、隐式锁"><a href="#按加锁的方式划分：显式锁、隐式锁" class="headerlink" title="按加锁的方式划分：显式锁、隐式锁"></a>按加锁的方式划分：显式锁、隐式锁</h4><h5 id="1-隐式锁"><a href="#1-隐式锁" class="headerlink" title="1. 隐式锁"></a>1. 隐式锁</h5><p><img src="image-20230811110023843.png" alt="image-20230811110023843"></p>
<ul>
<li><strong>情景一</strong>：对于聚簇索引记录来说，有一个 <code>trx_id</code> 隐藏列，该隐藏列记录着最后改动该记录的 <code>事务 id</code> 。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的 trx_id 隐藏列代表的的就是 当前事务的 事务id ，如果其他事务此时想对该记录添加 S锁 或者 X锁 时，首先会看一下该记录的 trx_id 隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个 X 锁 （也就是为当前事务创建一个锁结构， is_waiting 属性是 false ），然后自己进入等待状态 （也就是为自己也创建一个锁结构， is_waiting 属性是 true ）。</li>
<li><strong>情景二</strong>：对于二级索引记录来说，本身并没有 trx_id 隐藏列，但是在二级索引页面的 Page Header 部分有一个 <code>PAGE_MAX_TRX_ID</code> 属性，该属性代表对该页面做改动的最大的 <code>事务id</code> ，如 果 PAGE_MAX_TRX_ID 属性值小于当前最小的活跃 事务id ，那么说明对该页面做修改的事务都已 经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记 录，然后再重复 情景一 的做法。</li>
</ul>
<p><img src="image-20230814135230317.png" alt="image-20230814135230317"></p>
<h5 id="2-显式锁"><a href="#2-显式锁" class="headerlink" title="2. 显式锁"></a>2. 显式锁</h5><h4 id="其它锁之：全局锁"><a href="#其它锁之：全局锁" class="headerlink" title="其它锁之：全局锁"></a>其它锁之：全局锁</h4><p>全局锁就是对 <code>整个数据库实例</code> 加锁。当你需要让整个库处于 <code>只读状态</code> 的时候，可以使用这个命令，之后 其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结 构等）和更新类事务的提交语句。全局锁的典型使用 <code>场景</code> 是：做 <code>全库逻辑备份</code> 。</p>
<p>全局锁的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Flush tables with read lock</span><br></pre></td></tr></table></figure>

<h4 id="其它锁之：死锁"><a href="#其它锁之：死锁" class="headerlink" title="其它锁之：死锁"></a>其它锁之：死锁</h4><h5 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h5><p>两个事务都持有对方需要的锁，并且在等待对方释放，并且双方都不会释放自己的锁。</p>
<h5 id="2-产生死锁的必要条件"><a href="#2-产生死锁的必要条件" class="headerlink" title="2. 产生死锁的必要条件"></a>2. 产生死锁的必要条件</h5><ol>
<li>两个或者两个以上事务</li>
<li>每个事务都已经持有锁并且申请新的锁</li>
<li>锁资源同时只能被同一个事务持有或者不兼容</li>
<li>事务之间因为持有锁和申请锁导致彼此循环等待</li>
</ol>
<blockquote>
<p>死锁的关键在于：两个（或以上）的Session加锁的顺序不一致。</p>
</blockquote>
<h5 id="3-如何处理死锁"><a href="#3-如何处理死锁" class="headerlink" title="3. 如何处理死锁"></a>3. 如何处理死锁</h5><p><strong>方式1：</strong>等待，直到超时（innodb_lock_wait_timeout&#x3D;50s)</p>
<p><img src="image-20230814143130529.png" alt="image-20230814143130529"></p>
<p><strong>方式2：</strong>使用死锁检测处理死锁程序</p>
<p>方式1检测死锁太过被动，innodb还提供了<code>wait-for graph算法</code>来主动进行死锁检测，每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法都会被触发。</p>
<p>这是一种较为<code>主动的死锁检测机制</code>，要求数据库保存<code>锁的信息链表</code>和<code>事务等待链表</code>两部分信息。</p>
<p><img src="image-20230814143232065.png" alt="image-20230814143232065"></p>
<p>基于这两个信息，可以绘制wait-for graph（等待图）</p>
<p><img src="image-20230814143543508.png" alt="image-20230814143543508"></p>
<blockquote>
<p>死锁检测的原理是构建一个以事务为顶点，锁为边的有向图，判断有向图是否存在环，存在既有死锁。</p>
</blockquote>
<p>一旦检测到回路、有死锁，这时候InnoDB存储引擎会选择<code>回滚undo量最小的事务</code>，让其他事务继续执行（<code>innodb_deadlock_detect=on</code>表示开启这个逻辑）。</p>
<p>缺点：每个新的被阻塞的线程，都要判断是不是由于自己的加入导致了死锁，这个操作时间复杂度是O(n)。如果100个并发线程同时更新同一行，意味着要检测100*100&#x3D;1万次，1万个线程就会有1千万次检测。</p>
<p><strong>如何解决？</strong></p>
<ul>
<li>方式1：关闭死锁检测，但意味着可能会出现大量的超时，会导致业务有损。</li>
<li>方式2：控制并发访问的数量。比如在中间件中实现对于相同行的更新，在进入引擎之前排队，这样在InnoDB内部就不会有大量的死锁检测工作。</li>
</ul>
<p><strong>进一步的思路：</strong></p>
<p>可以考虑通过将一行改成逻辑上的多行来减少<code>锁冲突</code>。比如，连锁超市账户总额的记录，可以考虑放到多条记录上。账户总额等于这多个记录的值的总和。 </p>
<h5 id="4-如何避免死锁"><a href="#4-如何避免死锁" class="headerlink" title="4. 如何避免死锁"></a>4. 如何避免死锁</h5><p><img src="image-20230814143935088.png" alt="image-20230814143935088"></p>
<h3 id="锁的内部结构"><a href="#锁的内部结构" class="headerlink" title="锁的内部结构"></a>锁的内部结构</h3><p>我们前边说对一条记录加锁的本质就是在内存中创建一个<code>锁结构</code>与之关联，那么是不是一个事务对多条记录加锁，就要创建多个<code>锁结构</code>呢？比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 事务T1</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure>

<p>理论上创建多个<code>锁结构</code>没问题，但是如果一个事务要获取10000条记录的锁，生成10000个锁结构也太崩溃了！所以决定在对不同记录加锁时，如果符合下边这些条件的记录会放在一个<code>锁结构</code>中。</p>
<ul>
<li>在同一个事务中进行加锁操作</li>
<li>被加锁的记录在同一个页面中</li>
<li>加锁的类型是一样的</li>
<li>等待状态是一样的</li>
</ul>
<p><code>InnoDB</code> 存储引擎中的 <code>锁结构</code> 如下：</p>
<p><img src="image-20230814164723883.png" alt="image-20230814164723883"></p>
<p>结构解析：</p>
<p><code>1. 锁所在的事务信息 </code>：</p>
<p>不论是 <code>表锁</code> 还是 <code>行锁</code> ，都是在事务执行过程中生成的，哪个事务生成了这个锁结构 ，这里就记录这个事务的信息。</p>
<p>此 <code>锁所在的事务信息</code> 在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p>
<p><code>2. 索引信息</code> ：</p>
<p>对于 <code>行锁</code> 来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p>
<p><code>3. 表锁／行锁信息</code> ：</p>
<p><code>表锁结构</code> 和 <code>行锁结构</code> 在这个位置的内容是不同的：</p>
<ul>
<li><p>表锁：</p>
<p>记载着是对哪个表加的锁，还有其他的一些信息。</p>
</li>
<li><p>行锁：</p>
<p>记载了三个重要的信息：</p>
<ul>
<li><code>Space ID</code> ：记录所在表空间。</li>
<li><code>Page Number</code> ：记录所在页号。</li>
<li><code>n_bits </code>：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同 的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个<code>n_bis</code>属性代表使用了多少比特位。</li>
</ul>
<blockquote>
<p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后 也不至于重新分配锁结构</p>
</blockquote>
</li>
</ul>
<p><code>4. type_mode</code> ：</p>
<p>这是一个32位的数，被分成了 <code>lock_mode</code> 、 <code>lock_type</code> 和 <code>rec_lock_type</code> 三个部分，如图所示：</p>
<p><img src="image-20230814164817719.png" alt="image-20230814164817719"></p>
<ul>
<li>锁的模式（lock_mode），占用低4位，可选的值如下：<ul>
<li><code>LOCK_IS</code> （十进制的 0 ）：表示共享意向锁，也就是 <code>IS锁</code> 。</li>
<li><code>LOCK_IX</code> （十进制的 1 ）：表示独占意向锁，也就是 <code>IX锁</code> 。</li>
<li><code>LOCK_S</code> （十进制的 2 ）：表示共享锁，也就是 <code>S锁</code> 。</li>
<li><code>LOCK_X</code> （十进制的 3 ）：表示独占锁，也就是 <code>X锁</code> 。</li>
<li><code>LOCK_AUTO_INC</code> （十进制的 4 ）：表示 <code>AUTO-INC锁</code> 。</li>
</ul>
</li>
</ul>
<p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p>
<ul>
<li>锁的类型（lock_type），占用第5～8位，不过现阶段只有第5位和第6位被使用：<ul>
<li><code>LOCK_TABLE</code> （十进制的 16 ），也就是当第5个比特位置为1时，表示表级锁。</li>
<li><code>LOCK_REC </code>（十进制的 32 ），也就是当第6个比特位置为1时，表示行级锁。</li>
</ul>
</li>
<li>行锁的具体类型（rec_lock_type），使用其余的位来表示。只有在lock_type的值为LOCK_REC时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：<ul>
<li><code>LOCK_ORDINARY</code> （十进制的 0 ）：表示 <code>next-key锁</code> 。</li>
<li><code>LOCK_GAP</code> （十进制的 512 ）：也就是当第10个比特位置为1时，表示 <code>gap锁</code> 。</li>
<li><code>LOCK_REC_NOT_GAP</code> （十进制的 1024 ）：也就是当第11个比特位置为1时，表示正经 <code>记录锁</code> 。</li>
<li><code>LOCK_INSERT_INTENTION</code> （十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li>
</ul>
</li>
<li>is_waiting属性呢？基于内存空间的节省，所以把is_waiting属性放到了type_mode这个32 位的数字中：<ul>
<li><code>LOCK_WAIT</code> （十进制的 256 ） ：当第9个比特位置为 1 时，表示 <code>is_waiting</code> 为 <code>true</code> ，也 就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 0 时，表示 <code>is_waiting</code> 为 <code>false</code> ，也就是当前事务获取锁成功。</li>
</ul>
</li>
</ul>
<p><code>5. 其他信息</code> ：</p>
<p>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p>
<p><code>6. 一堆比特位</code> ：</p>
<p>如果是 <code>行锁结构</code> 的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的 <code>n_bits</code> 属性 表示的。InnoDB数据页中的每条记录在 <code>记录头信息</code> 中都包含一个 <code>heap_no</code> 属性，伪记录 <code>Infimum</code> 的 <code>heap_no</code> 值为 0 ， <code>Supremum</code> 的 <code>heap_no</code> 值为 1 ，之后每插入一条记录， <code>heap_no</code> 值就增1。 锁结 构 最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个 <code>heap_no</code> ，即一个比特位映射 到页内的一条记录。</p>
<h3 id="锁监控"><a href="#锁监控" class="headerlink" title="锁监控"></a>锁监控</h3><p>关于MySQL锁的监控，我们一般可以通过检查 InnoDB_row_lock 等状态变量来分析系统上的行锁的争夺情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status like &#x27;innodb_row_lock%&#x27;;</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Variable_name                 | Value |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Innodb_row_lock_current_waits | 0     |</span><br><span class="line">| Innodb_row_lock_time          | 0     |</span><br><span class="line">| Innodb_row_lock_time_avg      | 0     |</span><br><span class="line">| Innodb_row_lock_time_max      | 0     |</span><br><span class="line">| Innodb_row_lock_waits         | 0     |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>对各个状态量的说明如下：</p>
<ul>
<li>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</li>
<li><code>Innodb_row_lock_time</code> ：从系统启动到现在锁定总时间长度；（等待总时长）</li>
<li><code>Innodb_row_lock_time_avg</code> ：每次等待所花平均时间；（等待平均时长）</li>
<li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</li>
<li><code>Innodb_row_lock_waits</code> ：系统启动后到现在总共等待的次数；（等待总次数）</li>
</ul>
<p>对于这5个状态变量，比较重要的3个见上面（灰色）。</p>
<p>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。</p>
<p><strong>其他监控方法：</strong></p>
<p>MySQL把事务和锁的信息记录在了 <code>information_schema</code> 库中，涉及到的三张表分别是 <code>INNODB_TRX</code> 、 <code>INNODB_LOCKS</code> 和 <code>INNODB_LOCK_WAITS</code> 。</p>
<p><code>MySQL5.7及之前</code> ，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事 务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。</p>
<p>MySQL8.0删除了information_schema.INNODB_LOCKS，添加了 <code>performance_schema.data_locks</code> ，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同， performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。</p>
<p>同时，information_schema.INNODB_LOCK_WAITS也被 <code>performance_schema.data_lock_waits</code> 所代 替。</p>
<p>我们模拟一个锁等待的场景，以下是从这三张表收集的信息</p>
<p>锁等待场景，我们依然使用记录锁中的案例，当事务2进行等待时，查询情况如下：</p>
<p>（1）查询正在被锁阻塞的sql语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.INNODB_TRX\G;</span><br></pre></td></tr></table></figure>



<p>重要属性代表含义已在上述中标注。</p>
<p>（2）查询锁等待情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM data_lock_waits\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">							ENGINE: INNODB</span><br><span class="line">		REQUESTING_ENGINE_LOCK_ID: 139750145405624:7:4:7:139747028690608</span><br><span class="line">REQUESTING_ENGINE_TRANSACTION_ID: 13845 #被阻塞的事务ID</span><br><span class="line">			REQUESTING_THREAD_ID: 72</span><br><span class="line">			REQUESTING_EVENT_ID: 26</span><br><span class="line">REQUESTING_OBJECT_INSTANCE_BEGIN: 139747028690608</span><br><span class="line">		BLOCKING_ENGINE_LOCK_ID: 139750145406432:7:4:7:139747028813248</span><br><span class="line">BLOCKING_ENGINE_TRANSACTION_ID: 13844 #正在执行的事务ID，阻塞了13845</span><br><span class="line">			BLOCKING_THREAD_ID: 71</span><br><span class="line">			BLOCKING_EVENT_ID: 24</span><br><span class="line">BLOCKING_OBJECT_INSTANCE_BEGIN: 139747028813248</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>（3）查询锁的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql &gt; SELECT * from performance_schema.data_locks\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">ENGINE: INNODB</span><br><span class="line">ENGINE_LOCK_ID: 139750145405624:1068:139747028693520</span><br><span class="line">ENGINE_TRANSACTION_ID: 13847</span><br><span class="line">THREAD_ID: 72</span><br><span class="line">EVENT_ID: 31</span><br><span class="line">OBJECT_SCHEMA: atguigu</span><br><span class="line">OBJECT_NAME: user</span><br><span class="line">PARTITION_NAME: NULL</span><br><span class="line">SUBPARTITION_NAME: NULL</span><br><span class="line">INDEX_NAME: NULL</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 139747028693520</span><br><span class="line">LOCK_TYPE: TABLE</span><br><span class="line">LOCK_MODE: IX</span><br><span class="line">LOCK_STATUS: GRANTED</span><br><span class="line">LOCK_DATA: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">ENGINE: INNODB</span><br><span class="line">ENGINE_LOCK_ID: 139750145405624:7:4:7:139747028690608</span><br><span class="line">ENGINE_TRANSACTION_ID: 13847</span><br><span class="line">THREAD_ID: 72</span><br><span class="line">EVENT_ID: 31</span><br><span class="line">OBJECT_SCHEMA: atguigu</span><br><span class="line">OBJECT_NAME: user</span><br><span class="line">PARTITION_NAME: NULL</span><br><span class="line">SUBPARTITION_NAME: NULL</span><br><span class="line">INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 139747028690608</span><br><span class="line">LOCK_TYPE: RECORD</span><br><span class="line">LOCK_MODE: X,REC_NOT_GAP</span><br><span class="line">LOCK_STATUS: WAITING</span><br><span class="line">LOCK_DATA: 1</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">ENGINE: INNODB</span><br><span class="line">ENGINE_LOCK_ID: 139750145406432:1068:139747028816304</span><br><span class="line">ENGINE_TRANSACTION_ID: 13846</span><br><span class="line">THREAD_ID: 71</span><br><span class="line">EVENT_ID: 28</span><br><span class="line">OBJECT_SCHEMA: atguigu</span><br><span class="line">OBJECT_NAME: user</span><br><span class="line">PARTITION_NAME: NULL</span><br><span class="line">SUBPARTITION_NAME: NULL</span><br><span class="line">INDEX_NAME: NULL</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 139747028816304</span><br><span class="line">LOCK_TYPE: TABLE</span><br><span class="line">LOCK_MODE: IX</span><br><span class="line">LOCK_STATUS: GRANTED</span><br><span class="line">LOCK_DATA: NULL</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">ENGINE: INNODB</span><br><span class="line">ENGINE_LOCK_ID: 139750145406432:7:4:7:139747028813248</span><br><span class="line">ENGINE_TRANSACTION_ID: 13846</span><br><span class="line">THREAD_ID: 71</span><br><span class="line">EVENT_ID: 28</span><br><span class="line">OBJECT_SCHEMA: atguigu</span><br><span class="line">OBJECT_NAME: user</span><br><span class="line">PARTITION_NAME: NULL</span><br><span class="line">SUBPARTITION_NAME: NULL</span><br><span class="line">INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 139747028813248</span><br><span class="line">LOCK_TYPE: RECORD</span><br><span class="line">LOCK_MODE: X,REC_NOT_GAP</span><br><span class="line">LOCK_STATUS: GRANTED</span><br><span class="line">LOCK_DATA: 1</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>

<p>从锁的情况可以看出来，两个事务分别获取了IX锁，我们从意向锁章节可以知道，IX锁互相时兼容的。所 以这里不会等待，但是事务1同样持有X锁，此时事务2也要去同一行记录获取X锁，他们之间不兼容，导 致等待的情况发生。</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p><strong>间隙锁加锁规则（共11个案例）</strong></p>
<p>间隙锁是在可重复读隔离级别下才会生效的： next-key lock 实际上是由间隙锁加行锁实现的，如果切换 到读提交隔离级别 (read-committed) 的话，就好理解了，过程中去掉间隙锁的部分，也就是只剩下行锁 的部分。而在读提交隔离级别下间隙锁就没有了，为了解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row 。也就是说，许多公司的配置为：读提交隔离级别加 binlog_format&#x3D;row。业务不 需要可重复读的保证，这样考虑到读提交下操作数据的锁范围更小（没有间隙锁），这个选择是合理的。</p>
<p>next-key lock的加锁规则</p>
<p>总结的加锁规则里面，包含了两个 “ “ 原则 ” ” 、两个 “ “ 优化 ” ” 和一个 “bug” 。</p>
<ol>
<li>原则 1 ：加锁的基本单位是 next-key lock 。 next-key lock 是前开后闭区间。</li>
<li>原则 2 ：查找过程中访问到的对象才会加锁。任何辅助索引上的锁，或者非索引列上的锁，最终 都要回溯到主键上，在主键上也要加一把锁。</li>
<li>优化 1 ：索引上的等值查询，给唯一索引加锁的时候， next-key lock 退化为行锁。也就是说如果 InnoDB扫描的是一个主键、或是一个唯一索引的话，那InnoDB只会采用行锁方式来加锁</li>
<li>优化 2 ：索引上（不一定是唯一索引）的等值查询，向右遍历时且最后一个值不满足等值条件的 时候， next-keylock 退化为间隙锁。</li>
<li>一个 bug ：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ol>
<p>我们以表test作为例子，建表语句和初始化语句如下：其中id为主键索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `test` (</span><br><span class="line">`id` int(11) NOT NULL,</span><br><span class="line">`col1` int(11) DEFAULT NULL,</span><br><span class="line">`col2` int(11) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">insert into test values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure>

<p><strong>案例一：唯一索引等值查询间隙锁</strong></p>
<p><img src="image-20230815155438182.png" alt="image-20230815155438182"></p>
<p>由于表 test 中没有 id&#x3D;7 的记录</p>
<p>根据原则 1 ，加锁单位是 next-key lock ， session A 加锁范围就是 (5,10] ； 同时根据优化 2 ，这是一个等 值查询 (id&#x3D;7) ，而 id&#x3D;10 不满足查询条件， next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)</p>
<p><strong>案例二：非唯一索引等值查询锁</strong></p>
<p><img src="image-20230815155504426.png" alt="image-20230815155504426"></p>
<p>这里 session A 要给索引 col1 上 col1&#x3D;5 的这一行加上读锁。</p>
<ol>
<li>根据原则 1 ，加锁单位是 next-key lock ，左开右闭，5是闭上的，因此会给 (0,5] 加上 next-key lock 。</li>
<li>要注意 c 是普通索引，因此仅访问 c&#x3D;5 这一条记录是不能马上停下来的（可能有col1&#x3D;5的其他记 录），需要向右遍历，查到c&#x3D;10 才放弃。根据原则 2 ，访问到的都要加锁，因此要给 (5,10] 加 next-key lock 。</li>
<li>但是同时这个符合优化 2 ：等值判断，向右遍历，最后一个值不满足 col1&#x3D;5 这个等值条件，因此退化成间隙锁 (5,10) 。</li>
<li>根据原则 2 ， 只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。</li>
</ol>
<p>但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住 这个例子说明，锁是加在索引上的。</p>
<p>执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</p>
<p>如果你要用 lock in share mode来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，因为覆盖索引不会访问主键索引，不会给主键索引上加锁</p>
<p><strong>案例三：主键索引范围查询锁</strong></p>
<p>上面两个例子是等值查询的，这个例子是关于范围查询的，也就是说下面的语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from test where id=10 for update</span><br><span class="line">select * from tets where id&gt;=10 and id&lt;11 for update;</span><br></pre></td></tr></table></figure>

<p>这两条查语句肯定是等价的，但是它们的加锁规则不太一样</p>
<p><img src="image-20230815155551257.png" alt="image-20230815155551257"></p>
<ol>
<li>开始执行的时候，要找到第一个 id&#x3D;10 的行，因此本该是 next-key lock(5,10] 。 根据优化 1 ，主键 id 上的等值条件，退化成行锁，只加了 id&#x3D;10 这一行的行锁。</li>
<li>它是范围查询， 范围查找就往后继续找，找到 id&#x3D;15 这一行停下来，不满足条件，因此需要加 next-key lock(10,15] 。</li>
</ol>
<p>session A 这时候锁的范围就是主键索引上，行锁 id&#x3D;10 和 next-key lock(10,15] 。<strong>首次 session A 定位查找 id&#x3D;10 的行的时候，是当做等值查询来判断的，而向右扫描到 id&#x3D;15 的时候，用的是范围查询判断。</strong></p>
<p><strong>案例四：非唯一索引范围查询锁</strong></p>
<p>与案例三不同的是，案例四中查询语句的 where 部分用的是字段 c ，它是普通索引</p>
<p>这两条查语句肯定是等价的，但是它们的加锁规则不太一样</p>
<p><img src="image-20230815155611168.png" alt="image-20230815155611168"></p>
<p>在第一次用 col1&#x3D;10 定位记录的时候，索引 c 上加了 (5,10] 这个 next-key lock 后，由于索引 col1 是非唯 一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 (5,10] 和 (10,15] 这两个 next-keylock 。</p>
<p>这里需要扫描到 col1&#x3D;15 才停止扫描，是合理的，因为 InnoDB 要扫到 col1&#x3D;15 ，才知道不需要继续往后找了。</p>
<p><strong>案例五：唯一索引范围查询锁 bug</strong></p>
<p><img src="image-20230815155624928.png" alt="image-20230815155624928"></p>
<p>session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15] 这个 next-key lock ，并且因 为 id 是唯一键，所以循环判断到 id&#x3D;15 这一行就应该停止了。</p>
<p>但是实现上， InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id&#x3D;20 。而且由于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock 也会被锁上。照理说，这里锁住 id&#x3D;20 这一行的行为，其实是没有必要的。因为扫描到 id&#x3D;15 ，就可以确定不用往后再找了。</p>
<p><strong>案例六：非唯一索引上存在 “ “ 等值 “ “ 的例子</strong></p>
<p>这里，我给表 t 插入一条新记录：insert into t values(30,10,30);也就是说，现在表里面有两个c&#x3D;10的行</p>
<p><strong>但是它们的主键值 id 是不同的（分别是 10 和 30 ），因此这两个c&#x3D;10 的记录之间，也是有间隙的。</strong></p>
<p><img src="image-20230815155642260.png" alt="image-20230815155642260"></p>
<p>这次我们用 delete 语句来验证。注意， delete 语句加锁的逻辑，其实跟 select … for update 是类似的， 也就是我在文章开始总结的两个 “ 原则 ” 、两个 “ 优化 ” 和一个 “bug” 。</p>
<p>这时， session A 在遍历的时候，先访问第一个 col1&#x3D;10 的记录。同样地，根据原则 1 ，这里加的是 (col1&#x3D;5,id&#x3D;5) 到 (col1&#x3D;10,id&#x3D;10) 这个 next-key lock 。</p>
<p>由于c是普通索引，所以继续向右查找，直到碰到 (col1&#x3D;15,id&#x3D;15) 这一行循环才结束。根据优化 2 ，这是 一个等值查询，向右查找到了不满足条件的行，所以会退化成 (col1&#x3D;10,id&#x3D;10) 到 (col1&#x3D;15,id&#x3D;15) 的间隙锁。</p>
<p><img src="image-20230815155658963.png" alt="image-20230815155658963"></p>
<p>这个 delete 语句在索引 c 上的加锁范围，就是上面图中蓝色区域覆盖的部分。这个蓝色区域左右两边都 是虚线，表示开区间，即 (col1&#x3D;5,id&#x3D;5) 和 (col1&#x3D;15,id&#x3D;15) 这两行上都没有锁</p>
<p><strong>案例七： limit 语句加锁</strong></p>
<p>例子 6 也有一个对照案例，场景如下所示：</p>
<p><img src="image-20230815155731648.png" alt="image-20230815155731648"></p>
<p>session A 的 delete 语句加了 limit 2 。你知道表 t 里 c&#x3D;10 的记录其实只有两条，因此加不加 limit 2 ，删除的效果都是一样的。但是加锁效果却不一样</p>
<p>这是因为，案例七里的 delete 语句明确加了 limit 2 的限制，因此在遍历到 (col1&#x3D;10, id&#x3D;30) 这一行之后， 满足条件的语句已经有两条，循环就结束了。因此，索引 col1 上的加锁范围就变成了从（ col1&#x3D;5,id&#x3D;5) 到（col1&#x3D;10,id&#x3D;30) 这个前开后闭区间，如下图所示：</p>
<p><img src="image-20230815155752339.png" alt="image-20230815155752339"></p>
<p>这个例子对我们实践的指导意义就是， 在删除数据的时候尽量加 limit 。</p>
<p>这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p>
<p><strong>案例八：一个死锁的例子</strong></p>
<p><img src="image-20230815155819525.png" alt="image-20230815155819525"></p>
<ol>
<li>session A 启动事务后执行查询语句加 lock in share mode ，在索引 col1 上加了 next-keylock(5,10] 和 间隙锁 (10,15) （索引向右遍历退化为间隙锁）；</li>
<li>session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待； 实际上分成了两步， 先是加 (5,10) 的间隙锁，加锁成功；然后加 col1&#x3D;10 的行锁，因为sessionA上已经给这行加上了读 锁，此时申请死锁时会被阻塞</li>
<li>然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁， InnoDB 让 session B 回滚</li>
</ol>
<p><strong>案例九：order by索引排序的间隙锁1</strong></p>
<p>如下面一条语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test where id&gt;9 and id&lt;12 order by id desc for update;</span><br></pre></td></tr></table></figure>

<p>下图为这个表的索引id的示意图。</p>
<p><img src="image-20230815155849877.png" alt="image-20230815155849877"></p>
<ol>
<li>首先这个查询语句的语义是 order by id desc ，要拿到满足条件的所有行，优化器必须先找到 “ 第 一个 id&lt;12 的值 ” 。</li>
<li>这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到 id&#x3D;12 的这个值，只是最终 没找到，但找到了 (10,15) 这个间隙。（ id&#x3D;15 不满足条件，所以 next-key lock 退化为了间隙锁 (10, 15) 。）</li>
<li>然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到 id&#x3D;5 这一行，又因为区间是左开右 闭的，所以会加一个next-key lock (0,5] 。 也就是说，在执行过程中，通过树搜索的方式定位记录 的时候，用的是 “ 等值查询 ” 的方法。</li>
</ol>
<p><strong>案例十：order by索引排序的间隙锁2</strong></p>
<p><img src="image-20230815155906903.png" alt="image-20230815155906903"></p>
<ol>
<li><p>由于是 order by col1 desc ，第一个要定位的是索引 col1 上 “ 最右边的 ”col1&#x3D;20 的行。这是一个非唯一索引的等值查询：</p>
<p>左开右闭区间，首先加上 next-key lock (15,20] 。 向右遍历，col1&#x3D;25不满足条件，退化为间隙锁 所以会 加上间隙锁(20,25) 和 next-key lock (15,20] 。</p>
</li>
<li><p>在索引 col1 上向左遍历，要扫描到 col1&#x3D;10 才停下来。同时又因为左开右闭区间，所以 next-key lock 会加到 (5,10] ，这正是阻塞session B 的 insert 语句的原因。</p>
</li>
<li><p>在扫描过程中， col1&#x3D;20 、 col1&#x3D;15 、 col1&#x3D;10 这三行都存在值，由于是 select * ，所以会在主键 id 上加三个行锁。 因此， session A 的 select 语句锁的范围就是：</p>
<ol>
<li>索引 col1 上 (5, 25) ；</li>
<li>主键索引上 id&#x3D;15 、 20 两个行锁。</li>
</ol>
</li>
</ol>
<p><strong>案例十一：update修改数据的例子-先插入后删除</strong></p>
<p><img src="image-20230815155921998.png" alt="image-20230815155921998"></p>
<p>注意：根据 col1&gt;5 查到的第一个记录是 col1&#x3D;10 ，因此不会加 (0,5] 这个 next-key lock 。</p>
<p>session A 的加锁范围是索引 col1 上的 (5,10] 、 (10,15] 、 (15,20] 、 (20,25] 和(25,supremum] 。</p>
<p>之后 session B 的第一个 update 语句，要把 col1&#x3D;5 改成 col1&#x3D;1 ，你可以理解为两步：</p>
<ol>
<li>插入 (col1&#x3D;1, id&#x3D;5) 这个记录；</li>
<li>删除 (col1&#x3D;5, id&#x3D;5) 这个记录。</li>
</ol>
<p>通过这个操作， session A 的加锁范围变成了图 7 所示的样子:</p>
<p><img src="image-20230815155940495.png" alt="image-20230815155940495"></p>
<p>好，接下来 session B 要执行 update t set col1 &#x3D; 5 where col1 &#x3D; 1 这个语句了，一样地可以拆成两步：</p>
<ol>
<li>插入 (col1&#x3D;5, id&#x3D;5) 这个记录；</li>
<li>删除 (col1&#x3D;1, id&#x3D;5) 这个记录。 第一步试图在已经加了间隙锁的 (1,10) 中插入数据，所以就被堵住了。</li>
</ol>
<h2 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h2><h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h3><p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的 <code>并发控制 </code>。这项技术使得在InnoDB的事务隔离级别下执行 <code>一致性读</code> 操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样 在做查询的时候就不用等待另一个事务释放锁。</p>
<p>MVCC没有正式的标准，在不同的DBMS中MVCC的实现方式可能是不同的，也不是普遍使用的（大家可以参考相关的DBMS文档）。这里讲解InnoDB中MVCC的实现机制（MySQL其他的存储引擎并不支持它）。</p>
<h3 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h3><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 <code>读-写冲突</code> ，做到 即使有读写冲突时，也能做到 <code>不加锁</code> ， <code>非阻塞并发读</code> ，而这个读指的就是 <code>快照读</code> , 而非 <code>当前读</code> 。当前 读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p>
<h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>快照读又叫一致性读，读取的是快照数据。<strong>不加锁的简单的 SELECT 都属于快照读</strong>，即不加锁的非阻塞 读；比如这样：</p>
<p>之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下， 避免了加锁操作，降低了开销。</p>
<p>既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</p>
<p>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p>
<h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务 不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前 读。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM student LOCK IN SHARE MODE; # 共享锁</span><br><span class="line">SELECT * FROM student FOR UPDATE; # 排他锁</span><br><span class="line">INSERT INTO student values ... # 排他锁</span><br><span class="line">DELETE FROM student WHERE ... # 排他锁</span><br><span class="line">UPDATE student SET ... # 排他锁</span><br></pre></td></tr></table></figure>

<h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><h4 id="再谈隔离级别"><a href="#再谈隔离级别" class="headerlink" title="再谈隔离级别"></a>再谈隔离级别</h4><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题：</p>
<p><img src="image-20230815163828907.png" alt="image-20230815163828907"></p>
<p><img src="image-20230815163838917.png" alt="image-20230815163838917"></p>
<p><img src="image-20230815163847655.png" alt="image-20230815163847655"></p>
<h4 id="隐藏字段、Undo-Log版本链"><a href="#隐藏字段、Undo-Log版本链" class="headerlink" title="隐藏字段、Undo Log版本链"></a>隐藏字段、Undo Log版本链</h4><p>回顾一下undo日志的版本链，对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。</p>
<ul>
<li><code>trx_id</code> ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 <code>事务id</code> 赋值给 <code>trx_id</code> 隐藏列。</li>
<li><code>roll_pointer</code> ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 <code>undo日志</code> 中，然 后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。<img src="image-20230815165542866.png" alt="image-20230815165542866"></li>
</ul>
<p>假设插入该记录的<code>事务id</code>为<code>8</code>，那么此刻该条记录的示意图如下所示：<img src="image-20230815165653237.png" alt="image-20230815165653237"></p>
<blockquote>
<p>insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Undo Log Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。</p>
</blockquote>
<p>假设之后两个事务id分别为 <code>10</code> 、 <code>20</code> 的事务对这条记录进行<code> UPDATE</code> 操作，操作流程如下：<img src="image-20230815165712920-1692089834267-3.png" alt="image-20230815165712920"></p>
<p><img src="image-20230815165728184.png" alt="image-20230815165728184"></p>
<p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个 <code>roll_pointer</code> 属性 （ <code>INSERT</code> 操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些 <code>undo日志</code> 都连起来，串成一个链表：</p>
<p><img src="image-20230815165744098.png" alt="image-20230815165744098"></p>
<p>对该记录每次更新后，都会将旧值放到一条 <code>undo日志</code> 中，就算是该记录的一个旧版本，随着更新次数 的增多，所有的版本都会被 <code>roll_pointer</code> 属性连接成一个链表，我们把这个链表称之为 <code>版本链</code> ，版本链的头节点就是当前记录最新的值。</p>
<p>每个版本中还包含生成该版本时对应的<code>事务id</code>。</p>
<h3 id="MVCC实现原理之ReadView"><a href="#MVCC实现原理之ReadView" class="headerlink" title="MVCC实现原理之ReadView"></a>MVCC实现原理之ReadView</h3><p>MVCC 的实现依赖于：<code>隐藏字段</code>、<code>Undo Log</code>、<code>Read View</code>。</p>
<h4 id="什么是ReadView"><a href="#什么是ReadView" class="headerlink" title="什么是ReadView"></a>什么是ReadView</h4><p><img src="image-20230826191403716.png" alt="image-20230826191403716"></p>
<h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p>使用 <code>READ UNCOMMITTED</code> 隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</p>
<p>使用 <code>SERIALIZABLE</code> 隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</p>
<p>使用 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别的事务，都必须保证读到 <code>已经提交了的</code> 事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p>
<p>这个ReadView中主要包含4个比较重要的内容，分别如下：</p>
<ol>
<li><p><code>creator_trx_id</code> ，创建这个 Read View 的事务 ID。</p>
<blockquote>
<p>说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为 事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</p>
</blockquote>
</li>
<li><p><code>trx_ids</code> ，表示在生成ReadView时当前系统中活跃的读写事务的 <code>事务id列表</code> 。</p>
</li>
<li><p><code>up_limit_id</code> ，活跃的事务中最小的事务 ID。</p>
</li>
<li><p><code>low_limit_id</code> ，表示生成ReadView时系统中应该分配给下一个事务的 id 值。low_limit_id 是系 统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。</p>
</li>
</ol>
<blockquote>
<p>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1， 2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时， trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。</p>
</blockquote>
<img src="image-20220714142254768.png" alt="image-20220714142254768" style="float:left;">

<h4 id="ReadView的规则"><a href="#ReadView的规则" class="headerlink" title="ReadView的规则"></a>ReadView的规则</h4><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p>
<ul>
<li>如果被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。 </li>
<li>如果被访问版本的trx_id属性值小于ReadView中的 up_limit_id 值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。 </li>
<li>如果被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id 值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。 </li>
<li>如果被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id 之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。<ul>
<li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。 </li>
<li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul>
</li>
</ul>
<h4 id="MVCC整体操作流程"><a href="#MVCC整体操作流程" class="headerlink" title="MVCC整体操作流程"></a>MVCC整体操作流程</h4><p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它：</p>
<ol>
<li>首先获取事务自己的版本号，也就是事务 ID； </li>
<li>获取 ReadView； </li>
<li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li>
<li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照； </li>
<li>最后返回符合规则的数据。</li>
</ol>
<p><img src="image-20230826192132426-1693048894390-2.png" alt="image-20230826192132426"></p>
<p>在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次 Read View。</p>
<p>如表所示：</p>
<p><img src="image-20230826192225825.png" alt="image-20230826192225825"></p>
<p>注意，此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。</p>
<p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View，如下表所示：</p>
<p><img src="image-20230826192258069.png" alt="image-20230826192258069"></p>
<h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><p><img src="image-20230826192315904.png" alt="image-20230826192315904"></p>
<h5 id="READ-COMMITTED隔离级别下"><a href="#READ-COMMITTED隔离级别下" class="headerlink" title="READ COMMITTED隔离级别下"></a>READ COMMITTED隔离级别下</h5><p><strong>READ COMMITTED ：每次读取数据前都生成一个ReadView。</strong></p>
<p>现在有两个 <code>事务id</code> 分别为 <code>10</code> 、 <code>20</code> 的事务在执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE student SET name=&quot;李四&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;王五&quot; WHERE id=1;</span><br><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：事务执行过程中，只有在第一次真正修改记录时（比如使用INSERT、DELETE、UPDATE语句），才会被分配一个单独的事务id，这个事务id是递增的。所以我们才在事务2中更新一些别的表的记录，目的是让它分配事务id。</p>
</blockquote>
<p>此刻，表student 中 id 为 1 的记录得到的版本链表如下所示：</p>
<p><img src="image-20230906160053022.png" alt="image-20230906160053022"></p>
<p>假设现在有一个使用 <code>READ COMMITTED</code> 隔离级别的事务开始执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="image-20230906160114583.png" alt="image-20230906160114583"></p>
<p>之后，我们把 <code>事务id</code> 为 <code>10</code> 的事务提交一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE student SET name=&quot;李四&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;王五&quot; WHERE id=1;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>然后再到 <code>事务id</code> 为 <code>20</code> 的事务中更新一下表 <code>student</code> 中 <code>id</code> 为 <code>1</code> 的记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line">UPDATE student SET name=&quot;钱七&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;宋八&quot; WHERE id=1;</span><br></pre></td></tr></table></figure>

<p>此刻，表student中 <code>id</code> 为 <code>1</code> 的记录的版本链就长这样：</p>
<p><img src="image-20230906160131107.png" alt="image-20230906160131107"></p>
<p>然后再到刚才使用 <code>READ COMMITTED</code> 隔离级别的事务中继续查找这个 id 为 1 的记录，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>均未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;王五&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="image-20230906160209736.png" alt="image-20230906160209736"></p>
<p><img src="image-20230906160216570.png" alt="image-20230906160216570"></p>
<h5 id="REPEATABLE-READ隔离级别下"><a href="#REPEATABLE-READ隔离级别下" class="headerlink" title="REPEATABLE READ隔离级别下"></a>REPEATABLE READ隔离级别下</h5><p>使用 <code>REPEATABLE READ</code> 隔离级别的事务来说，只会在第一次执行查询语句时生成一个 <code>ReadView</code> ，之后的查询就不会重复生成了。</p>
<p>比如，系统里有两个 <code>事务id</code> 分别为 <code>10</code> 、 <code>20</code> 的事务在执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE student SET name=&quot;李四&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;王五&quot; WHERE id=1;</span><br><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>此刻，表student 中 id 为 1 的记录得到的版本链表如下所示：</p>
<p><img src="image-20230906160312950.png" alt="image-20230906160312950"></p>
<p>假设现在有一个使用 <code>REPEATABLE READ</code> 隔离级别的事务开始执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="image-20230906160351467.png" alt="image-20230906160351467"></p>
<p>之后，我们把 <code>事务id</code> 为 <code>10</code> 的事务提交一下，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE student SET name=&quot;李四&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;王五&quot; WHERE id=1;</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>然后再到 <code>事务id</code> 为 <code>20</code> 的事务中更新一下表 <code>student</code> 中 <code>id</code> 为 <code>1</code> 的记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line">UPDATE student SET name=&quot;钱七&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;宋八&quot; WHERE id=1;</span><br></pre></td></tr></table></figure>

<p>此刻，表student 中 <code>id</code> 为 <code>1</code> 的记录的版本链长这样：</p>
<p><img src="image-20230906160405652.png" alt="image-20230906160405652"></p>
<p>然后再到刚才使用 <code>REPEATABLE READ</code> 隔离级别的事务中继续查找这个 <code>id</code> 为 <code>1</code> 的记录，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>均未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br><span class="line"># SELECT2：Transaction <span class="number">10</span>提交，Transaction <span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值仍为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="image-20230906160429207.png" alt="image-20230906160429207"></p>
<p><img src="image-20230906160434734.png" alt="image-20230906160434734"></p>
<p>这次<code>SELECT</code>查询得到的结果是重复的，记录的列<code>c</code>值都是<code>张三</code>，这就是<code>可重复读</code>的含义。如果我们之后再把<code>事务id</code>为<code>20</code>的记录提交了，然后再到刚才使用<code>REPEATABLE READ</code>隔离级别的事务中继续查找这个<code>id</code>为<code>1</code>的记录，得到的结果还是<code>张三</code>，具体执行过程大家可以自己分析一下。</p>
<h5 id="如何解决幻读"><a href="#如何解决幻读" class="headerlink" title="如何解决幻读"></a>如何解决幻读</h5><p>接下来说明InnoDB 是如何解决幻读的。</p>
<p>假设现在表 student 中只有一条数据，数据内容中，主键 id&#x3D;1，隐藏的 trx_id&#x3D;10，它的 undo log 如下图所示。</p>
<p><img src="image-20230906160747466.png" alt="image-20230906160747466"></p>
<p>假设现在有事务 A 和事务 B 并发执行，<code>事务 A</code> 的事务 id 为 <code>20</code> ， <code>事务 B</code> 的事务 id 为 <code>30</code> 。</p>
<p>步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from student where id &gt;= 1;</span><br></pre></td></tr></table></figure>

<p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下： <code>trx_ids= [20,30] ， up_limit_id=20 ， low_limit_id=31 ， creator_trx_id=20</code> 。</p>
<p>由于此时表 student 中只有一条数据，且符合 where id&gt;&#x3D;1 条件，因此会查询出来。然后根据 ReadView 机制，发现该行数据的trx_id&#x3D;10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p>
<p>结论：事务 A 的第一次查询，能读取到一条数据，id&#x3D;1。</p>
<p>步骤2：接着事务 B(trx_id&#x3D;30)，往表 student 中新插入两条数据，并提交事务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student(id,name) values(2,&#x27;李四&#x27;);</span><br><span class="line">insert into student(id,name) values(3,&#x27;王五&#x27;);</span><br></pre></td></tr></table></figure>

<p>此时表student 中就有三条数据了，对应的 undo 如下图所示：</p>
<p><img src="image-20230906160921067.png" alt="image-20230906160921067"></p>
<p>步骤3：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成 ReadView。此时表 student 中的 3 条数据都满足 where id&gt;&#x3D;1 的条件，因此会先查出来。然后根据 ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p>
<p>1）首先 id&#x3D;1 的这条数据，前面已经说过了，可以被事务 A 看到。 </p>
<p>2）然后是 id&#x3D;2 的数据，它的 trx_id&#x3D;30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之 间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids&#x3D;[20,30]，因此在数组内，这表 示 id&#x3D;2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。</p>
<p>3）同理，id&#x3D;3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。</p>
<p><img src="image-20230906160931475.png" alt="image-20230906160931475"></p>
<p>结论：最终事务 A 的第二次查询，只能查询出 id&#x3D;1 的这条数据。这和事务 A 的第一次查询的结果是一样 的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这里介绍了 MVCC 在 <code>READ COMMITTD</code> 、 <code>REPEATABLE READ</code> 这两种隔离级别的事务在执行快照读操作时 访问记录的版本链的过程。这样使不同事务的 <code>读-写</code> 、 <code>写-读</code> 操作并发执行，从而提升系统性能。</p>
<p>核心点在于 ReadView 的原理， <code>READ COMMITTD</code> 、 <code>REPEATABLE READ</code> 这两个隔离级别的一个很大不同 就是生成ReadView的时机不同：</p>
<ul>
<li><code>READ COMMITTD</code> 在每一次进行普通SELECT操作前都会生成一个ReadView </li>
<li><code>REPEATABLE READ</code> 只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复 使用这个ReadView就好了。</li>
</ul>
<p><img src="image-20230906161027132.png" alt="image-20230906161027132"></p>
<p>通过MVCC我们可以解决：</p>
<p><img src="image-20230906161034640.png" alt="image-20230906161034640"></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo</title>
    <url>/2023/03/31/Dubbo/</url>
    <content><![CDATA[<h2 id="Dubbo架构体系"><a href="#Dubbo架构体系" class="headerlink" title="Dubbo架构体系"></a>Dubbo架构体系</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。</p>
<p>Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>
<h2 id="Dubbo基本使用"><a href="#Dubbo基本使用" class="headerlink" title="Dubbo基本使用"></a>Dubbo基本使用</h2><h3 id="Dubbo与SpringBoot的整合"><a href="#Dubbo与SpringBoot的整合" class="headerlink" title="Dubbo与SpringBoot的整合"></a>Dubbo与SpringBoot的整合</h3><p>基于Zookeeper实现Dubbo与Spring Boot的集成整合。</p>
<h4 id="顶级工程pom依赖"><a href="#顶级工程pom依赖" class="headerlink" title="顶级工程pom依赖"></a><strong>顶级工程pom依赖</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dubbo-version</span>&gt;</span>2.7.8<span class="tag">&lt;/<span class="name">dubbo-version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>2.3.0.RELEASE<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- Spring Boot --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">&lt;!-- Apache Dubbo  --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-dependencies-bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dubbo-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dubbo-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Dubbo Spring Boot Starter --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dubbo-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Dubbo核心组件 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--Spring Boot 依赖 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Zookeeper客户端框架 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Zookeeper dependencies --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-dependencies-zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dubbo-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="公用RPC接口工程"><a href="#公用RPC接口工程" class="headerlink" title="公用RPC接口工程"></a>公用RPC接口工程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取订单详情</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> orderId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getOrder</span><span class="params">(Long orderId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务端工程"><a href="#服务端工程" class="headerlink" title="服务端工程"></a>服务端工程</h4><p>1、pom依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Dubbo Spring Boot Starter --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dubbo-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Dubbo 核心依赖 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 公用RPC接口依赖 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、RPC服务接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DubboService(version = &quot;$&#123;dubbo.spring.provider.version&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;dubbo.spring.provider.version&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serviceVersion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取订单详情</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> orderId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOrder</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;get order detail ,orderId=&quot;</span>+orderId +<span class="string">&quot;,serverPort=&quot;</span>+serverPort +<span class="string">&quot;,serviceVersion=&quot;</span>+serviceVersion;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过DubboService注解， 声明为RPC服务，version可以标识具体的版本号， 消费端需匹配保持一致。</p>
<p>3、工程配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">18081</span></span><br><span class="line"><span class="comment"># 应用程序名称</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">dubbo-spring-provider</span></span><br><span class="line"><span class="comment"># Dubbo服务扫描路径</span></span><br><span class="line"><span class="attr">dubbo.scan.base-packages</span>=<span class="string">com.itheima</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Dubbo 通讯协议</span></span><br><span class="line"><span class="attr">dubbo.protocol.name</span>=<span class="string">dubbo</span></span><br><span class="line"><span class="comment"># Dubbo服务提供的端口， 配置为-1，代表为随机端口 默认20880</span></span><br><span class="line"><span class="attr">dubbo.protocol.port</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## Dubbo 注册器配置信息</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="attr">dubbo.registry.file</span> = <span class="string">$&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache</span></span><br><span class="line"><span class="attr">dubbo.spring.provider.version</span> = <span class="string">1.0.0</span></span><br></pre></td></tr></table></figure>



<h4 id="消费端工程"><a href="#消费端工程" class="headerlink" title="消费端工程"></a>消费端工程</h4><p>1、pom依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Dubbo Spring Boot Starter --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dubbo-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 公用RPC接口依赖 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、消费端调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单服务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DubboReference(version = &quot;$&#123;dubbo.spring.provider.version&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取订单详情接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> orderId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/getOrder&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOrder</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = orderService.getOrder(orderId);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、工程配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">18084</span></span><br><span class="line"><span class="comment">#服务名称</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">dubbo-spring-consumer</span></span><br><span class="line"><span class="comment">#服务版本号</span></span><br><span class="line"><span class="attr">dubbo.spring.provider.version</span> = <span class="string">1.0.0</span></span><br><span class="line"><span class="comment">#消费端注册器配置信息</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="attr">dubbo.registry.file</span> = <span class="string">$&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache</span></span><br></pre></td></tr></table></figure>

<h3 id="Dubbo高阶配置运用"><a href="#Dubbo高阶配置运用" class="headerlink" title="Dubbo高阶配置运用"></a>Dubbo高阶配置运用</h3><h4 id="不同配置覆盖关系"><a href="#不同配置覆盖关系" class="headerlink" title="不同配置覆盖关系"></a>不同配置覆盖关系</h4><p>配置规则：</p>
<p>方法级优先，接口级次之，全局配置再次之。</p>
<p>如果级别一样，则消费方优先，提供方次之。</p>
<h4 id="属性配置优先级"><a href="#属性配置优先级" class="headerlink" title="属性配置优先级"></a><strong>属性配置优先级</strong></h4><p>优先级从高到低：</p>
<ul>
<li>JVM -D 参数；</li>
<li>XML（application.yml&#x2F;application.properties）配置会重写dubbo.properties 中的，一般配置项目特有的</li>
<li>Properties默认配置（dubbo.properties），仅仅作用于以上两者没有配置时，一般配置全局公共配置</li>
</ul>
<h4 id="重试与容错处理机制"><a href="#重试与容错处理机制" class="headerlink" title="重试与容错处理机制"></a><strong>重试与容错处理机制</strong></h4><p>容错机制：</p>
<ul>
<li><p>Failfast Cluster</p>
<p>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p>
</li>
<li><p>Failsafe Cluster</p>
<p>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p>
</li>
<li><p>Failback Cluster</p>
<p>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p>
</li>
<li><p>Forking Cluster</p>
<p>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks&#x3D;”2” 来设置最大并行数。</p>
</li>
<li><p>Broadcast Cluster</p>
<p>广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>
</li>
</ul>
<h4 id="多版本控制"><a href="#多版本控制" class="headerlink" title="多版本控制"></a><strong>多版本控制</strong></h4><p>根据指定的版本，消费端和服务端必须一致，否则无法远程调用</p>
<h4 id="本地存根调用"><a href="#本地存根调用" class="headerlink" title="本地存根调用"></a>本地存根调用</h4><h4 id="负载均衡机制"><a href="#负载均衡机制" class="headerlink" title="负载均衡机制"></a><strong>负载均衡机制</strong></h4><ol>
<li><p>默认负载策略</p>
<p>Dubbo默认采用的是随机负载策略。</p>
<p>开启三个服务节点，通过消费端访问验证： <a href="http://127.0.0.1:18084/order/getOrder?orderId=123">http://127.0.0.1:18084/order/getOrder?orderId=123</a></p>
<p>通过控制后台日志输出， 可以看到每个服务节点呈现不规则的调用。</p>
</li>
<li><p>Dubbo 支持的负载均衡策略，可用参看源码：<code>AbstractLoadBalance</code></p>
<ul>
<li><p>Random LoadBalance：默认</p>
<blockquote>
<p>随机，按权重设置随机概率。 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p>
</blockquote>
</li>
<li><p>RoundRobin LoadBalance</p>
<blockquote>
<p>加权轮询负载均衡，按公约后的权重设置轮询比率。 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p>
</blockquote>
</li>
<li><p>LeastActive LoadBalance</p>
<blockquote>
<p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。 活跃数其实就是在当前这个服务调用者中当前这个时刻 某个invoker（某个服务提供者的某个接口）某个方法的调用并发数，在调用之前+1 调用之后-1的一个计数器，如果出现多个活跃数相等invoker的时候使用随机算法来选取一个</p>
</blockquote>
</li>
<li><p>ConsistentHash LoadBalance</p>
<blockquote>
<p>一致性 Hash，相同参数的请求总是发到同一提供者。 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<blockquote>
<blockquote>
<p>一致性Hash负载均衡涉及到两个主要的配置参数为<strong>hash.arguments</strong> 与<strong>hash.nodes</strong>。</p>
</blockquote>
<blockquote>
<p><strong>hash.arguments</strong> ： 当进行调用时候根据调用方法的哪几个参数生成key，并根据key来通过一致性hash算法来选择调用结点</p>
</blockquote>
<blockquote>
<p><strong>hash.nodes</strong>： 为结点的副本数</p>
</blockquote>
</blockquote>
<ul>
<li><p>ShortestResponseLoadBalance</p>
<blockquote>
<p>2.7.7 +新增</p>
<p>最短响应时间负载均衡</p>
<p>从多个服务提供者中选择出调用成功的且响应时间最短的服务提供者，由于满足这样条件的服务提供者有可能有多个。所以当选择出多个服务提供者后要根据他们的权重做分析，如果权重一样，则随机</p>
</blockquote>
</li>
</ul>
<h4 id="服务降级运用"><a href="#服务降级运用" class="headerlink" title="服务降级运用"></a>服务降级运用</h4><h2 id="Dubbo源码分析"><a href="#Dubbo源码分析" class="headerlink" title="Dubbo源码分析"></a>Dubbo源码分析</h2><p><img src="1322298-20220522215206659-384650563.png" alt="1322298-20220522215206659-384650563"></p>
<h3 id="服务导出"><a href="#服务导出" class="headerlink" title="服务导出"></a>服务导出</h3><p>如图所示，在ServiceConfig执行export方法，根据接口实现代理对象，对方法进行增强，并封装成invoker对象，在拦截增强执行invoke方法内，通过SPI自适应机制生成对应的Expoter对象，一层一层封装handler对象，最终在最底层Server对象中开启netty监听，并在zookeeper中注册资源信息，最终完成服务端的启动</p>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3>]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos</title>
    <url>/2023/03/02/Nacos/</url>
    <content><![CDATA[<h2 id="Nacos安装"><a href="#Nacos安装" class="headerlink" title="Nacos安装"></a>Nacos安装</h2><h2 id="Nacos功能应用"><a href="#Nacos功能应用" class="headerlink" title="Nacos功能应用"></a>Nacos功能应用</h2><h3 id="Nacos服务注册与发现"><a href="#Nacos服务注册与发现" class="headerlink" title="Nacos服务注册与发现"></a>Nacos服务注册与发现</h3><p>​	服务发现是微服务架构体系中最关键的组件之一。Nacos Discovery Starter可以帮助您将服务自动注册到Nacos服务端，并且能够动态感知和刷新某个服务实例的服务列表。初次之外，Nacos Discovery Starter也将服务实例自身的一些元数据信息，例如host，port，健康检查URL，主页等注册到Nacos上</p>
]]></content>
      <categories>
        <category>nacos</category>
        <category>spring alibaba</category>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>nacos</tag>
        <tag>注册中心</tag>
        <tag>配置中心</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql</title>
    <url>/2023/06/16/Mysql%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="MySQL基本原理"><a href="#MySQL基本原理" class="headerlink" title="MySQL基本原理"></a>MySQL基本原理</h2><h3 id="Mysql表类型（存储引擎）的选择"><a href="#Mysql表类型（存储引擎）的选择" class="headerlink" title="Mysql表类型（存储引擎）的选择"></a>Mysql表类型（存储引擎）的选择</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>插件式存储引擎是MySQL数据库最重要的特性之一，用户可以根据应用的需要选择如何存储和索引数据、是否使用事务等。MySQL默认支持多种存储引擎，以适用于不同领域的数据库应用需要，用户可以通过选择使用不同的存储引擎提高应用的效率，提供灵活的存储，用户甚至可以按照自己的定制和使用自己的存储引擎，以实现最大程度的可定制性。</p>
<p>MySQL5.0支持的存储引擎包括MyLSAM、InnoDB、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB和DBD提供了事务安全表，其他引擎都是非事务安全表。</p>
<p>创建表时如果不指定存储引擎，那么系统就会使用默认存储引擎，MySQL5.5之前的默认存储引擎是MyLSAM，5.5之后改为InnoDB。如果要修改默认的存储引擎，可以在参数中设置default-table-type</p>
<h4 id="各个存储引擎的特点"><a href="#各个存储引擎的特点" class="headerlink" title="各个存储引擎的特点"></a>各个存储引擎的特点</h4><p><strong>MyISAM</strong></p>
<p>不支持事务，不支持外键，其优势就是访问速度快，对事务完整性没有要求或者以select、insert为主的应用基本上都可以使用这个引擎来创建表</p>
<p>每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但扩展名分别是：</p>
<ul>
<li>.frm（存储表定义）</li>
<li>.MYD（MYData，存储数据）</li>
<li>.MYI（MYIndex，存储索引）</li>
</ul>
<p>数据文件和索引文件可以放置在不同目录，平均分布IO，获得更快的速度</p>
<p>要指定索引文件和数据文件的路径，需要在创建表的时候通过DATA DIRECTORY和INDEX DIRECTORY语句指定，也就是说不同的MyISAM表的索引文件和数据文件可以放置到不同路径下。文件路径需要是绝对路径，并且具有访问权限。</p>
<p>MyISAM类型的表可能是会损坏，原因可能是多种多样的，损坏后的表可能不能被访问，会提示需要修复或者访问返回错误的结果。MyISAM类型的表提供修复工具，可以用CHECK TABLE语句来检查MyISAM表的健康，并用REPAIR TABLE 语句修复一个损坏的MyISAM表，表损坏可能导致数据库异常重新启动，需要尽快修复并尽可能的确认损坏原因，需要尽快修复并确认损坏的原因。</p>
<p>MyISAM的表还支持3中不同的存储格式，分别是：</p>
<ul>
<li>静态（固定长度）表</li>
<li>动态表</li>
<li>压缩表</li>
</ul>
<p>其中静态表是默认的存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定的长度的，这种存储方式的优点是存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多。静态表在存储数据时会按照列的宽度定义补足空格，但是在应用访问的时候并不会得到这些空格，这些空格在返回给应用之前已经去掉。</p>
<p>但是有些要注意的的问题，如果需要保存的内容后面本来有空格，那么返回结果的时候会别去掉。</p>
<p>动态表包含变长字段，记录不是固定的长度，这样存储的有点是占用的空间相对较少，但是频繁的更新和删除记录会产生碎片，需要定期执行OPTIMIZE TABLE语句或者myisamchk-r命令来改善性能，并且在出现故障时恢复相对比较困难</p>
<p>压缩表有由myisampack工具创建，占据非常小的磁盘空间。因为每个记录是被单独压缩的，所有只有非常小的访问开支</p>
<p><strong>InnoDB</strong></p>
<p>InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。</p>
<p><strong>1、自动增长列</strong></p>
<p>InnoDB，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列。但是MyISAM表，自动增长列可以是组合索引的其他列，这样插入记录后，自动增长列是按照组合索引的前面几列进行排序后递增的。</p>
<p><strong>2、外键约束</strong></p>
<p>当某个表的创建了外键参照，那么该表的对应索引或者主键禁止被删除</p>
<p><strong>3、存储方式</strong></p>
<p>InnoDB存储表和索引有两种方式：</p>
<ul>
<li>使用共享表空间存储，这种方式创建的表的表结构保存在.frm文件中，数据和索引保存在innodb_data_home_dir和innodb_data_file_path定义的表空间中，可以是多个文件。</li>
<li>使用多表空间存储，这种方式创建的表的结构仍然保存在.frm文件中，但是每个表的数据和索引单独保存在.ibd中，如果是多个分区表，则每个分区对应单独的.ibd文件，文件名是表名+分区名，可以创建分区的时候指定每个分区的数据文件的位置，以此来将表的IO均匀分布在磁盘上。</li>
</ul>
<p>要使用多表空间的存储方式，需要设置参数innodb_file_pre_table，并且重新启动服务后才可以生效，对于新建的表按照多表空间的方式创建，已有的表仍然使用共享表空间存储。如果将已有的多表空间方式修改回共享表空间方式，则新建表会在共享表空间中创建，但已有的多表空间的表仍然保存原来的访问方式。所以多表空间的参数生效后，只对新建的表生效。</p>
<p>多表空间文件没有大小限制，不需要设置初始大小，也不需要设置文件的最大限制、扩展大小等参数</p>
<p>对于使用多表空间特性的表，可以比较方便地进行单表备份和恢复操作，但是直接复制.ibd文件是不行的，因为没有共享表空间的数据字典信息，直接复制.ibd文件和.frm文件恢复时是不能被正确识别的，但是可以通过以下命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name discard tablespace</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name import tablespace</span><br></pre></td></tr></table></figure>

<p>将备份恢复到数据库中，但是这样的单表备份，只能恢复表原来所在的数据库中，而不能恢复到其他数据库中。如果要将单表恢复到目标数据库中，则需要通过mysqldump和mysqlimport来实现</p>
<h4 id="如何选择合适的存储引擎"><a href="#如何选择合适的存储引擎" class="headerlink" title="如何选择合适的存储引擎"></a>如何选择合适的存储引擎</h4><p>在选择存储引擎时，应根据应用特点，选择合适的存储引擎，对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合</p>
<p>MyISAM：默认的MySQL插件式存储引擎。如果应用是以读操作或是查操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求 不是很高，那么选择这个存储引擎是合适的。MyISAM是在web、数据仓储和其他仓储和其他应用环境下最常使用的存储引擎之一。</p>
<p>InnoDB：用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包括很多的更新、删除操作，那么InnoDB存储引擎应该是比较合适的选择。InnoDB存储引擎除了有效降低由于删除和更新导致的锁定，还可以确保事务的完整提交和回滚，对于类似计费系统或者财务系统对数据准确性要求比较高的系统，InnoDB是合适的选择。</p>
<h3 id="选择合适的数据类型"><a href="#选择合适的数据类型" class="headerlink" title="选择合适的数据类型"></a>选择合适的数据类型</h3><h4 id="CHAR和VARCHAR"><a href="#CHAR和VARCHAR" class="headerlink" title="CHAR和VARCHAR"></a>CHAR和VARCHAR</h4><p>CHAR和VARCHAR类型类似，都是用来存储字符串的，但他们保存和检索方式不同。CHAR属于固定长度的字符类型，而VARCHAR属于可变长度的字符类型。</p>
<p>由于CHAR是固定长度的，所以他的处理速度比VARCHAR快得多，但是其缺点是浪费存储空间，程序需要对行尾空格进行处理，所以对于那些长度变化不大并且对查询速度有较高要求的数据可以考虑使用CHAR类型来存储。</p>
<p>随着MySQL版本的不断升级，VARCHAR数据类型的性能也在不断改进并提高，所以在许多的应用中，VARCHAR类型被更多地使用</p>
<p>不同存储引擎使用原则：</p>
<p>MyISAM：建议使用固定长度的数据列代替可变长度的数据列</p>
<p>InnoDB：建议使用VARCHAR类型。对于InnoDB数据表，内部的行存储格式没有区分固定长度和可变长度列（所有数据行都使用指向数据列值得头指针），因此在本质上，使用固定长度的CHAR列不一定比使用可变长度VARCHAR列性能要好。因而，主要的性能因素是数据行使用的存储总量。由于CHAR平均占用的空间多于VARCHAR，因此使用VARCHAR来最小化需要处理数据行的存储总量和磁盘I&#x2F;O是比较好。</p>
<h4 id="TEXT与BLOB"><a href="#TEXT与BLOB" class="headerlink" title="TEXT与BLOB"></a>TEXT与BLOB</h4><p>一般保存少量的字符串的时候，我们会选择CHAR或者VARCHAR；而在保存较大文本时，通常会选择使用TEXT和BLOB；两者区别，BLOB存储二进制数据，TEXT只保存字符数据。</p>
<p>（1）BLOB和TEXT值会引起一些性能问题，特别是在执行了大量的删除操作时</p>
<p>删除操作会在数据表中留下很大的“空洞”，以后填入这些“空洞”的记录在插入的性能上会有影响。为了提高性能，建议定期使用OPTIMIZE TABLE 功能对这类表进行碎片整理，避免因为“空洞”导致性能问题。</p>
<p>（2）使用合成的索引来提高大文本字段的查询性能</p>
<p>合成索引就是根据大文本字段的内容建立一个散列值，并把这个值存储在单独的数据列中，接下来就可以通过检索散列值找到数据行了。但只适用于精准查询。可以使用MD5生成散列值。</p>
<p>（3）在不必要的时候避免检索大型的BLOB或TEXT值</p>
<p>（4）把BLOB或TEXT分离到单独的表中</p>
<h4 id="浮点数和定点数"><a href="#浮点数和定点数" class="headerlink" title="浮点数和定点数"></a>浮点数和定点数</h4><p>浮点数一般用于表示含有小数部分的数值。当一个字段被定义为浮点类型后，如果插入数据的精度超过改了定义的实际精度，则插入值会被四舍五入到实际定义的精度值，然后插入，四舍五入过程不会报错。在MySQL中float、double用来表示浮点数。</p>
<p>定点数不同于浮点数，定点数实际上是以字符串形式存放的，所以定点数可以更精确地保存数据。如果实际插入的数值精度大于实际定义的精度，则MySQL会警告（默认的SQLModel下），但是数据按照实际精度四舍五入后插入；如果SQLModel是在TRADITIONAL（传统模式）下，则系统会直接报错，导致数据无法插入。decimal表示定点数。</p>
<p>使用原则：</p>
<ul>
<li>浮点数存在误差</li>
<li>对货币等对精度敏感的数据，应该用定点数表示或存储</li>
<li>在编程中，如果用到浮点数，要特别注意误差问题，并尽量避免使用浮点数比较</li>
<li>要注意浮点数中一些特殊值的处理</li>
</ul>
<h4 id="日期类型选择"><a href="#日期类型选择" class="headerlink" title="日期类型选择"></a>日期类型选择</h4><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><table>
<thead>
<tr>
<th>字符集</th>
<th>是否定长</th>
<th>编码方式</th>
<th>其他说明</th>
</tr>
</thead>
<tbody><tr>
<td>ACSII</td>
<td>是</td>
<td>单字节7位编码</td>
<td>最早的奠基性字符集</td>
</tr>
<tr>
<td>ISO-8859-1&#x2F;latin1</td>
<td>是</td>
<td>单字节8位编码</td>
<td>西欧字符集，经常被一些程序员用来转码</td>
</tr>
<tr>
<td>GB2312-80</td>
<td>是</td>
<td>双字节编码</td>
<td>早起标准，不推荐再使用</td>
</tr>
<tr>
<td>GBK</td>
<td>是</td>
<td>双字节编码</td>
<td>虽然不是国际，但是支持的系统不少</td>
</tr>
<tr>
<td>GB18030</td>
<td>否</td>
<td>2字节或4字节编码</td>
<td>开始有一些支持，但数据库支持的很少见</td>
</tr>
<tr>
<td>UTF-32</td>
<td>是</td>
<td>4字节编码</td>
<td>UCS-4原始编码，现在很少使用</td>
</tr>
<tr>
<td>UCS-2</td>
<td>是</td>
<td>2字节编码</td>
<td>Windows2000内部用UCS-2</td>
</tr>
<tr>
<td>UTF-16</td>
<td>否</td>
<td>2字节或4字节编码</td>
<td>Java和WindowsXP&#x2F;NT等内部使用UTF-16</td>
</tr>
<tr>
<td>UTF-8</td>
<td>否</td>
<td>1~4字节编码</td>
<td>互联网和UNIX&#x2F;Linux广泛支持的Unicode字符集；<br>MySQLServer也使用</td>
</tr>
</tbody></table>
<h4 id="怎样选择合适的字符集"><a href="#怎样选择合适的字符集" class="headerlink" title="怎样选择合适的字符集"></a>怎样选择合适的字符集</h4><ol>
<li>满足应用支持语言需求，如果应用要处理各种各样的文字，或者将发布到使用不同语言的国家或者地区，就应该选择Unicode字符集。对MySQL来说，目前就是UTF-8。</li>
<li>如果应用中涉及已有数据的导入，就要充分考虑数据库字符集对已有数据的兼容性。</li>
<li>如果数据库只需要支持一般中文，数据量很大，性能要求也很高，那应该选择双字节定长编码的中文字符集，比如GBK。因为，相对于UTF-8而言，GBK比较小，每个汉字只占2个字节，而UTF-8汉字编码需要3个字节，这样可以减少磁盘I&#x2F;O、数据库Cache以及网络传输的时间，从而提高性能。相反，如果应用主要处理英文字符，仅有少量汉字数据，那么选择UTF-8更好，因为GBK、UCS-2、UTF-16的西文字符编码都是2字节，会造成很多不必要的开销</li>
<li>如果数据库需要做大量字符运算，如比较、排序等，那么选择定长字符集可能更好，因为定长字符集的处理速度要比变长字符集的处理速度快</li>
<li>如果所有客户端程序都支持相同的字符集，则应该优先选择该字符集作为数据库的字符集。这样可以避免因字符集转换带来的性能开销和数据损失。</li>
</ol>
<h4 id="MySQL支持的字符集简介"><a href="#MySQL支持的字符集简介" class="headerlink" title="MySQL支持的字符集简介"></a>MySQL支持的字符集简介</h4><p>MySQL服务器可以支持多种字符集，在同一台服务器、同一个数据库甚至同一表的不同字段都可以指定不同的字符集，相比Oracle等其他数据库管理系统，在同一个数据库只能使用相同的字符集，MySQL明显存在更大的灵活性。</p>
<h4 id="MySQL字符集的设置"><a href="#MySQL字符集的设置" class="headerlink" title="MySQL字符集的设置"></a>MySQL字符集的设置</h4><p>MySQL的字符集和校对规则有四个级别的默认设置：服务器级、数据库级、表级和字段级。他们分别在不同的地方设置，作用也不相同。</p>
<p>MySQL的字符集包括字符集和校对规则两个概念。其中字符集用来定义MySQL存储字符串的方式，校对规则用来定义比较字符串的方式。字符集和校对规则是一对多关系。</p>
<p>校对规则命名约定：他们以相关的字符集名开始，通常包括一个语言名，并且以 ci（大小写不敏感）、cs（大小写敏感）或bin（二元，即比较是基于字符编码的值而与language无关）结束。</p>
<p><strong>服务器字符集和校对规则</strong></p>
<p>服务器字符集和校对规则，可以再MySQL服务启动的时候确定。</p>
<p><strong>数据库字符集和校对规则</strong></p>
<p>数据库字符集和校对规则在创建数据库的时候指定。如果数据库里已经存在数据，因为修改字符集并不能将已有的数据按照新的字符集进行存放，所以不能通过修改数据库的字符集直接修改数据库的内容。</p>
<p><strong>表字符集和校对规则</strong></p>
<p><strong>连接字符集和校对规则</strong></p>
<p>对于客户端和服务器的交互操作，MySQL提供了3个不同的参数：character_set_client、character_set_connection和character_set_result，分别代表客户端、连接和返回结果的字符集。通常情况下，这3个字符集应该相同的，才可以确保用户写入的数据可以正确的读出。</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>视图是虚拟存在的表，对于使用视图的用户来说基本上是透明的。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p>
<p>视图的优势：</p>
<ul>
<li>简单：使用视图的用户完全不需要关心后面对应的表结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集</li>
<li>安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是可以通过视图就可以简单实现</li>
<li>数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响</li>
</ul>
<h3 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>存储过程和函数是事先经过编译并存储在数据库的一段SQL语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p>
<p>存储过程和函数的区别在于函数必须由返回值，而存储过程没有，存储过程的参数可以使用IN、OUT、INOU类型，而函数的参数只能是IN类型的。如果有函数从其他类型的数据库迁移到MySQL，那么就可能因此需要将函数改造成存储过程。</p>
<h2 id="MySQL高级原理"><a href="#MySQL高级原理" class="headerlink" title="MySQL高级原理"></a>MySQL高级原理</h2><h3 id="Linux下MySQL的安装与使用"><a href="#Linux下MySQL的安装与使用" class="headerlink" title="Linux下MySQL的安装与使用"></a>Linux下MySQL的安装与使用</h3><h3 id="MySQL的数据目录"><a href="#MySQL的数据目录" class="headerlink" title="MySQL的数据目录"></a>MySQL的数据目录</h3><h3 id="用户与权限管理"><a href="#用户与权限管理" class="headerlink" title="用户与权限管理"></a>用户与权限管理</h3><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a><strong>用户管理</strong></h4><p><strong>登录MySQL服务器</strong></p>
<p>启动MySQL服务后，可以通过mysql命令来登录MySQL服务器，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql –h hostname|hostIP –P port –u username –p DatabaseName –e &quot;SQL语句&quot;</span><br></pre></td></tr></table></figure>

<p>下面详细介绍命令中的参数：</p>
<ul>
<li>-h参数 后面接主机名或者主机IP，hostname为主机，hostIP为主机IP。</li>
<li>-P参数 后面接MySQL服务的端口，通过该参数连接到指定的端口。MySQL服务的默认端口是3306，不使用该参数时自动连接到3306端口，port为连接的端口号。</li>
<li>-u参数 后面接用户名，username为用户名。</li>
<li>-p参数 会提示输入密码。</li>
<li>DatabaseName参数 指明登录到哪一个数据库中。如果没有该参数，就会直接登录到MySQL数据库中，然后可以使用USE命令来选择数据库。</li>
<li>-e参数 后面可以直接加SQL语句。登录MySQL服务器以后即可执行这个SQL语句，然后退出MySQL服务器。</li>
</ul>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p -hlocalhost -P3306 mysql -e &quot;select host,user from user&quot;</span><br></pre></td></tr></table></figure>

<p><strong>创建用户</strong></p>
<p>CREATE USER语句的基本语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER 用户名 [IDENTIFIED BY &#x27;密码&#x27;][,用户名 [IDENTIFIED BY &#x27;密码&#x27;]];</span><br></pre></td></tr></table></figure>

<ul>
<li>用户名参数表示新建用户的账户，由 用户（User） 和 主机名（Host） 构成；</li>
<li>“[ ]”表示可选，也就是说，可以指定用户登录时需要密码验证，也可以不指定密码验证，这样用户可以直接登录。不过，不指定密码的方式不安全，不推荐使用。如果指定密码值，这里需要使用IDENTIFIED BY指定明文密码值。</li>
<li>CREATE USER语句可以同时创建多个用户。</li>
</ul>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> zhang3 IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123123&#x27;</span>; # 默认host是 <span class="operator">%</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;li4&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>修改用户</strong></p>
<p>修改用户名：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> mysql.user <span class="keyword">SET</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;li4&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;wang5&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p><strong>删除用户</strong></p>
<p><strong>方式1：使用DROP方式删除（推荐）</strong></p>
<p>使用DROP USER语句来删除用户时，必须用于DROP USER权限。DROP USER语句的基本语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="keyword">user</span>[,<span class="keyword">user</span>]…;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> li4 ; # 默认删除host为<span class="operator">%</span>的用户</span><br></pre></td></tr></table></figure>

<p><strong>设置当前用户密码</strong></p>
<p>使用ALTER USER命令来修改当前用户密码用户可以使用ALTER命令来修改自身密码，如下语句代表修改当前登录用户的密码。基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">USER</span>() IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;new_password&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>修改其它用户密码</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">user</span> [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>]</span><br><span class="line">[,<span class="keyword">user</span>[IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>]]…;</span><br></pre></td></tr></table></figure>

<h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a><strong>权限管理</strong></h4><p><strong>权限列表</strong></p>
<ol>
<li>CREATE和DROP权限 ，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。</li>
<li>SELECT、INSERT、UPDATE和DELETE权限 允许在一个数据库现有的表上实施操作。</li>
<li>SELECT权限只有在它们真正从一个表中检索行时才被用到。</li>
<li>INDEX权限 允许创建或删除索引，INDEX适用于已有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。</li>
<li>ALTER权限可以使用ALTER TABLE来更改表的结构和重新命名表。</li>
<li>CREATE ROUTINE权限 用来创建保存的程序（函数和程序），ALTER ROUTINE权限用来更改和删除保存的程序， EXECUTE权限 用来执行保存的程序。</li>
<li>GRANT权限允许授权给其他用户，可用于数据库、表和保存的程序。</li>
<li>FILE权限 使用户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）。</li>
</ol>
<p>​	<strong>授予权限的原则</strong></p>
<p>权限控制主要是出于安全因素，因此需要遵循以下几个经验原则：</p>
<ol>
<li>只授予能满足需要的最小权限，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。 </li>
<li>创建用户的时候限制用户的登录主机 ，一般是限制成指定IP或者内网IP段。</li>
<li>为每个用户设置满足密码复杂度的密码 。</li>
<li>定期清理不需要的用户，回收权限或者删除用户。</li>
</ol>
<p><strong>授予权限</strong></p>
<p>给用户授权的方式有 2 种，分别是通过把角色赋予用户给用户授权和直接给用户授权 。用户是数据库的使用者，我们可以通过给用户授予访问数据库中资源的权限，来控制使用者对数据库的访问，消除安全隐患。</p>
<p>授权命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限<span class="number">1</span>,权限<span class="number">2</span>,…权限n <span class="keyword">ON</span> 数据库名称.表名称 <span class="keyword">TO</span> 用户名@用户地址 [IDENTIFIED <span class="keyword">BY</span> ‘密码口令’];</span><br></pre></td></tr></table></figure>

<p>该权限如果发现没有该用户，则会直接新建一个用户。</p>
<p>比如：</p>
<ul>
<li>给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">INSERT</span>,<span class="keyword">DELETE</span>,<span class="keyword">UPDATE</span> <span class="keyword">ON</span> atguigudb.<span class="operator">*</span> <span class="keyword">TO</span> li4<span class="variable">@localhost</span> ;</span><br></pre></td></tr></table></figure>

<ul>
<li>授予通过网络方式登录的joe用户 ，对所有库所有表的全部权限，密码设为123。注意这里唯独不包括grant的权限。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> joe@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">我们在开发应用的时候，经常会遇到一种需求，就是要根据用户的不同，对数据进行横向和纵向的分组。</span><br><span class="line"><span class="code">	所谓横向的分组，就是指用户可以接触到的数据的范围，比如可以看到哪些表的数据；</span></span><br><span class="line"><span class="code">	所谓纵向的分组，就是指用户对接触到的数据能访问到什么程度，比如能看、能改，甚至是删除。</span></span><br></pre></td></tr></table></figure>

<p><strong>查看权限</strong></p>
<ul>
<li>查看当前用户权限</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS;</span><br><span class="line"># 或</span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="built_in">CURRENT_USER</span>;</span><br><span class="line"># 或</span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="built_in">CURRENT_USER</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>查看某用户的全局权限</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;user&#x27;</span>@<span class="string">&#x27;主机地址&#x27;</span> ;</span><br></pre></td></tr></table></figure>

<p><strong>收回权限</strong></p>
<p>收回权限就是取消已经赋予用户的某些权限。收回用户不必要的权限可以在一定程度上保证系统的安全性。MySQL中使用 REVOKE语句取消用户的某些权限。使用REVOKE收回权限之后，用户账户的记录将从db、host、tables_priv和columns_priv表中删除，但是用户账户记录仍然在user表中保存（删除user表中的账户记录使用DROP USER语句）。</p>
<p><strong>注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限。</strong></p>
<ul>
<li>收回权限命令</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限<span class="number">1</span>,权限<span class="number">2</span>,…权限n <span class="keyword">ON</span> 数据库名称.表名称 <span class="keyword">FROM</span> 用户名@用户地址;</span><br></pre></td></tr></table></figure>

<p>举例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#收回全库全表的所有权限</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">FROM</span> joe@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">#收回mysql库下的所有表的插删改查权限</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>,<span class="keyword">INSERT</span>,<span class="keyword">UPDATE</span>,<span class="keyword">DELETE</span> <span class="keyword">ON</span> mysql.<span class="operator">*</span> <span class="keyword">FROM</span> joe<span class="variable">@localhost</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意： 须用户重新登录后才能生效</strong></p>
<h4 id="权限表"><a href="#权限表" class="headerlink" title="权限表"></a><strong>权限表</strong></h4><p>user表user表是MySQL中最重要的一个权限表， 记录用户账号和权限信息 ，有49个字段。</p>
<p>这些字段可以分成4类，分别是范围列（或用户列）、权限列、安全列和资源控制列。</p>
<p><strong>范围列（或用户列）</strong></p>
<p>host ： 表示连接类型</p>
<ul>
<li>% 表示所有远程通过 TCP方式的连接</li>
<li>IP 地址 如 (192.168.1.2、127.0.0.1) 通过制定ip地址进行的TCP方式的连接</li>
<li>机器名 通过制定网络中的机器名进行的TCP方式的连接</li>
<li>::1 IPv6的本地ip地址，等同于IPv4的 127.0.0.1</li>
<li>localhost 本地方式通过命令行方式的连接 ，比如mysql -u xxx -p xxx 方式的连接。</li>
</ul>
<p>user ： 表示用户名，同一用户通过不同方式链接的权限是不一样的。</p>
<p>password ： 密码</p>
<ul>
<li>所有密码串通过 password(明文字符串) 生成的密文字符串。MySQL 8.0 在用户管理方面增加了角色管理，默认的密码加密方式也做了调整，由之前的 SHA1 改为了 SHA2 ，不可逆 。同时加上 MySQL 5.7 的禁用用户和用户过期的功能，MySQL 在用户管理方面的功能和安全性都较之前版本大大的增强了。</li>
<li>mysql 5.7 及之后版本的密码保存到 authentication_string 字段中不再使用password 字段。</li>
</ul>
<p><strong>权限列</strong></p>
<ul>
<li>Grant_priv字段：表示是否拥有GRANT权限</li>
<li>Shutdown_priv字段：表示是否拥有停止MySQL服务的权限</li>
<li>Super_priv字段：表示是否拥有超级权限</li>
<li>Execute_priv字段：表示是否拥有EXECUTE权限。拥有EXECUTE权限，可以执行存储过程和函数。</li>
<li>Select_priv , Insert_priv等：为该用户所拥有的权限。</li>
</ul>
<p><strong>安全列</strong> 安全列只有6个字段，其中两个是ssl相关的（ssl_type、ssl_cipher），用于 加密 ；两个是x509相关的（x509_issuer、x509_subject），用于 标识用户 ；另外两个Plugin字段用于 验证用户身份 的插件，该字段不能为空。如果该字段为空，服务器就使用内建授权验证机制验证用户身份。</p>
<p><strong>资源控制列</strong> 资源控制列的字段用来 限制用户使用的资源 ，包含4个字段，分别为：①max_questions，用户每小时允许执行的查询操作次数； ②max_updates，用户每小时允许执行的更新操作次数； ③max_connections，用户每小时允许执行的连接操作次数； ④max_user_connections，用户允许同时建立的连接次数。</p>
<p>查看字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC mysql.user;</span><br></pre></td></tr></table></figure>

<p>查看用户, 以列的方式显示数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mysql.user \G;</span><br></pre></td></tr></table></figure>

<p>查询特定字段：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> host,<span class="keyword">user</span>,authentication_string,select_priv,insert_priv,drop_priv <span class="keyword">FROM</span> mysql.user;</span><br></pre></td></tr></table></figure>

<p><strong>db表</strong></p>
<p>使用DESCRIBE查看db表的基本结构：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> mysql.db;</span><br></pre></td></tr></table></figure>

<p><strong>1.</strong> <strong>用户列</strong> db表用户列有3个字段，分别是Host、User、Db。这3个字段分别表示主机名、用户名和数据库名。表示从某个主机连接某个用户对某个数据库的操作权限，这3个字段的组合构成了db表的主键。</p>
<p><strong>2.</strong> <strong>权限列</strong></p>
<p>Create_routine_priv和Alter_routine_priv这两个字段决定用户是否具有创建和修改存储过程的权限。</p>
<p><strong>tables_priv表和columns_priv表</strong></p>
<p>tables_priv表用来 对表设置操作权限 ，columns_priv表用来对表的 某一列设置权限 。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">desc</span> mysql.tables_priv;</span><br></pre></td></tr></table></figure>

<p>tables_priv表有8个字段，分别是Host、Db、User、Table_name、Grantor、Timestamp、Table_priv和Column_priv，各个字段说明如下：</p>
<ul>
<li>Host 、 Db 、 User 和 Table_name 四个字段分别表示主机名、数据库名、用户名和表名。</li>
<li>Grantor表示修改该记录的用户。</li>
<li>Timestamp表示修改该记录的时间。</li>
<li>Table_priv 表示对象的操作权限。包括Select、Insert、Update、Delete、Create、Drop、Grant、References、Index和Alter。</li>
<li>Column_priv字段表示对表中的列的操作权限，包括Select、Insert、Update和References。</li>
</ul>
<p><strong>procs_priv表</strong></p>
<p>procs_priv表可以对存储过程和存储函数设置操作权限 </p>
<h4 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a><strong>角色管理</strong></h4><p><strong>角色的理解</strong></p>
<p>引入角色的目的是 方便管理拥有相同权限的用户 。恰当的权限设定，可以确保数据的安全性，这是至关重要的</p>
<p><strong>创建角色</strong></p>
<p>创建角色使用 CREATE ROLE 语句，语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ROLE <span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>] [,<span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>]]...</span><br></pre></td></tr></table></figure>

<p>角色名称的命名规则和用户名类似。如果 host_name省略，默认为% ， role_name不可省略 ，不可为空。</p>
<p><strong>给角色赋予权限</strong></p>
<p>创建角色之后，默认这个角色是没有任何权限的，我们需要给角色授权。给角色授权的语法结构是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> privileges <span class="keyword">ON</span> table_name <span class="keyword">TO</span> <span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>上述语句中privileges代表权限的名称，多个权限以逗号隔开。</p>
<p><strong>查看角色的权限</strong></p>
<p>赋予角色权限之后，我们可以通过 SHOW GRANTS 语句，来查看权限是否创建成功了：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;manager&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Grants <span class="keyword">for</span> manager@<span class="operator">%</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> `manager`@`<span class="operator">%</span>` <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> `demo`.`goodsmaster` <span class="keyword">TO</span> `manager`@`<span class="operator">%</span>` <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> `demo`.`invcount` <span class="keyword">TO</span> `manager`@`<span class="operator">%</span>` <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> `demo`.`settlement` <span class="keyword">TO</span> `manager`@`<span class="operator">%</span>` <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>只要你创建了一个角色，系统就会自动给你一个“ USAGE ”权限，意思是 连接登录数据库的权限 。代码的最后三行代表了我们给角色“manager”赋予的权限，也就是对商品信息表、盘点表和应付账款表的只读权限。</p>
<p>结果显示，库管角色拥有商品信息表的只读权限和盘点表的增删改查权限。</p>
<p><strong>回收角色的权限</strong></p>
<p>角色授权后，可以对角色的权限进行维护，对权限进行添加或撤销。添加权限使用GRANT语句，与角色授权相同。撤销角色或角色权限使用REVOKE语句。</p>
<p>修改了角色的权限，会影响拥有该角色的账户的权限。</p>
<p>撤销角色权限的SQL语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> privileges <span class="keyword">ON</span> tablename <span class="keyword">FROM</span> <span class="string">&#x27;rolename&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>删除角色</strong></p>
<p>当我们需要对业务重新整合的时候，可能就需要对之前创建的角色进行清理，删除一些不会再使用的角色。删除角色的操作很简单，你只要掌握语法结构就行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> ROLE role [,role2]...</span><br></pre></td></tr></table></figure>

<p>注意， 如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限 。</p>
<p><strong>给用户赋予角色</strong></p>
<p>角色创建并授权后，要赋给用户并处于 激活状态 才能发挥作用。给用户添加角色可使用GRANT语句，语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> role [,role2,...] <span class="keyword">TO</span> <span class="keyword">user</span> [,user2,...];</span><br></pre></td></tr></table></figure>

<p>在上述语句中，role代表角色，user代表用户。可将多个角色同时赋予多个用户，用逗号隔开即可。</p>
<p><strong>激活角色</strong></p>
<p><strong>方式1：使用set default role命令激活角色</strong></p>
<p><strong>方式2：将activate_all_roles_on_login设置为ON</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> activate_all_roles_on_login<span class="operator">=</span><span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure>

<p>这条 SQL 语句的意思是，对 所有角色永久激活 。运行这条语句之后，用户才真正拥有了赋予角色的所有权限。</p>
<p><strong>撤销用户的角色</strong></p>
<p>撤销用户角色的SQL语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> role <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p><strong>设置强制角色(mandatory role)</strong></p>
<p>方式1：服务启动前设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">mandatory_roles=&#x27;role1,role2@localhost,r3@%.atguigu.com&#x27;</span><br></pre></td></tr></table></figure>

<p>方式2：运行时设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SET PERSIST mandatory_roles = &#x27;role1,role2@localhost,r3@%.example.com&#x27;; #系统重启后仍然有效</span><br><span class="line">SET GLOBAL mandatory_roles = &#x27;role1,role2@localhost,r3@%.example.com&#x27;; #系统重启后失效</span><br></pre></td></tr></table></figure>

<h3 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h3><h4 id="第1层：连接层"><a href="#第1层：连接层" class="headerlink" title="第1层：连接层"></a><strong>第1层：连接层</strong></h4><p>系统（客户端）访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。</p>
<p>经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。</p>
<ul>
<li>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</li>
<li>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</li>
</ul>
<p>TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p>
<h4 id="第2层：服务层"><a href="#第2层：服务层" class="headerlink" title="第2层：服务层"></a><strong>第2层：服务层</strong></h4><ul>
<li><p><strong>SQL Interface: SQL接口</strong></p>
<ul>
<li><p>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQLInterface</p>
</li>
<li><p>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</p>
</li>
</ul>
</li>
<li><p><strong>Parser:</strong> <strong>解析器</strong></p>
<ul>
<li><p>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</p>
</li>
<li><p>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建 语法树 ，并根据数据字典丰富查询语法树，会 验证该客户端是否具有执行该查询的权限 。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。</p>
</li>
</ul>
</li>
<li><p><strong>Optimizer:</strong> <strong>查询优化器</strong></p>
<ul>
<li><p>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划 。</p>
</li>
<li><p>这个执行计划表明应该 使用哪些索引 进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</p>
</li>
<li><p>它使用“ 选取-投影-连接 ”策略进行查询。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这个SELECT查询先根据WHERE语句进行 <strong>选取</strong> ，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性 投影 ，而不是将属性全部取出以后再进行过滤，将这两个查询条件 连接 起来生成最终查询结果。</p>
</li>
</ul>
</li>
<li><p><strong>Caches &amp; Buffers： 查询缓存组件</strong></p>
<ul>
<li><p>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。</p>
</li>
<li><p>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</p>
</li>
<li><p>这个查询缓存可以在 不同客户端之间共享 。</p>
</li>
<li><p>从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除 。</p>
</li>
</ul>
</li>
</ul>
<h4 id="第3层：引擎层"><a href="#第3层：引擎层" class="headerlink" title="第3层：引擎层"></a>第3层：引擎层</h4><p>插件式存储引擎层（ Storage Engines），真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p>
<h4 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h4><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 文件系统 上，以 文件 的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用DAS、NAS、SAN等各种存储系统。</p>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><h4 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a><strong>索引概述</strong></h4><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。</p>
<p><strong>索引的本质：</strong>索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 高级查找算法 。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ol>
<li>类似大学图书馆建书目索引，提高数据检索的效率，降低 数据库的IO成本 ，这也是创建索引最主要的原因。 </li>
<li>通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性 。</li>
<li>在实现数据的参考完整性方面，可以 加速表和表之间的连接 。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。 </li>
<li>在使用分组和排序子句进行数据查询时，可以显著 减少查询中分组和排序的时间 ，降低了CPU的消耗。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ol>
<li>创建索引和维护索引要 耗费时间 ，并且随着数据量的增加，所耗费的时间也会增加。</li>
<li>索引需要占 磁盘空间 ，除了数据表占数据空间之外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。 </li>
<li>虽然索引大大提高了查询速度，同时却会 降低更新表的速度 。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</li>
</ol>
<h3 id="InnoDB数据存储结构"><a href="#InnoDB数据存储结构" class="headerlink" title="InnoDB数据存储结构"></a>InnoDB数据存储结构</h3><h4 id="数据库存储结构：页"><a href="#数据库存储结构：页" class="headerlink" title="数据库存储结构：页"></a>数据库存储结构：页</h4><h5 id="磁盘与内存交互的基本单位：页"><a href="#磁盘与内存交互的基本单位：页" class="headerlink" title="磁盘与内存交互的基本单位：页"></a>磁盘与内存交互的基本单位：页</h5><p>InnoDB将数据划分为若干个页，InnoDB中页的大小默认为16k。</p>
<p>以页作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16k的内容到内存中，一次最少把内存中的16k内容刷新到磁盘中，也就是说，在数据库中，不论读一行，还是读多行，都是将这些所在的页进行加载，也就是说数据库管理存储空间的基本单位是页，数据库I&#x2F;O操作的最小单位是页，一个页中可以存储多个记录</p>
<h5 id="页的概述"><a href="#页的概述" class="headerlink" title="页的概述"></a>页的概述</h5><p>页可以在物理结构上不相连，只要通过双向链表相关联即可，每个数据页中记录会按照主键从小到大组成一个单向链表，每个数据页都会为存储在它里边的记录生成一个页目录，在通过主键查找某记录的时候在页目录中使用二分法快速定位到对应的槽，然后再遍历对应分组中的记录即可快速找到指定的记录。</p>
<h4 id="页的内部结构"><a href="#页的内部结构" class="headerlink" title="页的内部结构"></a>页的内部结构</h4><p><img src="2E798A58-F8E0-4CC7-B442-596383809330.png" alt="2E798A58-F8E0-4CC7-B442-596383809330"></p>
<h5 id="File-Header（文件头部）（38字节）"><a href="#File-Header（文件头部）（38字节）" class="headerlink" title="File Header（文件头部）（38字节）"></a>File Header（文件头部）（38字节）</h5><p><img src="FAB11077-E54A-43AB-82B9-2B0304750D21.png" alt="img"></p>
<ol>
<li><p>FIL_PAGE_OFFSET（4字节）、</p>
<p>每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页。</p>
</li>
<li><p>FIL_PAGE_OFFSET（4字节）</p>
<p><img src="E26C1E0A-9104-472B-9543-9A1C98E97642.png" alt="img"></p>
</li>
<li><p>FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）</p>
</li>
<li><p>FIL_PAGE_SPACE_OR_CHKSUM（4字节）</p>
</li>
<li><p>FIL_PAGE_LSN（8字节）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql日志与备份</title>
    <url>/2023/07/14/Mysql%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h2 id="其他数据库日志"><a href="#其他数据库日志" class="headerlink" title="其他数据库日志"></a>其他数据库日志</h2><p><img src="image-20230906161424994.png" alt="image-20230906161424994"></p>
<p><strong>千万不要小看日志</strong>。很多看似奇怪的问题，答案往往就藏在日志里。很多情况下，只有通过查看日志才 能发现问题的原因，真正解决问题。所以，一定要学会查看日志，养成检查日志的习惯，对提升你的数 据库应用开发能力至关重要。</p>
<h3 id="MySQL支持的日志"><a href="#MySQL支持的日志" class="headerlink" title="MySQL支持的日志"></a>MySQL支持的日志</h3><h4 id="日志类型"><a href="#日志类型" class="headerlink" title="日志类型"></a>日志类型</h4><p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为 <code>二进制日志</code> 、 <code>错误日志</code> 、 <code>通用查询日志</code> 和 <code>慢查询日志</code> ，这也是常用的4种。MySQL 8又新增两种支持的日志： 中继日志 和 数据定义语句日志 。使 用这些日志文件，可以查看MySQL内部发生的事情。</p>
<p>这6类日志分别为：</p>
<ul>
<li><strong>慢查询日志</strong>：记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。 </li>
<li><strong>通用查询日志</strong>：记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令， 对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。 </li>
<li><strong>错误日志</strong>：记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的 状态，从而对服务器进行维护。 </li>
<li><strong>二进制日志</strong>：记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故 障时数据的无损失恢复。 </li>
<li><strong>中继日志</strong>：用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。 从服务器通过读取中继日志的内容，来同步主服务器上的操作。 </li>
<li><strong>数据定义语句日志</strong>：记录数据定义语句执行的元数据操作。</li>
</ul>
<p>除二进制日志外，其他日志都是 <code>文本文件</code> 。默认情况下，所有日志创建于 <code>MySQL数据目录</code> 中。</p>
<h4 id="日志的弊端"><a href="#日志的弊端" class="headerlink" title="日志的弊端"></a>日志的弊端</h4><ul>
<li>日志功能会 <code>降低MySQL数据库的性能</code> 。例如，在查询非常频繁的MySQL数据库系统中，如果开启了通用查询日志和慢查询日志，MySQL数据库会花费很多时间记录日志。</li>
<li>日志会 <code>占用大量的磁盘空间</code> 。对于用户量非常大，操作非常频繁的数据库，日志文件需要的存储空间设置比数据库文件需要的存储空间还要大。</li>
</ul>
<h3 id="慢查询日志-slow-query-log"><a href="#慢查询日志-slow-query-log" class="headerlink" title="慢查询日志(slow query log)"></a>慢查询日志(slow query log)</h3><h3 id="通用查询日志-general-query-log"><a href="#通用查询日志-general-query-log" class="headerlink" title="通用查询日志(general query log)"></a>通用查询日志(general query log)</h3><p>通用查询日志用来 <code>记录用户的所有操作</code> ，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止 时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时，<strong>查看通用查询日志， 还原操作时的具体场景</strong>，可以帮助我们准确定位问题。</p>
<h4 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h4><p><img src="image-20230920151129880.png" alt="image-20230920151129880"></p>
<h4 id="查看当前状态"><a href="#查看当前状态" class="headerlink" title="查看当前状态"></a>查看当前状态</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span>                        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> general_log      <span class="operator">|</span> OFF                          <span class="operator">|</span> #通用查询日志处于关闭状态</span><br><span class="line"><span class="operator">|</span> general_log_file <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu01.log <span class="operator">|</span> #通用查询日志文件的名称是atguigu01.log</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>

<p><img src="image-20230920151229071.png" alt="image-20230920151229071"></p>
<h4 id="启动日志"><a href="#启动日志" class="headerlink" title="启动日志"></a>启动日志</h4><p><strong>方式1：永久性方式</strong></p>
<p>修改my.cnf或者my.ini配置文件来设置。在[mysqld]组下加入log选项，并重启MySQL服务。格式如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">general_log</span>=<span class="string">ON</span></span><br><span class="line"><span class="attr">general_log_file</span>=<span class="string">[path[filename]] #日志文件所在目录路径，filename为日志文件</span></span><br></pre></td></tr></table></figure>

<p>如果不指定目录和文件名，通用查询日志将默认存储在MySQL数据目录中的hostname.log文件中， hostname表示主机名。</p>
<p><strong>方式2：临时性方式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL general_log=on; # 开启通用查询日志</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL general_log_file=’path/filename’; # 设置日志文件保存位置</span><br></pre></td></tr></table></figure>

<p>对应的，关闭操作SQL命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL general_log=off; # 关闭通用查询日志</span><br></pre></td></tr></table></figure>

<p>查看设置后情况：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;general_log%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p>通用查询日志是以 <code>文本文件</code> 的形式存储在文件系统中的，可以使用 <code>文本编辑器</code> 直接打开日志文件。每台 MySQL服务器的通用查询日志内容是不同的。</p>
<ul>
<li>在Windows操作系统中，使用文本文件查看器； </li>
<li>在Linux系统中，可以使用vi工具或者gedit工具查看； </li>
<li>在Mac OSX系统中，可以使用文本文件查看器或者vi等工具查看。</li>
</ul>
<p>从 <code>SHOW VARIABLES LIKE &#39;general_log%&#39;</code>; 结果中可以看到通用查询日志的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/sbin/mysqld, Version: 8.0.26 (MySQL Community Server - GPL). started with:</span><br><span class="line">Tcp port: 3306 Unix socket: /var/lib/mysql/mysql.sock</span><br><span class="line">Time Id Command Argument</span><br><span class="line">2022-01-04T07:44:58.052890Z 10 Query SHOW VARIABLES LIKE &#x27;%general%&#x27;</span><br><span class="line">2022-01-04T07:45:15.666672Z 10 Query SHOW VARIABLES LIKE &#x27;general_log%&#x27;</span><br><span class="line">2022-01-04T07:45:28.970765Z 10 Query select * from student</span><br><span class="line">2022-01-04T07:47:38.706804Z 11 Connect root@localhost on using Socket</span><br><span class="line">2022-01-04T07:47:38.707435Z 11 Query select @@version_comment limit 1</span><br><span class="line">2022-01-04T07:48:21.384886Z 12 Connect root@172.16.210.1 on using TCP/IP</span><br><span class="line">2022-01-04T07:48:21.385253Z 12 Query SET NAMES utf8</span><br><span class="line">2022-01-04T07:48:21.385640Z 12 Query USE `atguigu12`</span><br><span class="line">2022-01-04T07:48:21.386179Z 12 Query SHOW FULL TABLES WHERE Table_Type !=</span><br><span class="line">&#x27;VIEW&#x27;</span><br><span class="line">2022-01-04T07:48:23.901778Z 13 Connect root@172.16.210.1 on using TCP/IP</span><br><span class="line">2022-01-04T07:48:23.902128Z 13 Query SET NAMES utf8</span><br><span class="line">2022-01-04T07:48:23.905179Z 13 Query USE `atguigu`</span><br><span class="line">2022-01-04T07:48:23.905825Z 13 Query SHOW FULL TABLES WHERE Table_Type !=</span><br><span class="line">&#x27;VIEW&#x27;</span><br><span class="line">2022-01-04T07:48:32.163833Z 14 Connect root@172.16.210.1 on using TCP/IP</span><br><span class="line">2022-01-04T07:48:32.164451Z 14 Query SET NAMES utf8</span><br><span class="line">2022-01-04T07:48:32.164840Z 14 Query USE `atguigu`</span><br><span class="line">2022-01-04T07:48:40.006687Z 14 Query select * from account</span><br></pre></td></tr></table></figure>

<p>在通用查询日志里面，我们可以清楚地看到，什么时候开启了新的客户端登陆数据库，登录之后做了什么 SQL 操作，针对的是哪个数据表等信息。</p>
<h4 id="停止日志"><a href="#停止日志" class="headerlink" title="停止日志"></a>停止日志</h4><p><strong>方式1：永久性方式</strong></p>
<p>修改 <code>my.cnf</code> 或者 <code>my.ini</code> 文件，把[mysqld]组下的 <code>general_log</code> 值设置为 <code>OFF</code> 或者把general_log一项 注释掉。修改保存后，再<code>重启MySQL服务</code> ，即可生效。 </p>
<p>举例1：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">general_log</span>=<span class="string">OFF</span></span><br></pre></td></tr></table></figure>

<p>举例2：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment">#general_log=ON</span></span><br></pre></td></tr></table></figure>

<p><strong>方式2：临时性方式</strong></p>
<p>使用SET语句停止MySQL通用查询日志功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL general_log=off;</span><br></pre></td></tr></table></figure>

<p>查询通用日志功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;general_log%&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="删除-刷新日志"><a href="#删除-刷新日志" class="headerlink" title="删除\刷新日志"></a>删除\刷新日志</h4><p>如果数据的使用非常频繁，那么通用查询日志会占用服务器非常大的磁盘空间。数据管理员可以删除很长时间之前的查询日志，以保证MySQL服务器上的硬盘空间。</p>
<p><strong>手动删除文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;general_log%&#x27;;</span><br></pre></td></tr></table></figure>

<p>可以看出，通用查询日志的目录默认为MySQL数据目录。在该目录下手动删除通用查询日志 atguigu01.log</p>
<p>使用如下命令重新生成查询日志文件，具体命令如下。刷新MySQL数据目录，发现创建了新的日志文 件。前提一定要开启通用日志。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqladmin -uroot -p flush-logs</span><br></pre></td></tr></table></figure>

<p>如果希望备份旧的通用查询日志，就必须先将旧的日志文件复制出来或者改名，然后执行上面的mysqladmin命令。正确流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd mysql-data-directory # 输入自己的通用日志文件所在目录</span><br><span class="line">mv mysql.general.log mysql.general.log.old # 指定旧的文件名 以及 新的文件名</span><br><span class="line">mysqladmin -uroot -p flush-logs</span><br></pre></td></tr></table></figure>

<h3 id="错误日志-error-log"><a href="#错误日志-error-log" class="headerlink" title="错误日志(error log)"></a>错误日志(error log)</h3><p><img src="image-20231106221909417.png" alt="image-20231106221909417"></p>
<h4 id="启动日志-1"><a href="#启动日志-1" class="headerlink" title="启动日志"></a>启动日志</h4><p>在MySQL数据库中，错误日志功能是 <code>默认开启</code> 的。而且，错误日志 <code>无法被禁止</code> 。</p>
<p>默认情况下，错误日志存储在MySQL数据库的数据文件夹下，名称默认为 <code>mysqld.log</code> （Linux系统）或 <code>hostname.err</code> （mac系统）。如果需要制定文件名，则需要在my.cnf或者my.ini中做如下配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">log-error</span>=<span class="string">[path/[filename]] #path为日志文件所在的目录路径，filename为日志文件名</span></span><br></pre></td></tr></table></figure>

<p>修改配置项后，需要重启MySQL服务以生效。</p>
<h4 id="查看日志-1"><a href="#查看日志-1" class="headerlink" title="查看日志"></a>查看日志</h4><p>MySQL错误日志是以文本文件形式存储的，可以使用文本编辑器直接查看。</p>
<p>查询错误日志的存储路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;log_err%&#x27;;</span><br><span class="line">+----------------------------+----------------------------------------+</span><br><span class="line">| Variable_name              | Value                                  |</span><br><span class="line">+----------------------------+----------------------------------------+</span><br><span class="line">| log_error                  | /var/log/mysqld.log                    |</span><br><span class="line">| log_error_services         | log_filter_internal; log_sink_internal |</span><br><span class="line">| log_error_suppression_list |                                        |</span><br><span class="line">| log_error_verbosity        | 2                                      |</span><br><span class="line">+----------------------------+----------------------------------------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>执行结果中可以看到错误日志文件是mysqld.log，位于MySQL默认的数据目录下。</p>
<img src="workspace/architect/StudyNotes/MySQL高级篇/MySQL日志与备份篇.assets/image-20220715160657093.png" alt="image-20220715160657093" style="float:left;">

<h4 id="删除-刷新日志-1"><a href="#删除-刷新日志-1" class="headerlink" title="删除\刷新日志"></a>删除\刷新日志</h4><p>对于很久以前的错误日志，数据库管理员查看这些错误日志的可能性不大，可以将这些错误日志删除， 以保证MySQL服务器上的 <code>硬盘空间</code> 。MySQL的错误日志是以文本文件的形式存储在文件系统中的，可以 <code>直接删除</code> 。</p>
<ul>
<li><p>第一步（方式1）：删除操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -f /var/lib/mysql/mysqld.log</span><br></pre></td></tr></table></figure>

<p>在运行状态下删除错误日志文件后，MySQL并不会自动创建日志文件。</p>
</li>
<li><p>第一步（方式2）：重命名文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv /var/log/mysqld.log /var/log/mysqld.log.old</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步：重建日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqladmin -uroot -p flush-logs</span><br></pre></td></tr></table></figure>

<p>可能会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@atguigu01 log]# mysqladmin -uroot -p flush-logs</span><br><span class="line">Enter password:</span><br><span class="line">mysqladmin: refresh failed; error: &#x27;Could not open file &#x27;/var/log/mysqld.log&#x27; for</span><br><span class="line">error logging.&#x27;</span><br></pre></td></tr></table></figure>

<p>官网提示：</p>
<p><img src="workspace/architect/StudyNotes/MySQL高级篇/MySQL日志与备份篇.assets/image-20220715161132368.png" alt="image-20220715161132368"></p>
</li>
</ul>
<p>补充操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install -omysql -gmysql -m0644 /dev/null /var/log/mysqld.log</span><br></pre></td></tr></table></figure>

<img src="workspace/architect/StudyNotes/MySQL高级篇/MySQL日志与备份篇.assets/image-20220715161216556.png" alt="image-20220715161216556" style="float:left;">

<h4 id="MySQL-8-0-新特性"><a href="#MySQL-8-0-新特性" class="headerlink" title="MySQL 8.0 新特性"></a>MySQL 8.0 新特性</h4><img src="workspace/architect/StudyNotes/MySQL高级篇/MySQL日志与备份篇.assets/image-20220715161321565.png" alt="image-20220715161321565" style="float:left;">

<blockquote>
<p>小结：</p>
<p>通常情况下，管理员不需要查看错误日志。但是，MySQL服务器发生异常时，管理员可以从错误日志中找到发生异常的时间、原因，然后根据这些信息来解决异常。</p>
</blockquote>
<h3 id="二进制日志-bin-log"><a href="#二进制日志-bin-log" class="headerlink" title="二进制日志(bin log)"></a>二进制日志(bin log)</h3><p>binlog可以说是MySQL中比较 <code>重要</code> 的日志了，在日常开发及运维过程中，经常会遇到。</p>
<p>binlog即binary log，二进制日志文件，也叫作变更日志（update log）。它记录了数据库所有执行的 <code>DDL</code> 和 <code>DML</code> 等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、 show等）。</p>
<p>它以<code>事件形式</code>记录并保存在<code>二进制文件</code>中。通过这些信息，我们可以再现数据更新操作的全过程。</p>
<blockquote>
<p>如果想要记录所有语句（例如，为了识别有问题的查询），需要使用通用查询日志。</p>
</blockquote>
<p>binlog主要应用场景：</p>
<p><img src="image-20231106222028359.png" alt="image-20231106222028359"></p>
<p><img src="image-20231106222034227.png" alt="image-20231106222034227"></p>
<h4 id="查看默认情况"><a href="#查看默认情况" class="headerlink" title="查看默认情况"></a>查看默认情况</h4><p>查看记录二进制日志是否开启：在MySQL8中默认情况下，二进制文件是开启的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%log_bin%&#x27;;</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">| Variable_name                   | Value                            |</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">| log_bin                         | ON                               |</span><br><span class="line">| log_bin_basename                | /var/lib/mysql/binlog            |</span><br><span class="line">| log_bin_index                   | /var/lib/mysql/binlog.index      |</span><br><span class="line">| log_bin_trust_function_creators | OFF                              |</span><br><span class="line">| log_bin_use_v1_row_events       | OFF                              |</span><br><span class="line">| sql_log_bin                     | ON                               |</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<img src="workspace/architect/StudyNotes/MySQL高级篇/MySQL日志与备份篇.assets/image-20220715163520596.png" alt="image-20220715163520596" style="float:left;">

<h4 id="日志参数设置"><a href="#日志参数设置" class="headerlink" title="日志参数设置"></a>日志参数设置</h4><p><strong>方式1：永久性方式</strong></p>
<p>修改MySQL的 <code>my.cnf</code> 或 <code>my.ini</code> 文件可以设置二进制日志的相关参数：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment">#启用二进制日志</span></span><br><span class="line"><span class="attr">log-bin</span>=<span class="string">atguigu-bin</span></span><br><span class="line"><span class="attr">binlog_expire_logs_seconds</span>=<span class="string">600</span></span><br><span class="line"><span class="attr">max_binlog_size</span>=<span class="string">100M</span></span><br></pre></td></tr></table></figure>

<img src="workspace/architect/StudyNotes/MySQL高级篇/MySQL日志与备份篇.assets/image-20220715163811664.png" alt="image-20220715163811664" style="float:left;">

<p>重新启动MySQL服务，查询二进制日志的信息，执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%log_bin%&#x27;;</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">| Variable_name                   | Value                            |</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">| log_bin                         | ON                               |</span><br><span class="line">| log_bin_basename                | /var/lib/mysql/atguigu-bin       |</span><br><span class="line">| log_bin_index                   | /var/lib/mysql/atguigu-bin.index |</span><br><span class="line">| log_bin_trust_function_creators | OFF                              |</span><br><span class="line">| log_bin_use_v1_row_events       | OFF                              |</span><br><span class="line">| sql_log_bin                     | ON                               |</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>设置带文件夹的bin-log日志存放目录</strong></p>
<p>如果想改变日志文件的目录和名称，可以对my.cnf或my.ini中的log_bin参数修改如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">log-bin</span>=<span class="string">&quot;/var/lib/mysql/binlog/atguigu-bin&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意：新建的文件夹需要使用mysql用户，使用下面的命令即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown -R -v mysql:mysql binlog</span><br></pre></td></tr></table></figure>

<img src="workspace/architect/StudyNotes/MySQL高级篇/MySQL日志与备份篇.assets/image-20220715164107352.png" alt="image-20220715164107352" style="float:left;">

<p><strong>方式2：临时性方式</strong></p>
<p>如果不希望通过修改配置文件并重启的方式设置二进制日志的话，还可以使用如下指令，需要注意的是 在mysql8中只有 <code>会话级别</code> 的设置，没有了global级别的设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># global 级别</span><br><span class="line">mysql&gt; set global sql_log_bin=0;</span><br><span class="line">ERROR 1228 (HY000): Variable &#x27;sql_log_bin&#x27; is a SESSION variable and can`t be used</span><br><span class="line">with SET GLOBAL</span><br><span class="line"></span><br><span class="line"># session级别</span><br><span class="line">mysql&gt; SET sql_log_bin=0;</span><br><span class="line">Query OK, 0 rows affected (0.01 秒)</span><br></pre></td></tr></table></figure>

<h4 id="查看日志-2"><a href="#查看日志-2" class="headerlink" title="查看日志"></a>查看日志</h4><p>当MySQL创建二进制日志文件时，先创建一个以“filename”为名称、以“.index”为后缀的文件，再创建一 个以“filename”为名称、以“.000001”为后缀的文件。</p>
<p>MySQL服务 <code>重新启动一次</code> ，以“.000001”为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的 个数与MySQL服务启动的次数相同；如果日志长度超过了 <code>max_binlog_size</code> 的上限（默认是1GB），就会创建一个新的日志文件。</p>
<p>查看当前的二进制日志文件列表及大小。指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW BINARY LOGS;</span><br><span class="line">+--------------------+-----------+-----------+</span><br><span class="line">| Log_name           | File_size | Encrypted |</span><br><span class="line">+--------------------+-----------+-----------+</span><br><span class="line">| atguigu-bin.000001 | 156       | No        |</span><br><span class="line">+--------------------+-----------+-----------+</span><br><span class="line">1 行于数据集 (0.02 秒)</span><br></pre></td></tr></table></figure>

<p>所有对数据库的修改都会记录在binlog中。但binlog是二进制文件，无法直接查看，想要更直观的观测它就要借助<code>mysqlbinlog</code>命令工具了。指令如下：在查看执行，先执行一条SQL语句，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update student set name=&#x27;张三_back&#x27; where id=1;</span><br></pre></td></tr></table></figure>

<p>开始查看binlog</p>
<img src="workspace/architect/StudyNotes/MySQL高级篇/MySQL日志与备份篇.assets/image-20220715164718970.png" alt="image-20220715164718970" style="float:left;">

<img src="workspace/architect/StudyNotes/MySQL高级篇/MySQL日志与备份篇.assets/image-20220715164743351.png" alt="image-20220715164743351" style="float:left;">

<img src="workspace/architect/StudyNotes/MySQL高级篇/MySQL日志与备份篇.assets/image-20220715164809401.png" alt="image-20220715164809401" style="float:left;">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqlbinlog -v &quot;/var/lib/mysql/binlog/atguigu-bin.000002&quot;</span><br><span class="line">#220105 9:16:37 server id 1 end_log_pos 324 CRC32 0x6b31978b Query thread_id=10</span><br><span class="line">exec_time=0 error_code=0</span><br><span class="line">SET TIMESTAMP=1641345397/*!*/;</span><br><span class="line">SET @@session.pseudo_thread_id=10/*!*/;</span><br><span class="line">SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0,</span><br><span class="line">@@session.unique_checks=1, @@session.autocommit=1/*!*/;</span><br><span class="line">SET @@session.sql_mode=1168113696/*!*/;</span><br><span class="line">SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;</span><br><span class="line">/*!\C utf8mb3 *//*!*/;</span><br><span class="line">SET</span><br><span class="line">@@session.character_set_client=33,@@session.collation_connection=33,@@session.collatio</span><br><span class="line">n_server=255/*!*/;</span><br><span class="line">SET @@session.lc_time_names=0/*!*/;</span><br><span class="line">SET @@session.collation_database=DEFAULT/*!*/;</span><br><span class="line">/*!80011 SET @@session.default_collation_for_utf8mb4=255*//*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 324</span><br><span class="line">#220105 9:16:37 server id 1 end_log_pos 391 CRC32 0x74f89890 Table_map:</span><br><span class="line">`atguigu14`.`student` mapped to number 85</span><br><span class="line"># at 391</span><br><span class="line">#220105 9:16:37 server id 1 end_log_pos 470 CRC32 0xc9920491 Update_rows: table id</span><br><span class="line">85 flags: STMT_END_F</span><br><span class="line"></span><br><span class="line">BINLOG &#x27;</span><br><span class="line">dfHUYRMBAAAAQwAAAIcBAAAAAFUAAAAAAAEACWF0Z3VpZ3UxNAAHc3R1ZGVudAADAw8PBDwAHgAG</span><br><span class="line">AQEAAgEhkJj4dA==</span><br><span class="line">dfHUYR8BAAAATwAAANYBAAAAAFUAAAAAAAEAAgAD//8AAQAAAAblvKDkuIkG5LiA54+tAAEAAAAL</span><br><span class="line">5byg5LiJX2JhY2sG5LiA54+tkQSSyQ==</span><br><span class="line">&#x27;/*!*/;</span><br><span class="line">### UPDATE `atguigu`.`student`</span><br><span class="line">### WHERE</span><br><span class="line">### @1=1</span><br><span class="line">### @2=&#x27;张三&#x27;</span><br><span class="line">### @3=&#x27;一班&#x27;</span><br><span class="line">### SET</span><br><span class="line">### @1=1</span><br><span class="line">### @2=&#x27;张三_back&#x27;</span><br><span class="line">### @3=&#x27;一班&#x27;</span><br><span class="line"># at 470</span><br><span class="line">#220105 9:16:37 server id 1 end_log_pos 501 CRC32 0xca01d30f Xid = 15</span><br><span class="line">COMMIT/*!*/;</span><br></pre></td></tr></table></figure>

<p>前面的命令同时显示binlog格式的语句，使用如下命令不显示它</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqlbinlog -v --base64-output=DECODE-ROWS &quot;/var/lib/mysql/binlog/atguigu-bin.000002&quot;</span><br><span class="line">#220105 9:16:37 server id 1 end_log_pos 324 CRC32 0x6b31978b Query thread_id=10</span><br><span class="line">exec_time=0 error_code=0</span><br><span class="line">SET TIMESTAMP=1641345397/*!*/;</span><br><span class="line">SET @@session.pseudo_thread_id=10/*!*/;</span><br><span class="line">SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0,</span><br><span class="line">@@session.unique_checks=1, @@session.autocommit=1/*!*/;</span><br><span class="line">SET @@session.sql_mode=1168113696/*!*/;</span><br><span class="line">SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;</span><br><span class="line">/*!\C utf8mb3 *//*!*/;</span><br><span class="line">SET</span><br><span class="line">@@session.character_set_client=33,@@session.collation_connection=33,@@session.collatio</span><br><span class="line">n_server=255/*!*/;</span><br><span class="line">SET @@session.lc_time_names=0/*!*/;</span><br><span class="line">SET @@session.collation_database=DEFAULT/*!*/;</span><br><span class="line">/*!80011 SET @@session.default_collation_for_utf8mb4=255*//*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 324</span><br><span class="line">#220105 9:16:37 server id 1 end_log_pos 391 CRC32 0x74f89890 Table_map:</span><br><span class="line">`atguigu14`.`student` mapped to number 85</span><br><span class="line"># at 391</span><br><span class="line">#220105 9:16:37 server id 1 end_log_pos 470 CRC32 0xc9920491 Update_rows: table id</span><br><span class="line">85 flags: STMT_END_F</span><br><span class="line">### UPDATE `atguigu14`.`student`</span><br><span class="line">### WHERE</span><br><span class="line">### @1=1</span><br><span class="line">### @2=&#x27;张三&#x27;</span><br><span class="line">### @3=&#x27;一班&#x27;</span><br><span class="line">### SET</span><br><span class="line">### @1=1</span><br><span class="line">### @2=&#x27;张三_back&#x27;</span><br><span class="line">### @3=&#x27;一班&#x27;</span><br><span class="line"># at 470</span><br><span class="line">#220105 9:16:37 server id 1 end_log_pos 501 CRC32 0xca01d30f Xid = 15</span><br></pre></td></tr></table></figure>

<p>关于mysqlbinlog工具的使用技巧还有很多，例如只解析对某个库的操作或者某个时间段内的操作等。简单分享几个常用的语句，更多操作可以参考官方文档。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 可查看参数帮助</span><br><span class="line">mysqlbinlog --no-defaults --help</span><br><span class="line"># 查看最后100行</span><br><span class="line">mysqlbinlog --no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |tail</span><br><span class="line">-100</span><br><span class="line"># 根据position查找</span><br><span class="line">mysqlbinlog --no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |grep -A</span><br><span class="line">20 &#x27;4939002&#x27;</span><br></pre></td></tr></table></figure>

<p>上面这种办法读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息，下面介绍一种更为方便的查询命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show binlog events [IN &#x27;log_name&#x27;] [FROM pos] [LIMIT [offset,] row_count];</span><br></pre></td></tr></table></figure>

<ul>
<li><code>IN &#39;log_name&#39;</code> ：指定要查询的binlog文件名（不指定就是第一个binlog文件）　 </li>
<li><code>FROM pos</code> ：指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算） </li>
<li><code>LIMIT [offset]</code> ：偏移量(不指定就是0) </li>
<li><code>row_count</code> :查询总条数（不指定就是所有行）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show binlog events in &#x27;atguigu-bin.000002&#x27;;</span><br><span class="line">+--------------------+-----+----------------+-----------+-------------+--------------------------------------------------------+</span><br><span class="line">| Log_name           | Pos | Event_type     | Server_id | End_log_pos | Info                                                   |</span><br><span class="line">+--------------------+-----+----------------+-----------+-------------+--------------------------------------------------------+</span><br><span class="line">| atguigu-bin.000002 | 4   | Format_desc    | 1         | 125         | Server ver: 8.0.26, Binlog ver: 4                      |</span><br><span class="line">| atguigu-bin.000002 | 125 | Previous_gtids | 1         | 156         |                                                        |</span><br><span class="line">| atguigu-bin.000002 | 156 | Anonymous_Gtid | 1         | 235         | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;                   |</span><br><span class="line">| atguigu-bin.000002 | 235 | Query          | 1         | 324         | BEGIN                                                  |</span><br><span class="line">| atguigu-bin.000002 | 324 | Table_map      | 1         | 391         | table_id: 85(atguigu14.student)                        |</span><br><span class="line">| atguigu-bin.000002 | 391 | Update_rows    | 1         | 470         | table_id: 85flags: STMT_END_F                          |</span><br><span class="line">| atguigu-bin.000002 | 470 | Xid            | 1         | 501         | COMMIT /*xid=15 */                                     |</span><br><span class="line">| atguigu-bin.000002 | 501 | Anonymous_Gtid | 1         | 578         | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;                   |</span><br><span class="line">| atguigu-bin.000002 | 578 | Query     | 1 | 721 | use `atguigu14`; create table test(id int, title varchar(100)) /* xid=19 */ |</span><br><span class="line">| atguigu-bin.000002 | 721 | Anonymous_Gtid | 1         | 800         | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;                   |</span><br><span class="line">| atguigu-bin.000002 | 800 | Query          | 1         | 880         | BEGIN                                                  |</span><br><span class="line">| atguigu-bin.000002 | 880 | Table_map      | 1         | 943         | table_id: 89(atguigu14.test)                           |</span><br><span class="line">| atguigu-bin.000002 | 943 | Write_rows     | 1         | 992         | table_id: 89 flags: STMT_END_F                         |</span><br><span class="line">| atguigu-bin.000002 | 992 | Xid            | 1         | 1023        | COMMIT /*xid=21 */                                     |</span><br><span class="line">+--------------------+-----+----------------+-----------+-------------+--------------------------------------------------------+</span><br><span class="line">14 行于数据集 (0.02 秒)</span><br></pre></td></tr></table></figure>

<img src="workspace/architect/StudyNotes/MySQL高级篇/MySQL日志与备份篇.assets/image-20220715165603879.png" alt="image-20220715165603879" style="float:left;">

<p>上面我们讲了这么多都是基于binlog的默认格式，binlog格式查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;binlog_format&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| binlog_format | ROW   |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 行于数据集 (0.02 秒)</span><br></pre></td></tr></table></figure>

<p>除此之外，binlog还有2种格式，分别是<code>Statement</code>和<code>Mixed</code></p>
<ul>
<li><p>Statement</p>
<p>每一条会修改数据的sql都会记录在binlog中。</p>
<p>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。</p>
</li>
<li><p>Row</p>
<p>5.1.5版本的MySQL才开始支持row level 的复制，它不记录sql语句上下文相关信息，仅保存哪条记录被修改。</p>
<p>优点：row level 的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下 的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题。</p>
</li>
<li><p>Mixed</p>
<p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。</p>
<p>详细情况，下章讲解。</p>
</li>
</ul>
<h4 id="使用日志恢复数据"><a href="#使用日志恢复数据" class="headerlink" title="使用日志恢复数据"></a>使用日志恢复数据</h4><p>如果MySQL服务器启用了二进制日志，在数据库出现意外丢失数据时，可以使用MySQLbinlog工具从指定的时间点开始（例如，最后一次备份）直到现在或另一个指定的时间点的日志中回复数据。</p>
<p>mysqlbinlog恢复数据的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqlbinlog [option] filename|mysql –uuser -ppass;</span><br></pre></td></tr></table></figure>

<p>这个命令可以这样理解：使用mysqlbinlog命令来读取filename中的内容，然后使用mysql命令将这些内容恢复到数据库中。</p>
<ul>
<li><p><code>filename</code> ：是日志文件名。</p>
</li>
<li><p><code>option</code> ：可选项，比较重要的两对option参数是–start-date、–stop-date 和 –start-position、– stop-position。</p>
<ul>
<li><code>--start-date</code> 和<code> --stop-date</code> ：可以指定恢复数据库的起始时间点和结束时间点。</li>
<li><code>--start-position</code>和<code>--stop-position</code> ：可以指定恢复数据的开始位置和结束位置。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复，例如atguigu-bin.000001必须在atguigu-bin.000002之前恢复。</p>
</blockquote>
<p>详见p189，由于翻页过快，这部分没办法记录。</p>
<h4 id="删除二进制日志"><a href="#删除二进制日志" class="headerlink" title="删除二进制日志"></a>删除二进制日志</h4><p>MySQL的二进制文件可以配置自动删除，同时MySQL也提供了安全的手动删除二进制文件的方法。 <code>PURGE MASTER LOGS</code> 只删除指定部分的二进制日志文件， <code>RESET MASTER</code> 删除所有的二进制日志文 件。具体如下：</p>
<p><strong>1. PURGE MASTER LOGS：删除指定日志文件</strong></p>
<p>PURGE MASTER LOGS语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PURGE &#123;MASTER | BINARY&#125; LOGS TO ‘指定日志文件名’</span><br><span class="line">PURGE &#123;MASTER | BINARY&#125; LOGS BEFORE ‘指定日期’</span><br></pre></td></tr></table></figure>

<img src="workspace/architect/StudyNotes/MySQL高级篇/MySQL日志与备份篇.assets/image-20220715171712026.png" alt="image-20220715171712026" style="float:left;">

<img src="workspace/architect/StudyNotes/MySQL高级篇/MySQL日志与备份篇.assets/image-20220715172015185.png" alt="image-20220715172015185" style="float:left;">

<p><strong>2. RESET MASTER: 删除所有二进制日志文件</strong></p>
<img src="workspace/architect/StudyNotes/MySQL高级篇/MySQL日志与备份篇.assets/image-20220715172104967.png" alt="image-20220715172104967" style="float:left;">

<h4 id="其它场景"><a href="#其它场景" class="headerlink" title="其它场景"></a>其它场景</h4><p>二进制日志可以通过数据库的 <code>全量备份</code> 和二进制日志中保存的 <code>增量信息</code> ，完成数据库的 <code>无损失恢复</code> 。 但是，如果遇到数据量大、数据库和数据表很多（比如分库分表的应用）的场景，用二进制日志进行数据恢复，是很有挑战性的，因为起止位置不容易管理。</p>
<p>在这种情况下，一个有效的解决办法是 <code>配置主从数据库服务器</code> ，甚至是 <code>一主多从</code> 的架构，把二进制日志文件的内容通过中继日志，同步到从数据库服务器中，这样就可以有效避免数据库故障导致的数据异常等问题。</p>
<h3 id="再谈二进制日志-binlog"><a href="#再谈二进制日志-binlog" class="headerlink" title="再谈二进制日志(binlog)"></a>再谈二进制日志(binlog)</h3>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC框架</title>
    <url>/2023/02/02/RPC%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>RPC 的主要功能目标是让构建分布式计算（应用）更容易，是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议规范，简单的来说就是像调用本地服务一样调用远程服务，对开发者而言是透明的。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1、RPC框架一般使用长链接，不必每次通信都要3次握手，减少网络开销</p>
<p>2、RPC框架一般都有注册中心，有丰富的监控管理</p>
<p>3、发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作</p>
<p>4、协议私密，安全性较高</p>
<p>5、rpc 能做到协议更简单内容更小，效率更高</p>
<p>6、rpc是面向服务的更高级的抽象，支持服务注册发现，负载均衡，超时重试，熔断降级等高级特性</p>
<h2 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h2><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>在高可用的生产环境中，服务一般都以集群方式提供服务，集群里面的IP等重要参数信息可能随时会发生变化，节点也可能会动态扩缩容，客户端需要能够及时感知服务端的变化，获取集群最新服务节点的连接信息，而这些变化要求是要对调用方应用无感知的。</p>
<p>常用的注册中心：<strong>Zookeeper</strong>，<strong>Consul</strong>，<strong>Nacos</strong></p>
<h3 id="代理技术"><a href="#代理技术" class="headerlink" title="代理技术"></a>代理技术</h3><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">在运行期动态的创建代理类，它是通过接口生成代理类的，与静态代理相比更加灵活，但是也有一定的限制，第一是代理对象必须实现一个接口，否则会报异常。第二是有性能问题，因为是通过反射来实现调用的，所以比正常的直接调用来得慢，并且通过生成类文件也会多消耗部分方法区空间，可能引起Full GC。</span><br></pre></td></tr></table></figure>

<p><strong>代码实现：</strong></p>
<p>1、定义一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、编写实现类，并定义一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.jdk;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、编写一个代理方法处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: jdk动态代理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JdkProxy</span><span class="params">(Object object)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> method.invoke(object, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉打豆豆&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、生成代理对象测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dogProxy</span> <span class="operator">=</span> (Animal) Proxy.newProxyInstance(animal.getClass().getClassLoader(), animal.getClass().getInterfaces(), <span class="keyword">new</span> <span class="title class_">JdkProxy</span>(animal));</span><br><span class="line">        dogProxy.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现原理：</strong></p>
<p>JDK动态代理是指：代理类实例在程序运行时，由JVM根据反射机制动态的生成。也就是说代理类不是用户自己定义的，而是由JVM生成的。</p>
<p><strong>1.1 InvocationHandler接口</strong></p>
<p>​		代理实例的调用处理器需要实现InvocationHandler接口，并且每个代理实例都有一个关联的调用处理器。当一个方法在代理实例上被调用时，这个方法调用将被编码并分派到其调用处理器的invoke方法上。</p>
<p>​		也就是说，我们创建的每一个代理实例都要有一个关联的InvocationHandler，并且在调用代理实例的方法时，会被转到InvocationHandler的invoke方法上。</p>
<p>publicObject invoke(Object proxy, Method method, Object[] args) throws Throwable；该invoke方法的作用是：处理代理实例上的方法调用并返回结果。</p>
<p>其有三个参数，分别为：</p>
<ul>
<li><strong>proxy</strong>：是调用该方法的代理实例。</li>
<li><strong>method</strong>：是在代理实例上调用的接口方法对应的Method实例。</li>
<li><strong>args</strong>：一个Object数组，是在代理实例上的方法调用中传递的参数值。如果接口方法为无参，则该值为null。</li>
<li>其返回值为：调用代理实例上的方法的返回值</li>
</ul>
<p><strong>1.2 Proxy类</strong></p>
<p>Proxy类提供了创建动态代理类及其实例的静态方法，该类也是动态代理类的超类。</p>
<p>代理类具有以下属性：</p>
<ul>
<li>代理类的名称以 “$Proxy” 开头，后面跟着一个数字序号。</li>
<li>代理类继承了Proxy类。</li>
<li>代理类实现了创建时指定的接口（JDK动态代理是面向接口的）。</li>
<li>每个代理类都有一个公共构造函数，它接受一个参数，即接口InvocationHandler的实现，用于设置代理实例的调用处理器。</li>
</ul>
<p>Proxy提供了两个静态方法，用于获取代理对象。</p>
<p><strong>1.2.1 getProxyClass</strong></p>
<p>用于获取代理类的Class对象，再通过调用构造函数创建代理实例。</p>
<p>该方法有两个参数：</p>
<ul>
<li><strong>loader</strong>：为类加载器。</li>
<li><strong>intefaces</strong>：为接口的Class对象数组。</li>
</ul>
<p>返回值为动态代理类的Class对象。</p>
<p><strong>1.2.2 newProxyInstance</strong></p>
<p>用于创建一个代理实例。</p>
<p>该方法有三个参数：</p>
<ul>
<li><strong>loader</strong>：为类加载器。</li>
<li><strong>interfaces</strong>：为接口的Class对象数组。</li>
<li><strong>h</strong>：指定的调用处理器。</li>
</ul>
<p>返回值为指定接口的代理类的实例。</p>
<p><strong>生成代理类：</strong></p>
<ul>
<li>代理类继承了Proxy类，其主要目的是为了传递InvocationHandler</li>
<li>代理类实现了被代理的接口，这也是为什么代理类可以直接强转成接口的原因。</li>
<li>有一个公开的构造函数，参数为指定的InvocationHandler，并将参数传递到父类Proxy中。</li>
<li>每一个实现的方法，都会调用InvocationHandler中的invoke方法，并将代理类本身、Method实例、入参三个参数进行传递。这也是为什么调用代理类中的方法时，总会分派到InvocationHandler中的invoke方法的原因。</li>
</ul>
<p><strong>代理生成过程：</strong></p>
<ol>
<li><p>调用<strong>getProxyClass 和 newProxyInstance</strong>方法，底层逻辑都会调用<strong>getProxyClass0</strong>方法</p>
</li>
<li><p>代理接口的最多不能超过65535个，会先从缓存<strong>WeakCache</strong>中获取代理类，则没有再通过<strong>ProxyClassFactory</strong>创建代理类。</p>
</li>
<li><p>ProxyClassFactory是Proxy类的一个静态内部类，该类用于生成代理类。</p>
<p>1）代理类的名称就是在这里定义的，其前缀是$Proxy，后缀是一个数字。</p>
<p>2）调用ProxyGenerator.generateProxyClass生成文件流。</p>
<p>3）defineClass0方法是一个native方法，负责字节码加载的实现，并返回对应的Class对象。</p>
</li>
</ol>
<h4 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">ASM 是一个 Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为（也就是生成的代码可以覆盖原来的类也可以是原始类的子类）。不过ASM在创建class字节码的过程中，操纵的是底层JVM的汇编指令级别，这要求ASM使用者要对class组织结构和JVM汇编指令有一定的了解</span><br></pre></td></tr></table></figure>

<h4 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">CGLIB(Code Generation Library)是一个基于ASM的字节码生成库。其原理是动态生成一个要代理类的子类，子类重写要代理的类的所有不是final的方法，在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用java反射的JDK动态代理要快</span><br></pre></td></tr></table></figure>

<p><strong>代码实现：</strong></p>
<p>1、创建一个测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.cglib;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-28</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、实现MethodInterceptor接口，自定义拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-28</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、通过Enhancer创建代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.cglib;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; clazz)</span>&#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">CglibProxy</span>());</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.cglib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-28</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">proxy</span> <span class="operator">=</span> (Student) CglibProxyFactory.createProxy(Student.class);</span><br><span class="line">        proxy.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现原理：</strong></p>
<p>动态生成一个要代理类的子类，子类重写要代理的类的所有不是 final 的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。</p>
<p>采用ASM字节码生成框架，使用字节码技术生成代理类，比使用 Java 反射效率要高。</p>
<p><strong>代理字节码文件：</strong></p>
<ul>
<li>生成的动态代理类继承了父类 Student，并且实现了接口 Factory</li>
<li>动态代理类持有 MethodInterceptor</li>
<li>动态代理类会重写父类 Student 的非 final、private 方法；也会构建自己的方法（cglib 方法），构建方式：CGLIB”+“$父类方法名$</li>
<li>cglib 方法的方法体：super.方法名，直接调用父类；重写方法：它会调用拦截器中的 intercept() 方法</li>
<li>methodProxy.invokeSuper() 方法会调用动态代理类中的 cglib 方法；methodProxy.invoke() 方法会调用动态代理类中的重写方法</li>
</ul>
<h4 id="bytebuddy"><a href="#bytebuddy" class="headerlink" title="bytebuddy"></a>bytebuddy</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Byte Buddy本身也是基于 ASM API 实现的，是一个较高层级的抽象的字节码操作工具，通过使用 Byte Buddy ，任何熟悉 Java 编程语言的人都有望非常容易地进行字节码操作。</span><br></pre></td></tr></table></figure>

<p>增强案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.bytebuddy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.ByteBuddy;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.implementation.FixedValue;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.matcher.ElementMatcher;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.matcher.ElementMatchers;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 入门案例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteBuddy</span>()</span><br><span class="line">                <span class="comment">//指定父类</span></span><br><span class="line">                .subclass(Object.class)</span><br><span class="line">                <span class="comment">//指定生成的类名</span></span><br><span class="line">                .name(<span class="string">&quot;User&quot;</span>)</span><br><span class="line">                <span class="comment">//按名称拦截类的 toString</span></span><br><span class="line">                .method(ElementMatchers.named(<span class="string">&quot;toString&quot;</span>))</span><br><span class="line">                <span class="comment">//拦截方法调用 返回固定值</span></span><br><span class="line">                .intercept(FixedValue.value(<span class="string">&quot;HelloWorld&quot;</span>))</span><br><span class="line">                <span class="comment">//生成字节码</span></span><br><span class="line">                .make()</span><br><span class="line">                <span class="comment">//classloader 加载字节码到内存</span></span><br><span class="line">                .load(ByteBuddy.class.getClassLoader())</span><br><span class="line">                <span class="comment">//获得Class对象</span></span><br><span class="line">                .getLoaded()</span><br><span class="line">                .newInstance()</span><br><span class="line">                .toString();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>subclass(Object.class)</strong> ：创建一个Object的子类</li>
<li><strong>name(“ExampleClass”) :</strong> 新建的类名叫做“ExampleClass” ,暂时没有用到</li>
<li><strong>method()</strong> ：要拦截“ExampleClass”中的方法</li>
<li><strong>ElementMatchers.named(“toString”)</strong> ：拦截条件，拦截toString()这个方法, 没有条件，表示所有的方法</li>
<li><strong>intercept()</strong> ：指定了拦截到的方法要修改成什么样子，是不是和 Spring AOP有点像了</li>
<li><strong>make()</strong> ：创建上面生成的这个类型</li>
<li><strong>load()</strong> ：加载这个生成的类</li>
<li><strong>newInstance()</strong> ：Java 反射的API，创建实例</li>
</ul>
<p>在Byte buddy中默认提供了一个 dynamicType.saveIn() 方法，可以保存编译后的Class文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.bytebuddy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.ByteBuddy;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.dynamic.DynamicType;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.implementation.FixedValue;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.matcher.ElementMatchers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 保存class文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LookUpClassFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        DynamicType.Unloaded&lt;Object&gt; dynamicType = <span class="keyword">new</span> <span class="title class_">ByteBuddy</span>()</span><br><span class="line">                <span class="comment">// 指定父类</span></span><br><span class="line">                .subclass(Object.class)</span><br><span class="line">                <span class="comment">// 指定生成类的名称</span></span><br><span class="line">                .name(<span class="string">&quot;User&quot;</span>)</span><br><span class="line">                <span class="comment">// 按名称 拦截该类的 toString()</span></span><br><span class="line">                .method(ElementMatchers.named(<span class="string">&quot;toString&quot;</span>))</span><br><span class="line">                <span class="comment">// 拦截方法调用 返回固定值</span></span><br><span class="line">                .intercept(FixedValue.value(<span class="string">&quot;Hello World!!&quot;</span>))</span><br><span class="line">                <span class="comment">// 产生字节码</span></span><br><span class="line">                .make();</span><br><span class="line">        DynamicType.Loaded&lt;Object&gt; loaded = dynamicType.load(ByteBuddy.class.getClassLoader());</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(HelloWorld.class.getResource(<span class="string">&quot;./&quot;</span>).getPath());</span><br><span class="line">        dynamicType.saveIn(file);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> loaded.getLoaded().newInstance().toString();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其他API</strong></p>
<ul>
<li><p>defineMethod(“main”, String.class, Modifier.PUBLIC + Modifier.STATIC)，</p>
<p>定义方法；名称、返回类型、属性<em>public static void</em></p>
<p>Modifier.PUBLIC + Modifier.STATIC，这是一个是二进制相加，每一个类型都在二进制中占有一位。例如 1 2 4 8 … 对应的二进制占位 1111。既可以执行相加运算，并又能保留原有单元的属性。</p>
</li>
<li><p>withParameter(String[].class, “args”)，</p>
<p>定义参数；参数类型、参数名称</p>
</li>
<li><p>intercept(FixedValue.value(“Hello World!”))，</p>
<p>拦截设置返回值，但此时还能满足我们的要求。</p>
</li>
<li><p>defineField() 方法：创建字段。</p>
</li>
<li><p>implement() 方法：实现接口。</p>
</li>
</ul>
<h4 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Javassist 使操作Java字节码变得简单，一个可以用于编辑Java字节码的类库，提供了两种级别的API：源码级别和字节码级别。如果用户使用源码级API，他们可以在不需要过多了解Java字节码规范的前提下使用它提供的基于java语言的API来编辑字节码文件。如果使用字节码级API则允许用户直接编辑字节码文件。Javassist在复杂的字节码级操作上提供了更高级别的抽象层。另外Javassist使用了反射机制，这使得它在运行时比ASM慢。</span><br></pre></td></tr></table></figure>

<p><strong>类</strong></p>
<ul>
<li>ClassPool：javassist的类池，使用ClassPool 类可以跟踪和控制所操作的类，它的工作方式与 JVM 类装载器非常相似</li>
<li>CtClass： CtClass提供了类的操作，如在类中动态添加新字段、方法和构造函数、以及改变类、父类和接口的方法。</li>
<li>CtField：类的属性，通过它可以给类创建新的属性，还可以修改已有的属性的类型，访问修饰符等</li>
<li>CtMethod：类中的方法，通过它可以给类创建新的方法，还可以修改返回类型，访问修饰符等， 甚至还可以修改方法体内容代码</li>
<li>CtConstructor：与CtMethod类</li>
</ul>
<p><strong>API</strong></p>
<p>ClassPool</p>
<ul>
<li>ClassPool pool &#x3D; ClassPool.getDefault(); 类库, jvm中所加载的class</li>
<li>CtClass ctClass &#x3D; pool.get(“com.itheima.Student”); 加载一个已知的类, 注：参数必须为全量类名</li>
<li>CtClass tClass &#x3D; pool.makeClass(“com.itheima.Calculator”); 创建一个新的类, 类名必须为全量类名</li>
</ul>
<p>CtField</p>
<ul>
<li>CtField ctField &#x3D; ctClass.getDeclaredField(“name”); 获取已知类的属性</li>
<li>CtField ctFieldNew &#x3D; new CtField(CtClass.intType,“age”,ctClass); 构建新的类的成员变量</li>
<li>ctFieldNew.setModifiers(Modifier.PUBLIC); 设置类的访问修饰符为public</li>
<li>ctClass.addField(ctFieldNew); 将属性添加到类中</li>
</ul>
<p>CtMethod</p>
<ul>
<li><p>CtMethod ctMethod &#x3D; ctClass.getDeclaredMethod(“sayHello”); 获取已有方法</p>
</li>
<li><p>CtMethod ctMethod &#x3D; new CtMethod(CtClass.intType, “calc”, new CtClass[]{CtClass.intType,CtClass.intType}, tClass);创建新的方法, 参数1:方法的返回类型，参数2：名称，参数3：方法的参数，参数4：方法所属的类</p>
</li>
<li><p>ctMethod.setModifiers(Modifier.PUBLIC); 设置方法的访问修饰</p>
</li>
<li><p>ctClass.addMethod(ctMethod); 将新建的方法添加到类中</p>
</li>
<li><p>ctMethod.setBody(“return $1 + $2;”); 方法体内容代码 $1代表第一个参数，$2代表第二个参数</p>
</li>
<li><p>CtMethod getMethod &#x3D; CtNewMethod.make(“public int getAge() { return this.age;}”, ctClass); </p>
<p>CtMethod setMethod &#x3D; CtNewMethod.make(“public void setAge(int age) { this.age &#x3D; age;}”, ctClass);ctClass.addMethod(getMethod);ctClass.addMethod(setMethod);  直接创建方法</p>
</li>
</ul>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="jdk序列化"><a href="#jdk序列化" class="headerlink" title="jdk序列化"></a>jdk序列化</h4><p>被序列化的对象需要实现java.io.Serializable接口</p>
<h5 id="serialVersionUID的作用"><a href="#serialVersionUID的作用" class="headerlink" title="serialVersionUID的作用"></a>serialVersionUID的作用</h5><p>一句话：其目的是序列化对象版本控制，有关各版本反序列化时是否兼容。如果在新版本中这个值修改了，新版本就不兼容旧版本，反序列化时会抛出InvalidClassException异常。如果修改较小，比如仅仅是增加了一个属性，我们希望向下兼容，老版本的数据都能保留，那就不用修改；如果我们删除了一个属性，或者更改了类的继承关系，必然不兼容旧数据，这时就应该手动更新版本号，即SerialVersionUid。</p>
<p>serialVersionUID有两种显示的生成方式：</p>
<ul>
<li>一是默认的1L，比如：private static final long serialVersionUID &#x3D; 1L;</li>
<li>二是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，</li>
</ul>
<h5 id="静态变量的序列化"><a href="#静态变量的序列化" class="headerlink" title="静态变量的序列化"></a>静态变量的序列化</h5><p>静态变量不会被序列化。因为静态变量在全局区,本来流里面就没有写入静态变量,我打印静态变量当然会去全局区查找</p>
<h5 id="Transient-关键字作用"><a href="#Transient-关键字作用" class="headerlink" title="Transient 关键字作用"></a>Transient 关键字作用</h5><p>Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol>
<li>Java序列化只是针对对象的状态进行保存，至于对象中的方法，序列化不关心</li>
<li>当一个父类实现了序列化，那么子类会自动实现序列化，不需要显示实现序列化接口</li>
<li>当一个对象的实例变量引用了其他对象，序列化这个对象的时候会自动把引用的对象也进行序列化（实现深度克隆）</li>
<li>当某个字段被申明为transient后，默认的序列化机制会忽略这个字段</li>
<li>被申明为transient的字段，如果需要序列化，可以添加两个私有方法：writeObject和readObject</li>
</ol>
<h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><p>XML序列化的好处在于可读性好，方便阅读和调试。但是序列化以后的字节码文件比较大，而且效率不高，适用于对性能不高，而且QPS较低的企业级内部系统之间的数据交换的场景，同时XML又具有语言无关性，所以还可以用于异构系统之间的数据交换和协议。比如我们熟知的Webservice，就是采用XML格式对数据进行序列化的。XML序列化&#x2F;反序列化的实现方式有很多，熟知的方式有XStream和Java自带的XML序列化和反序列化两种。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.serialize.xml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gxl.serialize.jdk.User;</span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.XStream;</span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.io.xml.DomDriver;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLSerializer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;Mic&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        String xml=serialize(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化完成：&quot;</span>+xml);</span><br><span class="line">        User nuser=deserialize(xml);</span><br><span class="line">        System.out.println(nuser);    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">serialize</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XStream</span>(<span class="keyword">new</span> <span class="title class_">DomDriver</span>()).toXML(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User <span class="title function_">deserialize</span><span class="params">(String xml)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (User)<span class="keyword">new</span> <span class="title class_">XStream</span>(<span class="keyword">new</span> <span class="title class_">DomDriver</span>()).fromXML(xml);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，相对于XML来说，JSON的字节流更小，而且可读性也非常好。现在JSON数据格式在企业运用是最普遍的</p>
<p>JSON序列化常用的开源工具有很多</p>
<ol>
<li>Jackson （<a href="javascript:void(0)">https://github.com/FasterXML/jackson）</a></li>
<li>阿里开源的FastJson （<a href="javascript:void(0)">https://github.com/alibaba/fastjon）</a></li>
<li>Google的GSON (<a href="javascript:void(0)">https://github.com/google/gson</a>)</li>
</ol>
<p>这几种json序列化工具中，Jackson与fastjson要比GSON的性能要好，但是Jackson、GSON的稳定性要比Fastjson好。而fastjson的优势在于提供的api非常容易使用	</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.serialize.json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.gxl.serialize.jdk.User;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonSerializer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;Mic&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> serializer(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化完成：&quot;</span> + json);</span><br><span class="line">        <span class="type">User</span> <span class="variable">nuser</span> <span class="operator">=</span> deserializer(json);</span><br><span class="line">        System.out.println(nuser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">serializer</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User <span class="title function_">deserializer</span><span class="params">(String json)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (User) JSON.parseObject(json, User.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a><strong>Hessian</strong></h4><p>Hessian是一个支持跨语言传输的二进制序列化协议，相对于Java默认的序列化机制来说，Hessian具有更好的性能和易用性，而且支持多种不同的语言</p>
<p>实际上Dubbo采用的就是Hessian序列化来实现，只不过Dubbo对Hessian进行了重构，性能更高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.serialize.hessian;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.caucho.hessian.io.HessianInput;</span><br><span class="line"><span class="keyword">import</span> com.caucho.hessian.io.HessianOutput;</span><br><span class="line"><span class="keyword">import</span> com.gxl.serialize.jdk.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HessianSerializer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;Mic&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes = serializer(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化完成&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">nuser</span> <span class="operator">=</span> deserializer(bytes);</span><br><span class="line">        System.out.println(nuser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] serializer(User user) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>(); <span class="comment">//表示输出到内存的实现</span></span><br><span class="line">        <span class="type">HessianOutput</span> <span class="variable">ho</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianOutput</span>(bos);</span><br><span class="line">        ho.writeObject(user);</span><br><span class="line">        <span class="keyword">return</span> bos.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User <span class="title function_">deserializer</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(data);</span><br><span class="line">        <span class="type">HessianInput</span> <span class="variable">hi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianInput</span>(bis);</span><br><span class="line">        <span class="keyword">return</span> (User) hi.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Protobuf序列化"><a href="#Protobuf序列化" class="headerlink" title="Protobuf序列化"></a>Protobuf序列化</h4><p>Protobuf是Google的一种数据交换格式，它独立于语言、独立于平台。Google提供了多种语言来实现，比如Java、C、Go、Python，每一种实现都包含了相应语言的编译器和库文件，Protobuf是一个纯粹的表示层协议，可以和各种传输层协议一起使用。</p>
<p>Protobuf使用比较广泛，主要是空间开销小和性能比较好，非常适合用于公司内部对性能要求高的RPC调用。 另外由于解析性能比较高，序列化以后数据量相对较少，所以也可以应用在对象的持久化场景中</p>
<p>但是要使用Protobuf会相对来说麻烦些，因为他有自己的语法，有自己的编译器，如果需要用到的话必须要去投入成本在这个技术的学习中</p>
<blockquote>
<p>protobuf有个缺点就是要传输的每一个类的结构都要生成对应的proto文件，如果某个类发生修改，还得重新生成该类对应的proto文件</p>
</blockquote>
<p>使用protobuf开发的一般步骤是</p>
<ol>
<li>配置开发环境，安装protocol compiler代码编译器</li>
<li>编写.proto文件，定义序列化对象的数据结构</li>
<li>基于编写的.proto文件，使用protocol compiler编译器生成对应的序列化&#x2F;反序列化工具类</li>
<li>基于自动生成的代码，编写自己的序列化应用</li>
</ol>
<h5 id="安装protobuf编译工具"><a href="#安装protobuf编译工具" class="headerlink" title="安装protobuf编译工具"></a>安装protobuf编译工具</h5><p>下载对应操作系统使用的protobuf包</p>
<p>编写proto文件</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;com.gxl.serialize.protobuf&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;UserProtos&quot;</span>;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span> &#123;  </span><br><span class="line">  <span class="keyword">required</span> <span class="type">int32</span>  age = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据类型说明如下：</p>
<ul>
<li><p>enum 枚举类</p>
</li>
<li><p>string &#x2F; bytes &#x2F; bool &#x2F; int32（4个字节）&#x2F;int64&#x2F;float&#x2F;double</p>
</li>
<li><p>message 自定义类</p>
</li>
<li><p>修饰符</p>
<ul>
<li>required 表示必填字段</li>
<li>optional 表示可选字段</li>
<li>repeated 可重复，表示集合</li>
<li>1，2，3，4需要在当前范围内是唯一的，表示顺序</li>
</ul>
</li>
<li><p>生成实例类，在cmd中运行如下命令</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc.exe --java_out=./ ./User.proto</span><br></pre></td></tr></table></figure>

<p>将生成的java文件拷贝到指定目录中</p>
<p><strong>测试代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.serialize.protobuf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.protobuf.ByteString;</span><br><span class="line"><span class="keyword">import</span> com.google.protobuf.InvalidProtocolBufferException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-31</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtobufSerializer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvalidProtocolBufferException &#123;</span><br><span class="line">        UserProtos.<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> UserProtos.User.newBuilder().setName(<span class="string">&quot;Mic&quot;</span>).setAge(<span class="number">18</span>).build();</span><br><span class="line">        <span class="type">ByteString</span> <span class="variable">bytes</span> <span class="operator">=</span> user.toByteString();</span><br><span class="line">        System.out.println(bytes.toByteArray().length);</span><br><span class="line">        UserProtos.<span class="type">User</span> <span class="variable">nUser</span> <span class="operator">=</span> UserProtos.User.parseFrom(bytes);</span><br><span class="line">        System.out.println(nUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Protobuf序列化原理解析"><a href="#Protobuf序列化原理解析" class="headerlink" title="Protobuf序列化原理解析"></a>Protobuf序列化原理解析</h5><p>正常来说，要达到最小的序列化结果，一定会用到压缩的技术，而protobuf里面用到了两种压缩算法，一种是varint，另一种是zigzag</p>
<p>先说第一种，我们先来看【Mic】是怎么被压缩的“Mic”这个字符，需要根据ASCII对照表转化为数字。M &#x3D;77、i&#x3D;105、c&#x3D;99，所以结果为 77 105 99</p>
<p>varint是对字节码做压缩，但是如果这个数字的二进制只需要一个字节表示的时候，其实最终编码出来的结果是不会变化的。 如果出现需要大于一个字节的方式来表示，则需要进行压缩。</p>
<p>采用T - L - V 的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑</p>
]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>SPI机制</title>
    <url>/2023/03/31/SPI%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="SPI的概述"><a href="#SPI的概述" class="headerlink" title="SPI的概述"></a>SPI的概述</h2><p>SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。</p>
<h2 id="java-SPI-机制"><a href="#java-SPI-机制" class="headerlink" title="java SPI 机制"></a>java SPI 机制</h2><p>在面向的对象的设计里，不同模块之间推崇面向接口编程，不建议在模块中对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。SPI使得程序能在ClassPath路径下的META-INF&#x2F;services文件夹查找接口的实现类，自动加载文件里所定义的实现类</p>
<p>Java SPI 实际上是“<strong>基于接口的编程＋策略模式＋配置文件</strong>”组合实现的动态加载机制。</p>
<h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><p>首先，我们定义一个接口，名称为 Robot。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来定义两个实现类，分别为 OptimusPrime 和 Bumblebee。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bumblebee</span> <span class="keyword">implements</span> <span class="title class_">Robot</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Bumblebee.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptimusPrime</span> <span class="keyword">implements</span> <span class="title class_">Robot</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Optimus Prime.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来 META-INF&#x2F;services 文件夹下创建一个文件，名称为 Robot 的全限定名 com.itheima.java.spi.Robot。文件内容为实现类的全限定的类名，如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">com.gxl.spi.Bumblebee</span></span><br><span class="line"><span class="attr">com.gxl.spi.OptimusPrime</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaSPITest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ServiceLoader&lt;Robot&gt; serviceLoader = ServiceLoader.load(Robot.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;JAVA SPI&quot;</span>);</span><br><span class="line">        serviceLoader.forEach(Robot::sayHello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a><strong>实现原理：</strong></h3><ol>
<li>应用程序调用ServiceLoader.load方法，创建一个新的ServiceLoader，并实例化该类中的成员变量</li>
<li>获取到serviceLoader对象，实现了iterator接口，并实现了hasNext方法，ServiceLoader先判断成员变量providers对象中(LinkedHashMap&lt;String,S&gt;类型)是否有缓存实例对象，如果有缓存，直接返回。 如果没有缓存，执行类的装载 ，在方法内部，去读取META-INF&#x2F;services +className文件的内容，</li>
</ol>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><p>使用 Java SPI 机制的优势是实现解耦，使得接口的定义与具体业务实现分离，而不是耦合在一起。应用进程可以根据实际业务情况启用或替换具体组件。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><ul>
<li>不能按需加载。虽然 ServiceLoader 做了延迟载入，但是基本只能通过遍历全部获取，也就是接口的实现类得全部载入并实例化一遍。如果你并不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。</li>
<li>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。</li>
<li>多个并发多线程使用 ServiceLoader 类的实例是不安全的。</li>
<li>加载不到实现类时抛出并不是真正原因的异常，错误很难定位。</li>
</ul>
<h2 id="Spring-SPI"><a href="#Spring-SPI" class="headerlink" title="Spring SPI"></a>Spring SPI</h2><p>Spring SPI沿用了Java SPI的设计思想，Spring采用的是spring.factories方式实现SPI机制，可以在不修改Spring源码的前提下，提供Spring框架的扩展性。</p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>1、定义一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataBaseService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getConnection</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、定义两个类，并实现接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysqlDataBase</span> <span class="keyword">implements</span> <span class="title class_">DataBaseService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mysql DB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OracleDataBase</span> <span class="keyword">implements</span> <span class="title class_">DataBaseService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Oracle DB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、在项目的META-INF目录下，新增spring.factories文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">com.gxl.spi.spring.DataBaseService</span>=<span class="string">com.gxl.spi.spring.MysqlDataBase,com.gxl.spi.spring.OracleDataBase</span></span><br></pre></td></tr></table></figure>

<p>4、测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringSpiTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;DataBaseService&gt; dataBaseServices = SpringFactoriesLoader.loadFactories(DataBaseService.class, Thread.currentThread().getContextClassLoader());</span><br><span class="line">        <span class="keyword">for</span> (DataBaseService dataBaseService : dataBaseServices) &#123;</span><br><span class="line">            dataBaseService.getConnection();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>loadFactoryNames解析spring.factories文件中指定接口的实现类的全限定名</p>
<p>获取所有jar包中META-INF&#x2F;spring.factories文件路径，以枚举值返回。 遍历spring.factories文件路径，逐个加载解析，整合factoryClass类型的实现类名称，获取到实现类的全类名称添加到Map集合中</p>
<p>通过类的权限定名，获取指定接口的实现类List集合，遍历通过反射实例化所有的实现类</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>Spring factories SPI是一个spring.factories配置文件存放多个接口及对应的实现类，以接口全限定名作为key，实现类作为value来配置，多个实现类用逗号隔开，仅spring.factories一个配置文件。</p>
<h2 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Dubbo 并未使用 Java SPI，而是重新实现了一套功能更强的 SPI 机制。Dubbo SPI 的相关逻辑被封装在了 ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。</p>
<h3 id="入门案例-1"><a href="#入门案例-1" class="headerlink" title="入门案例"></a>入门案例</h3><p>与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。下面来演示 Dubbo SPI 的用法：</p>
<p>1、在使用Dubbo SPI 时，需要在接口上标注 @SPI 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、Dubbo SPI 所需的配置文件需放置在 META-INF&#x2F;dubbo 路径下，与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置（key自己指定，value为实现类的全路径），配置内容如下。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">bumblebee</span>=<span class="string">com.gxl.spi.dubbo.Bumblebee</span></span><br><span class="line"><span class="attr">optimusPrime</span>=<span class="string">com.gxl.spi.dubbo.OptimusPrime</span></span><br></pre></td></tr></table></figure>

<p>3、通过 ExtensionLoader，我们可以加载指定的实现类，下面来演示 Dubbo SPI ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboSPITest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ExtensionLoader&lt;Robot&gt; extensionLoader =</span><br><span class="line">                ExtensionLoader.getExtensionLoader(Robot.class);</span><br><span class="line">        <span class="type">Robot</span> <span class="variable">optimusPrime</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;optimusPrime&quot;</span>);</span><br><span class="line">        optimusPrime.sayHello();</span><br><span class="line">        <span class="type">Robot</span> <span class="variable">bumblebee</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;bumblebee&quot;</span>);</span><br><span class="line">        bumblebee.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">getExtension(String name)  #根据key获取拓展对象</span><br><span class="line"><span class="code">    --&gt;createExtension(String name) #创建拓展实例</span></span><br><span class="line"><span class="code">        --&gt;getExtensionClasses #根据路径获取所有的拓展类</span></span><br><span class="line"><span class="code">            --&gt;loadExtensionClasses #加载拓展类</span></span><br><span class="line"><span class="code">                --&gt;cacheDefaultExtensionName #解析@SPI注解</span></span><br><span class="line"><span class="code">            --&gt;loadDirectory #方法加载指定文件夹配置文件</span></span><br><span class="line"><span class="code">                --&gt;loadResource #加载资源</span></span><br><span class="line"><span class="code">                    --&gt;loadClass #加载类，并通过 loadClass 方法对类进行缓存</span></span><br></pre></td></tr></table></figure>

<p>createExtension 方法的逻辑稍复杂一下，包含了如下的步骤：</p>
<ol>
<li>通过 getExtensionClasses 获取所有的拓展类</li>
<li>通过反射创建拓展对象</li>
<li>向拓展对象中注入依赖</li>
<li>将拓展对象包裹在相应的 Wrapper 对象中</li>
</ol>
<p>以上步骤中，第一个步骤是加载拓展类的关键，第三和第四个步骤是 Dubbo IOC 与 AOP 的具体实现。</p>
<h3 id="SPI中的IOC和AOP"><a href="#SPI中的IOC和AOP" class="headerlink" title="SPI中的IOC和AOP"></a>SPI中的IOC和AOP</h3><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>Dubbo IOC 是通过 setter 方法注入依赖。Dubbo 首先会通过反射获取到实例的所有方法，然后再遍历方法列表，检测方法名是否具有 setter 方法特征。若有，则通过 ObjectFactory 获取依赖对象，最后通过反射调用 setter 方法将依赖设置到目标对象中。整个过程对应的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">injectExtension</span><span class="params">(T instance)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (objectFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历目标类的所有方法</span></span><br><span class="line">            <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">                <span class="comment">// 检测方法是否以 set 开头，且方法仅有一个参数，且方法访问级别为 public</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().startsWith(<span class="string">&quot;set&quot;</span>)</span><br><span class="line">                    &amp;&amp; method.getParameterTypes().length == <span class="number">1</span></span><br><span class="line">                    &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                    <span class="comment">// 获取 setter 方法参数类型</span></span><br><span class="line">                    Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取属性名，比如 setName 方法对应属性名 name</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> getSetterProperty(method);</span><br><span class="line">                        <span class="comment">/* getSetterProperty :</span></span><br><span class="line"><span class="comment">                        method.getName().length() &gt; 3 ? </span></span><br><span class="line"><span class="comment">                            method.getName().substring(3, 4).toLowerCase() + </span></span><br><span class="line"><span class="comment">                                method.getName().substring(4) : &quot;&quot;;</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="comment">// 从 ObjectFactory 中获取依赖对象</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> objectFactory.getExtension(pt, property);</span><br><span class="line">                        <span class="keyword">if</span> (object != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 通过反射调用 setter 方法设置依赖</span></span><br><span class="line">                            method.invoke(instance, object);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(<span class="string">&quot;fail to inject via method...&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		在上面代码中，objectFactory 变量的类型为 AdaptiveExtensionFactory，AdaptiveExtensionFactory 内部维护了一个 ExtensionFactory 列表，用于存储其他类型的 ExtensionFactory。Dubbo 目前提供了两种 ExtensionFactory，分别是 SpiExtensionFactory 和 SpringExtensionFactory。前者用于创建自适应的拓展，后者是用于从 Spring 的 IOC 容器中获取所需的拓展。这两个类的类的代码不是很复杂，这里就不一一分析了。</p>
<p>​	Dubbo IOC 目前仅支持 setter 方式注入，总的来说，逻辑比较简单易懂。</p>
<h4 id="动态增强"><a href="#动态增强" class="headerlink" title="动态增强"></a>动态增强</h4><p>在Dubbo中，有一种特殊的类，被称为Wrapper类。通过<strong>装饰者模式</strong>，使用包装类包装原始的扩展点实例。在原始扩展点实现前后插入其他逻辑，实现AOP功能。</p>
<p><strong>装饰者模式</strong></p>
<p>装饰者模式：在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p>
<p>一般来说装饰者模式有下面几个参与者：</p>
<ul>
<li>Component：装饰者和被装饰者共同的父类，是一个接口或者抽象类，用来定义基本行为</li>
<li>ConcreteComponent：定义具体对象，即被装饰者</li>
<li>Decorator：抽象装饰者，继承自Component，从外类来扩展ConcreteComponent。对于ConcreteComponent来说，不需要知道Decorator的存在，Decorator是一个接口或抽象类</li>
<li>ConcreteDecorator：具体装饰者，用于扩展ConcreteComponent</li>
</ul>
<p>注：装饰者和被装饰者对象有相同的超类型，因为装饰者和被装饰者必须是一样的类型，<strong>这里利用继承是为了达到类型匹配，而不是利用继承获得行为。</strong></p>
<p><strong>dubbo中的AOP</strong></p>
<p>1、定义接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、定义被装饰者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptimusPrime</span> <span class="keyword">implements</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Optimus Prime.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、定义装饰者，为了简单没有定义装饰者接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bumblebee</span> <span class="keyword">implements</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Robot robot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bumblebee</span><span class="params">(Robot robot)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.robot = robot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Bumblebee.&quot;</span>);</span><br><span class="line">        robot.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、添加拓展点配置文件META-INF&#x2F;dubbo&#x2F;com.gxl.spi.dubbo.Robot,内容如下</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">optimusPrime</span>=<span class="string">com.gxl.spi.dubbo.OptimusPrime</span></span><br><span class="line"><span class="attr">wrapper</span>=<span class="string">com.gxl.spi.dubbo.Bumblebee</span></span><br></pre></td></tr></table></figure>

<p>5、测试，方法被增强</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboSPITest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ExtensionLoader&lt;Robot&gt; extensionLoader =</span><br><span class="line">                ExtensionLoader.getExtensionLoader(Robot.class);</span><br><span class="line">        <span class="type">Robot</span> <span class="variable">bumblebee</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;optimusPrime&quot;</span>);</span><br><span class="line">        bumblebee.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h4><h5 id="SPI中的自适应"><a href="#SPI中的自适应" class="headerlink" title="SPI中的自适应"></a>SPI中的自适应</h5><p>我们知道在 Dubbo 中，很多拓展都是通过 SPI 机制 进行加载的，比如 Protocol、Cluster、LoadBalance、ProxyFactory 等。有时，有些拓展并不想在框架启动阶段被加载，而是希望在拓展方法被调用时，根据运行时参数进行加载，即根据参数动态加载实现类。如下所示：</p>
<blockquote>
<p>根据参数动态选择的意思是：</p>
<p>通过ExtensionLoader.getExtensionLoader(XXXClass).getExtension(key)的形式来获取接口的某个实现类。</p>
<p>但这种形式本质上还是通过硬编码的形式在代码中固定的获取了接口的一个实现，诸如Protocol(实现有Dubbo、Redis、Thrift等)，或者Transporter(实现有Netty、Mina等)这些接口，我们是可以在Dubbo服务声明时指定具体实现的</p>
</blockquote>
<p>这种在运行时，根据方法参数才动态决定使用具体的拓展，在dubbo中就叫做扩展点自适应实例。其实是一个扩展点的代理，将扩展的选择从Dubbo启动时，延迟到RPC调用时。Dubbo中每一个扩展点都有一个自适应类，如果没有显式提供，Dubbo会自动为我们创建一个，默认使用Javaassist。</p>
<p><strong>自适应拓展机制的实现逻辑是这样的</strong></p>
<ol>
<li>首先 Dubbo 会为拓展接口生成具有代理功能的代码；</li>
<li>通过 javassist 或 jdk 编译这段代码，得到 Class 类；</li>
<li>通过反射创建代理类；</li>
<li>在代理类中，通过URL对象的参数来确定到底调用哪个实现类；</li>
</ol>
<h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><p><strong>Adaptive注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Adaptive &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可知，Adaptive 可注解在类或方法上。</p>
<ul>
<li>标注在类上：Dubbo 不会为该类生成代理类。Adaptive 注解在类上的情况很少，在 Dubbo 中，仅有两个类被 Adaptive 注解了，分别是 AdaptiveCompiler 和 AdaptiveExtensionFactory。此种情况，表示拓展的加载逻辑由人工编码完成。更多时候，Adaptive 是注解在接口方法上的，表示拓展的加载逻辑需由框架自动生成</li>
<li>标注在方法上：Dubbo 则会为该方法生成代理逻辑，表示当前方法需要根据 参数URL 调用对应的扩展点实现。例如 Protocol的SPI类有 injvm dubbo registry filter listener等等 很多扩展未知类， 它设计了Protocol$Adaptive的类，通过ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(spi类);来提取对象</li>
</ul>
<p><strong>获取自适应拓展类</strong></p>
<p>dubbo中每一个扩展点都有一个自适应类，如果没有显式提供，Dubbo会自动为我们创建一个，默认使用Javaassist。 先来看下创建自适应扩展类的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 精简代码如下</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getAdaptiveExtension</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> cachedAdaptiveInstance.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">                instance = cachedAdaptiveInstance.get();</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                      instance = createAdaptiveExtension();</span><br><span class="line">                      cachedAdaptiveInstance.set(instance); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看createAdaptiveExtension方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">        getExtensionClasses();</span><br><span class="line">        <span class="keyword">if</span> (cachedAdaptiveClass != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">cachedAdaptiveClass</span> <span class="operator">=</span> createAdaptiveExtensionClass();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>续看createAdaptiveExtensionClass方法，绕了一大圈，终于来到了具体的实现了。看这个createAdaptiveExtensionClass方法，它首先会生成自适应类的Java源码，然后再将源码编译成Java的字节码，加载到JVM中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> createAdaptiveExtensionClassCode();</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> findClassLoader();</span><br><span class="line">        org.apache.dubbo.common.compiler.<span class="type">Compiler</span> <span class="variable">compiler</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">        <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Compiler的代码，默认实现是javassist。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;javassist&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Compiler</span> &#123;</span><br><span class="line">    Class&lt;?&gt; compile(String code, ClassLoader classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createAdaptiveExtensionClassCode()方法中使用一个StringBuilder来构建自适应类的Java源码。方法实现比较长，这里就不贴代码了。这种生成字节码的方式也挺有意思的，先生成Java源代码，然后编译，加载到jvm中。通过这种方式，可以更好的控制生成的Java类。而且这样也不用care各个字节码生成框架的api等。因为xxx.java文件是Java通用的，也是我们最熟悉的。只是代码的可读性不强，需要一点一点构建xx.java的内容。</p>
<p>示例：以 Protocol 接口为例，Protocol接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;dubbo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Protocol</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getDefaultPort</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; Exporter&lt;T&gt; <span class="title function_">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> List&lt;ProtocolServer&gt; <span class="title function_">getServers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面给大家展示一下生成的 Protocol$Adaptive 的源码，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.rpc;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Protocol$Adaptive</span> <span class="keyword">implements</span> <span class="title class_">org</span>.apache.dubbo.rpc.Protocol &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.Invoker <span class="title function_">refer</span><span class="params">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg1 == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        org.apache.dubbo.common.<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> arg1;</span><br><span class="line">        <span class="type">String</span> <span class="variable">extName</span> <span class="operator">=</span> ( url.getProtocol() == <span class="literal">null</span> ? <span class="string">&quot;dubbo&quot;</span> : url.getProtocol() );</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url (&quot;</span> + url.toString() + <span class="string">&quot;) use keys([protocol])&quot;</span>);</span><br><span class="line">        org.apache.dubbo.rpc.<span class="type">Protocol</span> <span class="variable">extension</span> <span class="operator">=</span> (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> java.util.List <span class="title function_">getServers</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;The method public default java.util.List org.apache.dubbo.rpc.Protocol.getServers() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.Exporter <span class="title function_">export</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;</span>);</span><br><span class="line">        org.apache.dubbo.common.<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> arg0.getUrl();</span><br><span class="line">        <span class="type">String</span> <span class="variable">extName</span> <span class="operator">=</span> ( url.getProtocol() == <span class="literal">null</span> ? <span class="string">&quot;dubbo&quot;</span> : url.getProtocol() );</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url (&quot;</span> + url.toString() + <span class="string">&quot;) use keys([protocol])&quot;</span>);</span><br><span class="line">        org.apache.dubbo.rpc.<span class="type">Protocol</span> <span class="variable">extension</span> <span class="operator">=</span> (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.export(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;The method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDefaultPort</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;The method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以调用 Protocol 的接口的 refer方法为例，下面给大家看一下自适应拓展的整个过程：</p>
<p>1）、先通过 Protocol REF_PROTOCOL &#x3D; ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension(); 生成了 Protocol$Adaptive 代理类</p>
<p>2）、传参 Url 为：dubbo:&#x2F;&#x2F;192.168.1.247:20887&#x2F;org.apache.dubbo.config.spring.api.DemoService，调用 Protocol 的 refer 方法，此时直接调用是 Protocol$Adaptive 代理类的 refer 方法</p>
<p>3）、在 Protocol$Adaptive 的 refer 方法中先调用 url 中的 getProtocol() 方法获取拓展类名称，赋值给 extName 变量</p>
<p>4）、然后调用 org.apache.dubbo.rpc.Protocol extension &#x3D; (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName); 语句获取到具体的实现类的实例</p>
<p>5）、最后执行 extension.refer(arg0, arg1) 语句，调用 4 中获取到的具体实现类的 refer 方法，最终返回结果</p>
]]></content>
      <categories>
        <category>SPI</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud Consul</title>
    <url>/2023/03/02/SpringCloud-Consul/</url>
    <content><![CDATA[<h2 id="Consul介绍"><a href="#Consul介绍" class="headerlink" title="Consul介绍"></a>Consul介绍</h2><p>​		Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其它分布式服务注册与发现的方案，Consul 的方案更“一站式”，内置了服务注册与发现框 架、分布一致性协议实现、健康检查、Key&#x2F;Value 存储、多数据中心方案，不再需要依赖其它工具（比如 ZooKeeper 等）。使用起来也较 为简单。Consul 使用 Go 语言编写，因此具有天然可移植性(支持Linux、windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署，与Docker 等轻量级容器可无缝配合。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>服务发现</li>
<li>健康检查</li>
<li>Key&#x2F;Value 存储</li>
<li>多数据中心</li>
<li>社区活跃</li>
</ul>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>使用 Raft 算法来保证一致性, 比复杂的 Paxos 算法更直接. 相比较而言,zookeeper 采用的是 Paxos, 而 etcd 使用的则是 Raft。</li>
<li>支持多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障,而其部署则需要考虑网络延迟,分片等情况等。 zookeeper 和 etcd 均不提供多数据中心功能的支持。</li>
<li>支持健康检查。 etcd 不提供此功能。</li>
<li>支持 http 和 dns 协议接口。 zookeeper 的集成较为复杂, etcd 只支持http 协议</li>
<li>官方提供 web 管理界面, etcd 无此功能。</li>
<li>综合比较, Consul 作为服务注册和配置管理的新星, 比较值得关注和研究</li>
<li>提供了rest api 便于集成：<a href="https://www.consul.io/api-docs/index">https://www.consul.io/api-docs/index</a></li>
</ul>
<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul>
<li>client: 客户端, 无状态, 将 HTTP 和 DNS 接口请求转发给局域网内的服务端集群。</li>
<li>server: 服务端, 保存配置信息, 高可用集群, 在局域网内与本地客户端通讯, 通过广域网与其它数据中心通讯。 每个数据中心的 server 数量推荐为 3 个或是 5 个。</li>
</ul>
<p>Consul 客户端、服务端还支持夸中心的使用，更加提高了它的高可用性。</p>
<h2 id="Consul-基础架构"><a href="#Consul-基础架构" class="headerlink" title="Consul 基础架构"></a>Consul 基础架构</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li><p>agent</p>
<p>​		组成 consul 集群的每个成员上都要运行一个 agent，可以通过 consul agent 命令来启动。agent可以运行在 server 状态或者 client 状态。自然运行在 server 状态的节点被称为 server 节点；运行在 client 状态的节点被称为 client 节点</p>
</li>
<li><p>server 节点</p>
<p>​		负责组成 cluster 的复杂工作（选举server 自行选举一个 leader、状态维护、转发请求到 leader），以及 consul 提供的服务（响应RPC 请求），以及存放和复制数据。考虑到容错和收敛，一般部署 3 ~ 5 个比较合适。</p>
</li>
<li><p>client 节点</p>
<p>​		负责转发所有的 RPC 到 server 节点。本身无状态，且轻量级，因此，可以部署大量的client 节点。</p>
</li>
<li><p>数据中心</p>
<p>​		虽然数据中心的定义似乎很明显，但仍有一些细微的细节必须考虑。我们将一个数据中心定义为一个私有、低延迟和高带宽的网络环境。这不包括通过公共互联网的通信，但是为了我们的目的，单个EC2 区域内的多个可用区域将被视为单个数据中心的一部分。</p>
</li>
</ul>
<p>另外：</p>
<p>​		server 自行选举一个 leader。虽然 Consul 可以运行在一台 server ，但是建议使用 3 到 5 台来避免失败情况下数据的丢失。每个数据中心建议配置一个server 集群。</p>
<p>​		在基础设施中需要发现其他服务的组件可以查询任何一个 Consul 的server 或者agent，Agent 会自动转发请求到 server。</p>
<p>​		每个数据中心运行了一个 Consul server 集群。当一个跨数据中心的服务发现和配置请求创建时，本地 Consul Server 转发请求到远程的数据中心并返回结果。</p>
<h3 id="如何实现服务注册和发现"><a href="#如何实现服务注册和发现" class="headerlink" title="如何实现服务注册和发现"></a><strong>如何实现服务注册和发现</strong></h3><p><img src="1677740195077.jpg" alt="1677740195077"></p>
<p>工作原理：</p>
<ol>
<li>当Producer启动的时候，会向Consul发送一个post请求，并向Consul传输自己的IP和Port。</li>
<li>Consul 接收到Producer的注册后，每隔10s（默认）会向Producer发送一个健康检查的请求，检验Producer是否健康。</li>
<li>当Consumer以Http的方式向Producer发起请求，会先从Consul中拿到一个存储服务IP和Port的临时表，从表中拿到Producer的IP和Port后再发送请求。</li>
<li>该临时表每隔10s会更新，只包含有通过了健康检查的Producer。</li>
</ol>
<h2 id="Consul安装"><a href="#Consul安装" class="headerlink" title="Consul安装"></a>Consul安装</h2><p><strong>下载consul服务</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 从官网下载最新版本的Consul服务</span></span></span><br><span class="line">wget https://releases.hashicorp.com/consul/1.10.3/consul_1.10.3_linux_amd64.zip </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#使用unzip命令解压</span></span></span><br><span class="line">unzip consul_1.10.3_linux_amd64.zip </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#将解压好的consul可执行命令移动到/usr/local/bin目录下</span></span></span><br><span class="line">mv consul /usr/local/bin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#测试一下</span></span></span><br><span class="line">consul --version</span><br></pre></td></tr></table></figure>

<p><strong>启动consul服务</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// ip1</span><br><span class="line">consul agent -server -ui -bootstrap-expect=3 -data-dir=/data/consul -node=agent-1 -client=0.0.0.0 -bind=ip1 -datacenter=dc1</span><br><span class="line"> </span><br><span class="line">// ip2</span><br><span class="line">consul agent -server -ui -bootstrap-expect=3 -data-dir=/data/consul -node=agent-2 -client=0.0.0.0 -bind=ip2 -datacenter=dc1 -join ip1</span><br><span class="line"> </span><br><span class="line">// ip3</span><br><span class="line">consul agent -server -ui -bootstrap-expect=3 -data-dir=/data/consul -node=agent-3 -client=0.0.0.0 -bind=ip3 -datacenter=dc1 -join ip1</span><br></pre></td></tr></table></figure>

<p>​	<strong>参数解释：</strong></p>
<ul>
<li>-bootstrap-expect:集群期望的节点数，只有节点数量达到这个值才会选举leader。</li>
<li>-server： 运行在server模式</li>
<li>-client：consul服务侦听地址，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1所以不对外提供服务，如果你要对外提供服务改成0.0.0.0</li>
<li>-data-dir：指定数据目录，其他的节点对于这个目录必须有读的权限</li>
<li>-node：指定节点的名称</li>
<li>-bind：为该节点绑定一个地址</li>
<li>-config-dir：指定配置文件，定义服务的，默认所有一.json结尾的文件都会读</li>
<li>-enable-script-checks&#x3D;true：设置检查服务为可用</li>
<li>-datacenter: 数据中心名称</li>
</ul>
<p>-join：加入到已有的集群中</p>
<p> <strong>其他命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看集群成员</span></span><br><span class="line">consul members</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看集群状态</span></span><br><span class="line">consul info</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新加载配置文件</span></span><br><span class="line">consul reload</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">帮助</span></span><br><span class="line">consul agent -h</span><br></pre></td></tr></table></figure>

<p><strong>Consul 的 WebUI 控制台</strong></p>
<p><a href="http://ip1:8500/">http://ip1:8500</a></p>
]]></content>
      <categories>
        <category>Consul</category>
      </categories>
      <tags>
        <tag>注册中心</tag>
        <tag>Consul</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Gateway</title>
    <url>/2023/06/11/Spring-Cloud-Gateway/</url>
    <content><![CDATA[<p><strong>微服务网关就是一个系统，通过暴露该微服务网关系统，方便我们进行相关的鉴权，安全控制，日志统一处理，易于监控，限流等相关功能。</strong></p>
<h2 id="Gateway工作原理"><a href="#Gateway工作原理" class="headerlink" title="Gateway工作原理"></a>Gateway工作原理</h2><p><img src="1609152705386.png" alt="1609152705386"></p>
<p>Gateway的执行流程如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1:Gateway的客户端向Spring Cloud Gateway发起请求，请求首先会被HttpWebHandlerAdapter进行提取组装成网关的上下文，然后网关的上下文会传递到DispatcherHandler。</span><br><span class="line"></span><br><span class="line">2:DispatcherHandler是所有请求的分发处理器，DispatcherHandler主要负责分发请求对应的处理器，比如将请求分发到对应RoutePredicateHandlerMapping(路由断言处理器映射器）。</span><br><span class="line"></span><br><span class="line">3:路由断言处理映射器主要用于路由的查找，以及找到路由后返回对应的FilteringWebHandler。</span><br><span class="line"></span><br><span class="line">4:FilteringWebHandler主要负责组装Filter链表并调用Filter执行一系列Filter处理，然后把请求转到后端对应的代理服务处理，处理完毕后，将Response返回到Gateway客户端。</span><br><span class="line">在Filter链中，通过虚线分割Filter的原因是，过滤器可以在转发请求之前处理或者接收到被代理服务的返回结果之后处理。所有的Pre类型的Filter执行完毕之后，才会转发请求到被代理的服务处理。被代理的服务把所有请求完毕之后，才会执行Post类型的过滤器。</span><br></pre></td></tr></table></figure>

<h2 id="Gateway路由"><a href="#Gateway路由" class="headerlink" title="Gateway路由"></a>Gateway路由</h2><p>Gateway路由配置分为<strong>基于配置的静态路由</strong>设置和<strong>基于代码动态路由</strong>配置</p>
<p>静态路由是指在application.yml中把路由信息配置好了，而动态路由则支持在代码中动态加载路由信息，更加灵活，我们接下来把这2种路由操作都实现一次。</p>
<h3 id="基于配置路由设置"><a href="#基于配置路由设置" class="headerlink" title="基于配置路由设置"></a>基于配置路由设置</h3><p>配置参数说明：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">routes:路由配置</span><br><span class="line"><span class="bullet">-</span> id:唯一标识符</span><br><span class="line">uri:路由地址，可以是 lb://IP:端口     也可以是   lb://$&#123;spring.application.name&#125;</span><br><span class="line">predicates:断言，是指路由条件</span><br><span class="line"><span class="bullet">-</span> Path=/driver/<span class="strong">**:路由条件。Predicate 接受一个输入参数，返回一个布尔值结果。这里表示匹配所有以driver开始的请求。</span></span><br><span class="line"><span class="strong">filters:过滤器</span></span><br><span class="line"><span class="strong">- StripPrefix=1:真实路由的时候，去掉第1个路径，路径个数以/分割区分</span></span><br></pre></td></tr></table></figure>

<p>通过在配置文件中配置以上参数实现路由</p>
<h3 id="基于代码路由配置"><a href="#基于代码路由配置" class="headerlink" title="基于代码路由配置"></a>基于代码路由配置</h3><p>我们同样实现上面的功能，但这里基于代码方式实现。所有路由规则我们可以从数据库中读取并加载到程序中。基于代码的路由配置我们只需要创建<code>RouteLocator</code>并添加路由配置即可，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RouteLocator <span class="title function_">routeLocator</span><span class="params">(RouteLocatorBuilder builder)</span>&#123;</span><br><span class="line">       <span class="comment">//构建路由</span></span><br><span class="line">       <span class="keyword">return</span> builder.routes()</span><br><span class="line">               .route(<span class="string">&quot;order-route&quot;</span>,r-&gt; r.path(<span class="string">&quot;/order/**&quot;</span>).uri(<span class="string">&quot;lb://hailtaxi-order&quot;</span>))</span><br><span class="line">               .build();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在真实场景中，基于配置文件的方式更直观、简介，但代码的路由配置是更强大，可以实现很丰富的功能，可以把路由规则存在数据库中，每次直接从数据库中加载规则，这样的好处是可以动态刷新路由规则，通常应用于权限系统动态配置。</p>
<h3 id="Gateway-Predicate"><a href="#Gateway-Predicate" class="headerlink" title="Gateway-Predicate"></a>Gateway-Predicate</h3><p>上面路由匹配规则中我们都用了<code>- Path</code>方式，其实就是路径匹配方式，除了路径匹配方式，Gateway还支持很多丰富的匹配方式，我们对这些方式分别进行讲解。</p>
<p>routes下面的属性含义如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">id：我们自定义的路由 ID，保持唯一</span><br><span class="line"></span><br><span class="line">uri：目标服务地址</span><br><span class="line"></span><br><span class="line">predicates：路由条件，Predicate 接受一个输入参数，返回一个布尔值结果。该属性包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）</span><br></pre></td></tr></table></figure>

<p>Predicate 来源于 Java 8，Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）</p>
<p>在 Spring Cloud Gateway 中 Spring 利用 Predicate 的特性实现了各种路由匹配规则，通过 Header、请求参数等不同的条件来作为条件匹配到对应的路由。</p>
<p><img src="1609172632423.png" alt="1609172632423"></p>
<h4 id="Cookie："><a href="#Cookie：" class="headerlink" title="Cookie："></a><strong>Cookie：</strong></h4><p>Gateway的Cookie匹配接收两个参数：一个是 Cookie name ,一个是正则表达式。路由规则就是通过获取对应的 Cookie name 值和正则表达式去匹配，如果匹配上就会执行路由，如果没有匹配上则不执行。如下配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gateway:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">hailtaxi-driver</span></span><br><span class="line">    <span class="attr">uri:</span> <span class="string">lb://hailtaxi-driver</span></span><br><span class="line">    <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/driver/**</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Cookie=username,test</span></span><br></pre></td></tr></table></figure>

<p>这里表示请求携带了cookie为username的数据，并且值为test，就允许通过。</p>
<h4 id="Header-匹配："><a href="#Header-匹配：" class="headerlink" title="Header 匹配："></a><strong>Header 匹配：</strong></h4><p>Header 匹配 和 Cookie 匹配 一样，也是接收两个参数，一个 header 中属性名称和一个正则表达式，这个属性值和正则表达式匹配则执行。配置如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gateway:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">hailtaxi-driver</span></span><br><span class="line">    <span class="attr">uri:</span> <span class="string">lb://hailtaxi-driver</span></span><br><span class="line">    <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/driver/**</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Header=token,^(?!\d+$)[\da-zA-Z]+$</span></span><br></pre></td></tr></table></figure>

<p>上面的匹配规则，就是请求头要有token属性，并且值必须为数字和字母组合的正则表达式，例如携带token&#x3D;<code>19and30</code>就可以通过访问。</p>
<h4 id="请求方式匹配："><a href="#请求方式匹配：" class="headerlink" title="请求方式匹配："></a><strong>请求方式匹配：</strong></h4><p>通过请求的方式是 POST、GET、PUT、DELETE 等进行路由。配置如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gateway:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">hailtaxi-driver</span></span><br><span class="line">    <span class="attr">uri:</span> <span class="string">lb://hailtaxi-driver</span></span><br><span class="line">    <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/driver/**</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Method=GET,POST</span></span><br></pre></td></tr></table></figure>

<h2 id="Gateway过滤器"><a href="#Gateway过滤器" class="headerlink" title="Gateway过滤器"></a>Gateway过滤器</h2><p>Spring Cloud Gateway根据作用范围划分为<strong>GatewayFilter</strong>和<strong>GlobalFilter</strong>，二者区别如下：</p>
<ul>
<li>GatewayFilter : 需要通过spring.cloud.routes.filters 配置在具体路由下，只作用在当前路由上或通过spring.cloud.default-filters配置在全局，作用在所有路由上；gateway内置了多种过滤器工厂，配套的过滤器可以直接使用，如下图所示：</li>
</ul>
<p><img src="gateway30.png" alt="gateway30"></p>
<p><img src="gatewayfilter.png" alt="gatewayfilter"></p>
<ul>
<li>GlobalFilter : 全局过滤器，不需要在配置文件中配置，作用在所有的路由上，最终通过GatewayFilterAdapter包装成GatewayFilterChain可识别的过滤器，它为请求业务以及路由的URI转换为真实业务服务的请求地址的核心过滤器，不需要配置，系统初始化时加载，并作用在每个路由上。</li>
</ul>
<p><img src="1609180530575.png" alt="1609180530575"></p>
<p>过滤器作为Gateway的重要功能。常用于请求鉴权、服务调用时长统计、修改请求或响应header、限流、去除路径等等。</p>
<h3 id="过滤器分类"><a href="#过滤器分类" class="headerlink" title="过滤器分类"></a>过滤器分类</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">默认过滤器:出厂自带，实现好了拿来就用，不需要实现</span><br><span class="line">  全局默认过滤器</span><br><span class="line">  局部默认过滤器</span><br><span class="line">  </span><br><span class="line">自定义过滤器:根据需求自己实现，实现后需配置，然后才能用哦。</span><br><span class="line">  全局过滤器:作用在所有路由上。</span><br><span class="line">  局部过滤器:配置在具体路由下，只作用在当前路由上。</span><br></pre></td></tr></table></figure>

<p>默认过滤器十好几个，常见如下：</p>
<table>
<thead>
<tr>
<th>过滤器名称</th>
<th>说明</th>
<th>对应的类</th>
<th align="center">父类</th>
</tr>
</thead>
<tbody><tr>
<td>AddRequestHeader</td>
<td>对匹配上的请求加上Header</td>
<td>AddRequestHeaderGatewayFilterFactory</td>
<td align="center">AbstractNameValueGatewayFilterFactory</td>
</tr>
<tr>
<td>AddRequestParameters</td>
<td>对匹配上的请求路由</td>
<td>AddRequestHeaderGatewayFilterFactory</td>
<td align="center">AbstractNameValueGatewayFilterFactory</td>
</tr>
<tr>
<td>AddResponseHeader</td>
<td>对从网关返回的响应添加Header</td>
<td>AddResponseHeaderGatewayFilterFactory</td>
<td align="center">AbstractNameValueGatewayFilterFactory</td>
</tr>
<tr>
<td>StripPrefix</td>
<td>对匹配上的请求路径去除前缀</td>
<td>StripPrefixGatewayFilterFactory</td>
<td align="center">AbstractGatewayFilterFactory</td>
</tr>
</tbody></table>
<h3 id="默认过滤器的使用"><a href="#默认过滤器的使用" class="headerlink" title="默认过滤器的使用"></a>默认过滤器的使用</h3><p>所谓默认过滤器就是系统自带的。有很多，这里简要说明几个：（<strong>通过java配置，注释掉yaml配置</strong>）</p>
<p><strong>1)添加响应头</strong></p>
<p>AddResponseHeaderGatewayFilterFactory  属于  GatewayFilter</p>
<p>对输出响应头设置属性，比如对输出的响应设置其头部属性名称为：X-Response-Default-MyName , 值为test</p>
<p>修改配置文件，配置如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">     <span class="comment"># 配置全局默认过滤器 作用在所有路由上，也可单独为某个路由配置</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">      <span class="comment"># 往响应过滤器中加入信息</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddResponseHeader=X-Response-Default-MyName,test</span></span><br></pre></td></tr></table></figure>

<p><strong>2)前缀处理</strong></p>
<p>在项目中做开发对接接口的时候，我们很多时候需要统一API路径，比如统一以<code>/api</code>开始的请求调用<code>hailtaxi-driver</code>服务，但真实服务接口地址又没有<code>/api</code>路径，我们可以使用Gateway的过滤器处理请求路径。</p>
<p>在gateway中可以通过配置路由的过滤器StripPrefix实现映射路径中的前缀处理，我们来使用一下该过滤器，再进一步做说明。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gateway:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">hailtaxi-driver</span></span><br><span class="line">    <span class="attr">uri:</span> <span class="string">lb://hailtaxi-driver</span></span><br><span class="line">    <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/api/driver/**</span></span><br><span class="line">    <span class="attr">filters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">StripPrefix=1</span></span><br></pre></td></tr></table></figure>

<p>此处<code>- StripPrefix=1</code>表示真实请求地址是当前用户请求以<code>/api</code>开始的uri中去除第1个路径<code>/api</code>.</p>
<h3 id="自定义GatewayFilter"><a href="#自定义GatewayFilter" class="headerlink" title="自定义GatewayFilter"></a>自定义GatewayFilter</h3><h4 id="1、实现GatewayFilter接口"><a href="#1、实现GatewayFilter接口" class="headerlink" title="1、实现GatewayFilter接口"></a>1、实现GatewayFilter接口</h4><p>GatewayFilter 一般作用在某一个路由上，需要实例化创建才能使用，局部过滤器需要实现接口<code>GatewayFilter、Ordered</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-06-12</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DriverFilter</span> <span class="keyword">implements</span> <span class="title class_">GatewayFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;GatewayFilter拦截器执行---pre-----DriverFilter&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange).then(Mono.fromRunnable(() -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;GatewayFilter拦截器执行---post-----DriverFilter&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.filter.DriverFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.route.RouteLocator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 动态路由配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-06-12</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouteConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouteLocator <span class="title function_">routeLocator</span><span class="params">(RouteLocatorBuilder builder)</span>&#123;</span><br><span class="line">        <span class="comment">//构建路由</span></span><br><span class="line">        <span class="keyword">return</span> builder.routes()</span><br><span class="line">                .route(<span class="string">&quot;driver-route&quot;</span>,r-&gt; r.path(<span class="string">&quot;/driver/**&quot;</span>).uri(<span class="string">&quot;lb://hailtaxi-driver&quot;</span>).filter(<span class="keyword">new</span> <span class="title class_">DriverFilter</span>()))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、继承GatewayFilterFactory"><a href="#2、继承GatewayFilterFactory" class="headerlink" title="2、继承GatewayFilterFactory"></a>2、继承GatewayFilterFactory</h4><p>如果定义局部过滤器，想在配置文件中进行配置来使用，可以继承<code>AbstractGatewayFilterFactory&lt;T&gt;</code>抽象类或者<code>AbstractNameValueGatewayFilterFactory</code></p>
<p>整个体系结构为：</p>
<p><img src="gateway31.png" alt="gateway31"></p>
<p>这两个抽象类的区别就是前者接收一个参数（像StripPrefix和我们创建的这种），后者接收两个参数（像AddResponseHeader）</p>
<p>代码的编写可以参考：<code>StripPrefixGatewayFilterFactory</code> 和 <code>AddRequestHeaderGatewayFilterFactory</code></p>
<p><strong>过滤器工厂默认命名规则必须按照”名称”+GatewayFilterFactory&#96;，如上StripPrefixGatewayFilterFactory的过滤器名称为StripPrefix</strong></p>
<p><strong>2.1、继承<code>AbstractGatewayFilterFactory</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-06-13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DriverMethodGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;DriverMethodGatewayFilterFactory.Config&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DriverMethodGatewayFilterFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(Config.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Config config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (exchange, chain) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> config.getMethod();</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> config.getMsg();</span><br><span class="line">            log.info(<span class="string">&quot;DriverMethodGatewayFilterFactory 加载到的配置信息为:&#123;&#125;---&#123;&#125;&quot;</span>,method,msg);</span><br><span class="line">            <span class="comment">//将method添加到请求头中</span></span><br><span class="line">            exchange.getRequest().mutate().header(<span class="string">&quot;method&quot;</span>,method);</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">shortcutFieldOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//指定从yml中提前出来的配置信息填充到配置类中哪个属性,按规则配置</span></span><br><span class="line">        <span class="keyword">return</span>  Arrays.asList(<span class="string">&quot;method&quot;</span>,<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ShortcutType <span class="title function_">shortcutType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//默认规则</span></span><br><span class="line">        <span class="keyword">return</span> ShortcutType.DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String method;</span><br><span class="line">        <span class="keyword">private</span> String msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、配置文件中使用如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filters:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">DriverMethod=driver,test</span></span><br></pre></td></tr></table></figure>

<p><strong>2.2、继承<code>AbstractNameValueGatewayFilterFactory</code></strong></p>
<p>直接查看<code>AddRequestHeaderGatewayFilterFactory</code>源码，分析即可！</p>
<h3 id="自定义GlobalFilter"><a href="#自定义GlobalFilter" class="headerlink" title="自定义GlobalFilter"></a>自定义GlobalFilter</h3><p>定义全局过滤器需要实现GlobalFilter,Ordered接口：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">GlobalFilter:过滤器拦截处理方法</span><br><span class="line">Ordered:过滤器也有多个，这里主要定义过滤器执行顺序，里面有个方法getOrder()会返回过滤器执行顺序，返回值越小，越靠前执行</span><br></pre></td></tr></table></figure>

<p><strong>需求</strong>：</p>
<p>我们创建全局过滤器并完成常见业务用户权限校验，如果请求中有带有一个名字为<code>token</code>的请求参数，则认为请求有效放行，如果没有则拦截提示授权无效。</p>
<p>创建全局过滤器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-06-13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouterFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由拦截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;RouterFilter----------------&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="comment">//如果token为空，表示未登录</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token))&#123;</span><br><span class="line">            <span class="comment">//没登录，状态设置403</span></span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.PAYLOAD_TOO_LARGE);</span><br><span class="line">            <span class="comment">//结束请求</span></span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跨域配置"><a href="#跨域配置" class="headerlink" title="跨域配置"></a>跨域配置</h2><p>出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）。</p>
<p>在Spring Cloud Gateway中配置跨域是非常简单的，如下面<code>application.yml</code>所示：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gateway:</span></span><br><span class="line">  <span class="attr">globalcors:</span></span><br><span class="line">    <span class="attr">corsConfigurations:</span></span><br><span class="line">      <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">        <span class="attr">allowedOrigins:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">        <span class="attr">allowedMethods:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">GET</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">POST</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">PUT</span></span><br></pre></td></tr></table></figure>

<p>另外一种写法就需要创建<code>CorsWebFilter</code>过滤器，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置跨域</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CorsWebFilter <span class="title function_">corsFilter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">    <span class="comment">// cookie跨域</span></span><br><span class="line">    config.setAllowCredentials(Boolean.TRUE);</span><br><span class="line">    config.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    config.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="comment">// 配置前端js允许访问的自定义响应头</span></span><br><span class="line">    config.addExposedHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>(<span class="keyword">new</span> <span class="title class_">PathPatternParser</span>());</span><br><span class="line">    source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsWebFilter</span>(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>网关可以做很多的事情，比如，限流，当我们的系统 被频繁的请求的时候，就有可能 将系统压垮，所以 为了解决这个问题，需要在每一个微服务中做限流操作，但是如果有了网关，那么就可以在网关系统做限流，因为所有的请求都需要先通过网关系统才能路由到微服务中。</p>
<h3 id="令牌桶算法讲解"><a href="#令牌桶算法讲解" class="headerlink" title="令牌桶算法讲解"></a>令牌桶算法讲解</h3><p><img src="1609181986772.png" alt="1609181986772"></p>
<p>令牌桶算法是常见的限流算法之一，我们讲解一下漏桶算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）所有的请求在处理之前都需要拿到一个可用的令牌才会被处理；</span><br><span class="line">2）根据限流大小，设置按照一定的速率往桶里添加令牌；</span><br><span class="line">3）桶设置最大的放置令牌限制，当桶满时、新添加的令牌就被丢弃或者拒绝；</span><br><span class="line">4）请求达到后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑，处理完业务逻辑之后，将令牌直接删除；</span><br><span class="line">5）令牌桶有最低限额，当桶中的令牌达到最低限额的时候，请求处理完之后将不会删除令牌，以此保证足够的限流</span><br></pre></td></tr></table></figure>

<p>令牌桶算法的实现，有很多技术，Guaua是其中之一，redis客户端也有其实现。</p>
<p>spring cloud gateway 默认使用redis的RateLimter限流算法来实现，外面来简要实现一下：</p>
<p>1、引入依赖</p>
<p>首先需要引入redis的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis-reactive<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">redis:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>

<p>2、定义KeyResolver</p>
<p>在Application引导类中添加如下代码，KeyResolver用于计算某一个类型的限流的KEY也就是说，可以通过KeyResolver来指定限流的Key。</p>
<p>我们可以根据IP来限流，比如每个IP每秒钟只能请求一次，在GatewayApplication定义key的获取，获取客户端IP，将IP作为key，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * IP限流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean(name=&quot;ipKeyResolver&quot;)</span></span><br><span class="line"><span class="keyword">public</span> KeyResolver <span class="title function_">userKeyResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyResolver</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">resolve</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line">            <span class="comment">//获取远程客户端IP</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">hostName</span> <span class="operator">=</span> exchange.getRequest().getRemoteAddress().getAddress().getHostAddress();</span><br><span class="line">            System.out.println(<span class="string">&quot;hostName:&quot;</span>+hostName);</span><br><span class="line">            <span class="keyword">return</span> Mono.just(hostName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在路由中配置如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gateway:</span></span><br><span class="line">  <span class="comment">#路由配置</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="comment">#唯一标识符</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">hailtaxi-driver</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">lb://hailtaxi-driver</span></span><br><span class="line">      <span class="comment">#路由断言</span></span><br><span class="line">      <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/driver/**</span></span><br><span class="line">      <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RequestRateLimiter</span> <span class="comment">#请求数限流 名字不能随便写 ，使用默认的facatory</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="attr">key-resolver:</span> <span class="string">&quot;#&#123;@ipKeyResolver&#125;&quot;</span></span><br><span class="line">            <span class="attr">redis-rate-limiter.replenishRate:</span> <span class="number">1</span></span><br><span class="line">            <span class="attr">redis-rate-limiter.burstCapacity:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">redis-rate-limiter.replenishRate是您希望允许用户每秒执行多少请求，而不会丢弃任何请求。这是令牌桶填充的速率</span><br><span class="line">redis-rate-limiter.burstCapacity是指令牌桶的容量，允许在一秒钟内完成的最大请求数,将此值设置为零将阻止所有请求。</span><br><span class="line">key-resolver: “#&#123;@ipKeyResolver&#125;” 用于通过SPEL表达式来指定使用哪一个KeyResolver.</span><br></pre></td></tr></table></figure>

<p>如上配置： 表示 一秒内，允许 一个请求通过，令牌桶的填充速率也是一秒钟添加一个令牌。 最大突发状况 也只允许 一秒内有一次请求，可以根据业务来调整 。</p>
<h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><h3 id="Gateway工作流程源码剖析"><a href="#Gateway工作流程源码剖析" class="headerlink" title="Gateway工作流程源码剖析"></a>Gateway工作流程源码剖析</h3><h4 id="Gateway工作流程分析"><a href="#Gateway工作流程分析" class="headerlink" title="Gateway工作流程分析"></a>Gateway工作流程分析</h4>]]></content>
      <categories>
        <category>gateway</category>
        <category>网关</category>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>gateway</tag>
        <tag>网关</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper入门篇</title>
    <url>/2023/02/02/Zookeeper%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>Zookeeper 是 Apache Hadoop 项目下的一个子项目，是一个树形目录服务。</li>
<li>Zookeeper 翻译过来就是 动物园管理员，他是用来管 Hadoop（大象）、Hive(蜜蜂)、Pig(小 猪)的管理员。简称zk。</li>
<li>Zookeeper 是一个分布式的、开源的分布式应用程序的协调服务。</li>
<li>Zookeeper 提供的主要功能包括：配置管理、分布式锁、集群管理</li>
</ul>
<h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>ZooKeeper服务器是用Java创建的，它运行在JVM之上。需要安装JDK 7或更高版本。</p>
<h4 id="上传安装包"><a href="#上传安装包" class="headerlink" title="上传安装包"></a>上传安装包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打开 opt目录</span></span><br><span class="line">cd /opt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建zooKeeper目录</span></span><br><span class="line">mkdir  zooKeeper</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将zookeeper安装包上传到当前目录</span></span><br></pre></td></tr></table></figure>

<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><p>将tar包解压到&#x2F;opt&#x2F;zookeeper目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-ZooKeeper-3.5.6-bin.tar.gz </span><br></pre></td></tr></table></figure>

<h3 id="配置启动"><a href="#配置启动" class="headerlink" title="配置启动"></a>配置启动</h3><h4 id="配置zoo-cfg"><a href="#配置zoo-cfg" class="headerlink" title="配置zoo.cfg"></a>配置zoo.cfg</h4><p>进入到conf目录拷贝一个zoo_sample.cfg并完成配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入到conf目录</span></span><br><span class="line">cd /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/conf/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拷贝</span></span><br><span class="line">cp  zoo_sample.cfg  zoo.cfg</span><br></pre></td></tr></table></figure>

<p>修改zoo.cfg</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打开目录</span></span><br><span class="line">cd /opt/zooKeeper/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建zooKeeper存储目录</span></span><br><span class="line">mkdir  zkdata</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改zoo.cfg</span></span><br><span class="line">vim /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/conf/zoo.cfg</span><br></pre></td></tr></table></figure>

<p><img src="/./images/1577548250377.png" alt="1577548250377"></p>
<p>修改存储目录：dataDir&#x3D;&#x2F;opt&#x2F;zookeeper&#x2F;zkdata</p>
<h4 id="启动ZooKeeper"><a href="#启动ZooKeeper" class="headerlink" title="启动ZooKeeper"></a>启动ZooKeeper</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/bin/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动</span></span><br><span class="line">./zkServer.sh  start</span><br></pre></td></tr></table></figure>

<p><img src="1577548052037.png" alt="1577548052037"></p>
<p>看到上图表示ZooKeeper成功启动</p>
<h2 id="ZooKeeper-命令操作"><a href="#ZooKeeper-命令操作" class="headerlink" title="ZooKeeper 命令操作"></a>ZooKeeper 命令操作</h2><h3 id="Zookeeper命令操作数据模型"><a href="#Zookeeper命令操作数据模型" class="headerlink" title="Zookeeper命令操作数据模型"></a>Zookeeper命令操作数据模型</h3><ul>
<li><p>ZooKeeper 是一个树形目录服务,其数据模型和Unix的文件系统目录树很类似，拥有一个层次化结构。</p>
</li>
<li><p>这里面的每一个节点都被称为： ZNode，每个节点上都会保存自己的数据和节点信息。 </p>
</li>
<li><p>节点可以拥有子节点，同时也允许少量（1MB）数据存储在该节点之下。</p>
</li>
<li><p>节点可以分为四大类：</p>
<ol>
<li><p>PERSISTENT 持久化节点 </p>
</li>
<li><p>EPHEMERAL 临时节点 ：-e</p>
</li>
<li><p>PERSISTENT_SEQUENTIAL 持久化顺序节点 ：-s</p>
</li>
<li><p>EPHEMERAL_SEQUENTIAL 临时顺序节点  ：-es</p>
</li>
</ol>
</li>
</ul>
<p><img src="/../images/1592054828485.png" alt="1592054828485"></p>
<p><img src="/../images/1592054844023.png" alt="1592054844023"></p>
<h3 id="Zookeeper命令操作服务端命令"><a href="#Zookeeper命令操作服务端命令" class="headerlink" title="Zookeeper命令操作服务端命令"></a>Zookeeper命令操作服务端命令</h3><ul>
<li><p>启动 ZooKeeper 服务: .&#x2F;zkServer.sh start</p>
</li>
<li><p>查看 ZooKeeper 服务状态: .&#x2F;zkServer.sh status</p>
</li>
<li><p>停止 ZooKeeper 服务: .&#x2F;zkServer.sh stop </p>
</li>
<li><p>重启 ZooKeeper 服务: .&#x2F;zkServer.sh restart</p>
</li>
</ul>
<h3 id="Zookeeper客户端常用命令"><a href="#Zookeeper客户端常用命令" class="headerlink" title="Zookeeper客户端常用命令"></a>Zookeeper客户端常用命令</h3><ul>
<li>连接ZooKeeper服务端</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./zkCli.sh –server ip:port</span><br></pre></td></tr></table></figure>

<ul>
<li>断开连接</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure>

<ul>
<li>查看命令帮助</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">help</span><br></pre></td></tr></table></figure>

<ul>
<li>显示指定目录下节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls 目录</span><br></pre></td></tr></table></figure>

<ul>
<li>创建节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create /节点path value</span><br></pre></td></tr></table></figure>

<ul>
<li>获取节点值</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">get /节点path</span><br></pre></td></tr></table></figure>

<ul>
<li>设置节点值</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set /节点path value</span><br></pre></td></tr></table></figure>

<ul>
<li>删除单个节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">delete /节点path</span><br></pre></td></tr></table></figure>

<ul>
<li>删除带有子节点的节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deleteall /节点path</span><br></pre></td></tr></table></figure>

<h3 id="客户端命令-创建临时有序节点"><a href="#客户端命令-创建临时有序节点" class="headerlink" title="客户端命令-创建临时有序节点"></a>客户端命令-创建临时有序节点</h3><ul>
<li>创建临时节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create -e /节点path value</span><br></pre></td></tr></table></figure>

<ul>
<li>创建顺序节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create -s /节点path value</span><br></pre></td></tr></table></figure>

<ul>
<li>查询节点详细信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls –s /节点path </span><br></pre></td></tr></table></figure>

<ol>
<li><p>czxid：节点被创建的事务ID </p>
</li>
<li><p>ctime: 创建时间 </p>
</li>
<li><p>mzxid: 最后一次被更新的事务ID </p>
</li>
<li><p>mtime: 修改时间 </p>
</li>
<li><p>pzxid：子节点列表最后一次被更新的事务ID</p>
</li>
<li><p>cversion：子节点的版本号 </p>
</li>
<li><p>dataversion：数据版本号 </p>
</li>
<li><p>aclversion：权限版本号 </p>
</li>
<li><p>ephemeralOwner：用于临时节点，代表临时节点的事务ID，如果为持久节点则为0 </p>
</li>
<li><p>dataLength：节点存储的数据的长度 </p>
</li>
<li><p>numChildren：当前节点的子节点个数</p>
</li>
</ol>
<h2 id="ZooKeeper-JavaAPI-操作"><a href="#ZooKeeper-JavaAPI-操作" class="headerlink" title="ZooKeeper JavaAPI 操作"></a>ZooKeeper JavaAPI 操作</h2><h3 id="urator介绍"><a href="#urator介绍" class="headerlink" title="urator介绍"></a>urator介绍</h3><p>•Curator 是 Apache ZooKeeper 的Java客户端库。</p>
<p>•常见的ZooKeeper Java API ：</p>
<p>•原生Java API</p>
<p>•ZkClient</p>
<p>•Curator</p>
<p>•Curator 项目的目标是简化 ZooKeeper 客户端的使用。</p>
<p>•Curator 最初是 Netfix 研发的,后来捐献了 Apache 基金会,目前是 Apache 的顶级项目。</p>
<p>•官网：<a href="http://curator.apache.org/">http://curator.apache.org/</a></p>
<h3 id="JavaAPI操作建立连接"><a href="#JavaAPI操作建立连接" class="headerlink" title="JavaAPI操作建立连接"></a>JavaAPI操作建立连接</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnect</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//重试策略</span></span><br><span class="line">    <span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">3000</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//2.第二种方式</span></span><br><span class="line">    <span class="comment">//CuratorFrameworkFactory.builder();</span></span><br><span class="line">    client = CuratorFrameworkFactory.builder()</span><br><span class="line">        .connectString(<span class="string">&quot;192.168.200.130:2181&quot;</span>)</span><br><span class="line">        .sessionTimeoutMs(<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">        .connectionTimeoutMs(<span class="number">15</span> * <span class="number">1000</span>)</span><br><span class="line">        .retryPolicy(retryPolicy)</span><br><span class="line">        .namespace(<span class="string">&quot;itheima&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">//开启连接</span></span><br><span class="line">    client.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper-JavaAPI操作-创建节点"><a href="#Zookeeper-JavaAPI操作-创建节点" class="headerlink" title="Zookeeper JavaAPI操作-创建节点"></a>Zookeeper JavaAPI操作-创建节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建节点：create 持久 临时 顺序 数据</span></span><br><span class="line"><span class="comment">* 1. 基本创建 ：create().forPath(&quot;&quot;)</span></span><br><span class="line"><span class="comment">* 2. 创建节点 带有数据:create().forPath(&quot;&quot;,data)</span></span><br><span class="line"><span class="comment">* 3. 设置节点的类型：create().withMode().forPath(&quot;&quot;,data)</span></span><br><span class="line"><span class="comment">* 4. 创建多级节点  /app1/p1 ：create().creatingParentsIfNeeded().forPath(&quot;&quot;,data)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreate</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//2. 创建节点 带有数据</span></span><br><span class="line">    <span class="comment">//如果创建节点，没有指定数据，则默认将当前客户端的ip作为数据存储</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> client.create().forPath(<span class="string">&quot;/app2&quot;</span>, <span class="string">&quot;hehe&quot;</span>.getBytes());</span><br><span class="line">    System.out.println(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreate2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1. 基本创建</span></span><br><span class="line">    <span class="comment">//如果创建节点，没有指定数据，则默认将当前客户端的ip作为数据存储</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> client.create().forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">    System.out.println(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreate3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//3. 设置节点的类型</span></span><br><span class="line">    <span class="comment">//默认类型：持久化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> client.create().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">&quot;/app3&quot;</span>);</span><br><span class="line">    System.out.println(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreate4</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//4. 创建多级节点  /app1/p1</span></span><br><span class="line">    <span class="comment">//creatingParentsIfNeeded():如果父节点不存在，则创建父节点</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> client.create().creatingParentsIfNeeded().forPath(<span class="string">&quot;/app4/p1&quot;</span>);</span><br><span class="line">    System.out.println(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZookeeperJavaAPI操作-查询节点"><a href="#ZookeeperJavaAPI操作-查询节点" class="headerlink" title="ZookeeperJavaAPI操作-查询节点"></a>ZookeeperJavaAPI操作-查询节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查询节点：</span></span><br><span class="line"><span class="comment">* 1. 查询数据：get: getData().forPath()</span></span><br><span class="line"><span class="comment">* 2. 查询子节点： ls: getChildren().forPath()</span></span><br><span class="line"><span class="comment">* 3. 查询节点状态信息：ls -s:getData().storingStatIn(状态对象).forPath()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGet1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1. 查询数据：get</span></span><br><span class="line">    <span class="type">byte</span>[] data = client.getData().forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGet2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 2. 查询子节点： ls</span></span><br><span class="line">    List&lt;String&gt; path = client.getChildren().forPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    System.out.println(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGet3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Stat</span> <span class="variable">status</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line">    System.out.println(status);</span><br><span class="line">    <span class="comment">//3. 查询节点状态信息：ls -s</span></span><br><span class="line">    client.getData().storingStatIn(status).forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">    System.out.println(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper-JavaAPI操作-修改节点"><a href="#Zookeeper-JavaAPI操作-修改节点" class="headerlink" title="Zookeeper JavaAPI操作-修改节点"></a>Zookeeper JavaAPI操作-修改节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 修改数据</span></span><br><span class="line"><span class="comment">* 1. 基本修改数据：setData().forPath()</span></span><br><span class="line"><span class="comment">* 2. 根据版本修改: setData().withVersion().forPath()</span></span><br><span class="line"><span class="comment">* * version 是通过查询出来的。目的就是为了让其他客户端或者线程不干扰我。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	client.setData().forPath(<span class="string">&quot;/app1&quot;</span>, <span class="string">&quot;itcast&quot;</span>.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSetForVersion</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Stat</span> <span class="variable">status</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line">    <span class="comment">//3. 查询节点状态信息：ls -s</span></span><br><span class="line">    client.getData().storingStatIn(status).forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">version</span> <span class="operator">=</span> status.getVersion();<span class="comment">//查询出来的 3</span></span><br><span class="line">    System.out.println(version);</span><br><span class="line">    client.setData().withVersion(version).forPath(<span class="string">&quot;/app1&quot;</span>, <span class="string">&quot;hehe&quot;</span>.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper-JavaAPI操作-删除节点"><a href="#Zookeeper-JavaAPI操作-删除节点" class="headerlink" title="Zookeeper JavaAPI操作-删除节点"></a>Zookeeper JavaAPI操作-删除节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除节点： delete deleteall</span></span><br><span class="line"><span class="comment">* 1. 删除单个节点:delete().forPath(&quot;/app1&quot;);</span></span><br><span class="line"><span class="comment">* 2. 删除带有子节点的节点:delete().deletingChildrenIfNeeded().forPath(&quot;/app1&quot;);</span></span><br><span class="line"><span class="comment">* 3. 必须成功的删除:为了防止网络抖动。本质就是重试。  client.delete().guaranteed().forPath(&quot;/app2&quot;);</span></span><br><span class="line"><span class="comment">* 4. 回调：inBackground</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 删除单个节点</span></span><br><span class="line">    client.delete().forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//2. 删除带有子节点的节点</span></span><br><span class="line">    client.delete().deletingChildrenIfNeeded().forPath(<span class="string">&quot;/app4&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//3. 必须成功的删除</span></span><br><span class="line">    client.delete().guaranteed().forPath(<span class="string">&quot;/app2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete4</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//4. 回调</span></span><br><span class="line">    client.delete().guaranteed().inBackground(<span class="keyword">new</span> <span class="title class_">BackgroundCallback</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processResult</span><span class="params">(CuratorFramework client, CuratorEvent event)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我被删除了~&quot;</span>);</span><br><span class="line">            System.out.println(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper-JavaAPI操作-Watch监听概述"><a href="#Zookeeper-JavaAPI操作-Watch监听概述" class="headerlink" title="Zookeeper JavaAPI操作-Watch监听概述"></a>Zookeeper JavaAPI操作-Watch监听概述</h3><ol>
<li>ZooKeeper 允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</li>
<li>ZooKeeper 中引入了Watcher机制来实现了发布&#x2F;订阅功能能，能够让多个订阅者同时监听某一个对象，当一个对象自身状态变化时，会通知所有订阅者。</li>
<li>ZooKeeper 原生支持通过注册Watcher来进行事件监听，但是其使用并不是特别方便需要开发人员自己反复注册Watcher，比较繁琐。</li>
<li>Curator引入了 Cache 来实现对 ZooKeeper 服务端事件的监听。</li>
<li>ZooKeeper提供了三种Watcher：</li>
</ol>
<ul>
<li>NodeCache : 只是监听某一个特定的节点</li>
<li>PathChildrenCache : 监控一个ZNode的子节点</li>
<li>TreeCache : 可以监控整个树上的所有节点，类似于PathChildrenCache和NodeCache的组合</li>
</ul>
<h3 id="Zookeeper-JavaAPI操作-Watch监听-NodeCache"><a href="#Zookeeper-JavaAPI操作-Watch监听-NodeCache" class="headerlink" title="Zookeeper JavaAPI操作-Watch监听-NodeCache"></a>Zookeeper JavaAPI操作-Watch监听-NodeCache</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 演示 NodeCache：给指定一个节点注册监听器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testNodeCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1. 创建NodeCache对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">NodeCache</span> <span class="variable">nodeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeCache</span>(client,<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">    <span class="comment">//2. 注册监听</span></span><br><span class="line">   	nodeCache.getListenable().addListener(<span class="keyword">new</span> <span class="title class_">NodeCacheListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;节点变化了~&quot;</span>);</span><br><span class="line">            <span class="comment">//获取修改节点后的数据</span></span><br><span class="line">            <span class="type">byte</span>[] data = nodeCache.getCurrentData().getData();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    	<span class="comment">//3. 开启监听.如果设置为true，则开启监听是，加载缓冲数据</span></span><br><span class="line">    	nodeCache.start(<span class="literal">true</span>);</span><br><span class="line">    	<span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper-JavaAPI操作-Watch监听-PathChildrenCache"><a href="#Zookeeper-JavaAPI操作-Watch监听-PathChildrenCache" class="headerlink" title="Zookeeper JavaAPI操作-Watch监听-PathChildrenCache"></a>Zookeeper JavaAPI操作-Watch监听-PathChildrenCache</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPathChildrenCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1.创建监听对象</span></span><br><span class="line">    <span class="type">PathChildrenCache</span> <span class="variable">pathChildrenCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathChildrenCache</span>(client,<span class="string">&quot;/app2&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//2. 绑定监听器</span></span><br><span class="line">    pathChildrenCache.getListenable().addListener(<span class="keyword">new</span> <span class="title class_">PathChildrenCacheListener</span>() &#123;    			<span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子节点变化了~&quot;</span>);</span><br><span class="line">            System.out.println(event);</span><br><span class="line">            <span class="comment">//监听子节点的数据变更，并且拿到变更后的数据</span></span><br><span class="line">            <span class="comment">//1.获取类型</span></span><br><span class="line">            PathChildrenCacheEvent.<span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> event.getType();</span><br><span class="line">            <span class="comment">//2.判断类型是否是update</span></span><br><span class="line">            <span class="keyword">if</span>(type.equals(PathChildrenCacheEvent.Type.CHILD_UPDATED))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数据变了！！！&quot;</span>);</span><br><span class="line">                <span class="type">byte</span>[] data = event.getData().getData();</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//3. 开启</span></span><br><span class="line">    pathChildrenCache.start();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper-JavaAPI操作-Watch监听-TreeCache"><a href="#Zookeeper-JavaAPI操作-Watch监听-TreeCache" class="headerlink" title="Zookeeper JavaAPI操作-Watch监听-TreeCache"></a>Zookeeper JavaAPI操作-Watch监听-TreeCache</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 演示 TreeCache：监听某个节点自己和所有子节点们</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTreeCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1. 创建监听器</span></span><br><span class="line">    <span class="type">TreeCache</span> <span class="variable">treeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeCache</span>(client,<span class="string">&quot;/app2&quot;</span>);</span><br><span class="line">    <span class="comment">//2. 注册监听</span></span><br><span class="line">    treeCache.getListenable().addListener(<span class="keyword">new</span> <span class="title class_">TreeCacheListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">childEvent</span><span class="params">(CuratorFramework client, TreeCacheEvent event)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;节点变化了&quot;</span>);</span><br><span class="line">            System.out.println(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//3. 开启</span></span><br><span class="line">    treeCache.start();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper分布式锁-概念"><a href="#Zookeeper分布式锁-概念" class="headerlink" title="Zookeeper分布式锁-概念"></a>Zookeeper分布式锁-概念</h3><ul>
<li>在我们进行单机应用开发，涉及并发同步的时候，我们往往采用synchronized或者Lock的方式来解决多线程间的代码同步问题，这时多线程的运行都是在同一个JVM之下，没有任何问题。</li>
<li>但当我们的应用是分布式集群工作的情况下，属于多JVM下的工作环境，跨JVM之间已经无法通过多线程的锁解决同步问题。</li>
<li>那么就需要一种更加高级的锁机制，来处理种跨机器的进程之间的数据同步问题——这就是分布式锁。</li>
</ul>
<h3 id="Zookeeper分布式锁-zookeeper分布式锁原理"><a href="#Zookeeper分布式锁-zookeeper分布式锁原理" class="headerlink" title="Zookeeper分布式锁-zookeeper分布式锁原理"></a>Zookeeper分布式锁-zookeeper分布式锁原理</h3><p>核心思想：当客户端要获取锁，则创建节点，使用完锁，则删除该节点</p>
<p>客户端获取锁时，在lock节点下创建临时顺序节点。</p>
<p>然后获取lock下面的所有子节点，客户端获取到所有的子节点之后，如果发现自己创建的子节点序号最小，那么就认为该客户端获取到了锁。使用完锁后，将该节点删除。</p>
<p>如果发现自己创建的节点并非lock所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，同时对其注册事件监听器，监听删除事件。</p>
<h3 id="Zookeeper-分布式锁-Curator实现分布式锁API"><a href="#Zookeeper-分布式锁-Curator实现分布式锁API" class="headerlink" title="Zookeeper 分布式锁-Curator实现分布式锁API"></a>Zookeeper 分布式锁-Curator实现分布式锁API</h3><p>在Curator中有五种锁方案：</p>
<ul>
<li>InterProcessSemaphoreMutex：分布式排它锁（非可重入锁）</li>
<li>InterProcessMutex：分布式可重入排它锁</li>
<li>InterProcessReadWriteLock：分布式读写锁</li>
<li>InterProcessMultiLock：将多个锁作为单个实体管理的容器</li>
<li>InterProcessSemaphoreV2：共享信号量</li>
</ul>
<h2 id="ZooKeeper-集群搭建"><a href="#ZooKeeper-集群搭建" class="headerlink" title="ZooKeeper 集群搭建"></a>ZooKeeper 集群搭建</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li><p>三台服务器</p>
</li>
<li><p>安装JDK</p>
</li>
<li><p>上传zookeeper安装包至三台服务器</p>
</li>
<li><p>将Zookeeper解压 ，建立&#x2F;usr&#x2F;local&#x2F;zookeeper-cluster目录，将解压后的Zookeeper复制该目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /usr/local/zookeeper</span><br><span class="line">tar -zxvf apache-zookeeper-3.5.6-bin.tar.gz</span><br><span class="line">mv apache-zookeeper-3.5.6-bin /usr/local/zookeeper</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建data目录 ，并且将 conf下zoo_sample.cfg 文件改名为 zoo.cfg</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /usr/local/zookeeper/data</span><br><span class="line">mv  /usr/local/zookeeper/conf/zoo_sample.cfg  /usr/local/zookeeper/conf/zoo.cfg</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置dataDir 为创建的data目录和 指定的clientPort </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/zookeeper/conf/zoo.cfg</span><br><span class="line"></span><br><span class="line">clientPort=2181</span><br><span class="line">dataDir=/usr/local/zookeeper/data</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果定义集群，使用结点名访问，配置hostname</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname zookeeper1</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h3><ol>
<li><p>在zookeeper的 data 目录下创建一个 myid 文件，内容分别是1、2、3 。这个文件就是记录每个服务器的ID</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1 &gt;/usr/local/zookeeper/data/myid</span><br></pre></td></tr></table></figure>
</li>
<li><p>在每一个zookeeper 的 zoo.cfg配置客户端访问端口（clientPort）和集群服务器IP列表。集群服务器IP列表如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/zookeeper/conf/zoo.cfg</span><br><span class="line"></span><br><span class="line">server.1=ip:2881:3881</span><br><span class="line">server.2=ip:2882:3882</span><br><span class="line">server.3=ip:2883:3883</span><br></pre></td></tr></table></figure>

<p>解释：server.服务器ID&#x3D;服务器IP地址：服务器之间通信端口：服务器之间投票选举端口</p>
</li>
</ol>
<h3 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h3><p>分别在三台服务器上启动zookeeper</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/zookeeper/bin/zkServer.sh start</span><br></pre></td></tr></table></figure>

<p>启动后我们查询一下每个实例的运行状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/zookeeper/bin/zkServer.sh status</span><br></pre></td></tr></table></figure>

<p>如果存在一个leader和两个follower，说明集群启动成功</p>
<h4 id="Zookeepe集群角色"><a href="#Zookeepe集群角色" class="headerlink" title="Zookeepe集群角色"></a>Zookeepe集群角色</h4><p>在ZooKeeper集群服中务中有三个角色：</p>
<ul>
<li><p>Leader 领导者 ：</p>
<p>处理事务请求</p>
<p>集群内部各服务器的调度者</p>
</li>
<li><p>Follower 跟随者 ：</p>
<p>处理客户端非事务请求，转发事务请求给Leader服务器</p>
<p>参与Leader选举投票</p>
</li>
<li><p>Observer 观察者：</p>
<p>处理客户端非事务请求，转发事务请求给Leader服务器</p>
</li>
</ul>
<p><img src="/./images/1592058451822.png"></p>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper进阶篇</title>
    <url>/2023/03/02/Zookeeper%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>netty</title>
    <url>/2023/03/09/netty/</url>
    <content><![CDATA[<h2 id="JAVA-IO-模型"><a href="#JAVA-IO-模型" class="headerlink" title="JAVA IO 模型"></a>JAVA IO 模型</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>阻塞&#x2F;非阻塞：没有数据传过来时，读会阻塞直到有数据；缓冲区满时，写操作也会阻塞。非阻塞遇到这种情况直接返回</li>
<li>同步IO&#x2F;异步IO：数据就绪后需要自己去读是同步；数据就绪后系统直接读好回调给程序是异步</li>
</ul>
<h3 id="JAVA-BIO"><a href="#JAVA-BIO" class="headerlink" title="JAVA BIO"></a>JAVA BIO</h3><ol>
<li>BIO是blocking I&#x2F;O的简称，它是同步阻塞型IO，其相关的类和接口在java.io下</li>
<li>BIO模型简单来讲，就是服务端为每一个请求都分配一个线程进行处理，I&#x2F;O操作都是基于流Stream的操作</li>
</ol>
<h4 id="弊端："><a href="#弊端：" class="headerlink" title="弊端："></a>弊端：</h4><ul>
<li><strong>线程开销：</strong>客户端的的并发数和后端的并发数成1:1比例，线程的创建、销毁是非常消耗系统资源的，随着并发量增大，服务端性能显著下降，甚至会出现线程堆栈溢出等错误</li>
<li><strong>线程阻塞：</strong>当连接创建后如果该线程没有操作时，会进行阻塞操作，这样极大的浪费了服务器资源</li>
</ul>
<h3 id="JAVA-NIO-模型"><a href="#JAVA-NIO-模型" class="headerlink" title="JAVA NIO 模型"></a>JAVA NIO 模型</h3><ul>
<li>NIO，称之为New IO 或是 non-block IO （非阻塞IO），这两种说法都可以，其实称之为非阻塞IO更恰当一些</li>
<li>NIO的三大核心组件：<strong>Buffer（缓冲区）、Channel（通道）、Selector（选择器&#x2F;多路复用器）</strong></li>
</ul>
<h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p><strong>Buffer（缓冲区）：</strong></p>
<ul>
<li>Buffer是一个对象，包含一些要写入或者读出的数据，体现了与原I&#x2F;O的一个重要区别。在面向流的I&#x2F;O中，数据的读写是直接进入到stream中；在NIO中，所有数据都是用缓冲区处理的，读数据直接从缓冲区读，写数据直接写入到缓冲区。</li>
<li>缓冲区的本质是一个数组，通常是一个字节数组（ByteBuffer），也可以使用其他类型，但缓冲区又不仅仅是一个数组，它还提供了对数据结构化访问以及维护读写位置等操作。</li>
</ul>
<p><strong>Channel（通道）：</strong></p>
<ul>
<li>Channel 是一个通道，管道，网络数据通过Channel读取和写入，Channel和流Stream的不同之处在于Channel是双向的，流只在一个方向上移动（InputStream&#x2F;OutputStream），而Channel可以用于读写同时进行，即Channel是全双工的。</li>
</ul>
<p><strong>Selector（选择器&#x2F;多路复用器）：</strong></p>
<ul>
<li>Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，即该Channel处于就绪状态，它就会被Selector轮询出来，然后通过selectedKeys可以获取就绪Channel的集合，进行后续的I&#x2F;O操作。</li>
</ul>
<h3 id="JAVA-AIO模型"><a href="#JAVA-AIO模型" class="headerlink" title="JAVA AIO模型"></a>JAVA AIO模型</h3><p>AIO是asynchronous I&#x2F;O的简称，是异步IO，该异步IO是需要依赖于操作系统底层的异步IO实现。</p>
<p><strong>AIO的基本流程</strong>：用户线程通过系统调用，告知kernel内核启动某个IO操作，用户线程返回。kernel内核在整个IO操作（包括数据准备、数据复制）完成后，通知用户程序，用户执行后续的业务操作。</p>
<h2 id="Reactor-线程模型"><a href="#Reactor-线程模型" class="headerlink" title="Reactor 线程模型"></a>Reactor 线程模型</h2><p>Reactor线程模型不是Java专属，也不是Netty专属，它其实是一种并发编程模型，是一种思想，具有指导意义</p>
<p>Reactor模型中定义了三种角色：</p>
<ul>
<li><strong>Reactor</strong>：负责监听和分配事件，将I&#x2F;O事件分派给对应的Handler。新的事件包含连接建立就绪、读就绪、写就绪等。</li>
<li><strong>Acceptor</strong>：处理客户端新连接，并分派请求到处理器链中。</li>
<li><strong>Handler</strong>：将自身与事件绑定，执行非阻塞读&#x2F;写任务，完成channel的读入，完成处理业务逻辑后，负责</li>
<li>将结果写出channel</li>
</ul>
<h3 id="单Reactor-单线程"><a href="#单Reactor-单线程" class="headerlink" title="单Reactor-单线程"></a><strong>单Reactor-单线程</strong></h3><p>所有的接收连接，处理数据的相关操作都在一个线程中来完成，性能上有瓶颈</p>
<h3 id="单Reactor-多线程"><a href="#单Reactor-多线程" class="headerlink" title="单Reactor-多线程"></a><strong>单Reactor-多线程</strong></h3><p>把比较耗时的数据的编解码运算操作放入线程池中来执行，提升了性能但还不是最好的方式</p>
<h3 id="主从Reactor-多线程"><a href="#主从Reactor-多线程" class="headerlink" title="主从Reactor-多线程"></a><strong>主从Reactor-多线程</strong></h3><p>主从多线程，对于服务器来说，接收客户端的连接是比较重要的，因此将这部分操作单独用线程去操作</p>
<h4 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h4><ol>
<li>Reactor 主线程 MainReactor 对象通过 select 监听客户端连接事件，收到事件后，通过 Acceptor 处理客户端连接事件。</li>
<li>当 Acceptor 处理完客户端连接事件之后（与客户端建立好 Socket 连接），MainReactor 将连接分配给SubReactor。（即：MainReactor 只负责监听客户端连接请求，和客户端建立连接之后将连接交由SubReactor 监听后面的 IO 事件。）</li>
<li>SubReactor 将连接加入到自己的连接队列进行监听，并创建 Handler 对各种事件进行处理。</li>
<li>当连接上有新事件发生的时候，SubReactor 就会调用对应的 Handler 处理。</li>
<li>Handler 通过 read 从连接上读取请求数据，将请求数据分发给 Worker 线程池进行业务处理。</li>
<li>Worker 线程池会分配独立线程来完成真正的业务处理，并将处理结果返回给 Handler。Handler 通过send 向客户端发送响应数据</li>
<li>一个 MainReactor 可以对应多个 SubReactor，即一个 MainReactor 线程可以对应多个 SubReactor 线程</li>
</ol>
<h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><ul>
<li>MainReactor 线程与 SubReactor 线程的数据交互简单职责明确，MainReactor 线程只需要接收新连接，SubReactor 线程完成后续的业务处理。</li>
<li>MainReactor 线程与 SubReactor 线程的数据交互简单， MainReactor 线程只需要把新连接传给SubReactor 线程，SubReactor 线程无需返回数据。</li>
<li>多个 SubReactor 线程能够应对更高的并发请求。</li>
<li>这种模式的缺点是编程复杂度较高。但是由于其优点明显，在许多项目中被广泛使用，包括 Nginx、Memcached、Netty 等。</li>
<li>这种模式也被叫做服务器的 1+M+N 线程模式，即使用该模式开发的服务器包含一个（或多个，1 只是表示相对较少）连接建立线程+M 个 IO 线程+N 个业务处理线程。这是业界成熟的服务器程序设计模式。</li>
</ul>
<h2 id="Netty概述"><a href="#Netty概述" class="headerlink" title="Netty概述"></a>Netty概述</h2><ul>
<li>Netty是由JBOSS提供的一个java开源框架，现为 Github上的独立项目。Netty提供非阻塞的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。</li>
</ul>
<h3 id="Netty中的Reactor实现"><a href="#Netty中的Reactor实现" class="headerlink" title="Netty中的Reactor实现"></a>Netty中的Reactor实现</h3><p>Netty线程模型是基于Reactor模型实现的，对Reactor三种模式都有非常好的支持，并做了一定的改进，也非常的灵活，一般情况，在服务端会采用主从架构模型。</p>
<p><strong>工作流程：</strong></p>
<ol>
<li><p>Netty 抽象出两组线程池：BossGroup 和 WorkerGroup，每个线程池中都有EventLoop 线程（可以OIO,NIO,AIO）。BossGroup中的线程专门负责和客户端建立连接，WorkerGroup 中的线程专门负责处理连接上的读写, EventLoopGroup 相当于一个事件循环组，这个组中含有多个事件循环。</p>
</li>
<li><p>EventLoop 表示一个不断循环的执行事件处理的线程，每个EventLoop 都包含一个 Selector，用于监听注册在其上的 Socket 网络连接（Channel）。</p>
</li>
<li><p>每个 BossEventLoop 中循环执行以下三个步骤：</p>
<p>1）select：轮训注册在其上的 ServerSocketChannel 的 accept 事件（OP_ACCEPT 事件）</p>
<p>2）processSelectedKeys：处理 accept 事件，与客户端建立连接，生成一个SocketChannel，并将其注册到某个 WorkerEventLoop 上的 Selector 上</p>
<p>3）runAllTasks：再去以此循环处理任务队列中的其他任务</p>
</li>
<li><p>每个 Worker EventLoop 中循环执行以下三个步骤：</p>
<p>1）select：轮训注册在其上的SocketChannel 的 read&#x2F;write 事件（OP_READ&#x2F;OP_WRITE 事件）</p>
<p>2）processSelectedKeys：在对应的SocketChannel 上处理 read&#x2F;write 事件</p>
<p>3）runAllTasks：再去以此循环处理任务队列中的其他任务</p>
</li>
<li><p>在以上两个processSelectedKeys步骤中，会使用 Pipeline（管道），Pipeline 中引用了 Channel，即通过Pipeline 可以获取到对应的 Channel，Pipeline 中维护了很多的处理器（拦截处理器、过滤处理器、自定义处理器等）。</p>
</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li>Netty 的线程模型基于主从多Reactor模型。通常由一个线程负责处理OP_ACCEPT事件，拥有 CPU 核数的两倍的IO线程处理读写事件</li>
<li>一个通道的IO操作会绑定在一个IO线程中，而一个IO线程可以注册多个通道</li>
<li>在一个网络通信中通常会包含网络数据读写，编码、解码、业务处理。默认情况下网络数据读写，编码、解码等操作会在IO线程中运行，但也可以指定其他线程池。</li>
<li>通常业务处理会单独开启业务线程池（看业务类型），但也可以进一步细化，例如心跳包可以直接在IO线程中处理，而需要再转发给业务线程池，避免线程切换</li>
<li>在一个IO线程中所有通道的事件是串行处理的。</li>
<li>通常业务操作会专门开辟一个线程池，那业务处理完成之后，如何将响应结果通过 IO 线程写入到网卡中呢？业务线程调用 Channel对象的 write 方法并不会立即写入网络，只是将数据放入一个待写入缓存区，然后IO线程每次执行事件选择后，会从待写入缓存区中获取写入任务，将数据真正写入到网络中</li>
</ul>
<h2 id="Pipeline-和-Handler"><a href="#Pipeline-和-Handler" class="headerlink" title="Pipeline 和 Handler"></a>Pipeline 和 Handler</h2><h3 id="ChannelPipeline-amp-ChannelHandler"><a href="#ChannelPipeline-amp-ChannelHandler" class="headerlink" title="ChannelPipeline &amp; ChannelHandler"></a>ChannelPipeline &amp; ChannelHandler</h3><ul>
<li>ChannelPipeline 提供了 ChannelHandler 链的容器。以服务端程序为例，客户端发送过来的数据要接收，读取处理，我们称数据是入站的，需要经过一系列Handler处理后；如果服务器想向客户端写回数据，也需要经过一系列Handler处理，我们称数据是出站的。</li>
</ul>
<h3 id="ChannelHandler-分类"><a href="#ChannelHandler-分类" class="headerlink" title="ChannelHandler 分类"></a>ChannelHandler 分类</h3><p>对于数据的出站和入站，有着不同的ChannelHandler类型与之对应：</p>
<ol>
<li>ChannelInboundHandler 入站事件处理器</li>
<li>ChannelOutBoundHandler 出站事件处理器</li>
<li>ChannelHandlerAdapter提供了一些方法的默认实现，可减少用户对于ChannelHandler的编写</li>
<li>ChannelDuplexHandler：混合型，既能处理入站事件又能处理出站事件</li>
</ol>
<h3 id="ChannelHandler-体系结构"><a href="#ChannelHandler-体系结构" class="headerlink" title="ChannelHandler 体系结构"></a>ChannelHandler 体系结构</h3><ol>
<li>inbound入站事件处理顺序（方向）是由链表的头到链表尾，outbound事件的处理顺序是由链表尾到链表头。</li>
<li>inbound入站事件由netty内部触发，最终由netty外部的代码消费。</li>
<li>outbound事件由netty外部的代码触发，最终由netty内部消费。</li>
</ol>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><ul>
<li>InboundHandler是按照Pipleline的加载顺序(addLast)，<strong>顺序</strong>执行</li>
<li>OutboundHandler是按照Pipeline的加载顺序(addLast)，<strong>逆序</strong>执行</li>
</ul>
<h3 id="回写数据事件流转规则"><a href="#回写数据事件流转规则" class="headerlink" title="回写数据事件流转规则"></a>回写数据事件流转规则</h3><ul>
<li>如果是通过Channel对象进行数据回写，事件会从pipeline尾部流向头部</li>
<li>如果是通过ChannelHandlerContext对象进行数据回写，事件会从当前handler流向头部</li>
<li>问题：OutboundHandler和InboundHandler的先后顺序是否有要求？才能保证所有outboundHandler能被执行</li>
</ul>
<h2 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h2><ul>
<li><p>Bootstrap是引导的意思，它的作用是配置整个Netty程序，将各个组件都串起来，最后绑定端口、启动Netty服务</p>
</li>
<li><p>Netty中提供了2种类型的引导类，一种用于客户端(Bootstrap)，而另一种(ServerBootstrap)用于服务器，区别在于：</p>
<p>1、ServerBootstrap 将绑定到一个端口，因为服务器必须要监听连接，而 Bootstrap 则是由想要连接到远程	  节点的客户端应用程序所使用的</p>
<p>2、引导一个客户端只需要一个EventLoopGroup，但是一个ServerBootstrap则需要两个</p>
</li>
</ul>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul>
<li>Netty中的Channel是与网络套接字相关的，可以理解为是socket连接，在客户端与服务端连接的时候就会建立一个Channel，它负责基本的IO操作，比如：bind()、connect()，read()，write() 等</li>
</ul>
<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ol>
<li>通过Channel可获得当前网络连接的通道状态。</li>
<li>通过Channel可获得网络连接的配置参数（缓冲区大小等）。</li>
<li>Channel提供异步的网络I&#x2F;O操作，比如连接的建立、数据的读写、端口的绑定等。</li>
</ol>
<p>不同协议、不同的I&#x2F;O类型的连接都有不同的 Channel 类型与之对应</p>
<h2 id="EventLoopGroup-amp-EventLoop"><a href="#EventLoopGroup-amp-EventLoop" class="headerlink" title="EventLoopGroup&amp;EventLoop"></a>EventLoopGroup&amp;EventLoop</h2><ul>
<li>Netty是基于事件驱动的，比如：连接注册，连接激活；数据读取；异常事件等等，有了事件，就需要一个组件去监控事件的产生和事件的协调处理，这个组件就是EventLoop（事件循环&#x2F;EventExecutor），在Netty 中每个Channel 都会被分配到一个 EventLoop。一个 EventLoop 可以服务于多个 Channel。每个EventLoop 会占用一个 Thread，同时这个 Thread 会处理 EventLoop 上面发生的所有 IO 操作和事件。</li>
<li>EventLoopGroup 是用来生成 EventLoop 的，包含了一组EventLoop（可以初步理解成Netty线程池）</li>
</ul>
<h2 id="ChannelHandler-amp-amp-ChannelHandlerContext-amp-amp-ChannelPipeline"><a href="#ChannelHandler-amp-amp-ChannelHandlerContext-amp-amp-ChannelPipeline" class="headerlink" title="ChannelHandler&amp;&amp;ChannelHandlerContext&amp;&amp;ChannelPipeline"></a>ChannelHandler&amp;&amp;ChannelHandlerContext&amp;&amp;ChannelPipeline</h2><ul>
<li><strong>@Sharable</strong> 可以被复用，至于线程安全问题需要开发者自行保证</li>
<li>继承SimpleChannelInboundHandler需要重写channelRead0方法，且可以通过泛型指定msg类型</li>
<li>SimpleChannelInboundHandler在接收到数据后会自动release掉数据占用的Bytebuffer资源</li>
<li>注意事项：服务端异步处理数据，服务端想把客户端发送来的数据再写回等等场景下最好不要继承SimpleChannelInboundHandler</li>
<li>客户端推荐使用SimpleChannelInboundHandler，服务端看场景</li>
</ul>
<h2 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h2><h3 id="概念和作用"><a href="#概念和作用" class="headerlink" title="概念和作用"></a>概念和作用</h3><ul>
<li>Java NIO 提供了ByteBuffer 作为它的字节容器，但是这个类使用起来过于复杂，而且也有些繁琐。Netty使用ByteBuf来替代ByteBuffer，它是一个强大的实现，既解决了JDK API 的局限性， 又为网络应用程序的开发者提供了更好的API</li>
<li>从结构上来说，ByteBuf 由一串字节数组构成。数组中每个字节用来存放信息，ByteBuf提供了两个索引，一个用于读取数据（readerIndex ），一个用于写入数据（writerIndex）。这两个索引通过在字节数组中移动，来定位需要读或者写信息的位置。而JDK的ByteBuffer只有一个索引，因此需要使用flip方法进行读写切换</li>
</ul>
<h3 id="ByteBuf的三个指针"><a href="#ByteBuf的三个指针" class="headerlink" title="ByteBuf的三个指针"></a>ByteBuf的三个指针</h3><ul>
<li>readerIndex：指示读取的起始位置， 每读取一个字节， readerIndex自增累加1。 如果readerIndex 与writerIndex 相等，ByteBuf 不可读。</li>
<li>writerIndex：指示写入的起始位置， 每写入一个字节， writeIndex自增累加1。如果增加到 writerIndex 与capacity（） 容量相等，表示 ByteBuf 已经不可写，但是这个时候，并不代表不能往 ByteBuf 中写数据了， 如果发现往ByteBuf 中写数据写不进去的话，Netty 会自动扩容 ByteBuf，直到扩容到底层的内存大小为 maxCapacity</li>
<li>maxCapacity：指示ByteBuf 可以扩容的最大容量， 如果向ByteBuf写入数据时， 容量不足， 可以进行扩容的最大容量</li>
</ul>
<h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><ul>
<li><p>capacity()：表示 ByteBuf 底层占用了多少字节的内存（包括丢弃的字节、可读字节、可写字节），不同的底层实现机制有不同的计算方式。</p>
</li>
<li><p>maxCapacity()： ByteBuf 底层最大能够占用多少字节的内存，当向 ByteBuf 中写数据的时候，如果发现容量不足，则进行扩容，直到扩容到 maxCapacity，超过这个数，就抛异常。</p>
</li>
<li><p>readableBytes() 与 isReadable()：readableBytes() 表示 ByteBuf 当前可读的字节数，它的值等于writerIndex-readerIndex，如果两者相等，则不可读，isReadable() 方法返回 false</p>
</li>
<li><p>writableBytes()、 isWritable() 、maxWritableBytes()：writableBytes() 表示 ByteBuf 当前可写的字节数，它的值等于 capacity()-writerIndex，如果两者相等，则表示不可写，isWritable() 返回 false，但是这个时候，并不代表不能往 ByteBuf 中写数据了， 如果发现往ByteBuf 中写数据写不进去的话，Netty 会自动扩容 ByteBuf，直到扩容到底层的内存大小为 maxCapacity，而 maxWritableBytes() 就表示可写的最大字节数，它的值等于maxCapacity-writerIndex。</p>
</li>
<li><p>readerIndex() 与 readerIndex(int readerIndex)：前者表示返回当前的读指针 readerIndex, 后者表示设置读指针</p>
</li>
<li><p>writeIndex() 与 writeIndex(int writerIndex)：前者表示返回当前的写指针 writerIndex, 后者表示设置写指针</p>
</li>
<li><p>markReaderIndex() 与markWriterIndex()：表示把当前的读指针&#x2F;写指针保存起来，操作形式为：markedReaderIndex &#x3D; readerIndex &#x2F; markedWriterIndex &#x3D; writerIndex;</p>
</li>
<li><p>writeBytes(byte[] src)： 表示把字节数组 src 里面的数据全部写到 ByteBuf，src字节数组大小的长度通常小于等于writableBytes()</p>
</li>
<li><p>readBytes(byte[] dst)：把 ByteBuf 里面的数据全部读取到 dst，dst 字节数组的大小通常等于 readableBytes()</p>
</li>
<li><p>writeByte(int value)、readByte()：writeByte() 表示往 ByteBuf 中写一个字节，而 readByte() 表示从 ByteBuf 中读取一个字节，类似的 API 还有 writeBoolean()、writeChar()、writeShort()、writeInt()、writeLong()、writeFloat()、writeDouble() 与 readBoolean()、readChar()、readShort()、readInt()、readLong()、readFloat()、readDouble() 等等</p>
</li>
<li><p>discardReadBytes()： 丢弃已读取的字节空间，可写空间变多</p>
</li>
<li><p>clear()：重置readerIndex 、 writerIndex 为0，需要注意的是，重置并没有删除真正的内容</p>
</li>
<li><p>release()：真正去释放bytebuf中的数据，</p>
</li>
<li><p>ReferenceCountUtil.release(buf)：工具方法，内部还是调用release()</p>
</li>
</ul>
<h3 id="ByteBuf三类使用模式"><a href="#ByteBuf三类使用模式" class="headerlink" title="ByteBuf三类使用模式"></a>ByteBuf三类使用模式</h3><ul>
<li>堆缓冲区（HeapByteBuf）：内存分配在jvm堆，分配和回收速度比较快，可以被JVM自动回收，缺点是，如果进行socket的IO读写，需要额外做一次内存复制，将堆内存对应的缓冲区复制到内核Channel中，性能会有一定程度的下降。由于在堆上被 JVM 管理，在不被使用时可以快速释放。可以通过 ByteBuf.array() 来获取 byte[] 数据。</li>
<li>直接缓冲区（DirectByteBuf）：内存分配的是堆外内存（系统内存），相比堆内存，它的分配和回收速度会慢一些，但是将它写入或从Socket Channel中读取时，由于减少了一次内存拷贝，速度比堆内存块。</li>
<li>复合缓冲区（CompositeByteBuf）：顾名思义就是将两个不同的缓冲区从逻辑上合并，让使用更加方便。</li>
<li>Netty默认使用的是DirectByteBuf，如果需要使用HeapByteBuf模式，则需要进行系统参数的设置</li>
</ul>
<h3 id="ByteBuf-的分配器"><a href="#ByteBuf-的分配器" class="headerlink" title="ByteBuf 的分配器"></a>ByteBuf 的分配器</h3><p><strong>BufAllocator：</strong></p>
<p>Netty 提供了两种 ByteBufAllocator 的实现，分别是：</p>
<ul>
<li><p>PooledByteBufAllocator：实现了 ByteBuf 的对象的池化，提高性能减少并最大限度地减少内存碎片，池化思想通过预先申请一块专用内存地址作为<strong>内存池</strong>进行管理，从而不需要每次都进行分配和释放</p>
</li>
<li><p>UnpooledByteBufAllocator：没有实现对象的池化，每次会生成新的对象实例</p>
</li>
<li><p>对于Pooled类型的ByteBuf，不管是PooledDirectByteBuf还是PooledHeapByteBuf都只能由Netty内部自己使用（构造是私有和受保护的），开发者可以使用Unpooled类型的ByteBuf。</p>
</li>
<li><p>Netty提供Unpooled工具类创建的ByteBuf都是unpooled类型，默认采用的Allocator是direct类型；当然用户可以自己选择创建UnpooledDirectByteBuf和UnpooledHeapByteBuf</p>
</li>
</ul>
<h3 id="ByteBuf-的释放"><a href="#ByteBuf-的释放" class="headerlink" title="ByteBuf 的释放"></a>ByteBuf 的释放</h3><ul>
<li><p>ByteBuf如果采用的是堆缓冲区模式的话，可以由GC回收，但是如果采用的是直接缓冲区，就不受GC的管理，就得手动释放，否则会发生内存泄露，Netty自身引入了引用计数，提供了ReferenceCounted接口，当对象的引用计数&gt;0时要保证对象不被释放，当为0时需要被释放</p>
</li>
<li><p>手动释放，就是在使用完成后，调用ReferenceCountUtil.release(byteBuf); 进行释放，这种方式的弊端就是一旦忘记释放就可能会造成内存泄露</p>
</li>
<li><p>自动释放有三种方式，分别是：</p>
<p>1）入站的TailHandler（TailContext）、继SimpleChannelInboundHandler、HeadHandler（HeadContext）的出站释放</p>
<p>2）TailContext：Inbound流水线的末端，如果前面的handler都把消息向后传递最终由TailContext释放该消息，需要注意的是，如果没有进行向下传递，是不会进行释放操作的</p>
<p>3）SimpleChannelInboundHandler：自定义的InboundHandler继承自SimpleChannelInboundHandler，在SimpleChannelInboundHandler中自动释放</p>
<p>4）HeadContext：outbound流水线的末端，出站消息一般是由应用所申请，到达最后一站时，经过一轮复杂的调用，在flush完成后终将被release掉</p>
</li>
</ul>
<p><strong>对于入站消息：</strong></p>
<ul>
<li>对原消息不做处理，依次调用 ctx.fireChannelRead(msg)把原消息往下传，如果能到TailContext，那不用做什么释放，它会自动释放</li>
<li>将原消息转化为新的消息并调用 ctx.fireChannelRead(newMsg)往下传，那需要将原消息release掉</li>
<li>如果已经不再调用ctx.fireChannelRead(msg)传递任何消息，需要把原消息release掉。</li>
</ul>
<p><strong>对于出站消息</strong>：则无需用户关心，消息最终都会走到HeadContext，flush之后会自动释放。</p>
<h2 id="Future-amp-Promise"><a href="#Future-amp-Promise" class="headerlink" title="Future &amp; Promise"></a>Future &amp; Promise</h2><p><strong>Netty的异步编程模型</strong></p>
<ul>
<li>future和promise，目的是将值（future）与其计算方式（promise）分离，从而允许更灵活地进行计算，特别是通过并行化。Future 表示目标计算的返回值，Promise 表示计算的方式，这个模型将返回结果和计算逻辑分离，目的是为了让计算逻辑不影响返回结果，从而抽象出一套异步编程模型。而计算逻辑与结果关联的纽带就是 callback。</li>
<li>Netty中有非常多的异步调用，譬如：client&#x2F;server的启动，连接，数据的读写等操作都是支持异步的。</li>
</ul>
<h3 id="Netty-ChannelFuture"><a href="#Netty-ChannelFuture" class="headerlink" title="Netty ChannelFuture"></a>Netty ChannelFuture</h3><p>ChannelFuture：跟Channel的操作有关，Netty中的Handler处理都是异步IO，通过ChannelFuture添加事件监听，可获取Channel异步IO操作的结果；当然也可等待获取，但最好不要在handler中通过future的sync或await来获取异步操作的结果。</p>
<h3 id="Netty-ChannelPromise"><a href="#Netty-ChannelPromise" class="headerlink" title="Netty ChannelPromise"></a>Netty ChannelPromise</h3><p>1、Promise机制</p>
<ul>
<li>Netty的Future，只是增加了监听器。整个异步的状态，是不能进行设置和修改的，于是Netty的 Promise接口扩展了Netty的Future接口，可以设置异步执行的结果。在IO操作过程，如果顺利完成、或者发生异常，都可以设置Promise的结果，并且通知Promise的Listener们。</li>
</ul>
<p>2、ChannelPromise接口，则继承扩展了Promise和ChannelFuture。所以，ChannelPromise既绑定了  Channel，又具备了设置监听回调的功能，还可以设置IO操作的结果，是Netty实际编程使用的最多的接口。</p>
<h2 id="Netty-消息编解码器"><a href="#Netty-消息编解码器" class="headerlink" title="Netty 消息编解码器"></a>Netty 消息编解码器</h2><h3 id="一次编解码"><a href="#一次编解码" class="headerlink" title="一次编解码"></a>一次编解码</h3><p>主要解决TCP粘包，半包问题</p>
<p>主要分为三种：</p>
<ol>
<li>固定长度（FixedLengthFrameDecoder）</li>
<li>分隔符（DelimiterBasedFrameDecoder）</li>
<li>固定长度字段存消息长度 （LengthFieldBasedFrameDecoder）（推荐使用）</li>
</ol>
<h3 id="二次编解码"><a href="#二次编解码" class="headerlink" title="二次编解码"></a>二次编解码</h3><ul>
<li>我们把解决半包粘包问题的常用三种解码器叫一次解码器，其作用是将原始数据流(可能会出现粘包和半包的数据流)转换为用户数据(ByteBuf中存储)，但仍然是字节数据，所以我们需要二次解码器将字节数组转换为java对象，或者将将一种格式转化为另一种格式，方便上层应用程序使用。</li>
<li>一次解码器继承自：ByteToMessageDecoder；二次解码器继承自：MessageToMessageDecoder；但他们的本质都是继承ChannelInboundHandlerAdapter</li>
</ul>
<h4 id="二次编解码方式"><a href="#二次编解码方式" class="headerlink" title="二次编解码方式"></a><strong>二次编解码方式</strong></h4><p>用户数据(ByteBuf )和 Java Object之间的转换，或者将将一种格式转化为另一种格式（譬如将应用数据转化成某种协议数据）。</p>
<ul>
<li>Java 序列化：不推荐使用，占用空间大，也只有java语言能用</li>
<li>Marshaling：比java序列化稍好</li>
<li>XML ：可读性好，但是占用空间大</li>
<li>JSON ：可读性也好，空间较小</li>
<li>MessagePack ：占用空间比JSON小，可读性不如JSON，但也还行</li>
<li>Protobuf ：性能高，体积小，但是可读性差</li>
<li>hessian ：跨语言、高效的二进制序列化协议，整体性能和protobuf差不多。</li>
<li>其他</li>
</ul>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Seata分布式事务</title>
    <url>/2023/06/05/Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h2><h3 id="事务的简介"><a href="#事务的简介" class="headerlink" title="事务的简介"></a>事务的简介</h3><p>​	事务是访问可能可能更新数据库各个数据项的一个程序执行单元。在关系数据库中，一个事务由一组SQL语句组成。事务具有四个属性：原子性、一致性、隔离性、持久性</p>
<p><strong>原子性：</strong>事务是一个不可分割的工作单位，事务中包括的操作要么都做，要么都不做</p>
<p><strong>一致性：</strong>事务必须是使数据库从一个一致性状态到另一个一致性状态，事务中间状态不能被观察到</p>
<p><strong>隔离性：</strong>一个事务的执行不能被其他事务干扰。即一个事务的内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。隔离性又分为四个级别：读未提交，读已提交，可重复读，串行化</p>
<p><strong>持久性：</strong>也称永久性，指一个事务一旦提交，他对数据库中数据改变应该是永久性的。接下来的其他操作或故障不应该对其有任何影响</p>
<h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h4 id="跨库事务"><a href="#跨库事务" class="headerlink" title="跨库事务"></a>跨库事务</h4><p>一个功能需要操作多个库，不同的库中存储不同的业务数据</p>
<h4 id="分库分表事务"><a href="#分库分表事务" class="headerlink" title="分库分表事务"></a>分库分表事务</h4><p>通常一个库数据量比较大或预期未来的数据量比较大，都会进行水平拆分，也就是分库分表</p>
<h4 id="跨应用事务"><a href="#跨应用事务" class="headerlink" title="跨应用事务"></a>跨应用事务</h4><h2 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h2><h3 id="CAP原理"><a href="#CAP原理" class="headerlink" title="CAP原理"></a>CAP原理</h3><p>在一个分布式系统中，当涉及读写操作时，只能保证一致性、可用性、分区容错性三者中的两个，另一个必须被牺牲</p>
<h4 id="C-Consistency-一致性"><a href="#C-Consistency-一致性" class="headerlink" title="C-Consistency 一致性"></a>C-Consistency 一致性</h4><p>对某个指定的客户端来说，读操作保证能够返回最新的写操作结果</p>
<p>这里并不是强调同一时刻拥有相同的数据，对于系统执行事务来说，在事务执行过程中，系统其实处于一个不一致的状态，不同的节点的数据并不完全一致</p>
<p>一致性强调客户端读操作能获取最新的写操作的结果，是因为事务在执行过程中，客户端是无法读取到未提交的数据的，只有等到事务提交后，客户端才能读到事务写入的数据，而如果事务失败则会进行回滚，客户端也不会读取到事务中间写入的数据</p>
<h4 id="A-Availability-可用性"><a href="#A-Availability-可用性" class="headerlink" title="A-Availability 可用性"></a>A-Availability 可用性</h4><p>非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应）。</p>
<p>这里强调的是合理的响应，不能超时，不能出错。注意并没有说“正确”的结果，例如，应该返回 100 但实际上返回了 90，肯定是不正确的结果，但可以是一个合理的结果。</p>
<h4 id="P-Partition-Tolerance-分区容忍性"><a href="#P-Partition-Tolerance-分区容忍性" class="headerlink" title="P-Partition Tolerance 分区容忍性"></a>P-Partition Tolerance 分区容忍性</h4><p>当出现<strong>网络分区</strong>后，系统能够继续“履行职责”。</p>
<p>这里<strong>网络分区</strong>是指： 一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障（节点间网络连接断开、节点宕机），使得有些节点之间不连通了，整个网络就分成了几块区域，数据就散布在了这些不连通的区域中。</p>
<h4 id="CAP-的选择"><a href="#CAP-的选择" class="headerlink" title="CAP 的选择"></a>CAP 的选择</h4><p>虽然 CAP 理论定义是三个要素中只能取两个，但放到分布式环境下来思考，我们会发现必须选择 P（分区容忍）要素，因为网络本身无法做到 100% 可靠，有可能出故障，所以分区是一个必然的现象</p>
<p>为什么必须要选择P:</p>
<p>如果我们选择了 CA（一致性 + 可用性） 而放弃了 P（分区容忍性），那么当发生分区现象时，为了保证 C（一致性），系统需要禁止写入，当有写入请求时，系统返回 error（例如，当前系统不允许写入），这又和 A(可用性) 冲突了，因为 A（可用性）要求返回 no error 和 no timeout。</p>
<p>因此，分布式系统理论上不可能选择 CA （一致性 + 可用性）架构，<strong>只能选择 CP（一致性 + 分区容忍性） 或者 AP （可用性 + 分区容忍性）架构，在一致性和可用性做折中选择</strong>。</p>
<p>针对这两种选择再来看一下：</p>
<p><strong>1、CP - Consistency + Partition Tolerance （一致性 + 分区容忍性）</strong></p>
<p><img src="cap1.png" alt="cap1"></p>
<p>如上图所示，因为Node1节点和Node2节点连接中断导致分区现象，Node1节点的数据已经更新到y，但是Node1 和 Node2 之间的复制通道中断，数据 y 无法同步到 Node2，Node2 节点上的数据还是旧数据x。</p>
<p>这时客户端C 访问 Node2 时，Node2 需要返回 Error，提示客户端 “系统现在发生了错误”，这种处理方式违背了可用性（Availability）的要求，因此 CAP 三者只能满足 CP。</p>
<p><strong>2、AP - Availability + Partition Tolerance （可用性 + 分区容忍性）</strong></p>
<p><img src="cap2.png" alt="cap2"></p>
<p> 同样是Node2 节点上的数据还是旧数据x，这时客户端C 访问 Node2 时，Node2 将当前自己拥有的数据 x 返回给客户端 了，而实际上当前最新的数据已经是 y 了，这就不满足一致性（Consistency）的要求了，因此 CAP 三者只能满足 AP。</p>
<p><strong>注意</strong>：这里 Node2 节点返回 x，虽然不是一个“正确”的结果，但是一个“合理”的结果，因为 x 是旧的数据，并不是一个错乱的值，只是不是最新的数据。</p>
<p><strong>值得补充的是：</strong>CAP理论告诉我们<strong>分布式系统只能选择AP或者CP</strong>，但实际上并不是说整个系统只能选择AP或者CP，在 CAP 理论落地实践时，我们需要将系统内的数据按照不同的应用场景和要求进行分类，每类数据选择不同的策略（CP 还是 AP），而不是直接限定整个系统所有数据都是同一策略。</p>
<p> <strong>另外，只能选择CP或者AP是指系统发生分区现象时无法同时保证C（一致性）和A（可用性），但不是意味着什么都不做，当分区故障解决后，系统还是要保持保证CA。也就是说选了AP不意味着放弃了C，选了CP不意味着放弃了A</strong></p>
<h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p><img src="base.png" alt="base"></p>
<p>BASE 是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency），是基于CAP定理演化而来，是对CAP中一致性和可用性权衡的结果；核心思想是即使无法做到强一致性（CAP 的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性。</p>
<h4 id="BA-Basically-Available基本可用"><a href="#BA-Basically-Available基本可用" class="headerlink" title="BA-Basically Available基本可用"></a>BA-Basically Available基本可用</h4><blockquote>
<p>分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</p>
</blockquote>
<p>这里的关键词是“<strong>部分</strong>”和“<strong>核心</strong>”，实际实践上，哪些是核心需要根据具体业务来权衡。例如登录功能相对注册功能更加核心，注册不了最多影响流失一部分用户，如果用户已经注册但无法登录，那就意味用户无法使用系统，造成的影响范围更大。</p>
<h4 id="S-Soft-State-软状态"><a href="#S-Soft-State-软状态" class="headerlink" title="S-Soft State 软状态"></a>S-Soft State 软状态</h4><p>允许系统存在中间状态，而该中间状态不会影响系统整体可用性。这里的中间状态就是 CAP 理论中的数据不一致。</p>
<h4 id="E-Eventual-Consistency-最终一致性"><a href="#E-Eventual-Consistency-最终一致性" class="headerlink" title="E-Eventual Consistency 最终一致性"></a>E-Eventual Consistency 最终一致性</h4><blockquote>
<p>系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。</p>
</blockquote>
<p>这里的关键词是“一定时间” 和 “最终”，“<strong>一定时间</strong>”和数据的特性是强关联的，不同业务不同数据能够容忍的不一致时间是不同的。例如支付类业务是要求秒级别内达到一致，因为用户时时关注；用户发的最新微博，可以容忍30分钟内达到一致的状态，因为用户短时间看不到明星发的微博是无感知的。而“<strong>最终</strong>”的含义就是不管多长时间，最终还是要达到一致性的状态。</p>
<p><strong>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充：</strong></p>
<ul>
<li><p><strong>CP 理论是忽略延时的，而实际应用中延时是无法避免的。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这一点就意味着完美的 CP 场景是不存在的，即使是几毫秒的数据复制延迟，在这几毫秒时间间隔内，系统是不符合 CP 要求的。因此 CAP 中的 CP 方案，实际上也是实现了最终一致性，只是“一定时间”是指几毫秒而已。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>AP 方案中牺牲一致性只是指发生分区故障期间，而不是永远放弃一致性。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这一点其实就是 BASE 理论延伸的地方，分区期间牺牲一致性，但分区故障恢复后，系统应该达到最终一致性。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="刚柔事务"><a href="#刚柔事务" class="headerlink" title="刚柔事务"></a>刚柔事务</h3><p>何谓刚柔事务？刚性事务它的事务是原子的，要么都成功要么都失败，也就是需要保障ACID理论，而柔性事务只需要保障数据最终一致即可，需要遵循BASE理论。</p>
<ul>
<li>刚性事务满足ACID理论</li>
<li>柔性事务满足BASE理论（基本可用，最终一致）</li>
</ul>
<p>基于BASE理论的设计思想，柔性事务下，在不影响系统整体可用性的情况下(Basically Available 基本可用)，允许系统存在数据不一致的中间状态(Soft State 软状态)，在经过数据同步的延时之后，最终数据能够达到一致。<strong>并不是完全放弃了ACID，而是通过放宽一致性要求，借助本地事务来实现最终分布式事务一致性的同时也保证系统的吞吐</strong>。</p>
<h2 id="常用事务解决方案模型"><a href="#常用事务解决方案模型" class="headerlink" title="常用事务解决方案模型"></a>常用事务解决方案模型</h2><p>分布式事务解决方案几乎都是柔性事务，分布式事务的实现有许多种，其中较经典是由Tuxedo提出的XA分布式事务协议，XA协议包含二阶段提交（2PC）和三阶段提交（3PC）两种实现。</p>
<p>其他还有 TCC、MQ 等最终一致性解决方案，至于工作中用哪种方案，需要根据业务场景选取，<code>2PC/3PC、TCC</code>数据强一致性高，而MQ是最终数据一致。</p>
<h3 id="DTP模型"><a href="#DTP模型" class="headerlink" title="DTP模型"></a>DTP模型</h3><p> X&#x2F;Open DTP(X&#x2F;Open Distributed Transaction Processing Reference Model) 是X&#x2F;Open 这个组织定义的一套分布式事务的标准，也就是了定义了规范和API接口，由厂商进行具体的实现</p>
<p><strong>X&#x2F;Open DTP中的角色</strong></p>
<p><img src="sw.webp" alt="sw"></p>
<p>**AP(Application Program)**：应用程序，主要是定义事务边界以及那些组成事务的特定于应用程序的操作。</p>
<p>**RM(Resouces Manager)**：资源管理器，管理一些共享资源的自治域，如提供对诸如数据库之类的共享资源的访问。譬如：数据库、文件系统等，并且提供了这些资源的访问方式。</p>
<p>**TM(Transaction Manager)**：事务管理器，管理全局事务，协调事务的提交或者回滚，并协调故障恢复。</p>
<p>DTP模型里面定义了XA协议接口，TM 和 RM 通过XA接口进行双向通信</p>
<h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><blockquote>
<p><code>2PC</code>、<code>3PC</code>，都是基于 <code>XA</code> 协议的</p>
</blockquote>
<h4 id="方案简介"><a href="#方案简介" class="headerlink" title="方案简介"></a>方案简介</h4><p>二阶段提交协议（Two-phase Commit，即2PC）是常用的分布式事务解决方案，即将事务的提交过程分为两个阶段来进行处理：<strong>准备阶段和提交阶段。事务的发起者称协调者，事务的执行者称参与者</strong>。</p>
<p>在分布式系统里，每个节点都可以知晓自己操作的成功或者失败，却无法知道其他节点操作的成功或失败。当一个事务跨多个节点时，为了保持事务的原子性与一致性，而引入一个协调者来统一掌控所有参与者的操作结果，并指示它们是否要把操作结果进行真正的提交或者回滚（rollback）。</p>
<p>二阶段提交的算法思路可以概括为：<strong>参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作</strong>。</p>
<p>核心思想就是对每一个事务都采用先尝试后提交的处理方式，处理后所有的读操作都要能获得最新的数据，因此也可以将二阶段提交看作是一个强一致性算法。</p>
<h4 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h4><blockquote>
<p>简单一点理解，可以把协调者节点比喻为带头大哥，参与者理解比喻为跟班小弟，带头大哥统一协调跟班小弟的任务执行。</p>
</blockquote>
<h5 id="阶段1：准备阶段"><a href="#阶段1：准备阶段" class="headerlink" title="阶段1：准备阶段"></a>阶段1：准备阶段</h5><blockquote>
<ul>
<li>1、协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待所有参与者答复。</li>
<li>2、各参与者执行事务操作，将undo和redo信息记入事务日志中（但不提交事务）。</li>
<li>3、如参与者执行成功，给协调者反馈yes，即可以提交；如执行失败，给协调者反馈no，即不可提交。</li>
</ul>
</blockquote>
<h5 id="阶段2：提交阶段"><a href="#阶段2：提交阶段" class="headerlink" title="阶段2：提交阶段"></a>阶段2：提交阶段</h5><p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(rollback)消息；否则，发送提交(commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源) </p>
<p>接下来分两种情况分别讨论提交阶段的过程。</p>
<p><strong>情况1，当所有参与者均反馈yes，提交事务</strong>：</p>
<p><img src="transaction09.png" alt="transaction09"></p>
<ul>
<li>1、协调者向所有参与者发出正式提交事务的请求（即commit请求）。</li>
<li>2、参与者执行commit请求，并释放整个事务期间占用的资源。</li>
<li>3、各参与者向协调者反馈ack(应答)完成的消息。</li>
<li>4、协调者收到所有参与者反馈的ack消息后，即完成事务提交</li>
</ul>
<p><strong>情况2，当任何阶段1一个参与者反馈no，中断事务</strong>：</p>
<p><img src="transaction10.png" alt="transaction10"></p>
<blockquote>
<ul>
<li>1、协调者向所有参与者发出回滚请求（即rollback请求）。</li>
<li>2、参与者使用阶段1中的undo信息执行回滚操作，并释放整个事务期间占用的资源。</li>
<li>3、各参与者向协调者反馈ack完成的消息。</li>
<li>4、协调者收到所有参与者反馈的ack消息后，即完成事务中断。</li>
</ul>
</blockquote>
<h4 id="方案总结"><a href="#方案总结" class="headerlink" title="方案总结"></a>方案总结</h4><p>2PC是一个强一致性的同步阻塞协议，事务执⾏过程中需要将所需资源全部锁定，也就是俗称的 <code>刚性事务</code></p>
<p>2PC方案实现起来简单，实际项目中使用比较少，主要因为以下问题：</p>
<ul>
<li>性能问题 所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。</li>
<li>可靠性问题 如果协调者存在单点故障问题，如果协调者出现故障，参与者将一直处于锁定状态。</li>
<li>数据一致性问题 在阶段2中，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。</li>
</ul>
<h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><h4 id="方案简介-1"><a href="#方案简介-1" class="headerlink" title="方案简介"></a>方案简介</h4><p>三阶段提交协议，是二阶段提交协议的改进版本，与二阶段提交不同的是，引入超时机制。同时在协调者和参与者中都引入超时机制（<code>2PC</code> 中只有协调者有超时机制）。</p>
<p>三阶段提交将二阶段的准备阶段拆分为2个阶段，插入了一个preCommit阶段，使得原先在二阶段提交中，参与者在准备之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。</p>
<h4 id="处理流程-1"><a href="#处理流程-1" class="headerlink" title="处理流程"></a>处理流程</h4><h5 id="阶段1：canCommit"><a href="#阶段1：canCommit" class="headerlink" title="阶段1：canCommit"></a>阶段1：canCommit</h5><p>协调者向参与者发送canCommit请求，参与者如果可以提交就返回yes响应(参与者不执行事务操作)，否则返回no响应：</p>
<blockquote>
<ul>
<li>1、协调者向所有参与者发出包含事务内容的canCommit请求，询问是否可以提交事务，并等待所有参与者答复。</li>
<li>2、参与者收到canCommit请求后，如果认为可以执行事务操作，则反馈yes并进入预备状态，否则反馈no。</li>
</ul>
</blockquote>
<h5 id="阶段2：preCommit"><a href="#阶段2：preCommit" class="headerlink" title="阶段2：preCommit"></a>阶段2：preCommit</h5><p>协调者根据阶段1 canCommit参与者的反应情况来决定是否可以基于事务的preCommit操作。根据响应情况，有以下两种可能。</p>
<p><strong>情况1，阶段1所有参与者均反馈yes，参与者预执行事务：</strong></p>
<p><img src="transaction11.png" alt="transaction11"></p>
<ul>
<li>1、协调者向所有参与者发出preCommit请求，进入准备阶段。</li>
<li>2、参与者收到preCommit请求后，执行事务操作，将undo和redo信息记入事务日志中（但不提交事务）。</li>
<li>3、各参与者向协调者反馈ack响应或no响应，并等待最终指令</li>
</ul>
<p><strong>情况2，阶段1任何一个参与者反馈no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务:</strong></p>
<p><img src="transaction12.png" alt="transaction12"></p>
<ul>
<li>1、协调者向所有参与者发出abort请求。</li>
<li>2、无论收到协调者发出的abort请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。</li>
</ul>
<h5 id="阶段3：do-Commit"><a href="#阶段3：do-Commit" class="headerlink" title="阶段3：do Commit"></a>阶段3：do Commit</h5><blockquote>
<p>该阶段进行真正的事务提交，也可以分为以下两种情况：</p>
</blockquote>
<p><strong>情况1：阶段2所有参与者均反馈ack响应，执行真正的事务提交：</strong></p>
<p><img src="transaction13.png" alt="transaction13"></p>
<ul>
<li>1、如果协调者处于工作状态，则向所有参与者发出do Commit请求。</li>
<li>2、参与者收到do Commit请求后，会正式执行事务提交，并释放整个事务期间占用的资源。</li>
<li>3、各参与者向协调者反馈ack完成的消息。</li>
<li>4、协调者收到所有参与者反馈的ack消息后，即完成事务提交</li>
</ul>
<p><strong>阶段2任何一个参与者反馈no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务：</strong></p>
<p><img src="transaction14.png" alt="transaction14"></p>
<ul>
<li>1、如果协调者处于工作状态，向所有参与者发出abort请求。</li>
<li>2、参与者使用阶段1中的undo信息执行回滚操作，并释放整个事务期间占用的资源。</li>
<li>3、各参与者向协调者反馈ack完成的消息。</li>
<li>4、协调者收到所有参与者反馈的ack消息后，即完成事务中断</li>
</ul>
<p><strong>注意</strong>：进入阶段3后，如果协调者出现问题，或者协调者与参与者网络出现问题，都会导致参与者无法接收到协调者发出的do Commit请求或rollback请求。此时，参与者都会在等待超时之后，继续执行事务提交。</p>
<p>阶段三 只允许成功不允许失败，如果服务器宕机或者停电，因为记录的阶段二的数据，重启服务后在提交事务，所以，到了阶段三，失败了也不进行回滚，<strong>只允许成功</strong>。</p>
<h4 id="方案总结-1"><a href="#方案总结-1" class="headerlink" title="方案总结"></a>方案总结</h4><p>优点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相比二阶段提交，三阶段提交降低了阻塞范围，在等待超时后协调者或参与者会中断事务。避免了协调者单点问题，阶段3中协调者出现问题时，参与者会继续提交事务。</span><br></pre></td></tr></table></figure>

<p>缺点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据不一致问题依然存在，当在参与者收到preCommit请求后等待do commit指令时，此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。</span><br></pre></td></tr></table></figure>

<h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><h4 id="方案简介-2"><a href="#方案简介-2" class="headerlink" title="方案简介"></a>方案简介</h4><p><strong>TCC（Try-Confirm-Cancel）的概念，最早是由Pat Helland于2007年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。</strong></p>
<p><strong>TCC是服务化的二阶段编程模型，其Try、Confirm、Cancel 3个方法均由业务编码实现，基本类似两阶段提交</strong></p>
<ul>
<li>Try操作作为一阶段，负责资源的检查和预留。</li>
<li>Confirm操作作为二阶段提交操作，执行真正的业务。</li>
<li>Cancel是预留资源的取消。</li>
</ul>
<p>TCC事务的Try、Confirm、Cancel可以理解为SQL事务中的Lock、Commit、Rollback。</p>
<p><code>TCC</code> 为在业务层编写代码实现的两阶段提交。<code>TCC</code> 分别指 <code>Try</code>、<code>Confirm</code>、<code>Cancel</code> ，一个业务操作要对应的写这三个方法。</p>
<h4 id="处理流程-2"><a href="#处理流程-2" class="headerlink" title="处理流程"></a>处理流程</h4><h5 id="阶段1：Try-阶段"><a href="#阶段1：Try-阶段" class="headerlink" title="阶段1：Try 阶段"></a>阶段1：Try 阶段</h5><p>从执行阶段来看，与传统事务机制中业务逻辑相同。但从业务角度来看，却不一样。TCC机制中的Try仅是一个初步操作，它和后续的确认一起才能真正构成一个完整的业务逻辑，这个阶段主要完成：</p>
<ul>
<li>完成所有业务检查( 一致性 )</li>
<li>预留必须业务资源( 准隔离性 )</li>
<li>Try 尝试执行业务 TCC事务机制以初步操作（Try）为中心的，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。因此，Try阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其执行结果撤销</li>
</ul>
<p><img src="transaction15.png" alt="transaction15"></p>
<h5 id="阶段2：Confirm-x2F-Cancel-阶段"><a href="#阶段2：Confirm-x2F-Cancel-阶段" class="headerlink" title="阶段2：Confirm &#x2F; Cancel 阶段"></a>阶段2：Confirm &#x2F; Cancel 阶段</h5><blockquote>
<p>根据Try阶段服务是否全部正常执行，继续执行确认操作（Confirm）或取消操作（Cancel）。 Confirm和Cancel操作满足幂等性，如果Confirm或Cancel操作执行失败，将会不断重试直到执行完成。</p>
</blockquote>
<h6 id="Confirm：确认"><a href="#Confirm：确认" class="headerlink" title="Confirm：确认"></a>Confirm：确认</h6><blockquote>
<p><strong>当Try阶段服务全部正常执行， 执行确认业务逻辑操作</strong></p>
</blockquote>
<p><img src="transaction16.png" alt="transaction16"></p>
<blockquote>
<p>这里使用的资源一定是Try阶段预留的业务资源。在TCC事务机制中认为，如果在Try阶段能正常的预留资源，那Confirm一定能完整正确的提交。Confirm阶段也可以看成是对Try阶段的一个补充，Try+Confirm一起组成了一个完整的业务逻辑。</p>
</blockquote>
<h6 id="Cancel：取消"><a href="#Cancel：取消" class="headerlink" title="Cancel：取消"></a>Cancel：取消</h6><blockquote>
<p><strong>当Try阶段存在服务执行失败， 进入Cancel阶段</strong></p>
</blockquote>
<p><img src="transaction17.png" alt="transaction17"></p>
<blockquote>
<p>Cancel取消执行，释放Try阶段预留的业务资源，上面的例子中，Cancel操作会把冻结的库存释放，并更新订单状态为取消。</p>
</blockquote>
<h4 id="方案总结-2"><a href="#方案总结-2" class="headerlink" title="方案总结"></a>方案总结</h4><p>TCC事务机制相对于传统事务机制（X&#x2F;Open XA），TCC事务机制相比于上面介绍的XA事务机制，有以下优点:</p>
<p>-<br>  性能提升 具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。</p>
<ul>
<li>数据最终一致性 基于Confirm和Cancel的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。</li>
<li>可靠性 解决了XA协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。</li>
</ul>
<p>缺点：TCC的Try、Confirm和Cancel操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。</p>
<h3 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h3><h4 id="方案简介-3"><a href="#方案简介-3" class="headerlink" title="方案简介"></a>方案简介</h4><p>本地消息表的方案最初是由ebay提出，核心思路是将分布式事务拆分成本地事务进行处理。</p>
<p> 方案通过在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。</p>
<p> 这样设计可以避免”<strong>业务处理成功 + 事务消息发送失败</strong>“，或”<strong>业务处理失败 + 事务消息发送成功</strong>“的棘手情况出现，保证2个系统事务的数据一致性。</p>
<h4 id="处理流程-3"><a href="#处理流程-3" class="headerlink" title="处理流程"></a>处理流程</h4><p> 下面把分布式事务最先开始处理的事务方成为事务主动方，在事务主动方之后处理的业务内的其他事务成为事务被动方。</p>
<p> 为了方便理解，下面继续以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建2个步骤，库存服务和订单服务分别在不同的服务器节点上，其中库存服务是事务主动方，订单服务是事务被动方。</p>
<p>事务的主动方需要额外新建事务消息表，用于记录分布式事务的消息的发生、处理状态。</p>
<p><strong>整个业务处理流程如下：</strong></p>
<p><img src="transaction18.png" alt="transaction18"></p>
<blockquote>
<p><strong>步骤1 事务主动方处理本地事务。</strong> 事务主动方在本地事务中处理业务更新操作和写消息表操作。 上面例子中库存服务阶段在本地事务中完成扣减库存和写消息表(图中1、2)。</p>
<p><strong>步骤2 事务主动方通过消息中间件，通知事务被动方处理事务通知事务待消息</strong>。 消息中间件可以基于Kafka、RocketMQ消息队列，事务主动方法主动写消息到消息队列，事务消费方消费并处理消息队列中的消息。 上面例子中，库存服务把事务待处理消息写到消息中间件，订单服务消费消息中间件的消息，完成新增订单（图中3 - 5）。</p>
<p><strong>步骤3 事务被动方通过消息中间件，通知事务主动方事务已处理的消息。</strong> 上面例子中，订单服务把事务已处理消息写到消息中间件，库存服务消费中间件的消息，并将事务消息的状态更新为已完成(图中6 - 8)</p>
</blockquote>
<p> 为了数据的一致性，当处理错误需要重试，事务发送方和事务接收方相关业务处理需要支持幂等。具体保存一致性的容错处理如下：</p>
<blockquote>
<p>1、当步骤1处理出错，事务回滚，相当于什么都没发生。</p>
<p>2、当步骤2、步骤3处理出错，由于未处理的事务消息还是保存在事务发送方，事务发送方可以定时轮询为超时消息数据，再次发送的消息中间件进行处理。事务被动方消费事务消息重试处理。</p>
<p>3、如果是业务上的失败，事务被动方可以发消息给事务主动方进行回滚。</p>
<p>4、如果多个事务被动方已经消费消息，事务主动方需要回滚事务时需要通知事务被动方回滚</p>
</blockquote>
<h4 id="方案总结-3"><a href="#方案总结-3" class="headerlink" title="方案总结"></a>方案总结</h4><p>方案的优点如下：</p>
<ul>
<li>从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对MQ中间件特性的依赖。</li>
<li>方案轻量，容易实现。</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>与具体的业务场景绑定，耦合性强，不可共用。</li>
<li>消息数据与业务数据同库，占用业务系统资源。</li>
<li>业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限</li>
</ul>
<h3 id="MQ事务"><a href="#MQ事务" class="headerlink" title="MQ事务"></a>MQ事务</h3><p>MQ事务保证最终一致性。</p>
<h4 id="方案简介-4"><a href="#方案简介-4" class="headerlink" title="方案简介"></a>方案简介</h4><p>基于MQ的分布式事务方案其实是对本地消息表的封装，将本地消息表存于MQ 内部，其他方面的协议基本与本地消息表一致。</p>
<h4 id="处理流程-4"><a href="#处理流程-4" class="headerlink" title="处理流程"></a>处理流程</h4><p>下面主要基于RocketMQ4.3之后的版本介绍MQ的分布式事务方案。</p>
<p>在本地消息表方案中，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务，RocketMQ的事务消息相对于普通MQ，相对于提供了2PC的提交接口，方案如下：</p>
<h5 id="正常情况——事务主动方发消息"><a href="#正常情况——事务主动方发消息" class="headerlink" title="正常情况——事务主动方发消息"></a>正常情况——事务主动方发消息</h5><p>这种情况下，事务主动方服务正常，没有发生故障，发消息流程如下：</p>
<p><img src="transaction19.png" alt="transaction19"></p>
<p>1、发送方向 MQ服务端(MQ Server)发送half消息。</p>
<p>2、MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功。</p>
<p>3、发送方开始执行本地事务逻辑。</p>
<p>4、发送方根据本地事务执行结果向 MQ Server 提交二次确认（commit 或是 rollback）。</p>
<p>5、MQ Server 收到 commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 rollback 状态则删除半消息，订阅方将不会接受该消息。</p>
<h5 id="异常情况——事务主动方消息恢复"><a href="#异常情况——事务主动方消息恢复" class="headerlink" title="异常情况——事务主动方消息恢复"></a>异常情况——事务主动方消息恢复</h5><p>在断网或者应用重启等异常情况下，图中第4步提交的二次确认超时未到达 MQ Server，此时处理逻辑如下：</p>
<p><img src="transaction20.png" alt="transaction20"></p>
<p>5、MQ Server 对该消息发起消息回查。</p>
<p>6、发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</p>
<p>7、发送方根据检查得到的本地事务的最终状态再次提交二次确认</p>
<p>8、MQ Server基于commit &#x2F; rollback 对消息进行投递或者删除</p>
<p>介绍完RocketMQ的事务消息方案后，由于前面已经介绍过本地消息表方案，这里就简单介绍RocketMQ分布式事务：</p>
<p><img src="transaction21.png" alt="transaction21"></p>
<p>事务主动方基于MQ通信通知事务被动方处理事务，事务被动方基于MQ返回处理结果。 如果事务被动方消费消息异常，需要不断重试，业务处理逻辑需要保证幂等。 如果是事务被动方业务上的处理失败，可以通过MQ通知事务主动方进行补偿或者事务回滚。</p>
<h4 id="方案总结-4"><a href="#方案总结-4" class="headerlink" title="方案总结"></a>方案总结</h4><p>相比本地消息表方案，MQ事务方案优点是：</p>
<ul>
<li>消息数据独立存储 ，降低业务系统与消息系统之间的耦合。</li>
<li>吞吐量优于使用本地消息表方案。</li>
</ul>
<p>缺点是：</p>
<ul>
<li>一次消息发送需要两次网络请求(half消息 + commit&#x2F;rollback消息)</li>
<li>业务处理服务需要实现消息状态回查接口</li>
</ul>
<h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><p>Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。在 Seata 开源之前，Seata 对应的内部版本在阿里经济体内部一直扮演着分布式一致性中间件的角色，帮助经济体平稳的度过历年的双11，对各BU业务进行了有力的支撑。经过多年沉淀与积累，商业化产品先后在阿里云、金融云进行售卖。2019.1 为了打造更加完善的技术生态和普惠技术成果，Seata 正式宣布对外开源，开放以来，广受欢迎，不到一年已经成为最受欢迎的分布式事务解决方案。</p>
<h3 id="Seata术语"><a href="#Seata术语" class="headerlink" title="Seata术语"></a>Seata术语</h3><p><strong>TC (Transaction Coordinator) - 事务协调者</strong></p>
<p>维护全局和分支事务的状态，驱动全局事务提交或回滚。</p>
<p><strong>TM (Transaction Manager) - 事务管理器</strong></p>
<p>定义全局事务的范围：开始全局事务、提交或回滚全局事务。</p>
<p><strong>RM (Resource Manager) - 资源管理器</strong></p>
<p>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>
<p><img src="seta1.png" alt="seta1"></p>
<p>Seata  致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p>
<h3 id="Seata-AT模式"><a href="#Seata-AT模式" class="headerlink" title="Seata AT模式"></a>Seata AT模式</h3><p>AT模式最受欢迎，使用也非常简单，但它内在的原理不简单。</p>
<p>AT模式的相关资料请参考官方文档说明：<a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p>
<p>下图是AT模式的执行流程：</p>
<p><img src="1614217488699.png" alt="1614217488699"></p>
]]></content>
      <categories>
        <category>分布式事务</category>
      </categories>
      <tags>
        <tag>seata</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2022/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">线性结构分为两种数据存储方式，一种是顺序存储，一种链式存储</span><br></pre></td></tr></table></figure>

<h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><p><strong>API设计</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>SequenceList</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>SequenceList(int capacity)：创建容量为capacity的SequenceList对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public void clear()：空置对象<br>2.public boolean isEmpty()：判断线性表是否为空，是返回true，否返回false<br>3.public int length():获取线性表中元素的个数<br>4.public T get(int i):读取并返回线性表中的第i个元素的值<br>5.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。<br>6.public void insert(T t):向线性表中添加一个元素t<br>7.public T remove(int i):删除并返回线性表中第i个数据元素。<br>8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回1</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] eles：存储元素的数组<br>2.private int N:当前线性表的长度</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 顺序数据结果实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-12-18</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequenceList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> T[] eles;</span><br><span class="line">    <span class="comment">//当前线性表长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SequenceList</span><span class="params">(<span class="type">int</span> capcity)</span>&#123;</span><br><span class="line">        eles = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capcity];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空置对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断线性表是否为空，是返回true，否返回false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取线性表中元素的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取并返回线性表中的第i个元素的值</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;当前元素不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eles[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在线性表的第i个元素之前插入一个值为t的数据元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> i,T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;插入位置不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(N== eles.length)&#123;</span><br><span class="line">            resize(<span class="number">2</span>*N);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把i位置空出来，i位置及其后面元素一次后移一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N;index&gt;i;index--)&#123;</span><br><span class="line">            eles[index] = eles[index-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把i位置赋值</span></span><br><span class="line">        eles[i] = t;</span><br><span class="line">        <span class="comment">//数量加1</span></span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向线性表中添加一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N== eles.length)&#123;</span><br><span class="line">            resize(<span class="number">2</span>*N);</span><br><span class="line">        &#125;</span><br><span class="line">        eles[N++] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除并返回线性表中第i个数据元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">remove</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;插入位置不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录i位置元素</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> eles[i];</span><br><span class="line">        <span class="comment">//i位置后面的元素都向前一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> index=i;index&lt;N-<span class="number">1</span>;index++)&#123;</span><br><span class="line">            eles[index] = eles[index+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前元素数量-1</span></span><br><span class="line">        N--;</span><br><span class="line">        <span class="comment">//当元素已经不足数组大小的1/4,则重置数组的大小</span></span><br><span class="line">        <span class="keyword">if</span> (N&gt;<span class="number">0</span>&amp;&amp;N&lt; eles.length/<span class="number">4</span>)&#123;</span><br><span class="line">            resize(eles.length/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;查找元素不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eles[i].equals(t))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> cur;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SIterator</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.cur=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cur&lt;N;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> eles[cur++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现扩容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newSize)</span>&#123;</span><br><span class="line">        T[] temp = eles;</span><br><span class="line">        eles = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[newSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            eles[i]=temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取数组长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> eles.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h5 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h5><p>单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据，</p>
<p>指针域用来指向其后继结点。链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。</p>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>LinkList</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>LinkList()：创建LinkList对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public void clear()：空置链表 <br>2.public boolean isEmpty()：判断线性表是否为空，是返回true，否返回false<br>3.public int length():获取线性表中元素的个数<br>4.public T get(int i):读取并返回线性表中的第i个元素的值<br>5.public void insert(T t)：往线性表中添加一个元素；<br>6.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。<br>7.public T remove(int i):删除并返回线性表中第i个数据元素。<br>8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1</td>
</tr>
<tr>
<td>成员内部类</td>
<td>private class Node:结点类</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node head:记录首结点<br>2.private int N:记录链表的长度</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.dc.pr.PRError;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 单向链表API实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-12-29</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkList</span><span class="params">()</span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空置链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">        head.next=<span class="literal">null</span>;</span><br><span class="line">        head.item=<span class="literal">null</span>;</span><br><span class="line">        N=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断线性表是否为空，是返回true，否返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N==<span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取线性表中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;位置不合法！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往线性表中添加一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//找到最后一个结点</span></span><br><span class="line">        <span class="keyword">while</span> (n.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建新结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t,<span class="literal">null</span>);</span><br><span class="line">        n.next = newNode;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在线性表的第i个元素之前插入一个值为t的数据元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> i,T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;位置不合法！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到i结点的上一个结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">//创建新结点并把next结点赋值为i结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t,temp);</span><br><span class="line">        <span class="comment">//将上个结点的next指向新结点</span></span><br><span class="line">        node.next = newNode;</span><br><span class="line">        <span class="comment">//数量加1</span></span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除并返回线性表中第i个数据元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">remove</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;位置不合法！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到i结点的上一个结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> node.next;</span><br><span class="line">        node.next=cur.next;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> cur.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; node.next!=<span class="literal">null</span>; i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="keyword">if</span> (t.equals(cur.item))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Node node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LIterator</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.node=head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node.next!=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            <span class="keyword">return</span> node.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结点类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T item;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T item, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = item;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><p>双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用</p>
<p>来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存</p>
<p>储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。</p>
<p><strong>结点API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Node</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(T t,Node pre,Node next)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>T item:存储数据<br>Node next：指向下一个结点<br>Node pre:指向上一个结点</td>
</tr>
</tbody></table>
<p><strong>双向链表API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>TwoWayLinkList</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>TwoWayLinkList()：创建TwoWayLinkList对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public void clear()：空置链表 <br>2.public boolean isEmpty()：判断线性表是否为空，是返回true，否返回false<br>3.public int length():获取线性表中元素的个数<br>4.public T get(int i):读取并返回线性表中的第i个元素的值<br>5.public void insert(T t)：往线性表中添加一个元素；<br>6.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。<br>7.public T remove(int i):删除并返回线性表中第i个数据元素。<br>8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1<br>9.public T getFirst():获取第一个元素<br>10.public T getLast():获取最后一个元素</td>
</tr>
<tr>
<td>成员内部类</td>
<td>private class Node:结点类</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node head:记录首结点<br>2.private Node last:记录尾结点<br>3.private int N:记录链表的长度</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 双向链表API实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-12-30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoWayLinkList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录首结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录尾结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录链表的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TwoWayLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空置链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">        head.next = last;</span><br><span class="line">        head.pre = <span class="literal">null</span>;</span><br><span class="line">        head.item = <span class="literal">null</span>;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断线性表是否为空，是返回true，否返回false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取线性表中元素的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取并返回线性表中的第i个元素的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;查找位置不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往线性表中添加一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (last==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果当前链表为空</span></span><br><span class="line">            <span class="comment">//直接将尾结点赋值，并将head和last连接</span></span><br><span class="line">            last = <span class="keyword">new</span> <span class="title class_">Node</span>(t,head,<span class="literal">null</span>);</span><br><span class="line">            head.next = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果链表尾结点存在值，创建新的结点连接到原尾结点，并将新结点赋值给尾结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">oldLastNode</span> <span class="operator">=</span> last;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t,oldLastNode,<span class="literal">null</span>);</span><br><span class="line">            oldLastNode.next = node;</span><br><span class="line">            last = node;</span><br><span class="line">        &#125;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在线性表的第i个元素之前插入一个值为t的数据元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> i,T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;查找位置不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先找到i结点前置结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到i结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="comment">//创建新结点，前置结点为原前置结点，后置结点为原i位置结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t,pre,cur);</span><br><span class="line">        <span class="comment">//原前置结点next指向新结点</span></span><br><span class="line">        pre.next = n;</span><br><span class="line">        <span class="comment">//原i结点前置指向n</span></span><br><span class="line">        cur.pre = n;</span><br><span class="line">        <span class="comment">//数量加1</span></span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除并返回线性表中第i个数据元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">remove</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;查找位置不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先找到i结点前置结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到i结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="comment">//找到i结点的后置结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        <span class="comment">//将前置结点和后置结点连接</span></span><br><span class="line">        pre.next = next;</span><br><span class="line">        next.pre = pre;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> cur.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; node.next!=<span class="literal">null</span> ; i++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            <span class="keyword">if</span> (node.item.equals(t))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取第一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取最后一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n.next!=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">            <span class="keyword">return</span> n.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 存储数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> T item;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 指向下一个结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Node pre;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 指向上一个结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T t,Node pre,Node next)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.item = t;</span><br><span class="line">            <span class="built_in">this</span>.pre = pre;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h5><p>使用递归方式实现链表的反转</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (N==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="comment">//当前列表为空，不需要反转</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       reverse(head.next);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Node <span class="title function_">reverse</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node.next==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="comment">//说明已经到最后一个结点，将头结点指向当前结点</span></span><br><span class="line">           head.next = node;</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//递归调用2反转方法</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> reverse(node.next);</span><br><span class="line">       <span class="comment">//将返回结点后置结点指向当前结点</span></span><br><span class="line">       pre.next = node;</span><br><span class="line">       <span class="comment">//当前结点后置结点置为null</span></span><br><span class="line">       node.next = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h5><p>快慢指针指的是定义两个指针，这两个指针的移动速度一块一慢，以此来制造出自己想要的差值，这个差值可以然</p>
<p>我们找到链表上相应的结点。一般情况下，快指针的移动步长为慢指针的两倍</p>
<p><strong>中间值问题</strong></p>
<p>定义一个链表，想获取中间值</p>
<p>使用快慢指针解决，定义两个指针，一个指针的步长为另一个指针的步长的二倍，当快指针到达尾部，慢指针停在的位置即为中间位置</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getMid</span><span class="params">(Node&lt;String&gt; first)</span>&#123;</span><br><span class="line">       Node&lt;String&gt; slow = first;</span><br><span class="line">       Node&lt;String&gt; fast = first;</span><br><span class="line">       <span class="keyword">while</span> (slow.next!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">           fast = fast.next.next;</span><br><span class="line">           slow = slow.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> slow.item;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>单向链表是否有环问题</strong></p>
<p>使用快慢指针，如果一个环状链表，两个速度有差异的指针一定会相遇</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCircle</span><span class="params">(Node&lt;String&gt; first)</span>&#123;</span><br><span class="line">    Node&lt;String&gt; slow = first;</span><br><span class="line">    Node&lt;String&gt; fast = first;</span><br><span class="line">    <span class="keyword">while</span> (slow.next!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        fast = first.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast.equals(slow))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>有环链表入口问题</strong></p>
<p>当快慢指针相遇时，我们可以判断到链表中有环，这时重新设定一个新指针指向链表的起点，且步长与慢指针一样</p>
<p>为1，则慢指针与“新”指针相遇的地方就是环的入口</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Node&lt;String&gt; <span class="title function_">getEntrance</span><span class="params">(Node&lt;String&gt; first)</span> &#123;</span><br><span class="line">    Node&lt;String&gt; slow = first;</span><br><span class="line">    Node&lt;String&gt; fast = first;</span><br><span class="line">    Node&lt;String&gt; temp = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">null</span> &amp;&amp; fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast.equals(slow))&#123;</span><br><span class="line">            temp = first;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp!=<span class="literal">null</span>)&#123;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">            <span class="keyword">if</span> (temp.equals(slow))&#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h5><p>循环链表，顾名思义，链表整体要形成一个圆环状。在单向链表中，最后一个节点的指针为null，不指向任何结</p>
<p>点，因为没有下一个元素了。要实现循环链表，我们只需要让单向链表的最后一个节点的指针指向头结点即可。</p>
<h5 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h5><p><strong>问题描述：</strong></p>
<p>传说有这样一个故事，在罗马人占领乔塔帕特后，39 个犹太人与约瑟夫及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，第一个人从1开始报数，依次后，如果有人报数到3，那么这个人就必须自杀，然后再由他的下一个人重新从1开始报数，直到所有人都自杀身亡为止。然而约瑟夫和他的朋友并不想遵从。于是，约瑟夫要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，从而逃过了这场死亡游戏 。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 约瑟夫经典问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-02</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Joseph</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//构建循环链表</span></span><br><span class="line">        Node&lt;Integer&gt; first = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//记录前一个结点</span></span><br><span class="line">        Node&lt;Integer&gt; pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">41</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//第一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">1</span>)&#123;</span><br><span class="line">                first = <span class="keyword">new</span> <span class="title class_">Node</span>(i,<span class="literal">null</span>);</span><br><span class="line">                pre = first;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Node&lt;Integer&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(i,<span class="literal">null</span>);</span><br><span class="line">            pre.next = node;</span><br><span class="line">            pre = node;</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">41</span>)&#123;</span><br><span class="line">                <span class="comment">//让最后一个结点指向第一个结点</span></span><br><span class="line">                pre.next = first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用count记录当前的报数值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历链表，没循环一次count++</span></span><br><span class="line">        Node&lt;Integer&gt; n = first;</span><br><span class="line">        Node&lt;Integer&gt; before = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (n!=n.next)&#123;</span><br><span class="line">            <span class="comment">//判断count的值，如果是3，则从链表中删除这个结点并打印，把count重置为0</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="comment">//删除当前结点</span></span><br><span class="line">                before.next = n.next;</span><br><span class="line">                System.out.println(n.item);</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                n = n.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                before = n;</span><br><span class="line">                n = n.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(n.item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈是一种基于先进后出(FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出</p>
<p>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一</p>
<p>个数据被第一个读出来）。</p>
<p><strong>链表实现栈API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>StackLink</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>StackLink()：创建StackLink对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false<br>2.public int size():获取栈中元素的个数<br>3.public T pop():弹出栈顶元素<br>4.public void push(T t)：向栈中压入元素t</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node head:记录首结点<br>2.private int N:记录链表的长度</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 栈API实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackLink</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录首结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前栈的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StackLink</span><span class="params">()</span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断栈是否为空，是返回true，否返回false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取栈中元素的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出栈顶元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">oldNode</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">if</span> (oldNode==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = head.next.next;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> oldNode.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向栈中压入元素t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">oldNode</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t,oldNode);</span><br><span class="line">        head.next = node;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StackIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">StackIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n.next!=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> n.next;</span><br><span class="line">            n = n.next;</span><br><span class="line">            <span class="keyword">return</span> node.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> T item;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T item, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = item;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组实现栈API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>StackArray</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>StackArray()：创建StackArray对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false<br>2.public int size():获取栈中元素的个数<br>3.public T pop():弹出栈顶元素<br>4.public void push(T t)：向栈中压入元素t</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] data:存储数据的顺序表<br>2.private int N:记录链表的长度</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 栈结构API数组实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackArray</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T[] data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StackArray</span><span class="params">(<span class="type">int</span> capcity)</span>&#123;</span><br><span class="line">        data = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capcity];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N&gt;=data.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈已满&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[N++] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> data[N-<span class="number">1</span>];</span><br><span class="line">        data[N-<span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StackIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> cur;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cur&lt;N;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data[cur++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两栈共享</strong></p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p><strong>括号匹配问题</strong></p>
<p><strong>问题描述：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">给定一个字符串，里边可能包含&quot;()&quot;小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。</span><br><span class="line">例如：</span><br><span class="line"><span class="code">    &quot;(上海)(长安)&quot;：正确匹配</span></span><br><span class="line"><span class="code">    &quot;上海((长安))&quot;：正确匹配</span></span><br><span class="line"><span class="code">    &quot;上海(长安(北京)(深圳)南京)&quot;:正确匹配</span></span><br><span class="line"><span class="code">    &quot;上海(长安))&quot;：错误匹配</span></span><br><span class="line"><span class="code">    &quot;((上海)长安&quot;：错误匹配</span></span><br></pre></td></tr></table></figure>

<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断str中的括号是否匹配</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> str 括号组成的字符串</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 如果匹配，返回true，如果不匹配，返回false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String str)</span>&#123;</span><br><span class="line">      StackLink&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">StackLink</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> String.valueOf(str.charAt(i));</span><br><span class="line">          <span class="keyword">if</span> (<span class="string">&quot;(&quot;</span>.equals(c))&#123;</span><br><span class="line">              stack.push(c);</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;)&quot;</span>.equals(c))&#123;</span><br><span class="line">              <span class="type">String</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">              <span class="keyword">if</span> (pop==<span class="literal">null</span>||<span class="string">&quot;&quot;</span>.equals(pop))&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (stack.size()==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>逆波兰表达式求值问题</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> notaion 逆波兰表达式的数组表示方式</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 逆波兰表达式的计算结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">caculate</span><span class="params">(String[] notaion)</span>&#123;</span><br><span class="line">       StackLink&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">StackLink</span>&lt;&gt;();</span><br><span class="line">       Integer o1;</span><br><span class="line">       Integer o2;</span><br><span class="line">       Integer result;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; notaion.length; i++) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">curr</span> <span class="operator">=</span> notaion[i];</span><br><span class="line">           <span class="keyword">switch</span> (curr)&#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                   o1 = stack.pop();</span><br><span class="line">                   o2 = stack.pop();</span><br><span class="line">                   result = o1 + o2;</span><br><span class="line">                   stack.push(result);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                   o1 = stack.pop();</span><br><span class="line">                   o2 = stack.pop();</span><br><span class="line">                   result = o2 - o1;</span><br><span class="line">                   stack.push(result);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                   o1 = stack.pop();</span><br><span class="line">                   o2 = stack.pop();</span><br><span class="line">                   result = o1 * o2;</span><br><span class="line">                   stack.push(result);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                   o1 = stack.pop();</span><br><span class="line">                   o2 = stack.pop();</span><br><span class="line">                   result = o2 / o1;</span><br><span class="line">                   stack.push(result);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   stack.push(Integer.valueOf(curr));</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       result = stack.pop();</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列是一种基于先进先出(FIFO)的数据结构，是一种只能在一端进行插入,在另一端进行删除操作的特殊线性表，它</p>
<p>按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。</p>
<h5 id="数组实现队列"><a href="#数组实现队列" class="headerlink" title="数组实现队列"></a>数组实现队列</h5><p>1、入队列，在队列增加元素；出队列，在队头弹出数据，同时数据整体向队头移动，保证队头有数据</p>
<p>2、由于每次移动数据，增加时间复杂度。于是增加队头队尾指针，通过移动指针来操作队列数据，但是不能重复利用数组空间</p>
<p>3、为了能重复利用，引出循环队列概念，当队尾指针最大后，再移动到队头开始，当front和rear相等，有可能是队列为空也有可能是队列满了</p>
<p>4、进而将rear指针定义为队尾的下一位置，从而得出结论front&#x3D;rear说明队列为空，(front+1)%quenenSize&#x3D;front，说明队列已满；并得出队列长度公式：(rear-front+quenenSize)%quenenSize</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用数组实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-05</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuenenArray</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] data;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队头指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队尾下一个结点指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuenenArray</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        data = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpety</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//头指针和尾指针相等</span></span><br><span class="line">        <span class="keyword">return</span> front==rear;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear-front+capacity)%capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向队列添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((rear+<span class="number">1</span>)%capacity==front)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列已满&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[rear] = t;</span><br><span class="line">        rear = (rear+<span class="number">1</span>)%capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rear==front)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> data[front];</span><br><span class="line">        front = (front+<span class="number">1</span>)%capacity;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showDatas</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T t : data) &#123;</span><br><span class="line">            System.out.print(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a>链表实现队列</h5><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 链表实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuenenLink</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//记录首结点</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">//记录最后一个结点</span></span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="comment">//记录队列中元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuenenLink</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回队列中元素的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向队列中插入元素t</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>) &#123;</span><br><span class="line">            last = <span class="keyword">new</span> <span class="title class_">Node</span>(t, <span class="literal">null</span>);</span><br><span class="line">            head.next = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">oldLast</span> <span class="operator">=</span> last;</span><br><span class="line">            last = <span class="keyword">new</span> <span class="title class_">Node</span>(t, <span class="literal">null</span>);</span><br><span class="line">            oldLast.next = last;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//个数+1</span></span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中拿出一个元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">oldFirst</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = oldFirst.next;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            last = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldFirst.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">QIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">QIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n.next != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> n.next;</span><br><span class="line">            n = n.next;</span><br><span class="line">            <span class="keyword">return</span> node.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> T item;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T item, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = item;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h3><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><p>树是由n（n&gt;&#x3D;1）个有限结点组成一个具有层次关系的集合。</p>
<p>树具有以下特点：</p>
<p> 1.每个结点有零个或多个子结点；</p>
<p> 2.没有父结点的结点为根结点；</p>
<p> 3.每一个非根结点只有一个父结点；</p>
<p> 4.每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树；</p>
<h4 id="树的相关概念"><a href="#树的相关概念" class="headerlink" title="树的相关概念"></a>树的相关概念</h4><p><strong>结点的度：</strong></p>
<p>一个结点含有的子树的个数称为该结点的度；</p>
<p><strong>叶结点：</strong></p>
<p>度为0的结点称为叶结点，也可以叫做终端结点</p>
<p><strong>分支结点：</strong></p>
<p>度不为0的结点称为分支结点，也可以叫做非终端结点</p>
<p><strong>结点的层次：</strong></p>
<p>从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推</p>
<p><strong>结点的层序编号：</strong></p>
<p>将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。</p>
<p><strong>树的度：</strong></p>
<p>树中所有结点的度的最大值</p>
<p><strong>树的高度(深度)：</strong></p>
<p>树中结点的最大层次</p>
<p><strong>森林：</strong></p>
<p> m（m&gt;&#x3D;0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根</p>
<p>结点，森林就变成一棵</p>
<p><strong>孩子结点：</strong></p>
<p>一个结点的直接后继结点称为该结点的孩子结点</p>
<p><strong>双亲结点(父结点)：</strong></p>
<p>一个结点的直接前驱称为该结点的双亲结点</p>
<p><strong>兄弟结点：</strong></p>
<p>同一双亲结点的孩子结点间互称兄弟结点</p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><h5 id="基本定义-1"><a href="#基本定义-1" class="headerlink" title="基本定义"></a>基本定义</h5><p>二叉树就是度不超过2的树(每个结点最多有两个子结点)</p>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p><strong>满二叉树：</strong></p>
<p>一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。</p>
<p><strong>完全二叉树：</strong></p>
<p>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p><strong>结点类：</strong></p>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>Node&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(Key key, Value value, Node left, Node right)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.public Node left:记录左子结点<br>2.public Node right:记录右子结点<br>3.public Key key:存储键<br>4.public Value value:存储值</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 结点类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;Key,Value&gt;&#123;</span><br><span class="line">      <span class="comment">//存储键</span></span><br><span class="line">      <span class="keyword">private</span> Key key;</span><br><span class="line">      <span class="comment">//存储值</span></span><br><span class="line">      <span class="keyword">private</span> Value value;</span><br><span class="line">      <span class="comment">//左结点</span></span><br><span class="line">      <span class="keyword">private</span> Node left;</span><br><span class="line">      <span class="comment">//右结点</span></span><br><span class="line">      <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 构造方法</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Key key, Value value, Node left, Node right)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.key = key;</span><br><span class="line">          <span class="built_in">this</span>.value = value;</span><br><span class="line">          <span class="built_in">this</span>.left = left;</span><br><span class="line">          <span class="built_in">this</span>.right = right;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉树API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>BinaryTree&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>BinaryTree()：创建BinaryTree对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node root:记录根结点<br>2.private int N:记录树中元素的个数</td>
</tr>
<tr>
<td>成员方法</td>
<td>1. public void put(Key key,Value value):向树中插入一个键值对<br>2.private Node put(Node x, Key key, Value val)：给指定树x上，添加键一个键值对，并返回添加后的新树<br>3.public Value get(Key key):根据key，从树中找出对应的值<br>4.private Value get(Node x, Key key):从指定的树x中，找出key对应的值<br>5.public void delete(Key key):根据key，删除树中对应的键值对<br>6.private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的新树<br>7.public int size():获取树中元素的个数</td>
</tr>
</tbody></table>
<p><strong>插入方法put实现思想：</strong></p>
<p>1.如果当前树中没有任何一个结点，则直接把新结点当做根结点使用</p>
<p>2.如果当前树不为空，则从根结点开始：</p>
<p> 2.1如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；</p>
<p> 2.2如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；</p>
<p> 2.3如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。</p>
<p><strong>查询方法get实现思想：</strong></p>
<p>从根节点开始：</p>
<p> 1.如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；</p>
<p> 2.如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；</p>
<p> 3.如果要查询的key等于当前结点的key，则树中返回当前结点的value。</p>
<p><strong>删除方法delete实现思想：</strong></p>
<p> 1.找到被删除结点；</p>
<p> 2.找到被删除结点右子树中的最小结点minNode</p>
<p> 3.删除右子树中的最小结点</p>
<p> 4.让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子</p>
<p>树</p>
<p> 5.让被删除结点的父节点指向最小结点minNode</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 二叉树实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span>&lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;,Value&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 树中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryTree</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向树中插入一个键值对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Key key,Value value)</span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给指定树x上，添加键一个键值对，并返回添加后的新树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">put</span><span class="params">(Node x, Key key, Value val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="literal">null</span>)&#123;</span><br><span class="line">            N++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key,val,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//新结点的key大于当前结点key，继续找当前结点的右子结点</span></span><br><span class="line">            x.right = put(x.right,key,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//新结点的key小于当前结点key，继续找当前结点的左子结点</span></span><br><span class="line">            x.left = put(x.left,key,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            x.value = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key，从树中找出对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Value <span class="title function_">get</span><span class="params">(Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从指定的树x中，找出key对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Value <span class="title function_">get</span><span class="params">(Node x,Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> get(x.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> get(x.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除树中对应的键值对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Key key)</span>&#123;</span><br><span class="line">        delete(root,key);</span><br><span class="line">        <span class="comment">//个数-1</span></span><br><span class="line">        N--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定树x上的键为key的键值对，并返回删除后的新树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">delete</span><span class="params">(Node x,Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            x.right = delete(x.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x.left = delete(x.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//新结点的key等于当前结点的key,当前x就是要删除的结点</span></span><br><span class="line">            <span class="comment">//1.如果当前结点的右子树不存在，则直接返回当前结点的左子结点</span></span><br><span class="line">            <span class="keyword">if</span> (x.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> x.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.如果当前结点的左子树不存在，则直接返回当前结点的右子结点</span></span><br><span class="line">            <span class="keyword">if</span> (x.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> x.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.当前结点的左右子树都存在</span></span><br><span class="line">            <span class="comment">//3.1找到右子树中最小的结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">minNode</span> <span class="operator">=</span> x.right;</span><br><span class="line">            <span class="keyword">while</span> (minNode.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                minNode = minNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.2删除右子树中最小的结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> x.right;</span><br><span class="line">            <span class="keyword">while</span> (n.left != <span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span> (n.left.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                   n.left = <span class="literal">null</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   n = n.left;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.3让被删除结点的左子树成为最小结点minNode的左子树，让被删除结点的右子树成为最小结点minNode的右子树</span></span><br><span class="line">            minNode.left = x.left;</span><br><span class="line">            minNode.right = x.right;</span><br><span class="line">            <span class="comment">//3.4让被删除结点的父节点指向最小结点minNode</span></span><br><span class="line">            x = minNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取树中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结点类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="comment">//存储键</span></span><br><span class="line">        <span class="keyword">private</span> Key key;</span><br><span class="line">        <span class="comment">//存储值</span></span><br><span class="line">        <span class="keyword">private</span> Value value;</span><br><span class="line">        <span class="comment">//左结点</span></span><br><span class="line">        <span class="keyword">private</span> Node left;</span><br><span class="line">        <span class="comment">//右结点</span></span><br><span class="line">        <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Key key, Value value, Node left, Node right)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找二叉树中的最小键</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找出整个树中最小的键</span></span><br><span class="line">   <span class="keyword">public</span> Key <span class="title function_">min</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> min(root).key;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//找出指定树x中最小的键所在的结点</span></span><br><span class="line">   <span class="keyword">public</span> Node <span class="title function_">min</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> min(x.left);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找二叉树中最大的键</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找出整个树中最大的键</span></span><br><span class="line">   <span class="keyword">public</span> Key <span class="title function_">max</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> max(root).key;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//找出指定树x中最小的键所在的结点</span></span><br><span class="line">   <span class="keyword">public</span> Node <span class="title function_">max</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> max(x.right);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h5><p><strong>前序遍历</strong></p>
<p>先访问根结点，然后再访问左子树，最后访问右子树</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用前序遍历，获取整个树中的所有键</span></span><br><span class="line">   <span class="keyword">public</span> QuenenLink&lt;Key&gt; <span class="title function_">preErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">       QuenenLink&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">       preErgodic(root,keys);</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用前序遍历，把指定树x中的所有键放入到keys队列中</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preErgodic</span><span class="params">(Node x,QuenenLink&lt;Key&gt; keys)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1.把当前结点的key放入到队列中;</span></span><br><span class="line">       keys.enqueue(x.key);</span><br><span class="line">       <span class="comment">//2.找到当前结点的左子树，如果不为空，递归遍历左子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           preErgodic(x.left,keys);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3.找到当前结点的右子树，如果不为空，递归遍历右子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">           preErgodic(x.right,keys);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>中序遍历</strong></p>
<p>先访问左子树，中间访问根节点，最后访问右子树</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用中序遍历，获取整个树中的所有键</span></span><br><span class="line">   <span class="keyword">public</span> QuenenLink&lt;Key&gt; <span class="title function_">midErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">       QuenenLink&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">       midErgodic(root,keys);</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用中序遍历，把指定树x中的所有键放入到keys队列中</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">midErgodic</span><span class="params">(Node x,QuenenLink&lt;Key&gt; keys)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1.找到当前结点的左子树，如果不为空，递归遍历左子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           midErgodic(x.left,keys);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2.把当前结点的key放入到队列中;</span></span><br><span class="line">       keys.enqueue(x.key);</span><br><span class="line">       <span class="comment">//3.找到当前结点的右子树，如果不为空，递归遍历右子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">           midErgodic(x.right,keys);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>后序遍历</strong></p>
<p>先访问左子树，再访问右子树，最后访问根节点</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用后序遍历，获取整个树中的所有键</span></span><br><span class="line">   <span class="keyword">public</span> QuenenLink&lt;Key&gt; <span class="title function_">afterErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">       QuenenLink&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">       afterErgodic(root,keys);</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用后序遍历，把指定树x中的所有键放入到keys队列中</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">afterErgodic</span><span class="params">(Node x,QuenenLink&lt;Key&gt; keys)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1.找到当前结点的左子树，如果不为空，递归遍历左子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           afterErgodic(x.left,keys);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2.找到当前结点的右子树，如果不为空，递归遍历右子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">           afterErgodic(x.right,keys);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3.把当前结点的key放入到队列中;</span></span><br><span class="line">       keys.enqueue(x.key);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>层序遍历</strong></p>
<p>所谓的层序遍历，就是从根节点（第一层）开始，依次向下，获取每一层所有结点的值</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用层序遍历得到树中所有的键</span></span><br><span class="line">   <span class="keyword">public</span> QuenenLink&lt;Key&gt; <span class="title function_">layerErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">       QuenenLink&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">       QuenenLink&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">       nodes.enqueue(root);</span><br><span class="line">       <span class="keyword">while</span> (!nodes.isEmpty())&#123;</span><br><span class="line">           <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nodes.dequeue();</span><br><span class="line">           keys.enqueue(node.key);</span><br><span class="line">           <span class="keyword">if</span> (node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">               nodes.enqueue(node.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">               nodes.enqueue(node.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="二叉树的最大深度问题"><a href="#二叉树的最大深度问题" class="headerlink" title="二叉树的最大深度问题"></a><strong>二叉树的最大深度问题</strong></h5><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算整个树的最大深度</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> maxDepth(root);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//计算指定树x的最大深度</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">       <span class="comment">//1.如果根结点为空，则最大深度为0；</span></span><br><span class="line">       <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//2.计算左子树的最大深度；</span></span><br><span class="line">       <span class="keyword">if</span> (x.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           maxL = maxDepth(x.left);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3.计算右子树的最大深度；</span></span><br><span class="line">       <span class="keyword">if</span> (x.right != <span class="literal">null</span>)&#123;</span><br><span class="line">           maxR = maxDepth(x.right);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4.当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1</span></span><br><span class="line">       max = maxL &gt; maxR ? maxL + <span class="number">1</span> : maxR + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h4><p>二叉查找树是最常用的一种二叉树，它支持快速插入、删除、查找操作，各个操作的时间复杂度跟树的高度成正比，最佳时间复杂度是 O(log­n)。</p>
<p>不过，由于二叉排序树本身为有序，当<strong>插入一个有序程度十分高的序列</strong>时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致<strong>最终的二叉排序树会退化为链表</strong>，从而使得二叉树的查询和插入效率恶化。**时间复杂度会退化到 O(n)**。</p>
<p>因此一般的<strong>二叉查找树不适用于数据经常变动（加入或删除）的情况</strong>。而是比较适合不会变动的数据，例如编程语言中的“保留字”等。</p>
<p>为了能够尽量降低查找所需要的时间，快速找到所要的键值，或者很快地知道当前的树中没有我们要的键值，必须让树的高度越小越好。要解决这个时间复杂度退化的问题，我们需要设计一种平衡二叉查找树。</p>
<h5 id="avl平衡树"><a href="#avl平衡树" class="headerlink" title="avl平衡树"></a>avl平衡树</h5><p>平衡二叉树（Balanced Binary Tree）又称 <strong>AVL</strong> 树（由 Adelse-Velskil 和 Landis 两个人发明），本身也是一棵二叉查找树，其产生是为了解决二叉排序树在插入时发生线性排列的现象。</p>
<p>平衡二叉树的严格定义是这样的：</p>
<ol>
<li>满足二叉查找树的性质，左子树所有值小于父节点，右子树所有值大于等于父节点。</li>
<li>作为一棵平衡二叉树，它需要满足任意一个节点的左右子树的高度相差不能大于 1。</li>
</ol>
<p>在平衡二叉树中，<strong>每次在插入数据和删除数据后，必要时就会对二叉树做一些高度的调整（左旋和右旋）</strong>，<strong>来让二叉查找树的高度随时维持平衡，将查找、插入、删除操作的时间复杂度保证在 O(log­n) 范围内</strong>。通常只有从那些插入点到根节点的路径上的节点的平衡性可能被改变，因为只有这些节点的子树可能变化。</p>
<p>平衡二叉树适用于动态数据，这就完成了哈希表不便完成的工作——动态性。所以：</p>
<ul>
<li>如果输入集合确定，所需要的就是查询，则可以考虑使用哈希表。</li>
<li>如果输入集合不确定，则考虑使用平衡二叉树&#x2F;红黑树，保证达到最大效率。</li>
</ul>
<p><strong>平衡二叉树主要优点集中在快速查找，</strong>频繁旋转会使插入和删除牺牲掉 O(log­n) 左右的时间，不过相对二叉查找树来说，时间上稳定了很多。<br><strong>Node结点类：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>Node&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(Key,Value)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.public K key:键<br>2.private V value:值<br>3.private Node left,right:左右结点<br>4.private int height:高度</td>
</tr>
</tbody></table>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>AvlTree&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>AvlTree()：创建AvlTree对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node root:记录根结点<br>2.private int N:记录树中元素的个数:</td>
</tr>
<tr>
<td>成员方法</td>
<td>1. public void put(Key key,Value value):向树中插入一个键值对<br>2.private Node put(Node x, Key key, Value val)：给指定树x上，添加键一个键值对，并返回添加后的新树<br>3.public Value get(Key key):根据key，从树中找出对应的值<br>4.private Value get(Node x, Key key):从指定的树x中，找出key对应的值<br>5.public void delete(Key key):根据key，删除树中对应的键值对<br>6.private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的新树<br>7.public int size():获取树中元素的个数<br>8.public Node rightRotate(Node x):右旋<br>9.public Node leftRotate(Node x):左旋</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: avl数实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AvlTree</span>&lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;,Value&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Key key;</span><br><span class="line">        <span class="keyword">private</span> Value value;</span><br><span class="line">        <span class="keyword">public</span> Node left,right;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Key key,Value value)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            left = <span class="literal">null</span>;</span><br><span class="line">            right = <span class="literal">null</span>;</span><br><span class="line">            height = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AvlTree</span><span class="params">()</span>&#123;</span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取树高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取平衡因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getBalanceFactor</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getHeight(node.left) - getHeight(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右旋</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">rightRotate</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="comment">//获取根结点的左子节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">left</span> <span class="operator">=</span> node.left;</span><br><span class="line">        <span class="comment">//获取左子节点的右子节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">lright</span> <span class="operator">=</span> left.right;</span><br><span class="line">        <span class="comment">//left为根结点，node为其右子节点，并lright调整为node的左子节点</span></span><br><span class="line">        left.right = node;</span><br><span class="line">        node.left = lright;</span><br><span class="line">        <span class="comment">//更新height</span></span><br><span class="line">        left.height = Math.max(getHeight(left.left),getHeight(left.right)) + <span class="number">1</span>;</span><br><span class="line">        node.height = Math.max(getHeight(node.left),getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左旋</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">leftRotate</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="comment">//获取根结点的右子节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> node.right;</span><br><span class="line">        <span class="comment">//获取右子节点的左子节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">rleft</span> <span class="operator">=</span> right.left;</span><br><span class="line">        <span class="comment">//right为根结点，node为其左子节点，并rleft调整为node的右子节点</span></span><br><span class="line">        right.left = node;</span><br><span class="line">        node.right = rleft;</span><br><span class="line">        <span class="comment">//更新height</span></span><br><span class="line">        right.height = Math.max(getHeight(right.left),getHeight(right.right)) + <span class="number">1</span>;</span><br><span class="line">        node.height = Math.max(getHeight(node.left),getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Key key,Value value)</span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">put</span><span class="params">(Node node,Key key,Value value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果为空，即空树添加结点</span></span><br><span class="line">            <span class="comment">//元素个数加1</span></span><br><span class="line">            N++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key,value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(node.key)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            node.left = put(node.left,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            node.right = put(node.right,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key)==<span class="number">0</span>)&#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新每个结点的height</span></span><br><span class="line">        node.height = Math.max(getHeight(node.left),getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//计算平衡因子</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">balanceFactor</span> <span class="operator">=</span> getBalanceFactor(node);</span><br><span class="line">        <span class="comment">//右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先左旋再右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.left = leftRotate(node.left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先右旋再左旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.right = rightRotate(node.right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据key，从树中找出对应的值</span></span><br><span class="line">    <span class="keyword">public</span> Value <span class="title function_">get</span><span class="params">(Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从指定的树x中，找出key对应的值</span></span><br><span class="line">    <span class="keyword">private</span> Value <span class="title function_">get</span><span class="params">(Node node,Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(node.key)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> get(node.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> get(node.right,key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据key，删除树中对应的键值对</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Key key)</span>&#123;</span><br><span class="line">        root = delete(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除指定树x上的键为key的键值对，并返回删除后的新树</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">delete</span><span class="params">(Node node,Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义新树</span></span><br><span class="line">        Node newNode;</span><br><span class="line">        <span class="comment">//找到key对应的位置</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.left = delete(node.left,key);</span><br><span class="line">            newNode = node;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.right = delete(node.right,key);</span><br><span class="line">            newNode = node;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//找到key的位置</span></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> node.right;</span><br><span class="line">                node.right = <span class="literal">null</span>;</span><br><span class="line">                N--;</span><br><span class="line">                newNode = rightNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> node.left;</span><br><span class="line">                node.left = <span class="literal">null</span>;</span><br><span class="line">                N--;</span><br><span class="line">                newNode = leftNode;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">                <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">minimum</span> <span class="operator">=</span> minimum(node.right);</span><br><span class="line">                minimum.right = delete(node.right,minimum.key);</span><br><span class="line">                minimum.left = node.left;</span><br><span class="line">                node.left = node.right = <span class="literal">null</span>;</span><br><span class="line">                newNode = minimum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新height</span></span><br><span class="line">        newNode.height = <span class="number">1</span> + Math.max(getHeight(newNode.left), getHeight(newNode.right));</span><br><span class="line">        <span class="comment">//计算平衡因子</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">balanceFactor</span> <span class="operator">=</span> getBalanceFactor(newNode);</span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(newNode.left) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rightRotate(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(newNode.right) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftRotate(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先左旋再右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(newNode.left) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            newNode.left = leftRotate(newNode.left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先右旋再左旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(newNode.right) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            newNode.right = rightRotate(newNode.right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根的二分搜索树的最小值所在的节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">minimum</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h5><p>为了保证查找树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个结点保存多个键。确切的说，我</p>
<p>们将一棵标准的二叉查找树中的结点称为2-结点(含有一个键和两条链)，而现在我们引入3-结点，它含有两个键和</p>
<p>三条链。2-结点和3-结点中的每条链都对应着其中保存的键所分割产生的一个区间。</p>
<p>一棵2-3查找树要么为空，要么满足满足下面两个要求：</p>
<p><strong>2-结点：</strong></p>
<p>含有一个键(及其对应的值)和两条链，左链接指向2-3树中的键都小于该结点，右链接指向的2-3树中的键都大</p>
<p>于该结点。</p>
<p><strong>3-结点：</strong></p>
<p>含有两个键(及其对应的值)和三条链，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都</p>
<p>位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。</p>
<p><strong>查找</strong></p>
<p>将二叉查找树的查找算法一般化我们就能够直接得到2-3树的查找算法。要判断一个键是否在树中，我们先将它和</p>
<p>根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的连</p>
<p>接，并在其指向的子树中递归地继续查找。如果这个是空链接，查找未命中。</p>
<p> <strong>插入</strong></p>
<p><strong>向2-结点中插入新键</strong></p>
<h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><p>红黑树是一种特殊的二叉查找树，每个结点都要储存位表示结点的颜色，或红或黑</p>
<p><strong>特点：</strong></p>
<ul>
<li>每个结点或红或黑</li>
<li>根结点是黑色</li>
<li>空叶子结点是黑色</li>
<li>如果一个几点是红色，那么他的子节点是黑色</li>
<li>从任意一个结点出发到空的叶子结点经过的黑色结点个数相同</li>
</ul>
<p><strong>Node结点类：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>Node&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(Key,Value)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.public K key:键<br>2.private V value:值<br>3.private Node left,right:左右结点<br>4.private boolean color:结点颜色</td>
</tr>
</tbody></table>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>RedBlackTree&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>RedBlackTree()：创建RedBlackTree对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node root:记录根结点<br>2.private int N:记录树中元素的个数:</td>
</tr>
<tr>
<td>成员方法</td>
<td>1. public void put(Key key,Value value):向树中插入一个键值对<br>2.private Node put(Node x, Key key, Value val)：给指定树x上，添加键一个键值对，并返回添加后的新树<br>3.public Value get(Key key):根据key，从树中找出对应的值<br>4.private Value get(Node x, Key key):从指定的树x中，找出key对应的值<br>5.public void delete(Key key):根据key，删除树中对应的键值对<br>6.private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的新树<br>7.public int size():获取树中元素的个数<br>8.public Node rightRotate(Node x):右旋<br>9.public Node leftRotate(Node x):左旋</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<h5 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h5><p><strong>特点</strong></p>
<p>B树中允许一个结点中包含多个key，可以是3个、4个、5个甚至更多，并不确定，需要看具体的实现。现在我们选</p>
<p>择一个参数M，来构造一个B树，我们可以把它称作是M阶的B树，那么该树会具有如下特点：</p>
<ul>
<li>每个结点最多有M-1个key，并且以升序排列；</li>
<li>每个结点最多能有M个子结点；</li>
<li>根结点至少有两个子结点</li>
</ul>
<p><strong>B树在磁盘文件中的应用</strong></p>
<p>​		在我们的程序中，不可避免的需要通过IO操作文件，而我们的文件是存储在磁盘上的。计算机操作磁盘上的文件是通过文件系统进行操作的，在文件系统中就使用到了B树这种数据结构。</p>
<p><strong>磁盘</strong></p>
<p>​		磁盘能够保存大量的数据，从GB一直到TB级，但是 他的读取速度比较慢，因为涉及到机器操作，读取速度为毫秒级 。磁盘由盘片构成,每个盘片有两面，又称为盘面 。盘片中央有一个可以旋转的主轴，他使得盘片以固定的旋转速率旋转，通常是5400rpm或者是7200rpm,一个磁盘中包含了多个这样的盘片并封装在一个密封的容器内 。盘片的每个表面是由一组称为磁道同心圆组成的 ，每个磁道被划分为了一组扇区 ，每个扇区包含相等数量的数据位，通常是512个子节，扇区之间由一些间隙隔开,这些间隙中不存储数据 。</p>
<p><strong>磁盘IO</strong></p>
<p>​		磁盘用磁头来读写存储在盘片表面的位，而磁头连接到一个移动臂上，移动臂沿着盘片半径前后移动，可以将磁头定位到任何磁道上，这称之为寻道操作。一旦定位到磁道后，盘片转动，磁道上的每个位经过磁头时，读写磁头就可以感知到该位的值，也可以修改值。对磁盘的访问时间分为 <strong>寻道时间</strong>，<strong>旋转时间</strong>，以及<strong>传送时间</strong>。</p>
<p>​		由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，因此为了提高效率，要尽量减少磁盘I&#x2F;O，减少读写操作。 为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此预读可以提高I&#x2F;O效率。,</p>
<p>​		页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（1024个字节或其整数倍），预读的长度一般为页的整倍数。主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<p>​		文件系统的设计者利用了磁盘预读原理，将一个结点的大小设为等于一个页（1024个字节或其整数倍），这样每个结点只需要一次I&#x2F;O就可以完全载入。那么3层的B树可以容纳1024<em>1024</em>1024差不多10亿个数据，如果换成二叉查找树，则需要30层！假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在10亿个数据中查找目标值，只需要小于3次硬盘读取就可以找到目标值，但红黑树需要小于30次，因此B树大大提高了IO的操作效率。</p>
<h5 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h5><p>B+树是对B树的一种变形树，它与B树的差异在于：</p>
<ul>
<li>非叶结点仅具有索引作用，也就是说，非叶子结点只存储key，不存储value；</li>
<li>树的所有叶结点构成一个有序链表，可以按照key排序的次序遍历全部数据。</li>
</ul>
<p><strong>B+树和B树的对比</strong></p>
<p><strong>B+</strong> <strong>树的优点在于：</strong></p>
<ul>
<li>由于B+树在非叶子结点上不包含真正的数据，只当做索引使用，因此在内存相同的情况下，能够存放更多的key。 </li>
<li>B+树的叶子结点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。</li>
</ul>
<p><strong>B树的优点在于：</strong></p>
<p>​		由于B树的每一个节点都包含key和value，因此我们根据key查找value时，只需要找到key所在的位置，就能找到value，但B+树只有叶子结点存储数据，索引每一次查找，都必须一次一次，一直找到树的最大深度处，也就是叶子结点的深度，才能找到value。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h4><p>堆是计算机科学中一类特殊的数据结构的统称，堆通常可以被看做是一棵完全二叉树的数组对象。</p>
<p><strong>堆的特性</strong></p>
<ul>
<li>它是完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求左满右不满。</li>
<li>它通常用数组来实现。如果一个结点的位置为k，则它的父结点的位置为[k&#x2F;2],而它的两个子结点的位置则分别为2k和2k+1。这样，在不使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动：从a[k]向上一层，就令k等于k&#x2F;2,向下一层就令k等于2k或2k+1。</li>
<li>每个结点都大于等于它的两个子结点。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的。</li>
</ul>
<h4 id="堆的API设计"><a href="#堆的API设计" class="headerlink" title="堆的API设计"></a>堆的API设计</h4><table>
<thead>
<tr>
<th>类名</th>
<th><strong>Heap</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Heap(int capacity)：创建容量为capacity的Heap对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br>2.private void exch(int i,int j):交换堆中i索引和j索引处的值<br>3.public T delMax():删除堆中最大的元素,并返回这个最大元素<br>4.public void insert(T t)：往堆中插入一个元素<br>5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br>6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] imtes : 用来存储元素的数组<br>2.private int N：记录堆中元素的个数</td>
</tr>
</tbody></table>
<h4 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a><strong>堆的实现</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.generic.IF_ACMPEQ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储堆中的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录堆中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j])&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换堆中i索引和j索引处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往堆中插入一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        <span class="comment">//上浮算法</span></span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除堆中最大的元素,并返回这个最大元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> items[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//交换索引1处和索引N处的值</span></span><br><span class="line">        exch(<span class="number">1</span>,N);</span><br><span class="line">        <span class="comment">//删除最后位置上的元素</span></span><br><span class="line">        items[N]=<span class="literal">null</span>;</span><br><span class="line">        N--;<span class="comment">//个数-1</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//如果已经到了根结点，就不需要循环了</span></span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//比较当前结点和其父节点</span></span><br><span class="line">            <span class="keyword">if</span> (less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">                <span class="comment">//父节点小于当前节点，则交换</span></span><br><span class="line">                exch(k/<span class="number">2</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//如果当前已经是最底层了，就不需要循环了</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k&lt;=N)&#123;</span><br><span class="line">            <span class="comment">//找到子节点中的较大者</span></span><br><span class="line">            <span class="type">int</span> max;</span><br><span class="line">            <span class="comment">//判断是否存在右结点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span>*k+<span class="number">1</span>&lt;=N)&#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span>*k,<span class="number">2</span>*k+<span class="number">1</span>))&#123;</span><br><span class="line">                    max = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    max = <span class="number">2</span>*k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                max = <span class="number">2</span>*k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较当前结点和子节点中较大者，如果当前结点不小，则结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (!less(k,max))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前结点小，则交换</span></span><br><span class="line">            exch(k,max);</span><br><span class="line">            k = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.generic.IF_ACMPEQ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储堆中的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录堆中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j])&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换堆中i索引和j索引处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往堆中插入一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        <span class="comment">//上浮算法</span></span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除堆中最大的元素,并返回这个最大元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> items[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//交换索引1处和索引N处的值</span></span><br><span class="line">        exch(<span class="number">1</span>,N);</span><br><span class="line">        <span class="comment">//删除最后位置上的元素</span></span><br><span class="line">        items[N]=<span class="literal">null</span>;</span><br><span class="line">        N--;<span class="comment">//个数-1</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//如果已经到了根结点，就不需要循环了</span></span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//比较当前结点和其父节点</span></span><br><span class="line">            <span class="keyword">if</span> (less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">                <span class="comment">//父节点小于当前节点，则交换</span></span><br><span class="line">                exch(k/<span class="number">2</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//如果当前已经是最底层了，就不需要循环了</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k&lt;=N)&#123;</span><br><span class="line">            <span class="comment">//找到子节点中的较大者</span></span><br><span class="line">            <span class="type">int</span> max;</span><br><span class="line">            <span class="comment">//判断是否存在右结点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span>*k+<span class="number">1</span>&lt;=N)&#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span>*k,<span class="number">2</span>*k+<span class="number">1</span>))&#123;</span><br><span class="line">                    max = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    max = <span class="number">2</span>*k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                max = <span class="number">2</span>*k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较当前结点和子节点中较大者，如果当前结点不小，则结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (!less(k,max))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前结点小，则交换</span></span><br><span class="line">            exch(k,max);</span><br><span class="line">            k = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><strong>AP设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>HeapSort</strong></th>
</tr>
</thead>
<tbody><tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] source)：对source数组中的数据从小到大排序<br>2.private static void createHeap(Comparable[] source, Comparable[] heap):根据原数组source，构造出堆heap<br>3.private static boolean less(Comparable[] heap, int i, int j)：判断heap堆中索引i处的元素是否小于索引j处的元素<br>4.private static void exch(Comparable[] heap, int i, int j):交换heap堆中i索引和j索引处的值<br>5.private static void sink(Comparable[] heap, int target, int range):在heap堆中，对target处的元素做下沉，范围是0~range。</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 堆排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对source数组中的数据从小到大排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] source)</span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个比原数组大1的数组</span></span><br><span class="line">        Comparable[] heap = <span class="keyword">new</span> <span class="title class_">Comparable</span>[source.length + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//2.构造堆</span></span><br><span class="line">        createHeap(source,heap);</span><br><span class="line">        <span class="comment">//3.堆排序</span></span><br><span class="line">        <span class="comment">//3.1定义一个变量，记录heap中未排序的所有元素中最大的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> heap.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (N != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//3.2交换heap中索引1处的元素和N处的元素</span></span><br><span class="line">            exch(heap,<span class="number">1</span>,N);</span><br><span class="line">            N--;</span><br><span class="line">            sink(heap,<span class="number">1</span>,N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.heap中的数据已经有序，拷贝到source中</span></span><br><span class="line">        System.arraycopy(heap,<span class="number">1</span>,source,<span class="number">0</span>,source.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据原数组source，构造出堆heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createHeap</span><span class="params">(Comparable[] source, Comparable[] heap)</span>&#123;</span><br><span class="line">        <span class="comment">//1.把source中的数据拷贝到heap中，从heap的1索引处开始填充</span></span><br><span class="line">        System.arraycopy(source,<span class="number">0</span>,heap,<span class="number">1</span>,source.length);</span><br><span class="line">        <span class="comment">//2.从heap索引的一半处开始倒叙遍历，对得到的每一个元素做下沉操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (heap.length-<span class="number">1</span>)/<span class="number">2</span>; i &gt; <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            sink(heap,i, heap.length-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断heap堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(Comparable[] heap, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap[i].compareTo(heap[j])&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换heap堆中i索引和j索引处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] heap, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable tmp=heap[i];</span><br><span class="line">        heap[i]=heap[j];</span><br><span class="line">        heap[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在heap堆中，对target处的元素做下沉，范围是0~range。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> range</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(Comparable[] heap, <span class="type">int</span> target, <span class="type">int</span> range)</span>&#123;</span><br><span class="line">        <span class="comment">//没有子结点了</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*target&lt;=range) &#123;</span><br><span class="line">            <span class="comment">//1.找出target结点的两个子结点中的较大值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">2</span> * target;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * target + <span class="number">1</span> &lt;= range) &#123;</span><br><span class="line">                <span class="comment">//存在右子结点</span></span><br><span class="line">                <span class="keyword">if</span> (less(heap, <span class="number">2</span> * target, <span class="number">2</span> * target + <span class="number">1</span>)) &#123;</span><br><span class="line">                    max = <span class="number">2</span> * target + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.如果当前结点的值小于子结点中的较大值，则交换</span></span><br><span class="line">            <span class="keyword">if</span> (less(heap, target, max)) &#123;</span><br><span class="line">                exch(heap, target, max);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.更新target的值</span></span><br><span class="line">            target = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;S&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;P&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        HeapSort.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>​		普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在某些情况下，我们可能需要找出队列中的最大值或者最小值，例如使用一个队列保存计算机的任务，一般情况下计算机的任务都是有优先级的，我们需要在这些计算机的任务中找出优先级最高的任务先执行，执行完毕后就需要把这个任务从队列中移除。普通的队列要完成这样的功能，需要每次遍历队列中的所有元素，比较并找出最大值，效率不是很高，这个时候，我们就可以使用一种特殊的队列来完成这种需求，优先队列。</p>
<h4 id="最大优先队列"><a href="#最大优先队列" class="headerlink" title="最大优先队列"></a><strong>最大优先队列</strong></h4><p><strong>最大优先队列API设计</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>MaxPriorityQueue</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>MaxPriorityQueue(int capacity)：创建容量为capacity的MaxPriorityQueue对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br>2.private void exch(int i,int j):交换堆中i索引和j索引处的值<br>3.public T delMax():删除队列中最大的元素,并返回这个最大元素<br>4.public void insert(T t)：往队列中插入一个元素<br>5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br>6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置<br>7.public int size():获取队列中元素的个数<br>8.public boolean isEmpty():判断队列是否为空</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] imtes : 用来存储元素的数组<br>2.private int N：记录堆中元素的个数</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.awt.geom.AreaOp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 最大优先队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-20</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPriorityQueue</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存储元素的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录堆中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxPriorityQueue</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换堆中i索引和j索引处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除队列中最大的元素,并返回这个最大元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> items[<span class="number">1</span>];</span><br><span class="line">        exch(<span class="number">1</span>,N);</span><br><span class="line">        items[N] = <span class="literal">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往队列中插入一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//比较当前节点与其父节点</span></span><br><span class="line">            <span class="keyword">if</span> (less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">                exch(k/<span class="number">2</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k&lt;=N)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= N)&#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span> * k,<span class="number">2</span> * k + <span class="number">1</span>))&#123;</span><br><span class="line">                    max = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!less(k,max))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(k,max);</span><br><span class="line">            k = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列中元素的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;S&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;P&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        MaxPriorityQueue&lt;String&gt; maxpq = <span class="keyword">new</span> <span class="title class_">MaxPriorityQueue</span>&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">            maxpq.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(maxpq.size());</span><br><span class="line">        String del;</span><br><span class="line">        <span class="keyword">while</span>(!maxpq.isEmpty())&#123;</span><br><span class="line">            del = maxpq.delMax();</span><br><span class="line">            System.out.print(del+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最小优先队列"><a href="#最小优先队列" class="headerlink" title="最小优先队列"></a>最小优先队列</h4><p>其实我们之前实现的堆可以把它叫做最大堆，我们可以用相反的思想实现最小堆，让堆中存放数据元素的数组满足</p>
<p>如下特性：</p>
<p>1.最小的元素放在数组的索引1处。</p>
<p>2.每个结点的数据总是小于等于它的两个子结点的数据。</p>
<p><strong>最小优先队列API设计</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>MinPriorityQueue</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>MinPriorityQueue(int capacity)：创建容量为capacity的MinPriorityQueue对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br>2.private void exch(int i,int j):交换堆中i索引和j索引处的值<br>3.public T delMax():删除队列中最大的元素,并返回这个最大元素<br>4.public void insert(T t)：往队列中插入一个元素<br>5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br>6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置<br>7.public int size():获取队列中元素的个数<br>8.public boolean isEmpty():判断队列是否为空</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] imtes : 用来存储元素的数组<br>2.private int N：记录堆中元素的个数</td>
</tr>
</tbody></table>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 最小优先队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-20</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinPriorityQueue</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存储元素的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录堆中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinPriorityQueue</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换堆中i索引和j索引处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除队列中最大的元素,并返回这个最大元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> items[<span class="number">1</span>];</span><br><span class="line">        exch(<span class="number">1</span>,N);</span><br><span class="line">        items[N] = <span class="literal">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往队列中插入一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//比较当前节点与其父节点</span></span><br><span class="line">            <span class="keyword">if</span> (less(k,k/<span class="number">2</span>))&#123;</span><br><span class="line">                exch(k/<span class="number">2</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k&lt;=N)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= N)&#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span> * k + <span class="number">1</span>,<span class="number">2</span> * k ))&#123;</span><br><span class="line">                    min = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (less(k,min))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(k,min);</span><br><span class="line">            k = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列中元素的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;S&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;P&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        MinPriorityQueue&lt;String&gt; maxpq = <span class="keyword">new</span> <span class="title class_">MinPriorityQueue</span>&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">            maxpq.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(maxpq.size());</span><br><span class="line">        String del;</span><br><span class="line">        <span class="keyword">while</span>(!maxpq.isEmpty())&#123;</span><br><span class="line">            del = maxpq.delMax();</span><br><span class="line">            System.out.print(del+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="索引优先队列"><a href="#索引优先队列" class="headerlink" title="索引优先队列"></a>索引优先队列</h4><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="图的定义及分类"><a href="#图的定义及分类" class="headerlink" title="图的定义及分类"></a>图的定义及分类</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h5><p>图是由一组顶点和一组能够将两个顶点相连的边组成的</p>
<h5 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a><strong>分类</strong></h5><p>按照连接两个顶点的边的不同，可以把图分为以下两种：</p>
<ul>
<li>无向图：边仅仅连接两个顶点，没有其他含义；</li>
<li>有向图：边不仅连接两个顶点，并且具有方向；</li>
</ul>
<h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><h5 id="图的相关术语"><a href="#图的相关术语" class="headerlink" title="图的相关术语"></a>图的相关术语</h5><p><strong>相邻顶点：</strong></p>
<p>当两个顶点通过一条边相连时，我们称这两个顶点是相邻的，并且称这条边依附于这两个顶点。</p>
<p><strong>度：</strong></p>
<p>某个顶点的度就是依附于该顶点的边的个数</p>
<p><strong>子图：</strong></p>
<p>是一幅图的所有边的子集(包含这些边依附的顶点)组成的图；</p>
<p><strong>路径：</strong></p>
<p>是由边顺序连接的一系列的顶点组成</p>
<p><strong>环：</strong></p>
<p>是一条至少含有一条边且终点和起点相同的路径</p>
<p><strong>连通图：</strong></p>
<p>如果图中任意一个顶点都存在一条路径到达另外一个顶点，那么这幅图就称之为连通图</p>
<p><strong>连通子图：</strong></p>
<p>一个非连通图由若干连通的部分组成，每一个连通的部分都可以称为该图的连通子图</p>
<h5 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a><strong>图的存储结构</strong></h5><p>要表示一幅图，只需要表示清楚以下两部分内容即可：</p>
<ol>
<li>图中所有的顶点；</li>
<li>所有连接顶点的边；</li>
</ol>
<p>常见的图的存储结构有两种：邻接矩阵和邻接表</p>
<p> <strong>邻接矩阵</strong></p>
<ol>
<li>使用一个V*V的二维数组int[V][V] adj,把索引的值看做是顶点；</li>
<li>如果顶点v和顶点w相连，我们只需要将adj[v][w]和adj[w][v]的值设置为1,否则设置为0即可。</li>
</ol>
<p>邻接矩阵这种存储方式的空间复杂度是V^2的，如果我们处理的问题规模比较大的话，内存空间极有可能不够用。</p>
<p><strong>邻接表</strong></p>
<ol>
<li>使用一个大小为V的数组 Queue[V] adj，把索引看做是顶点；</li>
<li>每个索引处adj[v]存储了一个队列，该队列中存储的是所有与该顶点相邻的其他顶点</li>
</ol>
<p>邻接表的空间并不是是线性级别的，采用邻接表这种存储形式来表示图</p>
<h5 id="图的实现"><a href="#图的实现" class="headerlink" title="图的实现"></a><strong>图的实现</strong></h5><p><strong>API设计</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>UndirectedGraph</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>UndirectedGraph(int V)：创建一个包含V个顶点但不包含边的图</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public int V():获取图中顶点的数量<br>2.public int E():获取图中边的数量<br>3.public void addEdge(int v,int w):向图中添加一条边 v-w<br>4.public Queue adj(int v)：获取和顶点v相邻的所有顶点</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private int V: 记录顶点数量<br>2.private int E: 记录边数量<br>3.private Queue[] adj: 邻接表</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.graph;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 无向图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-21</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UndirectedGraph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="comment">//边的数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> E;</span><br><span class="line">    <span class="comment">//邻接表</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt;[] adj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UndirectedGraph</span><span class="params">(<span class="type">int</span> V)</span>&#123;</span><br><span class="line">        <span class="comment">//初始化顶点数量</span></span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        <span class="comment">//初始化边的数量</span></span><br><span class="line">        <span class="built_in">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化邻接表</span></span><br><span class="line">        <span class="built_in">this</span>.adj = <span class="keyword">new</span> <span class="title class_">Queue</span>[V];</span><br><span class="line">        <span class="comment">//初始化邻接表中的空队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; adj.length; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> <span class="title class_">Queue</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取顶点数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">V</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取图中边的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">E</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向图中添加一条边 v-w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">        <span class="comment">//把w添加到v的链表中，这样顶点v就多了一个相邻点w</span></span><br><span class="line">        adj[v].enqueue(w);</span><br><span class="line">        <span class="comment">//把v添加到w的链表中，这样顶点w就多了一个相邻点v</span></span><br><span class="line">        adj[w].enqueue(v);</span><br><span class="line">        <span class="comment">//边的数目自增1</span></span><br><span class="line">        E++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取和顶点v相邻的所有顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">adj</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="图的搜索"><a href="#图的搜索" class="headerlink" title="图的搜索"></a>图的搜索</h5><p><strong>深度优先搜索</strong></p>
<p>​		所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找子结点，然后找兄弟结点。</p>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>DepthFirstSearch</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>DepthFirstSearch(UndirectedGraph G,int s)：构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相通顶点</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private void dfs(UndirectedGraph G, int v)：使用深度优先搜索找出G图中v顶点的所有相通顶点<br>2.public boolean marked(int w):判断w顶点与s顶点是否相通<br>3.public int count():获取与顶点s相通的所有顶点的总数</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索<br>2.private int count：记录有多少个顶点与s顶点相通</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 深度优先搜索</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepthFirstSearch</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索引代表顶点，值表示当前顶点是否已经被搜索</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录有多少个顶点与s顶点相通</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相通顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DepthFirstSearch(UndirectedGraph G,<span class="type">int</span> s)&#123;</span><br><span class="line">        <span class="comment">//创建一个和图的顶点数一样大小的布尔数组</span></span><br><span class="line">        marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[G.V()];</span><br><span class="line">        <span class="comment">//搜索G图中与顶点s相同的所有顶点</span></span><br><span class="line">        dfs(G,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用深度优先搜索找出G图中v顶点的所有相通顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(UndirectedGraph G, <span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="comment">//把当前顶点标记为已搜索</span></span><br><span class="line">        marked[v]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//遍历v顶点的邻接表，得到每一个顶点w</span></span><br><span class="line">        <span class="keyword">for</span> (Integer w : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked(w))&#123;</span><br><span class="line">                dfs(G,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//相通的顶点数量+1</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断w顶点与s顶点是否相通</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">marked</span><span class="params">(<span class="type">int</span> w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取与顶点s相通的所有顶点的总数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>广度优先搜索</strong></p>
<p>​		所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找兄弟结点，然后找子结点</p>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>BreadthFirstSearch</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>BreadthFirstSearch(UndirectedGraph G,int s)：构造广度优先搜索对象，使用广度优先搜索找出G图中s顶点的所有相通顶点</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private void dfs(UndirectedGraph G, int v)：使用深度优先搜索找出G图中v顶点的所有相通顶点<br>2.public boolean marked(int w):判断w顶点与s顶点是否相通<br>3.public int count():获取与顶点s相通的所有顶点的总数</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索<br>2.private int count：记录有多少个顶点与s顶点相通<br>3.private Queue waitSearch: 用来存储待搜索邻接表的点</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gxl.datastructure.line.QuenenLink;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 广度优先搜索</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BreadthFirstSearch</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索引代表顶点，值表示当前顶点是否已经被搜索</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录有多少个顶点与s顶点相通</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存储待搜索邻接表的点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> QuenenLink&lt;Integer&gt; waitSearch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造广度优先搜索对象，使用深广优先搜索找出G图中s顶点的所有相通顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BreadthFirstSearch(UndirectedGraph G, <span class="type">int</span> s)&#123;</span><br><span class="line">        <span class="comment">//创建一个和图的顶点数一样大小的布尔数组</span></span><br><span class="line">        marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[G.V()];</span><br><span class="line">        <span class="comment">//初始化待搜索顶点的队列</span></span><br><span class="line">        waitSearch = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//搜索G图中与顶点s相同的所有顶点</span></span><br><span class="line">        dfs(G,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用广度优先搜索找出G图中v顶点的所有相通顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(UndirectedGraph G, <span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="comment">//把当前顶点标记为已搜索</span></span><br><span class="line">        marked[v]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//把当前顶点v放入到队列中，等待搜索它的邻接表</span></span><br><span class="line">        waitSearch.enqueue(v);</span><br><span class="line">        <span class="comment">//使用while循环从队列中拿出待搜索的顶点wait，进行搜索邻接表</span></span><br><span class="line">        <span class="keyword">while</span> (!waitSearch.isEmpty())&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">wait</span> <span class="operator">=</span> waitSearch.dequeue();</span><br><span class="line">            <span class="keyword">for</span> (Integer w : G.adj(wait)) &#123;</span><br><span class="line">                <span class="comment">//如果当前顶点w没有被搜索过，则递归搜索与w顶点相通的其他顶点</span></span><br><span class="line">                <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                    dfs(G, w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//相通的顶点数量+1</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断w顶点与s顶点是否相通</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">marked</span><span class="params">(<span class="type">int</span> w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取与顶点s相通的所有顶点的总数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>路径查找</strong></p>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>DepthFirstPaths</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>DepthFirstPaths(UndirectedGraph G,int s)：构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相通顶点</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private void dfs(UndirectedGraph G, int v)：使用深度优先搜索找出G图中v顶点的所有相通顶点<br>2.public boolean hasPathTo(int v):判断v顶点与s顶点是否存在路径<br>3.public Stack pathTo(int v):找出从起点s到顶点v的路径(就是该路径经过的顶点)</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索<br>2.private int s：起点<br>3.private int[] edgeTo: 索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gxl.datastructure.line.StackLink;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 路径查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepthFirstPaths</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索引代表顶点，值表示当前顶点是否已经被搜索</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> s;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] edgeTo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造深度优先搜索对象，使用深度优先搜索找出G图中起点为s的所有路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DepthFirstPaths</span><span class="params">(UndirectedGraph G, <span class="type">int</span> s)</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个和图的顶点数一样大小的布尔数组</span></span><br><span class="line">        marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[G.V()];</span><br><span class="line">        <span class="comment">//创建一个和图顶点数一样大小的整型数组</span></span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="title class_">int</span>[G.V()];</span><br><span class="line">        <span class="comment">//初始化顶点</span></span><br><span class="line">        <span class="built_in">this</span>.s=s;</span><br><span class="line">        <span class="comment">//搜索G图中起点为s的所有路径</span></span><br><span class="line">        dfs(G,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用深度优先搜索找出G图中v顶点的所有相通顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(UndirectedGraph G, <span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="comment">//把当前顶点标记为已搜素</span></span><br><span class="line">        marked[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//遍历v顶点的邻接表，得到每个顶点w</span></span><br><span class="line">        <span class="keyword">for</span> (Integer w : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[w])&#123;</span><br><span class="line">                <span class="comment">//如果当前顶点w没有被搜索过，则将edgeTo[w]设置为v,表示w的前一个顶点为v，并递归搜索与w顶点相通的其他顶点</span></span><br><span class="line">                edgeTo[w] = v;</span><br><span class="line">                dfs(G,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v顶点与s顶点是否存在路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathTo</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找出从起点s到顶点v的路径(就是该路径经过的顶点)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> StackLink&lt;Integer&gt; <span class="title function_">pathTo</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="comment">//当前v顶点与s顶点不连通，所以直接返回null，没有路径</span></span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建路径中经过的顶点的容器</span></span><br><span class="line">        StackLink&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">StackLink</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//第一次把当前顶点存进去，然后将x变换为到达当前顶点的前一个顶点edgeTo[x],在把前一个顶点存进去，继续将x变化为到达前一个顶点的前一个顶点，继续存，一直到x的值为s为止，相当于逆推法，最后把s放进去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> v; x != s ; x=edgeTo[x]) &#123;</span><br><span class="line">            <span class="comment">//把当前顶点放入容器</span></span><br><span class="line">            path.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        path.push(s);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h4><p><strong>有向图的定义及相关术语</strong></p>
<p><strong>定义：</strong></p>
<p>有向图是一副具有方向性的图，是由一组顶点和一组有方向的边组成的，每条方向的边都连着一对有序的顶点。</p>
<p><strong>出度：</strong></p>
<p>由某个顶点指出的边的个数称为该顶点的出度。</p>
<p><strong>入度：</strong></p>
<p>指向某个顶点的边的个数称为该顶点的入度。</p>
<p><strong>有向路径：</strong></p>
<p>由一系列顶点组成，对于其中的每个顶点都存在一条有向边，从它指向序列中的下一个顶点。</p>
<p><strong>有向环：</strong></p>
<p>一条至少含有一条边，且起点和终点相同的有向路径。</p>
<p><strong>API设计</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Digraph</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Digraph(int V)：创建一个包含V个顶点但不包含边的有向图</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public int V():获取图中顶点的数量<br>2.public int E():获取图中边的数量<br>3.public void addEdge(int v,int w):向有向图中添加一条边 v-&gt;w<br>4.public QueueList adj(int v)：获取由v指出的边所连接的所有顶点<br>5.private Digraph reverse():该图的反向图</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private int V: 记录顶点数量<br>2.private int E: 记录边数量<br>3.private QueueList[] adj: 邻接表</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gxl.datastructure.line.QuenenLink;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 有向图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Digraph</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录顶点数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录边数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> E;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 邻接表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> QuenenLink&lt;Integer&gt;[] adj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法：创建一个包含V个顶点但不包含边的有向图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> V</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Digraph</span><span class="params">(<span class="type">int</span> V)</span>&#123;</span><br><span class="line">        <span class="comment">//初始化顶点数量</span></span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        <span class="comment">//初始化边的数量</span></span><br><span class="line">        <span class="built_in">this</span>.E=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化邻接表</span></span><br><span class="line">        <span class="built_in">this</span>.adj = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>[V];</span><br><span class="line">        <span class="comment">//初始化邻接表中的空队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; adj.length; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取图中顶点的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">V</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取图中边的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">E</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向有向图中添加一条边 v-&gt;w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">        <span class="comment">//由于有向图中边是有向的，v-&gt;w 边，只需要让w出现在v的邻接表中，而不需要让v出现在w的邻接表中</span></span><br><span class="line">        adj[v].enqueue(w);</span><br><span class="line">        E++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取由v指出的边所连接的所有顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> QuenenLink&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该图的反向图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Digraph <span class="title function_">reverse</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//创建新的有向图对象</span></span><br><span class="line">        <span class="type">Digraph</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Digraph</span>(V);</span><br><span class="line">        <span class="comment">//遍历0~V-1所有顶点,拿到每一个顶点v</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            <span class="comment">//得到原图中的v顶点对应的邻接表,原图中的边为 v-&gt;w,则反向图中边为w-&gt;v;</span></span><br><span class="line">            <span class="keyword">for</span> (Integer w : adj[v]) &#123;</span><br><span class="line">                r.addEdge(w,v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><strong>排序原理：</strong></p>
<ol>
<li><p>比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置</p>
</li>
<li><p>对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大</p>
<p>值。</p>
</li>
</ol>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Bubble</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Bubble()：创建Bubble对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序 <br>2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w<br>3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bubble</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组内的元素进行排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (greater(a[j],a[j+<span class="number">1</span>]))&#123;</span><br><span class="line">                    exch(a,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v是否大于w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v,Comparable w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换a数组中，索引i和索引j处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] a = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Bubble.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>冒泡排序的时间复杂度O(N^2)</strong></p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><strong>排序原理：</strong></p>
<p> 1.每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引	处的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引</p>
<p> 2.交换第一个索引处和最小值所在的索引处的值</p>
<p><strong>选择排序API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Selection</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Selection()：创建Selection对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序 <br>2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w<br>3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 选择排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-24</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Selection</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组内的元素进行排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span> &#123;</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= a.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//默认第一个位最小值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">//从i的下一位开始遍历，比较找到最小值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (greater(a[i], a[j])) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换i和minIndex</span></span><br><span class="line">            exch(a, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v是否大于w</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v, Comparable w)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换a数组中，索引i和索引j处的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] a = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Selection.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p><strong>排序原理：</strong></p>
<p>1.把所有的元素分为两组，已经排序的和未排序的；</p>
<p>2.找到未排序的组中的第一个元素，向已经排序的组中进行插入；</p>
<p>3.倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待      	插入元素放到这个位置，其他的元素向后移动一位；</p>
<p><strong>插入排序API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Insertion</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Insertion()：创建Insertion对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序 <br>2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w<br>3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 插入排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-24</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Insertion</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组内的元素进行排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (greater(a[j-<span class="number">1</span>],a[j]))&#123;</span><br><span class="line">                    exch(a,j-<span class="number">1</span>,j);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v是否大于w</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v, Comparable w)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换a数组中，索引i和索引j处的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] a = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Insertion.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p><strong>排序原理：</strong></p>
<ol>
<li>选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组；</li>
<li>对分好组的每一组数据完成插入排序；</li>
<li>减小增长量，最小减为1，重复第二步操作。</li>
</ol>
<p><strong>希尔排序的API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Shell</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Shell()：创建Shell对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序 <br>2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w<br>3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 希尔排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-24</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shell</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组内的元素进行排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="comment">//确定增长量h的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (h&lt;N/<span class="number">2</span>)&#123;</span><br><span class="line">            h=h*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当增量小于1，排序结束</span></span><br><span class="line">        <span class="keyword">while</span> (h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//找到待插入的元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="comment">//a[i]就是待插入的元素</span></span><br><span class="line">                <span class="comment">//把a[i]插入到a[i-h],a[i-2h],a[i-3h]...序列中</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= h; j-=h) &#123;</span><br><span class="line">                    <span class="comment">//a[j]就是待插入元素，依次和a[j-h],a[j-2h],a[j-3h]进行比较，如果a[j]小，那么交换位置，如果不小于，a[j]大，则插入完成。</span></span><br><span class="line">                    <span class="keyword">if</span> (greater(a[j-h],a[j]))&#123;</span><br><span class="line">                        exch(a,j,j-h);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            h/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v是否大于w</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v, Comparable w)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换a数组中，索引i和索引j处的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] a = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Shell.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><strong>排序原理：</strong></p>
<ol>
<li>尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止。</li>
<li>将相邻的两个子组进行合并成一个有序的大组；</li>
<li>不断的重复步骤2，直到最终只有一个组为止。</li>
</ol>
<p><strong>归并排序API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Merge</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Merge()：创建Merge对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序 <br>2.private static void sort(Comparable[] a, int lo, int hi)：对数组a中从索引lo到索引hi之间的元素进行排序<br>3.private static void merge(Comparable[] a, int lo, int mid, int hi):从索引lo到索引mid为一个子组，从索引mid+1到索引hi为另一个子组，把数组a中的这两个子组的数据合并成一个有序的大组（从索引lo到索引hi）<br>4.private static boolean less(Comparable v,Comparable w):判断v是否小于w<br>5.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private static Comparable[] assist：完成归并操作需要的辅助数组</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql索引及调优</title>
    <url>/2023/07/14/Mysql%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h2 id="为什么使用索引"><a href="#为什么使用索引" class="headerlink" title="为什么使用索引"></a>为什么使用索引</h2><p>索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则<code>通过索引查找</code>相关数据，如果不符合则需要<code>全表扫描</code>，即需要一条一条地查找记录，直到找到与条件符合的记录。</p>
<p><img src="index.png" alt="image-20230714142202471"></p>
<p>如上图所示，数据库没有索引的情况下，数据<code>分布在硬盘不同的位置上面</code>，读取数据时，摆臂需要前后摆动查询数据，这样操作非常消耗时间。如果<code>数据顺序摆放</code>，那么也需要从1到6行按顺序读取，这样就相当于进行了6次IO操作，<code>依旧非常耗时</code>。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找 Col 2 &#x3D; 89 这条记录，就要逐行去查找、去比较。从Col 2 &#x3D; 34 开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有<code>上千万条数据</code>，就意味着要做<code>很多很多次硬盘I/0</code>才能找到。现在要查找 Col 2 &#x3D; 89 这条记录。CPU必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间就是磁盘I&#x2F;O（涉及到磁盘的旋转时间（速度较快），磁头的寻道时间(速度慢、费时)）</p>
<p>假如给数据使用 <code>二叉树</code> 这样的数据结构进行存储，如下图所示</p>
<p><img src="image-20230714142455822.png" alt="image-20230714142455822">对字段 Col 2 添加了索引，就相当于在硬盘上为 Col 2 维护了一个索引的数据结构，即这个 <code>二叉搜索树</code>。二叉搜索树的每个结点存储的是 <code>(K, V) 结构</code>，key 是 Col 2，value 是该 key 所在行的文件指针（地址）。比如：该二叉搜索树的根节点就是：<code>(34, 0x07)</code>。现在对 Col 2 添加了索引，这时再去查找 Col 2 &#x3D; 89 这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找)。读 34 到内存，89 &gt; 34; 继续右侧数据，读 89 到内存，89&#x3D;&#x3D;89；找到数据返回。找到之后就根据当前结点的 value 快速定位到要查找的记录对应的地址。我们可以发现，只需要 <code>查找两次</code> 就可以定位到记录的地址，查询速度就提高了。</p>
<p>这就是我们为什么要建索引，目的就是为了 <code>减少磁盘I/O的次数</code>，加快查询速率。</p>
<h2 id="索引及其优缺点"><a href="#索引及其优缺点" class="headerlink" title="索引及其优缺点"></a>索引及其优缺点</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。</p>
<p><strong>索引的本质</strong>：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 <code>高级查找算法</code> 。</p>
<p><code>索引是在存储引擎中实现的</code>，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的 <code>最大索引数</code>和 <code>最大索引长度</code>。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>类似大学图书馆建书目索引，提高数据检索的效率，降低 <strong>数据库的IO成本</strong> ，这也是创建索引最主 要的原因。</li>
<li>通过创建唯一索引，可以保证数据库表中每一行 <strong>数据的唯一性</strong> 。</li>
<li>在实现数据的 参考完整性方面，可以 <strong>加速表和表之间的连接</strong> 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。</li>
<li>在使用分组和排序子句进行数据查询时，可以显著 <strong>减少查询中分组和排序的时间</strong> ，降低了CPU的消耗。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>增加索引也有许多不利的方面，主要表现在如下几个方面：</p>
<ol>
<li>创建索引和维护索引要 <strong>耗费时间</strong> ，并 且随着数据量的增加，所耗费的时间也会增加。</li>
<li>索引需要占 <strong>磁盘空间</strong> ，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文 件更快达到最大文件尺寸。</li>
<li>虽然索引大大提高了查询速度，同时却会 <strong>降低更新表的速度</strong> 。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 因此，选择使用索引时，需要综合考虑索引的优点和缺点。</li>
</ol>
<p>因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p>
<blockquote>
<p>提示：</p>
<p>索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p>
</blockquote>
<h2 id="InnoDB中索引的推演"><a href="#InnoDB中索引的推演" class="headerlink" title="InnoDB中索引的推演"></a>InnoDB中索引的推演</h2><h3 id="索引之前的查找"><a href="#索引之前的查找" class="headerlink" title="索引之前的查找"></a>索引之前的查找</h3><p>先来看一个精确匹配的例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [列名列表] <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="operator">=</span> xxx;</span><br></pre></td></tr></table></figure>

<h4 id="在一个页中的查找"><a href="#在一个页中的查找" class="headerlink" title="在一个页中的查找"></a>在一个页中的查找</h4><p>假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p>
<ul>
<li><p>以主键为搜索条件</p>
<p>可以在页目录中使用 <code>二分法</code> 快速定位到对应的槽，然后再遍历该槽对用分组中的记录即可快速找到指定记录。</p>
</li>
<li><p>以其他列作为搜索条件</p>
<p>因为在数据页中并没有对非主键列简历所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从 <code>最小记录</code> 开始 <code>依次遍历单链表中的每条记录</code>， 然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</p>
</li>
</ul>
<h4 id="在很多页中查找"><a href="#在很多页中查找" class="headerlink" title="在很多页中查找"></a>在很多页中查找</h4><p>在很多页中查找记录的活动可以分为两个步骤：</p>
<ol>
<li>定位到记录所在的页。</li>
<li>从所在的页内中查找相应的记录。</li>
</ol>
<p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能 从第一个页沿着双向链表 一直往下找，在每一个页中根据我们上面的查找方式去查 找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 超级耗时 的。如果一个表有一亿条记录呢？此时 索引 应运而生。</p>
<h3 id="设计索引"><a href="#设计索引" class="headerlink" title="设计索引"></a>设计索引</h3><p>建一个表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo(</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> c1 <span class="type">INT</span>,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> c2 <span class="type">INT</span>,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> c3 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">PRIMARY</span> KEY(c1)</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> ) ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure>

<p>这个新建的 <strong>index_demo</strong> 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键， 这个表使用 <strong>Compact</strong> 行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：</p>
<p><img src="image-20230714143358038.png" alt="image-20230714143358038"></p>
<p>我们只在示意图里展示记录的这几个部分：</p>
<ul>
<li>record_type ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记 录、 3 表示最大记录、 1 暂时还没用过，下面讲。</li>
<li>mysql&gt; CREATE TABLE index_demo( -&gt; c1 INT, -&gt; c2 INT, -&gt; c3 CHAR(1), -&gt; PRIMARY KEY(c1) -&gt; ) ROW_FORMAT &#x3D; Compact; next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用 箭头来表明下一条记录是谁。</li>
<li>各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。</li>
<li>其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li>
</ul>
<p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p>
<p><img src="image-20230714143826132.png" alt="image-20230714143826132"></p>
<p>把一些记录放到页里的示意图就是：</p>
<p><img src="image-20230714143859703.png" alt="image-20230714143859703"></p>
<h4 id="一个简单的索引设计方案"><a href="#一个简单的索引设计方案" class="headerlink" title="一个简单的索引设计方案"></a>一个简单的索引设计方案</h4><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们 <strong>想快速的定位到需要查找的记录在哪些数据页</strong> 中该咋办？我们可以为快速定位记录所在的数据页而建立一个目录 ，建这个目录必须完成下边这些事：</p>
<ul>
<li><p><strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</strong></p>
<p>假设：每个数据结构最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> index_demo <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="string">&#x27;u&#x27;</span>), (<span class="number">3</span>, <span class="number">9</span>, <span class="string">&#x27;d&#x27;</span>), (<span class="number">5</span>, <span class="number">3</span>, <span class="string">&#x27;y&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p> 那么这些记录以及按照主键值的大小串联成一个单向链表了，如图所示：</p>
<p><img src="image-20230714144032027.png" alt="image-20230714144032027"></p>
<p>从图中可以看出来， index_demo 表中的3条记录都被插入到了编号为10的数据页中了。此时我们再来插入一条记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> index_demo <span class="keyword">VALUES</span>(<span class="number">4</span>, <span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>因为 <strong>页10</strong> 最多只能放3条记录，所以我们不得不再分配一个新页：</p>
<p><img src="image-20230714144140221.png" alt="image-20230714144140221"></p>
<p>注意：新分配的 <strong>数据页编号可能并不是连续的</strong>。它们只是通过维护者上一个页和下一个页的编号而建立了 <strong>链表</strong> 关系。另外，<strong>页10</strong>中用户记录最大的主键值是5，而<strong>页28</strong>中有一条记录的主键值是4，因为5&gt;4，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为4的记录的时候需要伴随着一次 <strong>记录移动</strong>，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下：</p>
<p><img src="image-20230714144223889.png" alt="image-20230714144223889"></p>
<p>这个过程表明了在对页中的记录进行增删改查操作的过程中，我们必须通过一些诸如 <strong>记录移动</strong> 的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程称为 <strong>页分裂</strong>。</p>
<ul>
<li><strong>给所有的页建立一个目录项。</strong></li>
</ul>
<p>由于数据页的 <strong>编号可能是不连续</strong> 的，所以在向 index_demo 表中插入许多条记录后，可能是这样的效果：</p>
<p><img src="image-20230714144331137.png" alt="image-20230714144331137"></p>
<p>我们需要给它们做个 <strong>目录</strong>，每个页对应一个目录项，每个目录项包括下边两个部分：</p>
<p>1）页的用户记录中最小的主键值，我们用 <strong>key</strong> 来表示。</p>
<p>2）页号，我们用 <strong>page_on</strong> 表示。</p>
<p><img src="image-20230714154813715.png" alt="image-20230714154813715"></p>
<p>以 页28 为例，它对应 目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主 键值 5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键 值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：</p>
<ol>
<li>先从目录项中根据 二分法 快速确定出主键值为 20 的记录在 目录项3 中（因为 12 &lt; 20 &lt; 209 ），它对应的页是 页9 。</li>
<li>再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。</li>
</ol>
<p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 <strong>索引</strong> 。</p>
<h4 id="InnoDB中的索引方案"><a href="#InnoDB中的索引方案" class="headerlink" title="InnoDB中的索引方案"></a>InnoDB中的索引方案</h4><h5 id="迭代1次：目录项纪录的页"><a href="#迭代1次：目录项纪录的页" class="headerlink" title="迭代1次：目录项纪录的页"></a>迭代1次：目录项纪录的页</h5><p>InnoDB怎么区分一条记录是普通的 <strong>用户记录</strong> 还是 <strong>目录项记录</strong> 呢？使用记录头信息里的 <strong>record_type</strong> 属性，它的各自取值代表的意思如下：</p>
<ul>
<li>0：普通的用户记录</li>
<li>1：目录项记录</li>
<li>2：最小记录</li>
<li>3：最大记录</li>
</ul>
<p>我们把前边使用到的目录项放到数据页中的样子就是这样：</p>
<p><img src="image-20230714155726688.png" alt="image-20230714155726688"></p>
<p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 <strong>目录项记录</strong> 和普通的 <strong>用户记录</strong> 的不同点：</p>
<ul>
<li><strong>目录项记录</strong> 的 record_type 值是1，而 <strong>普通用户记录</strong> 的 record_type 值是0。</li>
<li>目录项记录只有 <strong>主键值和页的编号</strong> 两个列，而普通的用户记录的列是用户自己定义的，可能包含 <strong>很多列</strong> ，另外还有InnoDB自己添加的隐藏列。</li>
<li>了解：记录头信息里还有一个叫 <strong>min_rec_mask</strong> 的属性，只有在存储 <strong>目录项记录</strong> 的页中的主键值最小的 <strong>目录项记录</strong> 的 <strong>min_rec_mask</strong> 值为 <strong>1</strong> ，其他别的记录的 <strong>min_rec_mask</strong> 值都是 <strong>0</strong> 。</li>
</ul>
<p><strong>相同点</strong>：两者用的是一样的数据页，都会为主键值生成 <strong>Page Directory （页目录）</strong>，从而在按照主键值进行查找时可以使用 <strong>二分法</strong> 来加快查询速度。</p>
<p>现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p>
<ol>
<li>先到存储 目录项记录 的页，也就是页30中通过 二分法 快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9。</li>
<li>再到存储用户记录的页9中根据 二分法 快速定位到主键值为 20 的用户记录。</li>
</ol>
<h5 id="迭代2次：多个目录项纪录的页"><a href="#迭代2次：多个目录项纪录的页" class="headerlink" title="迭代2次：多个目录项纪录的页"></a>迭代2次：多个目录项纪录的页</h5><p><img src="image-20230714155915297.png" alt="image-20230714155915297"></p>
<p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：</p>
<ul>
<li>为存储该用户记录而新生成了 页31 。</li>
<li>因为原先存储目录项记录的 页30的容量已满 （我们前边假设只能存储4条目录项记录），所以不得 不需要一个新的 页32 来存放 页31 对应的目录项。</li>
</ul>
<p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为 20 的记录为例：</p>
<ol>
<li>确定 目录项记录页 我们现在的存储目录项记录的页有两个，即 页30 和 页32 ，又因为页30表示的目录项的主键值的 范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目 录项记录在 页30 中。</li>
<li>通过目录项记录页 确定用户记录真实所在的页 。 在一个存储 目录项记录 的页中通过主键值定位一条目录项记录的方式说过了。</li>
<li>在真实存储用户记录的页中定位到具体的记录。</li>
</ol>
<h5 id="迭代3次：目录项记录页的目录页"><a href="#迭代3次：目录项记录页的目录页" class="headerlink" title="迭代3次：目录项记录页的目录页"></a>迭代3次：目录项记录页的目录页</h5><p>如果我们表中的数据非常多则会<code>产生很多存储目录项记录的页</code>，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个<code>更高级的目录</code>，就像是一个多级目录一样，<code>大目录里嵌套小目录</code>，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p>
<p><img src="image-20230714160026724.png" alt="image-20230714160026724"></p>
<p>如图，我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用 户记录的主键值在 [1, 320) 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的 话，就到页32中查找更详细的目录项记录。</p>
<p>我们可以用下边这个图来描述它：</p>
<p><img src="image-20230714160111944.png" alt="image-20230714160111944"></p>
<p>这个数据结构，它的名称是 B+树 。</p>
<h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h5><p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存 放 1000条目录项记录 ，那么：</p>
<ul>
<li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。</li>
<li>如果B+树有2层，最多能存放 1000×100&#x3D;10,0000 条记录。</li>
<li>如果B+树有3层，最多能存放 1000×1000×100&#x3D;1,0000,0000 条记录。</li>
<li>如果B+树有4层，最多能存放 1000×1000×1000×100&#x3D;1000,0000,0000 条记录。相当多的记录！</li>
</ul>
<p>你的表里能存放 <strong>100000000000</strong> 条记录吗？所以一般情况下，我们用到的 <strong>B+树都不会超过4层</strong> ，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的 <strong>Page Directory</strong> （页目录），所以在页面内也可以通过 <strong>二分法</strong> 实现快速 定位记录。</p>
<h3 id="常见索引概念"><a href="#常见索引概念" class="headerlink" title="常见索引概念"></a>常见索引概念</h3><p>索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集 索引称为二级索引或者辅助索引。</p>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引并不是一种单独的索引类型，而是<strong>一种数据存储方式</strong>（所有的用户记录都存储在了叶子结点），也就是所谓的 <code>索引即数据，数据即索引</code>。</p>
<blockquote>
<p>术语”聚簇”表示当前数据行和相邻的键值聚簇的存储在一起</p>
</blockquote>
<p><strong>特点：</strong></p>
<ul>
<li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p>
<ul>
<li><code>页内</code> 的记录是按照主键的大小顺序排成一个 <code>单向链表</code> 。</li>
<li>各个存放 <code>用户记录的页</code> 也是根据页中用户记录的主键大小顺序排成一个 <code>双向链表</code> 。</li>
<li>存放 <code>目录项记录的页</code> 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 <code>双向链表</code> 。</li>
</ul>
</li>
<li><p>B+树的 叶子节点 存储的是完整的用户记录。</p>
<p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p>
</li>
</ul>
<p>我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX 语句去创建， <code>InnDB</code> 存储引擎会 <code>自动</code> 的为我们创建聚簇索引。</p>
<p><strong>优点：</strong></p>
<ul>
<li><code>数据访问更快</code> ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li>
<li>聚簇索引对于主键的 <code>排序查找</code> 和 <code>范围查找</code> 速度非常快</li>
<li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 <code>节省了大量的io操作</code> 。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><code>插入速度严重依赖于插入顺序</code> ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<code>自增的ID列为主键</code></li>
<li><code>更新主键的代价很高</code> ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li>
<li><code>二级索引访问需要两次索引查找</code> ，第一次找到主键值，第二次根据主键值找到行数据</li>
</ul>
<h4 id="二级索引（辅助索引、非聚簇索引）"><a href="#二级索引（辅助索引、非聚簇索引）" class="headerlink" title="二级索引（辅助索引、非聚簇索引）"></a>二级索引（辅助索引、非聚簇索引）</h4><p>如果我们想以别的列作为搜索条件该怎么办？肯定不能是从头到尾沿着链表依次遍历记录一遍。</p>
<p>答案：我们可以<code>多建几颗B+树</code>，不同的B+树中的数据采用不同的排列规则。比方说我们用<code>c2</code>列的大小作为数据页、页中记录的排序规则，再建一课B+树，效果如下图所示：</p>
<p><img src="image-20230714160245062.png" alt="image-20230714160245062"></p>
<p>这个B+树与上边介绍的聚簇索引有几处不同：</p>
<p><img src="image-20230714160311029.png" alt="image-20230714160311029"></p>
<p><strong>概念：回表</strong></p>
<p>我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根 据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就 是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！</p>
<p><strong>问题</strong>：为什么我们还需要一次 回表 操作呢？直接把完整的用户记录放到叶子节点不OK吗？</p>
<p><strong>回答</strong>：</p>
<p>如果把完整的用户记录放到叶子结点是可以不用回表。但是<code>太占地方</code>了，相当于每建立一课B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。</p>
<p>因为这种按照<code>非主键列</code>建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为<code>二级索引</code>，或者辅助索引。由于使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树为c2列简历的索引。</p>
<p>非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。</p>
<p><img src="image-20230714160414093.png" alt="image-20230714160414093"></p>
<p>小结：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：</p>
<ol>
<li>聚簇索引的<code>叶子节点</code>存储的就是我们的<code>数据记录</code>, 非聚簇索引的叶子节点存储的是<code>数据位置</code>。非聚簇索引不会影响数据表的物理存储顺序。</li>
<li>一个表<code>只能有一个聚簇索引</code>，因为只能有一种排序存储的方式，但可以有<code>多个非聚簇索引</code>，也就是多个索引目录提供数据检索。</li>
<li>使用聚簇索引的时候，数据的<code>查询效率高</code>，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。</li>
</ol>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按 照 c2和c3列 的大小进行排序，这个包含两层含义：</p>
<ul>
<li>先把各个记录和页按照c2列进行排序。</li>
<li>在记录的c2列相同的情况下，采用c3列进行排序</li>
</ul>
<p>为c2和c3建立的索引的示意图如下：</p>
<p><img src="image-20230714160448075.png" alt="image-20230714160448075"></p>
<p>如图所示，我们需要注意以下几点：</p>
<ul>
<li>每条目录项都有c2、c3、页号这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序</li>
<li>B+树叶子节点处的用户记录由c2、c3和主键c1列组成</li>
</ul>
<p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意 思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p>
<ul>
<li>建立 联合索引 只会建立如上图一样的1棵B+树。</li>
<li>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</li>
</ul>
<h3 id="InnoDB的B-树索引的注意事项"><a href="#InnoDB的B-树索引的注意事项" class="headerlink" title="InnoDB的B+树索引的注意事项"></a>InnoDB的B+树索引的注意事项</h3><h4 id="根页面位置万年不动"><a href="#根页面位置万年不动" class="headerlink" title="根页面位置万年不动"></a>根页面位置万年不动</h4><p>实际上B+树的形成过程是这样的：</p>
<ul>
<li>每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个 <code>根结点</code> 页面。最开始表中没有数据的时候，每个B+树索引对应的 <code>根结点</code> 中即没有用户记录，也没有目录项记录。</li>
<li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code> 中。</li>
<li>当根节点中的可用 <code>空间用完时</code> 继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如 <code>页a</code> 中，然后对这个新页进行 <code>页分裂</code> 的操作，得到另一个新页，比如<code>页b</code> 。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到 <code>页a</code> 或者 <code>页b</code> 中，而 <code>根节点</code> 便升级为存储目录项记录的页。</li>
</ul>
<p>这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表创建一个索引，那么它的根节点的页号便会被记录到某个地方。然后凡是 <code>InnoDB</code> 存储引擎需要用到这个索引的时候，都会从哪个固定的地方取出根节点的页号，从而来访问这个索引。</p>
<h4 id="内节点中目录项记录的唯一性"><a href="#内节点中目录项记录的唯一性" class="headerlink" title="内节点中目录项记录的唯一性"></a>内节点中目录项记录的唯一性</h4><p>我们知道B+树索引的内节点中目录项记录的内容是 <code>索引列 + 页号</code> 的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿 index_demo 表为例，假设这个表中的数据是这样的：</p>
<p><img src="image-20230714160708662.png" alt="image-20230714160708662"></p>
<p>如果二级索引中目录项记录的内容只是 <code>索引列 + 页号</code> 的搭配的话，那么为 <code>c2</code> 列简历索引后的B+树应该长这样：</p>
<p><img src="image-20230714160730495.png" alt="image-20230714160730495"></p>
<p>如果我们想新插入一行记录，其中 <code>c1</code> 、<code>c2</code> 、<code>c3</code> 的值分别是: <code>9</code>、<code>1</code>、<code>c</code>, 那么在修改这个为 c2 列建立的二级索引对应的 B+ 树时便碰到了个大问题：由于 <code>页3</code> 中存储的目录项记录是由 <code>c2列 + 页号</code> 的值构成的，<code>页3</code> 中的两条目录项记录对应的 c2 列的值都是1，而我们 <code>新插入的这条记录</code> 的 c2 列的值也是 <code>1</code>，那我们这条新插入的记录到底应该放在 <code>页4</code> 中，还是应该放在 <code>页5</code> 中？答案：对不起，懵了</p>
<p>为了让新插入记录找到自己在那个页面，我们需要<strong>保证在B+树的同一层页节点的目录项记录除页号这个字段以外是唯一的</strong>。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p>
<ul>
<li>索引列的值</li>
<li>主键值</li>
<li>页号</li>
</ul>
<p>也就是我们把<code>主键值</code>也添加到二级索引内节点中的目录项记录，这样就能保住 B+ 树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2建立二级索引后的示意图实际上应该是这样子的：</p>
<p><img src="image-20230714160813585.png" alt="image-20230714160813585"></p>
<p>这样我们再插入记录<code>(9, 1, &#39;c&#39;)</code> 时，由于 <code>页3</code> 中存储的目录项记录是由 <code>c2列 + 主键 + 页号</code> 的值构成的，可以先把新纪录的 <code>c2</code> 列的值和 <code>页3</code> 中各目录项记录的 <code>c2</code> 列的值作比较，如果 <code>c2</code> 列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的 <code>c2列 + 主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新纪录应该被插入到 <code>页5</code> 中。</p>
<h4 id="一个页面最少存储-2-条记录"><a href="#一个页面最少存储-2-条记录" class="headerlink" title="一个页面最少存储 2 条记录"></a>一个页面最少存储 2 条记录</h4><p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常多，而且最后的那个存放真实数据的目录中只存放一条数据。所以 <strong>InnoDB 的一个数据页至少可以存放两条记录</strong>。</p>
<h2 id="MyISAM中的索引方案"><a href="#MyISAM中的索引方案" class="headerlink" title="MyISAM中的索引方案"></a>MyISAM中的索引方案</h2><p>B树索引使用存储引擎如表所示：</p>
<table>
<thead>
<tr>
<th>索引 &#x2F; 存储引擎</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>B-Tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索 引是Btree索引；而Memory默认的索引是Hash索引。</p>
<p>MyISAM引擎使用 B+Tree 作为索引结构，叶子节点的data域存放的是 数据记录的地址 。</p>
<h3 id="MyISAM索引的原理"><a href="#MyISAM索引的原理" class="headerlink" title="MyISAM索引的原理"></a>MyISAM索引的原理</h3><p><img src="image-20230714160937717.png" alt="image-20230714160937717"></p>
<p><img src="image-20230714160952453.png" alt="image-20230714160952453"></p>
<p><img src="image-20230714161009301.png" alt="image-20230714161009301"></p>
<p><img src="image-20230714161024390.png" alt="image-20230714161024390"></p>
<p><img src="image-20230714161042650.png" alt="image-20230714161042650"></p>
<h3 id="MyISAM-与-InnoDB对比"><a href="#MyISAM-与-InnoDB对比" class="headerlink" title="MyISAM 与 InnoDB对比"></a>MyISAM 与 InnoDB对比</h3><p><strong>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区别：</strong></p>
<p>① 在InnoDB存储引擎中，我们只需要根据主键值对 聚簇索引 进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次 回表 操作，意味着MyISAM中建立的索引相当于全部都是 二级索引 。</p>
<p>② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是 分离的 ，索引文件仅保存数 据记录的地址。</p>
<p>③ InnoDB的非聚簇索引data域存储相应记录 主键的值 ，而MyISAM索引记录的是 地址 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域。</p>
<p>④ MyISAM的回表操作是十分 快速 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通 过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p>
<p>⑤ InnoDB要求表 必须有主键 （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐 含字段作为主键，这个字段长度为6个字节，类型为长整型。</p>
<p><strong>小结：</strong></p>
<p><img src="image-20230714161133219.png" alt="image-20230714161133219"></p>
<p><img src="image-20230714161149350.png" alt="image-20230714161149350"></p>
<h2 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h2><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p>
<ul>
<li><p>空间上的代价</p>
<p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p>
</li>
<li><p>时间上的代价</p>
<p>每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每 层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还 是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序 而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需 要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p>
</li>
</ul>
<blockquote>
<p>一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们得学学这些索引在哪些条件下起作用的。</p>
</blockquote>
<h2 id="MySQL数据结构选择的合理性"><a href="#MySQL数据结构选择的合理性" class="headerlink" title="MySQL数据结构选择的合理性"></a>MySQL数据结构选择的合理性</h2><p><img src="image-20230714161542610.png" alt="image-20230714161542610"></p>
<h3 id="全表查询"><a href="#全表查询" class="headerlink" title="全表查询"></a>全表查询</h3><h3 id="Hash查询"><a href="#Hash查询" class="headerlink" title="Hash查询"></a>Hash查询</h3><p><img src="image-20230714161720301.png" alt="image-20230714161720301"></p>
<p><strong>加快查找速度的数据结构，常见的有两类：</strong></p>
<p>(1) 树，例如平衡二叉搜索树，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是 <code>O(log2N)</code>;</p>
<p>(2)哈希，例如HashMap，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是 <code>O(1)</code>; (key, value)</p>
<p><img src="image-20230714161800540.png" alt="image-20230714161800540"></p>
<p><img src="image-20230714161820538.png" alt="image-20230714161820538"></p>
<p><img src="image-20230714161838622.png" alt="image-20230714161838622"></p>
<p>上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做 碰撞 ，在数据库中一般采用 链 接法 来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：</p>
<p><img src="image-20230714161928952.png" alt="image-20230714161928952"></p>
<p><strong>Hash结构效率高，那为什么索引结构要设计成树型呢？</strong></p>
<p><img src="image-20230714161957648.png" alt="image-20230714161957648"></p>
<p><strong>Hash索引适用存储引擎如表所示：</strong></p>
<table>
<thead>
<tr>
<th>索引 &#x2F; 存储引擎</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>HASH索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p><strong>Hash索引的适用性：</strong></p>
<p><img src="image-20230714162023308.png" alt="image-20230714162023308"></p>
<p><img src="image-20230714162039666.png" alt="image-20230714162039666"></p>
<p>采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时 候，通过自适应 Hash 索引可以明显提高数据的检索效率。</p>
<p>我们可以通过 innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%adaptive_hash_index&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p>
<p><strong>二叉搜索树的特点</strong></p>
<ul>
<li>一个节点只能有两个子节点，也就是一个节点度不能超过2</li>
<li>左子节点 &lt; 本节点; 右子节点 &gt;&#x3D; 本节点，比我大的向右，比我小的向左</li>
</ul>
<p><strong>查找规则</strong></p>
<p><img src="image-20230714162216120.png" alt="image-20230714162216120"></p>
<p><img src="image-20230714162235278.png" alt="image-20230714162235278"></p>
<p>但是特殊情况，就是有时候二叉树的深度非常大，比如：</p>
<p><img src="image-20230714162258227.png" alt="image-20230714162258227"></p>
<p>为了提高查询效率，就需要 减少磁盘IO数 。为了减少磁盘IO的次数，就需要尽量 降低树的高度 ，需要把 原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。</p>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p><img src="image-20230714162320731.png" alt="image-20230714162320731"></p>
<p><img src="image-20230714162335531.png" alt="image-20230714162335531"></p>
<p>每访问一次节点就需要进行一次磁盘 I&#x2F;O 操作，对于上面的树来说，我们需要进行 5次 I&#x2F;O 操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘 I&#x2F;O 操作次数多，会影响整体数据查询的效率。</p>
<p>针对同样的数据，如果我们把二叉树改成 M 叉树 （M&gt;2）呢？当 M&#x3D;3 时，同样的 31 个节点可以由下面 的三叉树来进行存储：</p>
<p><img src="image-20230714162418300.png" alt="image-20230714162418300"></p>
<p>你能看到此时树的高度降低了，当数据量 N 大的时候，以及树的分叉树 M 大的时候，M叉树的高度会远小于二叉树的高度 (M &gt; 2)。所以，我们需要把 &#96;树从“瘦高” 变 “矮胖”。</p>
<h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>B 树的英文是 Balance Tree，也就是 <code>多路平衡查找树</code>。简写为 B-Tree。它的高度远小于平衡二叉树的高度。</p>
<p>B 树的结构如下图所示：</p>
<p><img src="image-20230714162458716.png" alt="image-20230714162458716"></p>
<p><img src="image-20230714162510428.png" alt="image-20230714162510428"></p>
<p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p>
<ol>
<li>根节点的儿子数的范围是 [2,M]。</li>
<li>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 &#x3D; 关键字的数量 +1，k 的取值范围为 [ceil(M&#x2F;2), M]。</li>
<li>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M&#x2F;2), M]。</li>
<li>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]&lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树。</li>
<li>所有叶子节点位于同一层。</li>
</ol>
<p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它 有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15) 大于 12，刚好符合刚才我们给出的特征。</p>
<p>然后我们来看下如何用 B 树进行查找。假设我们想要 查找的关键字是 9 ，那么步骤可以分为以下几步：</p>
<ol>
<li>我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1；</li>
<li>按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2；</li>
<li>按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。</li>
</ol>
<p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比 较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I&#x2F;O 操作，消耗的时间比在内存中进行 比较所需要的时间要多，是数据查找用时的重要因素。 B 树相比于平衡二叉树来说磁盘 I&#x2F;O 操作要少 ， 在数据查询中比平衡二叉树效率要高。所以 只要树的高度足够低，IO次数足够少，就可以提高查询性能 。</p>
<p><img src="image-20230714162541238.png" alt="image-20230714162541238"></p>
<p><img src="image-20230714162559287.png" alt="image-20230714162559287"></p>
<h3 id="B-Tree-2"><a href="#B-Tree-2" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>B+Tree是一种多路搜索树，基于B树做出了改进，主流的DBMS都支持B+Tree的索引方式，相比于B-Tree，B+Tree更适合文件索引系统</p>
<p><strong>B+ 树和 B 树的差异在于以下几点：</strong></p>
<ol>
<li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字数 +1。</li>
<li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最 小）。</li>
<li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， 非 叶子节点既保存索引，也保存数据记录 。</li>
<li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大 小从小到大顺序链接。</li>
</ol>
<p><img src="image-20230714162812288.png" alt="image-20230714162812288"></p>
<p><img src="image-20230714162827963.png" alt="image-20230714162827963"></p>
<p><img src="image-20230714162844889.png" alt="image-20230714162844889"></p>
<p><img src="image-20230714162901691.png" alt="image-20230714162901691"></p>
<blockquote>
<p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。 但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</p>
</blockquote>
<p><strong>思考题：为了减少IO，索引树会一次性加载吗？</strong></p>
<p><img src="image-20230714162958135.png" alt="image-20230714162958135"></p>
<p><strong>思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p>
<p><img src="image-20230714163021807.png" alt="image-20230714163021807"></p>
<p><strong>思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p>
<p><img src="image-20230714163038655.png" alt="image-20230714163038655"></p>
<p><strong>思考题：Hash 索引与 B+ 树索引的区别</strong></p>
<p><img src="image-20230714163108708.png" alt="image-20230714163108708"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="image-20230714163142974.png" alt="image-20230714163142974"></p>
<h3 id="附录：算法的时间复杂度"><a href="#附录：算法的时间复杂度" class="headerlink" title="附录：算法的时间复杂度"></a>附录：算法的时间复杂度</h3><p>同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在 于选择合适算法和改进算法。</p>
<p><img src="image-20230714163203219.png" alt="image-20230714163203219"></p>
<h2 id="InnoDB数据存储结构"><a href="#InnoDB数据存储结构" class="headerlink" title="InnoDB数据存储结构"></a>InnoDB数据存储结构</h2><h3 id="数据库的存储结构：页"><a href="#数据库的存储结构：页" class="headerlink" title="数据库的存储结构：页"></a>数据库的存储结构：页</h3><p>索引结构给我们提供了高效的索引方式，不过索引信息和数据记录都是保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的存储引擎负责对表中数据的读写工作。不同的存储引擎的存放的格式一般是不同的，甚至有的存储引擎不用磁盘来存储数据（Memory）</p>
<h4 id="磁盘与内存交互基本单位：页"><a href="#磁盘与内存交互基本单位：页" class="headerlink" title="磁盘与内存交互基本单位：页"></a>磁盘与内存交互基本单位：页</h4><p>InnoDB将数据划分为若干个也，InnoDB中页的大小默认是16KB。</p>
<p>以页作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，数据库中，不论是读一行还是读多行，都是将这些行所在的页进行加载，也就是说，数据库管理存储空间的基本单位是页，数据库I&#x2F;O操作的最小单位是页，一个页中可以存储多个行记录。</p>
<p><img src="image-20230717090642194.png" alt="image-20230717090642194"></p>
<h4 id="页结构的概述"><a href="#页结构的概述" class="headerlink" title="页结构的概述"></a>页结构的概述</h4><p>这些页可以不在物理结构上相连，只要通过双向链表相关联即可，每个数据页中的记录会按照主键值从小到大顺序组成一个单向链表，每个数据页都会为存储在它里面的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历槽对应分组中的记录即可快速找到指定的目录。</p>
<h4 id="页的大小"><a href="#页的大小" class="headerlink" title="页的大小"></a>页的大小</h4><p>不同的数据库管理系统（简称DBMS）的页大小不同。比如在 MySQL 的 InnoDB 存储引擎中，默认页的大小是 <code>16KB</code>，我们可以通过下面的命令来进行查看：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_page_size%&#x27;</span></span><br></pre></td></tr></table></figure>

<p>SQL Server 中页的大小为 <code>8KB</code>，而在 Oracle 中我们用术语 “<code>块</code>“ （Block）来表示 “页”，Oracle 支持的快大小为2KB, 4KB, 8KB, 16KB, 32KB 和 64KB。</p>
<h4 id="页的上层结构"><a href="#页的上层结构" class="headerlink" title="页的上层结构"></a>页的上层结构</h4><p>另外在数据库中，还存在着区（Extent）、段（Segment）和表空间（Tablespace）的概念。行、页、区、段、表空间的关系如下图所示：</p>
<p><img src="image-20230717180015966.png" alt="image-20230717180015966"></p>
<p><img src="image-20230717180123529.png" alt="image-20230717180123529"></p>
<h3 id="页的内部结构"><a href="#页的内部结构" class="headerlink" title="页的内部结构"></a>页的内部结构</h3><p>页如果按类型划分的话，常见的有 <code>数据页（保存B+树节点）、系统表、Undo 页 和 事务数据页</code> 等。数据页是我们最常使用的页。</p>
<p>数据页的 <code>16KB</code> 大小的存储空间被划分为七个部分，分别是文件头（File Header）、页头（Page Header）、最大最小记录（Infimum + supremum）、用户记录（User Records）、空闲空间（Free Space）、页目录（Page Directory）和文件尾（File Tailer）。</p>
<p>页结构的示意图如下所示：</p>
<p><img src="image-20230717180300109.png" alt="image-20230717180300109"></p>
<p>如下表所示：</p>
<p><img src="image-20230717180327464.png" alt="image-20230717180327464"></p>
<p>我们可以把这7个结构分为3个部分。</p>
<h4 id="第一部分：File-Header-文件头部-和-File-Trailer-文件尾部"><a href="#第一部分：File-Header-文件头部-和-File-Trailer-文件尾部" class="headerlink" title="第一部分：File Header (文件头部) 和 File Trailer (文件尾部)"></a>第一部分：File Header (文件头部) 和 File Trailer (文件尾部)</h4><h4 id="第二部分：User-Records-用户记录-、最大最小记录、Free-Space-空闲空间"><a href="#第二部分：User-Records-用户记录-、最大最小记录、Free-Space-空闲空间" class="headerlink" title="第二部分：User Records (用户记录)、最大最小记录、Free Space (空闲空间)"></a>第二部分：User Records (用户记录)、最大最小记录、Free Space (空闲空间)</h4><h4 id="第三部分：Page-Directory-页目录-和-Page-Header-页面头部"><a href="#第三部分：Page-Directory-页目录-和-Page-Header-页面头部" class="headerlink" title="第三部分：Page Directory (页目录) 和 Page Header (页面头部)"></a>第三部分：Page Directory (页目录) 和 Page Header (页面头部)</h4><h4 id="从数据库页的角度看B-树如何查询"><a href="#从数据库页的角度看B-树如何查询" class="headerlink" title="从数据库页的角度看B+树如何查询"></a>从数据库页的角度看B+树如何查询</h4><p>一颗B+树按照字节类型可以分为两部分：</p>
<ol>
<li>叶子节点，B+ 树最底层的节点，节点的高度为0，存储行记录。</li>
<li>非叶子节点，节点的高度大于0，存储索引键和页面指针，并不存储行记录本身。</li>
</ol>
<p><img src="image-20230717180458188.png" alt="image-20230717180458188"></p>
<p>当我们从页结构来理解 B+ 树的结构的时候，可以帮我们理解一些通过索引进行检索的原理：</p>
<p><strong>B+树是如何进行记录检索的</strong></p>
<p>如果通过B+树的索引查询行记录，首先是从B+树的根开始，逐层检索，直到找到叶子结点，也就是找到对应的数据页为止，将数据页加载到内存中，页目录中的槽采用二分查找的方式，先找到一个祖略的记录分组，然后再在分组中通过链表遍历的方式查找记录</p>
<p><strong>普通索引和唯一索引在查询效率上有什么不同</strong></p>
<p>唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，找到了关键字就停止检索。而普通索引，可能存在用户记录中的关键字相同的情况，根据页结构的原理，当我们读取一条记录的时候，不是将这条记录从索引中读取出来，而是将这个记录所在的页加载到内存中进行读取，InnoDB存储引擎的页大小为16kb，在一个页中可能存着上千个记录，因此在普通索引的字段上进行查找也就是在内存中多几次判断下一条记录的操作。对于CPU来说，这些操作所消耗的时间可以忽略。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本没有差别。</p>
<h3 id="InnoDB行格式-或记录格式"><a href="#InnoDB行格式-或记录格式" class="headerlink" title="InnoDB行格式 (或记录格式)"></a>InnoDB行格式 (或记录格式)</h3><h3 id="区、段与碎片区"><a href="#区、段与碎片区" class="headerlink" title="区、段与碎片区"></a>区、段与碎片区</h3><h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p><img src="image-20230719092120684.png" alt="image-20230719092120684"></p>
<h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p><img src="image-20230719092203365.png" alt="image-20230719092203365"></p>
<h4 id="碎片区"><a href="#碎片区" class="headerlink" title="碎片区"></a>碎片区</h4><p><img src="image-20230719092241880.png" alt="image-20230719092241880"></p>
<h4 id="区的分类"><a href="#区的分类" class="headerlink" title="区的分类"></a>区的分类</h4><p>区大体上可以分为4种类型：</p>
<ul>
<li>空闲的区 (FREE) : 现在还没有用到这个区中的任何页面。</li>
<li>有剩余空间的碎片区 (FREE_FRAG)：表示碎片区中还有可用的页面。</li>
<li>没有剩余空间的碎片区 (FULL_FRAG)：表示碎片区中的所有页面都被使用，没有空闲页面。</li>
<li>附属于某个段的区 (FSEG)：每一个索引都可以分为叶子节点段和非叶子节点段。</li>
</ul>
<p>处于FREE、FREE_FRAG 以及 FULL_FRAG 这三种状态的区都是独立的，直属于表空间。而处于 FSEG 状态的区是附属于某个段的。</p>
<blockquote>
<p>如果把表空间比作是一个集团军，段就相当于师，区就相当于团。一般的团都是隶属于某个师的，就像是处于 FSEG 的区全部隶属于某个段，而处于 FREE、FREE_FRAG 以及 FULL_FRAG 这三种状态的区却直接隶属于表空间，就像独立团直接听命于军部一样。</p>
</blockquote>
<h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p><img src="image-20230719132316627.png" alt="image-20230719132316627"></p>
<h4 id="独立表空间"><a href="#独立表空间" class="headerlink" title="独立表空间"></a>独立表空间</h4><p>独立表空间，即每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间 (即：单表) 可以在不同的数据库之间进行 <code>迁移</code>。</p>
<p>空间可以回收 (DROP TABLE 操作可自动回收表空间；其他情况，表空间不能自己回收) 。如果对于统计分析或是日志表，删除大量数据后可以通过：alter table TableName engine&#x3D;innodb; 回收不用的空间。对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。</p>
<p><strong>独立表空间结构</strong></p>
<p>独立表空间由段、区、页组成。</p>
<p><strong>真实表空间对应的文件大小</strong></p>
<p>我们到数据目录里看，会发现一个新建的表对应的 .ibd 文件只占用了 96K，才6个页面大小 (MySQL5.7中)，这是因为一开始表空间占用的空间很小，因为表里边都没有数据。不过别忘了这些 .ibd 文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。</p>
<p><strong>查看 InnoDB 的表空间类型：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_file_per_table&#x27;</span></span><br></pre></td></tr></table></figure>

<p>你能看到 innodb_file_per_table&#x3D;ON, 这就意味着每张表都会单词保存一个 .ibd 文件。</p>
<h4 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h4><p>系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。</p>
<p><strong>InnoDB数据字典</strong></p>
<p><img src="image-20230719132724247.png" alt="image-20230719132724247"></p>
<p>删除这些数据并不是我们使用 INSERT 语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得以引入的一些额外数据，这些数据页称为 元数据。InnoDB 存储引擎特意定义了一些列的 内部系统表 (internal system table) 来记录这些元数据：</p>
<p><img src="image-20230719132804601.png" alt="image-20230719132804601"></p>
<p>这些系统表也称为 <code>数据字典</code>，它们都是以 B+ 树的形式保存在系统表空间的某个页面中。其中 <code>SYS_TABLES、SYS_COLUMNS、SYS_INDEXES、SYS_FIELDS</code> 这四个表尤其重要，称之为基本系统表 (basic system tables) ，我们先看看这4个表的结构：</p>
<p><img src="image-20230719132835123.png" alt="image-20230719132835123"></p>
<p><img src="image-20230719132907074.png" alt="image-20230719132907074"></p>
<p><img src="image-20230719132925143.png" alt="image-20230719132925143"></p>
<p><img src="image-20230719132943082.png" alt="image-20230719132943082"></p>
<p>注意：用户不能直接访问 InnoDB 的这些内部系统表，除非你直接去解析系统表空间对应文件系统上的文件。不过考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库 <code>information_schema</code> 中提供了一些以 <code>innodb_sys</code> 开头的表:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE information_schema;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_sys%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在 <code>information_scheme</code> 数据库中的这些以 <code>INNODB_SYS</code> 开头的表并不是真正的内部系统表 (内部系统表就是我们上边以 <code>SYS</code> 开头的那些表)，而是在存储引擎启动时读取这些以 <code>SYS</code> 开头的系统表，然后填充到这些以 <code>INNODB_SYS</code> 开头的表中。以 <code>INNODB_SYS</code> 开头的表和以 <code>SYS</code> 开头的表中的字段并不完全一样，但仅供大家参考已经足矣。</p>
<h3 id="数据页加载的三种方式"><a href="#数据页加载的三种方式" class="headerlink" title="数据页加载的三种方式"></a>数据页加载的三种方式</h3><p>InnoDB从磁盘中读取数据 <code>最小单位</code> 是数据页。而你想得到的 id &#x3D; xxx 的数据，就是这个数据页众多行中的一行。</p>
<p>对于MySQL存放的数据，逻辑概念上我们称之为表，在磁盘等物理层面而言是按 <code>数据页</code> 形式进行存放的，当其加载到 MySQL 中我们称之为 <code>缓存页</code>。</p>
<p>如果缓冲池没有该页数据，那么缓冲池有以下三种读取数据的方式，每种方式的读取速率是不同的：</p>
<p><strong>1. 内存读取</strong></p>
<p>如果该数据存在于内存中，基本上执行时间在 1ms 左右，效率还是很高的。</p>
<p><img src="image-20230719133137328.png" alt="image-20230719133137328"></p>
<p><strong>2. 随机读取</strong></p>
<p><img src="image-20230719133223246.png" alt="image-20230719133223246"></p>
<p><img src="image-20230719133239870.png" alt="image-20230719133239870"></p>
<p><strong>3. 顺序读取</strong></p>
<p><img src="image-20230719133309436.png" alt="image-20230719133309436"></p>
<h2 id="性能分析工具的使用"><a href="#性能分析工具的使用" class="headerlink" title="性能分析工具的使用"></a>性能分析工具的使用</h2><p>在数据库调优中，我们的目标是 <code>响应时间更快, 吞吐量更大</code> 。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式。</p>
<h3 id="数据库服务器的优化步骤"><a href="#数据库服务器的优化步骤" class="headerlink" title="数据库服务器的优化步骤"></a>数据库服务器的优化步骤</h3><p>当我们遇到数据库调优问题的时候，该如何思考呢？这里把思考的流程整理成下面这张图。</p>
<p>整个流程划分成了 <code>观察（Show status）</code> 和 <code>行动（Action）</code> 两个部分。字母 S 的部分代表观察（会使 用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。</p>
<p><img src="image-20230719133808779.png" alt="image-20230719133808779"></p>
<p><img src="image-20230719133830949.png" alt="image-20230719133830949"></p>
<p>我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解执行慢的SQL都有哪些，查看具体的SQL执行计划，甚至是SQL执行中的每一步的成本代价，这样才能定位问题所在，找到了问题，再采取相应的行动。</p>
<p><strong>详细解释一下这张图：</strong></p>
<p><img src="image-20230719133904974.png" alt="image-20230719133904974"></p>
<p><img src="image-20230719133923243.png" alt="image-20230719133923243"></p>
<h3 id="查看系统性能参数"><a href="#查看系统性能参数" class="headerlink" title="查看系统性能参数"></a>查看系统性能参数</h3><p>在MySQL中，可以使用 <code>SHOW STATUS</code> 语句查询一些MySQL数据库服务器的<code>性能参数、执行频率</code>。</p>
<p>SHOW STATUS语句语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;参数&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>一些常用的性能参数如下：</p>
<ul>
<li>Connections：连接MySQL服务器的次数。</li>
<li>Uptime：MySQL服务器的上线时间。</li>
<li>Slow_queries：慢查询的次数。</li>
<li>Innodb_rows_read：Select查询返回的行数</li>
<li>Innodb_rows_inserted：执行INSERT操作插入的行数</li>
<li>Innodb_rows_updated：执行UPDATE操作更新的 行数</li>
<li>Innodb_rows_deleted：执行DELETE操作删除的行数</li>
<li>Com_select：查询操作的次数。</li>
<li>Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。</li>
<li>Com_update：更新操作 的次数。</li>
<li>Com_delete：删除操作的次数。</li>
</ul>
<p>若查询MySQL服务器的连接次数，则可以执行如下语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Connections&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>若查询服务器工作时间，则可以执行如下语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Uptime&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>若查询MySQL服务器的慢查询次数，则可以执行如下语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Slow_queries&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>慢查询次数参数可以结合慢查询日志找出慢查询语句，然后针对慢查询语句进行<code>表结构优化</code>或者<code>查询语句优化</code>。</p>
<p>再比如，如下的指令可以查看相关的指令情况：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Innodb_rows_%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="统计SQL的查询成本-last-query-cost"><a href="#统计SQL的查询成本-last-query-cost" class="headerlink" title="统计SQL的查询成本: last_query_cost"></a>统计SQL的查询成本: last_query_cost</h3><p>一条SQL查询语句在执行前需要查询执行计划，如果存在多种执行计划的话，MySQL会计算每个执行计划所需要的成本，从中选择<code>成本最小</code>的一个作为最终执行的执行计划。</p>
<p>如果我们想要查看某条SQL语句的查询成本，可以在执行完这条SQL语句之后，通过查看当前会话中的<code>last_query_cost</code>变量值来得到当前查询的成本。它通常也是我们<code>评价一个查询的执行效率</code>的一个常用指标。这个查询成本对应的是<code>SQL 语句所需要读取的读页的数量</code>。</p>
<p>我们依然使用第8章的 student_info 表为例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student_info` (</span><br><span class="line">    `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `student_id` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">    `name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `course_id` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">    `class_id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `create_time` DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>如果我们想要查询 id&#x3D;900001 的记录，然后看下查询成本，我们可以直接在聚簇索引上进行查找：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time <span class="keyword">FROM</span> student_info <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">900001</span>;</span><br></pre></td></tr></table></figure>

<p>运行结果（1 条记录，运行时间为 0.042s ）</p>
<p>然后再看下查询优化器的成本，实际上我们只需要检索一个页即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SHOW STATUS LIKE <span class="string">&#x27;last_query_cost&#x27;</span>;</span></span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Variable_name   |   Value  |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Last_query_cost | 1.000000 |</span><br><span class="line">+-----------------+----------+</span><br></pre></td></tr></table></figure>

<p>如果我们想要查询 id 在 900001 到 9000100 之间的学生记录呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time <span class="keyword">FROM</span> student_info <span class="keyword">WHERE</span> id <span class="keyword">BETWEEN</span> <span class="number">900001</span> <span class="keyword">AND</span> <span class="number">900100</span>;</span><br></pre></td></tr></table></figure>

<p>运行结果（100 条记录，运行时间为 0.046s ）：</p>
<p>然后再看下查询优化器的成本，这时我们大概需要进行 20 个页的查询。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SHOW STATUS LIKE <span class="string">&#x27;last_query_cost&#x27;</span>;</span></span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   |   Value   |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Last_query_cost | 21.134453 |</span><br><span class="line">+-----------------+-----------+</span><br></pre></td></tr></table></figure>

<p>你能看到页的数量是刚才的 20 倍，但是查询的效率并没有明显的变化，实际上这两个 SQL 查询的时间 基本上一样，就是因为采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然 页 数量（last_query_cost）增加了不少 ，但是通过缓冲池的机制，并 没有增加多少查询时间 。</p>
<p><strong>使用场景：</strong>它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p>
<blockquote>
<p>SQL查询时一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：</p>
<ol>
<li><code>位置决定效率</code>。如果页就在数据库 <code>缓冲池</code> 中，那么效率是最高的，否则还需要从 <code>内存</code> 或者 <code>磁盘</code> 中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li>
<li><code>批量决定效率</code>。如果我们从磁盘中对单一页进行随机读，那么效率是很低的(差不多10ms)，而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li>
</ol>
<p>所以说，遇到I&#x2F;O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是进程使用的数据就要尽量放到<code>缓冲池</code>中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p>
</blockquote>
<h3 id="定位执行慢的-SQL：慢查询日志"><a href="#定位执行慢的-SQL：慢查询日志" class="headerlink" title="定位执行慢的 SQL：慢查询日志"></a>定位执行慢的 SQL：慢查询日志</h3><p><img src="image-20230719134247691.png" alt="image-20230719134247691"></p>
<h4 id="开启慢查询日志参数"><a href="#开启慢查询日志参数" class="headerlink" title="开启慢查询日志参数"></a>开启慢查询日志参数</h4><p><strong>1. 开启 slow_query_log</strong></p>
<p>在使用前，我们需要先查下慢查询是否已经开启，使用下面这条命令即可：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719134330093.png" alt="image-20230719134330093"></p>
<p>我们可以看到 <code>slow_query_log=OFF</code>，我们可以把慢查询日志打开，注意设置变量值的时候需要使用 global，否则会报错：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;ON&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>然后我们再来查看下慢查询日志是否开启，以及慢查询日志文件的位置：</p>
<p><img src="image-20230719134355223.png" alt="image-20230719134355223"></p>
<p>你能看到这时慢查询分析已经开启，同时文件保存在 <code>/var/lib/mysql/atguigu02-slow.log</code> 文件 中。</p>
<p><strong>2. 修改 long_query_time 阈值</strong></p>
<p>接下来我们来看下慢查询的时间阈值设置，使用如下命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719134443576.png" alt="image-20230719134443576"></p>
<p>这里如果我们想把时间缩短，比如设置为 1 秒，可以这样设置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#测试发现：设置<span class="keyword">global</span>的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并</span><br><span class="line">执行下述语句</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> long_query_time <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> long_query_time<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719134514085.png" alt="image-20230719134514085"></p>
<p><strong>补充：配置文件中一并设置参数</strong></p>
<p>如下的方式相较于前面的命令行方式，可以看做是永久设置的方式。</p>
<p>修改 <code>my.cnf</code> 文件，[mysqld] 下增加或修改参数 <code>long_query_time、slow_query_log</code> 和 <code>slow_query_log_file</code> 后，然后重启 MySQL 服务器。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log<span class="operator">=</span><span class="keyword">ON</span>  # 开启慢查询日志开关</span><br><span class="line">slow_query_log_file<span class="operator">=</span><span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu<span class="operator">-</span>low.log  # 慢查询日志的目录和文件名信息</span><br><span class="line">long_query_time<span class="operator">=</span><span class="number">3</span>  # 设置慢查询的阈值为<span class="number">3</span>秒，超出此设定值的<span class="keyword">SQL</span>即被记录到慢查询日志</span><br><span class="line">log_output<span class="operator">=</span>FILE</span><br></pre></td></tr></table></figure>

<p>如果不指定存储路径，慢查询日志默认存储到MySQL数据库的数据文件夹下。如果不指定文件名，默认文件名为hostname_slow.log。</p>
<h4 id="查看慢查询数目"><a href="#查看慢查询数目" class="headerlink" title="查看慢查询数目"></a>查看慢查询数目</h4><p>查询当前系统中有多少条慢查询记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%Slow_queries%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h4><p><strong>步骤1. 建表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">    `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `stuno` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">    `name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `age` <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `classId` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p><strong>步骤2：设置参数 log_bin_trust_function_creators</strong></p>
<p>创建函数，假如报错：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">This <span class="keyword">function</span> has <span class="keyword">none</span> <span class="keyword">of</span> DETERMINISTIC......</span><br></pre></td></tr></table></figure>

<ul>
<li>命令开启：允许创建函数设置：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>; # 不加<span class="keyword">global</span>只是当前窗口有效。</span><br></pre></td></tr></table></figure>

<p><strong>步骤3：创建函数</strong></p>
<p>随机产生字符串：（同上一章）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>)</span><br><span class="line">	<span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>) #该函数会返回一个字符串</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span></span><br><span class="line"><span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line">    	<span class="keyword">SET</span> return_str <span class="operator">=</span>CONCAT(return_str,<span class="built_in">SUBSTRING</span>(chars_str,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line">    	<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line">    <span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line"><span class="keyword">SELECT</span> rand_string(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>产生随机数值：（同上一章）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num (from_num <span class="type">INT</span> ,to_num <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span>RAND()<span class="operator">*</span>(to_num <span class="operator">-</span> from_num<span class="operator">+</span><span class="number">1</span>)) ;</span><br><span class="line">    <span class="keyword">RETURN</span> i;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#测试：</span><br><span class="line"><span class="keyword">SELECT</span> rand_num(<span class="number">10</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><strong>步骤4：创建存储过程</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_stu1( <span class="keyword">START</span> <span class="type">INT</span> , max_num <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>; #设置手动提交事务</span><br><span class="line">    REPEAT #循环</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>; #赋值</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (stuno, NAME ,age ,classId ) <span class="keyword">VALUES</span></span><br><span class="line">    ((<span class="keyword">START</span><span class="operator">+</span>i),rand_string(<span class="number">6</span>),rand_num(<span class="number">10</span>,<span class="number">100</span>),rand_num(<span class="number">10</span>,<span class="number">1000</span>));</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">    <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>; #提交事务</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p><strong>步骤5：调用存储过程</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#调用刚刚写好的函数, <span class="number">4000000</span>条记录,从<span class="number">100001</span>号开始</span><br><span class="line"><span class="keyword">CALL</span> insert_stu1(<span class="number">100001</span>,<span class="number">4000000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="测试及分析"><a href="#测试及分析" class="headerlink" title="测试及分析"></a>测试及分析</h4><p><strong>1. 测试</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SELECT * FROM student WHERE stuno = 3455655;</span></span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">|   id    |  stuno  |  name  | age  | classId |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| 3523633 | 3455655 | oQmLUr |  19  |    39   |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">1 row in set (2.09 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SELECT * FROM student WHERE name = <span class="string">&#x27;oQmLUr&#x27;</span>;</span></span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">|   id    |  stuno  |  name  |  age | classId |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| 1154002 | 1243200 | OQMlUR | 266  |   28    |</span><br><span class="line">| 1405708 | 1437740 | OQMlUR | 245  |   439   |</span><br><span class="line">| 1748070 | 1680092 | OQMlUR | 240  |   414   |</span><br><span class="line">| 2119892 | 2051914 | oQmLUr | 17   |   32    |</span><br><span class="line">| 2893154 | 2825176 | OQMlUR | 245  |   435   |</span><br><span class="line">| 3523633 | 3455655 | oQmLUr | 19   |   39    |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">6 rows in set (2.39 sec)</span><br></pre></td></tr></table></figure>

<p>从上面的结果可以看出来，查询学生编号为“3455655”的学生信息花费时间为2.09秒。查询学生姓名为 “oQmLUr”的学生信息花费时间为2.39秒。已经达到了秒的数量级，说明目前查询效率是比较低的，下面 的小节我们分析一下原因。</p>
<p><strong>2. 分析</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;slow_queries&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719134805361.png" alt="image-20230719134805361"></p>
<h4 id="慢查询日志分析工具：mysqldumpslow"><a href="#慢查询日志分析工具：mysqldumpslow" class="headerlink" title="慢查询日志分析工具：mysqldumpslow"></a>慢查询日志分析工具：mysqldumpslow</h4><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具 <code>mysqldumpslow</code> 。</p>
<p>查看mysqldumpslow的帮助信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldumpslow --help</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719134851652.png" alt="image-20230719134851652"></p>
<p>mysqldumpslow 命令的具体参数如下：</p>
<ul>
<li>-a: 不将数字抽象成N，字符串抽象成S</li>
<li>-s: 是表示按照何种方式排序：<ul>
<li>c: 访问次数</li>
<li>l: 锁定时间</li>
<li>r: 返回记录</li>
<li>t: 查询时间</li>
<li>al:平均锁定时间</li>
<li>ar:平均返回记录数</li>
<li>at:平均查询时间 （默认方式）</li>
<li>ac:平均查询次数</li>
</ul>
</li>
<li>-t: 即为返回前面多少条的数据；</li>
<li>-g: 后边搭配一个正则匹配模式，大小写不敏感的；</li>
</ul>
<p>举例：我们想要按照查询时间排序，查看前五条 SQL 语句，这样写即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s t -t 5 /var/lib/mysql/atguigu01-slow.log</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@bogon ~]# mysqldumpslow -s t -t 5 /var/lib/mysql/atguigu01-slow.log</span><br><span class="line"></span><br><span class="line">Reading mysql slow query log from /var/lib/mysql/atguigu01-slow.log</span><br><span class="line">Count: 1 Time=2.39s (2s) Lock=0.00s (0s) Rows=13.0 (13), root[root]@localhost</span><br><span class="line">SELECT * FROM student WHERE name = &#x27;S&#x27;</span><br><span class="line"></span><br><span class="line">Count: 1 Time=2.09s (2s) Lock=0.00s (0s) Rows=2.0 (2), root[root]@localhost</span><br><span class="line">SELECT * FROM student WHERE stuno = N</span><br><span class="line"></span><br><span class="line">Died at /usr/bin/mysqldumpslow line 162, &lt;&gt; chunk 2.</span><br></pre></td></tr></table></figure>

<p><strong>工作常用参考：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">得到返回记录集最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">得到访问次数最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">得到按照时间排序的前10条里面含有左连接的查询语句</span></span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more</span><br></pre></td></tr></table></figure>

<h4 id="关闭慢查询日志"><a href="#关闭慢查询日志" class="headerlink" title="关闭慢查询日志"></a>关闭慢查询日志</h4><p>MySQL服务器停止慢查询日志功能有两种方法：</p>
<p><strong>方式1：永久性方式</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log<span class="operator">=</span>OFF</span><br></pre></td></tr></table></figure>

<p>或者，把slow_query_log一项注释掉 或 删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#slow_query_log <span class="operator">=</span>OFF</span><br></pre></td></tr></table></figure>

<p>重启MySQL服务，执行如下语句查询慢日志功能。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow%&#x27;</span>; #查询慢查询日志所在目录</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%long_query_time%&#x27;</span>; #查询超时时长</span><br></pre></td></tr></table></figure>

<p><strong>方式2：临时性方式</strong></p>
<p>使用SET语句来设置。</p>
<p>（1）停止MySQL慢查询日志功能，具体SQL语句如下。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log<span class="operator">=</span>off;</span><br></pre></td></tr></table></figure>

<p>（2）<strong>重启MySQL服务</strong>，使用SHOW语句查询慢查询日志功能信息，具体SQL语句如下。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow%&#x27;</span>;</span><br><span class="line">#以及</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="删除慢查询日志"><a href="#删除慢查询日志" class="headerlink" title="删除慢查询日志"></a>删除慢查询日志</h4><p>使用SHOW语句显示慢查询日志信息，具体SQL语句如下。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> `slow_query_log<span class="operator">%</span>`;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719135056374.png" alt="image-20230719135056374"></p>
<p>从执行结果可以看出，慢查询日志的目录默认为MySQL的数据目录，在该目录下 <code>手动删除慢查询日志文件</code> 即可。</p>
<p>使用命令 <code>mysqladmin flush-logs</code> 来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqladmin -uroot -p flush-logs slow</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示</p>
<p>慢查询日志都是使用mysqladmin flush-logs命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。</p>
</blockquote>
<h4 id="查看-SQL-执行成本：SHOW-PROFILE"><a href="#查看-SQL-执行成本：SHOW-PROFILE" class="headerlink" title="查看 SQL 执行成本：SHOW PROFILE"></a>查看 SQL 执行成本：SHOW PROFILE</h4><p>show profile 在《逻辑架构》章节中讲过，这里作为复习。</p>
<p>show profile 是 MySQL 提供的可以用来分析当前会话中 SQL 都做了什么、执行的资源消耗工具的情况，可用于 sql 调优的测量。<code>默认情况下处于关闭状态</code>，并保存最近15次的运行结果。</p>
<p>我们可以在会话级别开启这个功能。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;profiling&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719135757901.png" alt="image-20230719135757901"></p>
<p>通过设置 profiling&#x3D;’ON’ 来开启 show profile:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> profiling <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719135827047.png" alt="image-20230719135827047"></p>
<p>然后执行相关的查询语句。接着看下当前会话都有哪些 profiles，使用下面这条命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> profiles;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719135859294.png" alt="image-20230719135859294"></p>
<p>你能看到当前会话一共有 2 个查询。如果我们想要查看最近一次查询的开销，可以使用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> profile;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719135924156.png" alt="image-20230719135924156"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profile cpu,block io <span class="keyword">for</span> query <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><img src="image-20230719135959180.png" alt="image-20230719135959180"></p>
<p><strong>show profile的常用查询参数：</strong></p>
<p>① ALL：显示所有的开销信息。</p>
<p>② BLOCK IO：显示块IO开销。</p>
<p>③ CONTEXT SWITCHES：上下文切换开销。</p>
<p>④ CPU：显示CPU开销信息。</p>
<p>⑤ IPC：显示发送和接收开销信息。</p>
<p>⑥ MEMORY：显示内存开销信 息。</p>
<p>⑦ PAGE FAULTS：显示页面错误开销信息。</p>
<p>⑧ SOURCE：显示和Source_function，Source_file， Source_line相关的开销信息。</p>
<p>⑨ SWAPS：显示交换次数开销信息。</p>
<p><strong>日常开发需注意的结论：</strong></p>
<p>① <code>converting HEAP to MyISAM</code>: 查询结果太大，内存不够，数据往磁盘上搬了。</p>
<p>② <code>Creating tmp table</code>：创建临时表。先拷贝数据到临时表，用完后再删除临时表。</p>
<p>③ <code>Copying to tmp table on disk</code>：把内存中临时表复制到磁盘上，警惕！</p>
<p>④ <code>locked</code>。</p>
<p>如果在show profile诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化。</p>
<p><strong>注意：</strong></p>
<p>不过SHOW PROFILE命令将被启用，我们可以从 information_schema 中的 profiling 数据表进行查看。</p>
<h3 id="分析查询语句：EXPLAIN"><a href="#分析查询语句：EXPLAIN" class="headerlink" title="分析查询语句：EXPLAIN"></a>分析查询语句：EXPLAIN</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><img src="image-20230719140206300.png" alt="image-20230719140206300"></p>
<p><strong>能做什么？</strong></p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>EXPLAIN 或 DESCRIBE语句的语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> select_options</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">SELECT</span> select_options</span><br></pre></td></tr></table></figure>

<p>如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个 EXPLAIN ，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719140324387.png" alt="image-20230719140324387"></p>
<p><img src="image-20230719140345673.png" alt="image-20230719140345673"></p>
<p>EXPLAIN 语句输出的各个列的作用如下：</p>
<p><img src="image-20230719140409198.png" alt="image-20230719140409198"></p>
<h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><p><strong>1. 建表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s1 (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key2 <span class="type">INT</span>,</span><br><span class="line">    key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    INDEX idx_key1 (key1),</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX idx_key2 (key2),</span><br><span class="line">    INDEX idx_key3 (key3),</span><br><span class="line">    INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s2 (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key2 <span class="type">INT</span>,</span><br><span class="line">    key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    INDEX idx_key1 (key1),</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX idx_key2 (key2),</span><br><span class="line">    INDEX idx_key3 (key3),</span><br><span class="line">    INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p><strong>2. 设置参数 log_bin_trust_function_creators</strong></p>
<p>创建函数，假如报错，需开启如下命令：允许创建函数设置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>; # 不加<span class="keyword">global</span>只是当前窗口有效。</span><br></pre></td></tr></table></figure>

<p><strong>3. 创建函数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string1(n <span class="type">INT</span>)</span><br><span class="line">	<span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>) #该函数会返回一个字符串</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span></span><br><span class="line"><span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line">        <span class="keyword">SET</span> return_str <span class="operator">=</span>CONCAT(return_str,<span class="built_in">SUBSTRING</span>(chars_str,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line">    <span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p><strong>4. 创建存储过程</strong></p>
<p>创建往s1表中插入数据的存储过程：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_s1 (<span class="keyword">IN</span> min_num <span class="type">INT</span> (<span class="number">10</span>),<span class="keyword">IN</span> max_num <span class="type">INT</span> (<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    REPEAT</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> s1 <span class="keyword">VALUES</span>(</span><br><span class="line">        (min_num <span class="operator">+</span> i),</span><br><span class="line">        rand_string1(<span class="number">6</span>),</span><br><span class="line">        (min_num <span class="operator">+</span> <span class="number">30</span> <span class="operator">*</span> i <span class="operator">+</span> <span class="number">5</span>),</span><br><span class="line">        rand_string1(<span class="number">6</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>),</span><br><span class="line">        rand_string1(<span class="number">5</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>));</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">    <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>创建往s2表中插入数据的存储过程：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_s2 (<span class="keyword">IN</span> min_num <span class="type">INT</span> (<span class="number">10</span>),<span class="keyword">IN</span> max_num <span class="type">INT</span> (<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    REPEAT</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> s2 <span class="keyword">VALUES</span>(</span><br><span class="line">        (min_num <span class="operator">+</span> i),</span><br><span class="line">        rand_string1(<span class="number">6</span>),</span><br><span class="line">        (min_num <span class="operator">+</span> <span class="number">30</span> <span class="operator">*</span> i <span class="operator">+</span> <span class="number">5</span>),</span><br><span class="line">        rand_string1(<span class="number">6</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>),</span><br><span class="line">        rand_string1(<span class="number">5</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>));</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">    <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p><strong>5. 调用存储过程</strong></p>
<p>s1表数据的添加：加入1万条记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> insert_s1(<span class="number">10001</span>,<span class="number">10000</span>);</span><br></pre></td></tr></table></figure>

<p>s2表数据的添加：加入1万条记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> insert_s2(<span class="number">10001</span>,<span class="number">10000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="EXPLAIN各列作用"><a href="#EXPLAIN各列作用" class="headerlink" title="EXPLAIN各列作用"></a>EXPLAIN各列作用</h4><p>为了让大家有比较好的体验，我们调整了下 <code>EXPLAIN</code> 输出列的顺序。</p>
<h5 id="1-table"><a href="#1-table" class="headerlink" title="1. table"></a>1. table</h5><p>不论我们的查询语句有多复杂，里边儿 包含了多少个表 ，到最后也是需要对每个表进行 单表访问 的，所 以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该 表的表名（有时不是真实的表名字，可能是简称）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719140905469.png" alt="image-20230719140905469"></p>
<p>这个查询语句只涉及对s1表的单表查询，所以 <code>EXPLAIN</code> 输出中只有一条记录，其中的table列的值为s1，表明这条记录是用来说明对s1表的单表访问方法的。</p>
<p>下边我们看一个连接查询的执行计划</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719140932181.png" alt="image-20230719140932181"></p>
<p>可以看出这个连接查询的执行计划中有两条记录，这两条记录的table列分别是s1和s2，这两条记录用来分别说明对s1表和s2表的访问方法是什么。</p>
<h5 id="2-id"><a href="#2-id" class="headerlink" title="2. id"></a>2. id</h5><p>我们写的查询语句一般都以 SELECT 关键字开头，比较简单的查询语句里只有一个 SELECT 关键字，比 如下边这个查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>稍微复杂一点的连接查询中也只有一个 SELECT 关键字，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2</span><br><span class="line"><span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1</span><br><span class="line"><span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>但是下边两种情况下在一条查询语句中会出现多个SELECT关键字：</p>
<p><img src="image-20230719141019804.png" alt="image-20230719141019804"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719141040463.png" alt="image-20230719141040463"></p>
<p>对于连接查询来说，一个SELECT关键字后边的FROM字句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719141105908.png" alt="image-20230719141105908"></p>
<p>可以看到，上述连接查询中参与连接的s1和s2表分别对应一条记录，但是这两条记录对应的<code>id</code>都是1。这里需要大家记住的是，<strong>在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的</strong>，出现在前边的表表示<code>驱动表</code>，出现在后面的表表示<code>被驱动表</code>。所以从上边的EXPLAIN输出中我们可以看到，查询优化器准备让s1表作为驱动表，让s2表作为被驱动表来执行查询。</p>
<p>对于包含子查询的查询语句来说，就可能涉及多个<code>SELECT</code>关键字，所以在**包含子查询的查询语句的执行计划中，每个<code>SELECT</code>关键字都会对应一个唯一的id值，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719141132286.png" alt="image-20230719141132286"></p>
<p><img src="image-20230719141149010.png" alt="image-20230719141149010"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询优化器可能对涉及子查询的查询语句进行重写，转变为多表查询的操作。  </span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key2 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719141332637.png" alt="image-20230719141332637"></p>
<p>可以看到，虽然我们的查询语句是一个子查询，但是执行计划中s1和s2表对应的记录的<code>id</code>值全部是1，这就表明<code>查询优化器将子查询转换为了连接查询</code>。</p>
<p>对于包含<code>UNION</code>子句的查询语句来说，每个<code>SELECT</code>关键字对应一个<code>id</code>值也是没错的，不过还是有点儿特别的东西，比方说下边的查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">Union</span>去重</span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719141356302.png" alt="image-20230719141356302"></p>
<p><img src="image-20230719141411657.png" alt="image-20230719141411657"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719141437507.png" alt="image-20230719141437507"></p>
<p><strong>小结:</strong></p>
<ul>
<li>id如果相同，可以认为是一组，从上往下顺序执行</li>
<li>在所有组中，id值越大，优先级越高，越先执行</li>
<li>关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</li>
</ul>
<h5 id="3-select-type"><a href="#3-select-type" class="headerlink" title="3. select_type"></a>3. select_type</h5><p><img src="image-20230719141516660.png" alt="image-20230719141516660"></p>
<p><img src="image-20230719141531340.png" alt="image-20230719141531340"></p>
<p>具体分析如下：</p>
<ul>
<li><p>SIMPLE</p>
<p>查询语句中不包含<code>UNION</code>或者子查询的查询都算作是<code>SIMPLE</code>类型，比方说下边这个单表查询<code>select_type</code>的值就是<code>SIMPLE</code>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719141602503.png" alt="image-20230719141602503"></p>
<p>当然，连接查询也算是 SIMPLE 类型，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719141623804.png" alt="image-20230719141623804"></p>
</li>
<li><p>PRIMARY</p>
<p>对于包含<code>UNION、UNION ALL</code>或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的<code>select_type</code>的值就是<code>PRIMARY</code>,比方说：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719141743749.png" alt="image-20230719141743749"></p>
<p>从结果中可以看到，最左边的小查询<code>SELECT * FROM s1</code>对应的是执行计划中的第一条记录，它<code>select_type</code>的值就是<code>PRIMARY</code>。</p>
</li>
<li><p>UNION</p>
<p>对于包含<code>UNION</code>或者<code>UNION ALL</code>的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询意外，其余的小查询的<code>select_type</code>值就是UNION，可以对比上一个例子的效果。</p>
</li>
<li><p>UNION RESULT</p>
<p>MySQL 选择使用临时表来完成<code>UNION</code>查询的去重工作，针对该临时表的查询的<code>select_type</code>就是<code>UNION RESULT</code>, 例子上边有。</p>
</li>
<li><p>SUBQUERY</p>
<p>如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>SUBQUERY</code>，比如下边这个查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719142049894.png" alt="image-20230719142049894"></p>
</li>
<li><p>DEPENDENT SUBQUERY</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> s1.key2 <span class="operator">=</span> s2.key2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719142129243.png" alt="image-20230719142129243"></p>
</li>
<li><p>DEPENDENT UNION</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719142414418.png" alt="image-20230719142414418"></p>
</li>
<li><p>DERIVED</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> key1, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> key1) <span class="keyword">AS</span> derived_s1 <span class="keyword">where</span> c <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719142441084.png" alt="image-20230719142441084"></p>
<p>从执行计划中可以看出，id为2的记录就代表子查询的执行方式，它的select_type是DERIVED, 说明该子查询是以物化的方式执行的。id为1的记录代表外层查询，大家注意看它的table列显示的是derived2，表示该查询时针对将派生表物化之后的表进行查询的。</p>
</li>
<li><p>MATERIALIZED</p>
<p>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后的外层查询进行连接查询时，该子查询对应的<code>select_type</code>属性就是DERIVED，比如下边这个查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2);</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719142530325.png" alt="image-20230719142530325"></p>
</li>
<li><p>UNCACHEABLE SUBQUERY</p>
<p>不常用，就不多说了。</p>
</li>
<li><p>UNCACHEABLE UNION</p>
<p>不常用，就不多说了。</p>
</li>
</ul>
<h5 id="4-partitions-可略"><a href="#4-partitions-可略" class="headerlink" title="4. partitions (可略)"></a>4. partitions (可略)</h5><h5 id="5-type"><a href="#5-type" class="headerlink" title="5. type"></a>5. type</h5><p>执行计划的一条记录就代表着MySQL对某个表的 <code>执行查询时的访问方法</code> , 又称“访问类型”，其中的 <code>type</code> 列就表明了这个访问方法是啥，是较为重要的一个指标。比如，看到<code>type</code>列的值是<code>ref</code>，表明<code>MySQL</code>即将使用<code>ref</code>访问方法来执行对<code>s1</code>表的查询。</p>
<p>完整的访问方法如下： <code>system ， const ， eq_ref ， ref ， fulltext ， ref_or_null ， index_merge ， unique_subquery ， index_subquery ， range ， index ， ALL</code> 。</p>
<p>我们详细解释一下：</p>
<ul>
<li><p><code>system</code></p>
<p>当表中<code>只有一条记录</code>并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是<code>system</code>。比方说我们新建一个<code>MyISAM</code>表，并为其插入一条记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t(i <span class="type">int</span>) Engine<span class="operator">=</span>MyISAM;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.05</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>然后我们看一下查询这个表的执行计划：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719144519679.png" alt="image-20230719144519679"></p>
<p>可以看到<code>type</code>列的值就是<code>system</code>了，</p>
<blockquote>
<p>测试，可以把表改成使用InnoDB存储引擎，试试看执行计划的<code>type</code>列是什么。ALL</p>
</blockquote>
</li>
<li><p>const</p>
<p>当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是<code>const</code>, 比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719144557169.png" alt="image-20230719144557169"></p>
</li>
<li><p>eq_ref</p>
<p>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较）。则对该被驱动表的访问方法就是<code>eq_ref</code>，比方说：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.id <span class="operator">=</span> s2.id;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719145624167.png" alt="image-20230719145624167"></p>
<p>从执行计划的结果中可以看出，MySQL打算将s2作为驱动表，s1作为被驱动表，重点关注s1的访问 方法是 <code>eq_ref</code> ，表明在访问s1表的时候可以 <code>通过主键的等值匹配</code> 来进行访问。</p>
</li>
<li><p>ref</p>
<p>当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是<code>ref</code>，比方说下边这个查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719145716821.png" alt="image-20230719145716821"></p>
</li>
<li><p>fulltext</p>
<p>全文检索</p>
</li>
<li><p>ref_or_null</p>
<p>当对普通二级索引进行等值匹配查询，该索引列的值也可以是<code>NULL</code>值时，那么对该表的访问方法就可能是<code>ref_or_null</code>，比如说：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key1 <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719145801914.png" alt="image-20230719145801914"></p>
</li>
<li><p>index_merge</p>
<p>一般情况下对于某个表的查询只能使用到一个索引，但单表访问方法时在某些场景下可以使用<code>Interseation、union、Sort-Union</code>这三种索引合并的方式来执行查询。我们看一下执行计划中是怎么体现MySQL使用索引合并的方式来对某个表执行查询的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719145828438.png" alt="image-20230719145828438"></p>
<p>从执行计划的 <code>type</code> 列的值是 <code>index_merge</code> 就可以看出，MySQL 打算使用索引合并的方式来执行 对 s1 表的查询。</p>
</li>
<li><p>unique_subquery</p>
<p>类似于两表连接中被驱动表的<code>eq_ref</code>访问方法，<code>unique_subquery</code>是针对在一些包含<code>IN</code>子查询的查询语句中，如果查询优化器决定将<code>IN</code>子查询转换为<code>EXISTS</code>子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的<code>type</code>列的值就是<code>unique_subquery</code>，比如下边的这个查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key2 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s2 <span class="keyword">where</span> s1.key1 <span class="operator">=</span> s2.key1) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719145919670.png" alt="image-20230719145919670"></p>
</li>
<li><p>index_subquery</p>
<p><code>index_subquery</code> 与 <code>unique_subquery</code> 类似，只不过访问子查询中的表时使用的是普通的索引，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> common_field <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key3 <span class="keyword">FROM</span> s2 <span class="keyword">where</span> s1.key1 <span class="operator">=</span> s2.key1) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719145949481.png" alt="image-20230719145949481"></p>
</li>
<li><p>range</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150012486.png" alt="image-20230719150012486"></p>
<p>或者：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> key1 <span class="operator">&lt;</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150040886.png" alt="image-20230719150040886"></p>
</li>
<li><p>index</p>
<p>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是<code>index</code>，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> key_part2 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150106325.png" alt="image-20230719150106325"></p>
<p>上述查询中的所有列表中只有key_part2 一个列，而且搜索条件中也只有 key_part3 一个列，这两个列又恰好包含在idx_key_part这个索引中，可是搜索条件key_part3不能直接使用该索引进行<code>ref</code>和<code>range</code>方式的访问，只能扫描整个<code>idx_key_part</code>索引的记录，所以查询计划的<code>type</code>列的值就是<code>index</code>。</p>
<blockquote>
<p>再一次强调，对于使用InnoDB存储引擎的表来说，二级索引的记录只包含索引列和主键列的值，而聚簇索引中包含用户定义的全部列以及一些隐藏列，所以扫描二级索引的代价比直接全表扫描，也就是扫描聚簇索引的代价更低一些。</p>
</blockquote>
</li>
<li><p>ALL</p>
<p>全表扫描</p>
</li>
</ul>
<p><strong>小结：</strong></p>
<p><strong>结果值从最好到最坏依次是：</strong></p>
<p><strong>system &gt; const &gt; eq_ref &gt; ref</strong> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
<p><strong>其中比较重要的几个提取出来（见上图中的粗体）。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 consts级别。（阿里巴巴 开发手册要求）</strong></p>
<h5 id="6-possible-keys和key"><a href="#6-possible-keys和key" class="headerlink" title="6. possible_keys和key"></a>6. possible_keys和key</h5><p>在EXPLAIN语句输出的执行计划中，<code>possible_keys</code>列表示在某个查询语句中，对某个列执行<code>单表查询时可能用到的索引</code>有哪些。一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。<code>key</code>列表示<code>实际用到的索引</code>有哪些，如果为NULL，则没有使用索引。比方说下面这个查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150326576.png" alt="image-20230719150326576"></p>
<p>上述执行计划的<code>possible_keys</code>列的值是<code>idx_key1, idx_key3</code>，表示该查询可能使用到<code>idx_key1, idx_key3</code>两个索引，然后<code>key</code>列的值是<code>idx_key3</code>，表示经过查询优化器计算使用不同索引的成本后，最后决定采用<code>idx_key3</code>。</p>
<h5 id="7-key-len"><a href="#7-key-len" class="headerlink" title="7. key_len"></a>7. key_len</h5><p>实际使用到的索引长度 (即：字节数)</p>
<p>帮你检查<code>是否充分的利用了索引</code>，<code>值越大越好</code>，主要针对于联合索引，有一定的参考意义。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150401618.png" alt="image-20230719150401618"></p>
<blockquote>
<p>int 占用 4 个字节</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key2 <span class="operator">=</span> <span class="number">10126</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150425383.png" alt="image-20230719150425383"></p>
<blockquote>
<p>key2上有一个唯一性约束，是否为NULL占用一个字节，那么就是5个字节</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150446322.png" alt="image-20230719150446322"></p>
<blockquote>
<p>key1 VARCHAR(100) 一个字符占3个字节，100*3，是否为NULL占用一个字节，varchar的长度信息占两个字节。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150508012.png" alt="image-20230719150508012"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> key_part2 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150530155.png" alt="image-20230719150530155"></p>
<blockquote>
<p>联合索引中可以比较，key_len&#x3D;606的好于key_len&#x3D;303</p>
</blockquote>
<p>key_len的长度计算公式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">varchar</span>(<span class="number">10</span>)变长字段且允许<span class="keyword">NULL</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> ( <span class="type">character</span> <span class="keyword">set</span>：utf8<span class="operator">=</span><span class="number">3</span>,gbk<span class="operator">=</span><span class="number">2</span>,latin1<span class="operator">=</span><span class="number">1</span>)<span class="operator">+</span><span class="number">1</span>(<span class="keyword">NULL</span>)<span class="operator">+</span><span class="number">2</span>(变长字段)</span><br><span class="line"></span><br><span class="line"><span class="type">varchar</span>(<span class="number">10</span>)变长字段且不允许<span class="keyword">NULL</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> ( <span class="type">character</span> <span class="keyword">set</span>：utf8<span class="operator">=</span><span class="number">3</span>,gbk<span class="operator">=</span><span class="number">2</span>,latin1<span class="operator">=</span><span class="number">1</span>)<span class="operator">+</span><span class="number">2</span>(变长字段)</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>(<span class="number">10</span>)固定字段且允许<span class="keyword">NULL</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> ( <span class="type">character</span> <span class="keyword">set</span>：utf8<span class="operator">=</span><span class="number">3</span>,gbk<span class="operator">=</span><span class="number">2</span>,latin1<span class="operator">=</span><span class="number">1</span>)<span class="operator">+</span><span class="number">1</span>(<span class="keyword">NULL</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>(<span class="number">10</span>)固定字段且不允许<span class="keyword">NULL</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> ( <span class="type">character</span> <span class="keyword">set</span>：utf8<span class="operator">=</span><span class="number">3</span>,gbk<span class="operator">=</span><span class="number">2</span>,latin1<span class="operator">=</span><span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h5 id="8-ref"><a href="#8-ref" class="headerlink" title="8. ref"></a>8. ref</h5><p><img src="image-20230719150619229.png" alt="image-20230719150619229"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150638537.png" alt="image-20230719150638537"></p>
<p>可以看到<code>ref</code>列的值是<code>const</code>，表明在使用<code>idx_key1</code>索引执行查询时，与<code>key1</code>列作等值匹配的对象是一个常数，当然有时候更复杂一点:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.id <span class="operator">=</span> s2.id;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150704459.png" alt="image-20230719150704459"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s2.key1 <span class="operator">=</span> <span class="built_in">UPPER</span>(s1.key1);</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150724181.png" alt="image-20230719150724181"></p>
<h5 id="9-rows"><a href="#9-rows" class="headerlink" title="9. rows"></a>9. rows</h5><p>预估的需要读取的记录条数，<code>值越小越好</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150756951.png" alt="image-20230719150756951"></p>
<h5 id="10-filtered"><a href="#10-filtered" class="headerlink" title="10. filtered"></a>10. filtered</h5><p>某个表经过搜索条件过滤后剩余记录条数的百分比</p>
<p>如果使用的是索引执行的单表扫描，那么计算时需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150827687.png" alt="image-20230719150827687"></p>
<p>对于单表查询来说，这个filtered的值没有什么意义，我们<code>更关注在连接查询中驱动表对应的执行计划记录的filtered值</code>，它决定了被驱动表要执行的次数 (即: rows * filtered)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150851270.png" alt="image-20230719150851270"></p>
<p>从执行计划中可以看出来，查询优化器打算把<code>s1</code>作为驱动表，<code>s2</code>当做被驱动表。我们可以看到驱动表<code>s1</code>表的执行计划的<code>rows</code>列为<code>9688</code>，filtered列为<code>10.00</code>，这意味着驱动表<code>s1</code>的扇出值就是<code>9688 x 10.00% = 968.8</code>，这说明还要对被驱动表执行大约<code>968</code>次查询。</p>
<h5 id="11-Extra"><a href="#11-Extra" class="headerlink" title="11. Extra"></a>11. Extra</h5><p>顾名思义，<code>Extra</code>列是用来说明一些额外信息的，包含不适合在其他列中显示但十分重要的额外信息。我们可以通过这些额外信息来<code>更准确的理解MySQL到底将如何执行给定的查询语句</code>。MySQL提供的额外信息有好几十个，我们就不一个一个介绍了，所以我们只挑选比较重要的额外信息介绍给大家。</p>
<ul>
<li><p>No tables used</p>
<p>当查询语句没有<code>FROM</code>子句时将会提示该额外信息，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151153955.png" alt="image-20230719151153955"></p>
</li>
<li><p>Impossible WHERE</p>
<p>当查询语句的<code>WHERE</code>子句永远为<code>FALSE</code>时将会提示该额外信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> <span class="number">1</span> <span class="operator">!=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151216044.png" alt="image-20230719151216044"></p>
</li>
<li><p>Using where</p>
<p><img src="image-20230719151232918.png" alt="image-20230719151232918"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151255817.png" alt="image-20230719151255817"></p>
<p><img src="image-20230719151442487.png" alt="image-20230719151442487"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151505275.png" alt="image-20230719151505275"></p>
</li>
<li><p>No matching min&#x2F;max row</p>
<p>当查询列表处有<code>MIN</code>或者<code>MAX</code>聚合函数，但是并没有符合<code>WHERE</code>子句中的搜索条件的记录时。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(key1) <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;abcdefg&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151526828.png" alt="image-20230719151526828"></p>
</li>
<li><p>Using index</p>
<p>当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用覆盖索引的情况下，在<code>Extra</code>列将会提示该额外信息。比方说下边这个查询中只需要用到<code>idx_key1</code>而不需要回表操作:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151554259.png" alt="image-20230719151554259"></p>
</li>
<li><p>Using index condition</p>
<p>有些搜索条件中虽然出现了索引列，但却不能使用到索引，比如下边这个查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key1 <span class="keyword">LIKE</span> <span class="string">&#x27;%a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151620769.png" alt="image-20230719151620769"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key1 <span class="keyword">LIKE</span> <span class="string">&#x27;%b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151641903.png" alt="image-20230719151641903"></p>
</li>
<li><p>Using join buffer (Block Nested Loop)</p>
<p>在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为其分配一块名叫<code>join buffer</code>的内存块来加快查询速度，也就是我们所讲的<code>基于块的嵌套循环算法</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.common_field <span class="operator">=</span> s2.common_field;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151705722.png" alt="image-20230719151705722"></p>
</li>
<li><p>Not exists</p>
<p>当我们使用左(外)连接时，如果<code>WHERE</code>子句中包含要求被驱动表的某个列等于<code>NULL</code>值的搜索条件，而且那个列是不允许存储<code>NULL</code>值的，那么在该表的执行计划的Extra列就会提示这个信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151727762.png" alt="image-20230719151727762"></p>
</li>
<li><p>Using intersect(…) 、 Using union(…) 和 Using sort_union(…)</p>
<p>如果执行计划的<code>Extra</code>列出现了<code>Using intersect(...)</code>提示，说明准备使用<code>Intersect</code>索引合并的方式执行查询，括号中的<code>...</code>表示需要进行索引合并的索引名称；</p>
<p>如果出现<code>Using union(...)</code>提示，说明准备使用<code>Union</code>索引合并的方式执行查询;</p>
<p>如果出现<code>Using sort_union(...)</code>提示，说明准备使用<code>Sort-Union</code>索引合并的方式执行查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151754158.png" alt="image-20230719151754158"></p>
</li>
<li><p>Zero limit</p>
<p>当我们的<code>LIMIT</code>子句的参数为<code>0</code>时，表示压根儿不打算从表中读取任何记录，将会提示该额外信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 LIMIT <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151820994.png" alt="image-20230719151820994"></p>
</li>
<li><p>Using filesort</p>
<p>有一些情况下对结果集中的记录进行排序是可以使用到索引的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> key1 LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151914985.png" alt="image-20230719151914985"></p>
<p><img src="image-20230719151931537.png" alt="image-20230719151931537"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> common_field LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151949693.png" alt="image-20230719151949693"></p>
<p>需要注意的是，如果查询中需要使用<code>filesort</code>的方式进行排序的记录非常多，那么这个过程是很耗费性能的，我们最好想办法<code>将使用文件排序的执行方式改为索引进行排序</code>。</p>
</li>
<li><p>Using temporary</p>
<p><img src="image-20230719152012778.png" alt="image-20230719152012778"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> common_field <span class="keyword">FROM</span> s1;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719152029183.png" alt="image-20230719152029183"></p>
<p>再比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> common_field, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> amount <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> common_field;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719152052680.png" alt="image-20230719152052680"></p>
<p>执行计划中出现<code>Using temporary</code>并不是一个好的征兆，因为建立与维护临时表要付出很大的成本的，所以我们<code>最好能使用索引来替代掉使用临时表</code>，比方说下边这个包含<code>GROUP BY</code>子句的查询就不需要使用临时表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> key1, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> amount <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> key1;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719152118103.png" alt="image-20230719152118103"></p>
<p>从 <code>Extra</code> 的 <code>Using index</code> 的提示里我们可以看出，上述查询只需要扫描 <code>idx_key1</code> 索引就可以搞 定了，不再需要临时表了。</p>
</li>
</ul>
<h5 id="12-小结"><a href="#12-小结" class="headerlink" title="12. 小结"></a>12. 小结</h5><ul>
<li>EXPLAIN不考虑各种Cache</li>
<li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li>
<li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li>
<li>部分统计信息是估算的，并非精确值</li>
</ul>
<h3 id="EXPLAIN的进一步使用"><a href="#EXPLAIN的进一步使用" class="headerlink" title="EXPLAIN的进一步使用"></a>EXPLAIN的进一步使用</h3><h4 id="EXPLAIN四种输出格式"><a href="#EXPLAIN四种输出格式" class="headerlink" title="EXPLAIN四种输出格式"></a>EXPLAIN四种输出格式</h4><p>这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式： <code>传统格式</code> ，<code>JSON格式</code> ， <code>TREE格式</code> 以及 <code>可视化输出</code> 。用户可以根据需要选择适用于自己的格式。</p>
<h5 id="1-传统格式"><a href="#1-传统格式" class="headerlink" title="1. 传统格式"></a>1. 传统格式</h5><p>传统格式简单明了，输出是一个表格形式，概要说明查询计划。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> s1.key1, s2.key1 <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.common_field <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719152337180.png" alt="image-20230719152337180"></p>
<h5 id="2-JSON格式"><a href="#2-JSON格式" class="headerlink" title="2. JSON格式"></a>2. JSON格式</h5><p>第1种格式中介绍的<code>EXPLAIN</code>语句输出中缺少了一个衡量执行好坏的重要属性 —— <code>成本</code>。而JSON格式是四种格式里面输出<code>信息最详尽</code>的格式，里面包含了执行的成本信息。</p>
<ul>
<li>JSON格式：在EXPLAIN单词和真正的查询语句中间加上 FORMAT&#x3D;JSON 。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN FORMAT<span class="operator">=</span>JSON <span class="keyword">SELECT</span> ....</span><br></pre></td></tr></table></figure>

<ul>
<li>EXPLAIN的Column与JSON的对应关系：(来源于MySQL 5.7文档)</li>
</ul>
<p><img src="image-20230719152429144.png" alt="image-20230719152429144"></p>
<p>这样我们就可以得到一个json格式的执行计划，里面包含该计划花费的成本。比如这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN FORMAT<span class="operator">=</span>JSON <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key2 <span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>\G</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719152449438.png" alt="image-20230719152449438"></p>
<p><img src="image-20230719152501556.png" alt="image-20230719152501556"></p>
<p><img src="image-20230719152520199.png" alt="image-20230719152520199"></p>
<p><img src="image-20230719152534137.png" alt="image-20230719152534137"></p>
<p><img src="image-20230719152549524.png" alt="image-20230719152549524"></p>
<p>我们使用 # 后边跟随注释的形式为大家解释了 <code>EXPLAIN FORMAT=JSON</code> 语句的输出内容，但是大家可能 有疑问 “<code>cost_info</code>“ 里边的成本看着怪怪的，它们是怎么计算出来的？先看 s1 表的 “<code>cost_info</code>“ 部 分：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;read_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1840.84&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eval_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;193.76&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;prefix_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2034.60&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data_read_per_join&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1M&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>read_cost</code> 是由下边这两部分组成的：</p>
<ul>
<li>IO 成本</li>
<li>检测 rows × (1 - filter) 条记录的 CPU 成本</li>
</ul>
<blockquote>
<p>小贴士： rows和filter都是我们前边介绍执行计划的输出列，在JSON格式的执行计划中，rows 相当于rows_examined_per_scan，filtered名称不变。</p>
</blockquote>
</li>
<li><p><code>eval_cost</code> 是这样计算的：</p>
<p>检测 rows × filter 条记录的成本。</p>
</li>
<li><p><code>prefix_cost</code> 就是单独查询 s1 表的成本，也就是：</p>
<p><code>read_cost + eval_cost</code></p>
</li>
<li><p><code>data_read_per_join</code> 表示在此次查询中需要读取的数据量。</p>
</li>
</ul>
<p>对于 <code>s2</code> 表的 “<code>cost_info</code>“ 部分是这样的：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;read_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;968.80&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eval_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;193.76&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;prefix_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3197.16&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data_read_per_join&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1M&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>由于 <code>s2</code> 表是被驱动表，所以可能被读取多次，这里的<code>read_cost</code> 和 <code>eval_cost</code> 是访问多次 <code>s2</code> 表后累加起来的值，大家主要关注里边儿的 <code>prefix_cost</code> 的值代表的是整个连接查询预计的成本，也就是单次查询 <code>s1</code> 表和多次查询 <code>s2</code> 表后的成本的和，也就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">968.80 + 193.76 + 2034.60 = 3197.16</span><br></pre></td></tr></table></figure>

<h5 id="3-TREE格式"><a href="#3-TREE格式" class="headerlink" title="3. TREE格式"></a>3. TREE格式</h5><p>TREE格式是8.0.16版本之后引入的新格式，主要根据查询的 <code>各个部分之间的关系</code> 和 <code>各部分的执行顺序</code> 来描述如何查询。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">EXPLAIN FORMAT=tree SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE</span></span><br><span class="line">s1.common_field = &#x27;a&#x27;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">EXPLAIN: -&gt; Nested loop inner join (cost=1360.08 rows=990)</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Filter: ((s1.common_field = &#x27;a&#x27;) and (s1.key1 is not null)) (cost=1013.75</span></span><br><span class="line">rows=990)</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Table scan on s1 (cost=1013.75 rows=9895)</span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Single-row index lookup on s2 using idx_key2 (key2=s1.key1), with index</span></span><br><span class="line">condition: (cast(s1.key1 as double) = cast(s2.key2 as double)) (cost=0.25 rows=1)</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<h5 id="4-可视化输出"><a href="#4-可视化输出" class="headerlink" title="4. 可视化输出"></a>4. 可视化输出</h5><p>可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。通过点击Workbench的放大镜图标，即可生成可视化的查询计划。</p>
<p><img src="image-20230719152804302.png" alt="image-20230719152804302"></p>
<p>上图按从左到右的连接顺序显示表。红色框表示 <code>全表扫描</code> ，而绿色框表示使用 <code>索引查找</code> 。对于每个表， 显示使用的索引。还要注意的是，每个表格的框上方是每个表访问所发现的行数的估计值以及访问该表的成本。</p>
<h4 id="SHOW-WARNINGS的使用"><a href="#SHOW-WARNINGS的使用" class="headerlink" title="SHOW WARNINGS的使用"></a>SHOW WARNINGS的使用</h4><p>在我们使用<code>EXPLAIN</code>语句查看了某个查询的执行计划后，紧接着还可以使用<code>SHOW WARNINGS</code>语句查看与这个查询的执行计划有关的一些扩展信息，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> s1.key1, s2.key1 <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.common_field <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719153017477.png" alt="image-20230719153017477"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SHOW WARNINGS\G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    Level: Note</span><br><span class="line">     Code: 1003</span><br><span class="line">Message: /* select#1 */ select `atguigu`.`s1`.`key1` AS `key1`,`atguigu`.`s2`.`key1`</span><br><span class="line">AS `key1` from `atguigu`.`s1` join `atguigu`.`s2` where ((`atguigu`.`s1`.`key1` =</span><br><span class="line">`atguigu`.`s2`.`key1`) and (`atguigu`.`s2`.`common_field` is not null))</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>大家可以看到<code>SHOW WARNINGS</code>展示出来的信息有三个字段，分别是<code>Level、Code、Message</code>。我们最常见的就是Code为1003的信息，当Code值为1003时，<code>Message</code>字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。比如我们上边的查询本来是一个左(外)连接查询，但是有一个s2.common_field IS NOT NULL的条件，这就会导致查询优化器把左(外)连接查询优化为内连接查询，从<code>SHOW WARNINGS</code>的<code>Message</code>字段也可以看出来，原本的LEFE JOIN已经变成了JOIN。</p>
<p>但是大家一定要注意，我们说<code>Message</code>字段展示的信息类似于查询优化器将我们的查询语句<code>重写后的语句</code>，并不是等价于，也就是说<code>Message</code>字段展示的信息并不是标准的查询语句，在很多情况下并不能直接拿到黑框框中运行，它只能作为帮助我们理解MySQL将如何执行查询语句的一个参考依据而已。</p>
<h3 id="分析优化器执行计划：trace"><a href="#分析优化器执行计划：trace" class="headerlink" title="分析优化器执行计划：trace"></a>分析优化器执行计划：trace</h3><p><img src="image-20230719153227898.png" alt="image-20230719153227898"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="operator">=</span><span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">set</span> optimizer_trace_max_mem_size<span class="operator">=</span><span class="number">1000000</span>;</span><br></pre></td></tr></table></figure>

<p>开启后，可分析如下语句：</p>
<ul>
<li>SELECT</li>
<li>INSERT</li>
<li>REPLACE</li>
<li>UPDATE</li>
<li>DELETE</li>
<li>EXPLAIN</li>
<li>SET</li>
<li>DECLARE</li>
<li>CASE</li>
<li>IF</li>
<li>RETURN</li>
<li>CALL</li>
</ul>
<p>测试：执行如下SQL语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>最后， 查询 information_schema.optimizer_trace 就可以知道MySQL是如何执行SQL的 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">*************************** <span class="number">1.</span> row ***************************</span><br><span class="line"><span class="comment">//第1部分：查询语句</span></span><br><span class="line">QUERY<span class="punctuation">:</span> select * from student where id &lt; <span class="number">10</span></span><br><span class="line"><span class="comment">//第2部分：QUERY字段对应语句的跟踪信息</span></span><br><span class="line">TRACE<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;join_preparation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//预备工作</span></span><br><span class="line">        <span class="attr">&quot;select#&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;expanded_query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/* select#1 */ select `student`.`id` AS</span></span><br><span class="line"><span class="string">            `id`,`student`.`stuno` AS `stuno`,`student`.`name` AS `name`,`student`.`age` AS</span></span><br><span class="line"><span class="string">            `age`,`student`.`classId` AS `classId` from `student` where (`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line">    <span class="punctuation">&#125;</span> <span class="comment">/* join_preparation */</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;join_optimization&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//进行优化</span></span><br><span class="line">    <span class="attr">&quot;select#&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;condition_processing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//条件处理</span></span><br><span class="line">        <span class="attr">&quot;condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WHERE&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;original_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;transformation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;equality_propagation&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;resulting_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;transformation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;constant_propagation&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;resulting_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;transformation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;trivial_condition_removal&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;resulting_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line">    <span class="punctuation">&#125;</span> <span class="comment">/* condition_processing */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;substitute_generated_columns&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//替换生成的列</span></span><br><span class="line">        <span class="punctuation">&#125;</span> <span class="comment">/* substitute_generated_columns */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table_dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//表的依赖关系</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;row_may_be_null&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;map_bit&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;depends_on_map_bits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">]</span> <span class="comment">/* depends_on_map_bits */</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* table_dependencies */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ref_optimizer_key_uses&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//使用键</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* ref_optimizer_key_uses */</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;rows_estimation&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//行判断</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;range_analysis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;table_scan&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">3973767</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;cost&quot;</span><span class="punctuation">:</span> <span class="number">408558</span></span><br><span class="line">            <span class="punctuation">&#125;</span> <span class="comment">/* table_scan */</span><span class="punctuation">,</span> <span class="comment">//扫描表</span></span><br><span class="line">            <span class="attr">&quot;potential_range_indexes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//潜在的范围索引</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;usable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;key_parts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;id&quot;</span></span><br><span class="line">                    <span class="punctuation">]</span> <span class="comment">/* key_parts */</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span> <span class="comment">/* potential_range_indexes */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;setup_range_conditions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//设置范围条件</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* setup_range_conditions */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;group_index_range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cause&quot;</span><span class="punctuation">:</span> <span class="string">&quot;not_group_by_or_distinct&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span> <span class="comment">/* group_index_range */</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;skip_scan_range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;potential_skip_scan_indexes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;usable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;cause&quot;</span><span class="punctuation">:</span> <span class="string">&quot;query_references_nonkey_column&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span> <span class="comment">/* potential_skip_scan_indexes */</span></span><br><span class="line">            <span class="punctuation">&#125;</span> <span class="comment">/* skip_scan_range */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzing_range_alternatives&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//分析范围选项</span></span><br><span class="line">            <span class="attr">&quot;range_scan_alternatives&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ranges&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;id &lt; 10&quot;</span></span><br><span class="line">                    <span class="punctuation">]</span> <span class="comment">/* ranges */</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index_dives_for_eq_ranges&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;rowid_ordered&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;using_mrr&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index_only&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cost&quot;</span><span class="punctuation">:</span> <span class="number">1.91986</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span> <span class="comment">/* range_scan_alternatives */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzing_roworder_intersect&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;usable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cause&quot;</span><span class="punctuation">:</span> <span class="string">&quot;too_few_roworder_scans&quot;</span></span><br><span class="line">        	<span class="punctuation">&#125;</span> <span class="comment">/* analyzing_roworder_intersect */</span></span><br><span class="line">        <span class="punctuation">&#125;</span> <span class="comment">/* analyzing_range_alternatives */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;chosen_range_access_summary&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//选择范围访问摘要</span></span><br><span class="line">            <span class="attr">&quot;range_access_plan&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;range_scan&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ranges&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;id &lt; 10&quot;</span></span><br><span class="line">                <span class="punctuation">]</span> <span class="comment">/* ranges */</span></span><br><span class="line">                <span class="punctuation">&#125;</span> <span class="comment">/* range_access_plan */</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;rows_for_plan&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cost_for_plan&quot;</span><span class="punctuation">:</span> <span class="number">1.91986</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span> <span class="comment">/* chosen_range_access_summary */</span></span><br><span class="line">                <span class="punctuation">&#125;</span> <span class="comment">/* range_analysis */</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* rows_estimation */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;considered_execution_plans&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//考虑执行计划</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;plan_prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* plan_prefix */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;best_access_path&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//最佳访问路径</span></span><br><span class="line">        <span class="attr">&quot;considered_access_paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;rows_to_scan&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;access_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;range&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;range_details&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;used_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span> <span class="comment">/* range_details */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;resulting_rows&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cost&quot;</span><span class="punctuation">:</span> <span class="number">2.81986</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* considered_access_paths */</span></span><br><span class="line">    <span class="punctuation">&#125;</span> <span class="comment">/* best_access_path */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;condition_filtering_pct&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span> <span class="comment">//行过滤百分比</span></span><br><span class="line">        <span class="attr">&quot;rows_for_plan&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cost_for_plan&quot;</span><span class="punctuation">:</span> <span class="number">2.81986</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* considered_execution_plans */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;attaching_conditions_to_tables&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//将条件附加到表上</span></span><br><span class="line">        <span class="attr">&quot;original_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;attached_conditions_computation&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* attached_conditions_computation */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;attached_conditions_summary&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//附加条件概要</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;attached&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* attached_conditions_summary */</span></span><br><span class="line">    <span class="punctuation">&#125;</span> <span class="comment">/* attaching_conditions_to_tables */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;finalizing_table_conditions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;original_table_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;final_table_condition &quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* finalizing_table_conditions */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;refine_plan&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//精简计划</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    	<span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* refine_plan */</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line">    <span class="punctuation">&#125;</span> <span class="comment">/* join_optimization */</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;join_execution&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//执行</span></span><br><span class="line">            <span class="attr">&quot;select#&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line">        	<span class="punctuation">&#125;</span> <span class="comment">/* join_execution */</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">//第3部分：跟踪信息过长时，被截断的跟踪信息的字节数。</span></span><br><span class="line">MISSING_BYTES_BEYOND_MAX_MEM_SIZE<span class="punctuation">:</span> <span class="number">0</span> <span class="comment">//丢失的超出最大容量的字节</span></span><br><span class="line"><span class="comment">//第4部分：执行跟踪语句的用户是否有查看对象的权限。当不具有权限时，该列信息为1且TRACE字段为空，一般在</span></span><br><span class="line">调用带有SQL SECURITY DEFINER的视图或者是存储过程的情况下，会出现此问题。</span><br><span class="line">INSUFFICIENT_PRIVILEGES<span class="punctuation">:</span> <span class="number">0</span> <span class="comment">//缺失权限</span></span><br><span class="line"><span class="number">1</span> row in set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="MySQL监控分析视图-sys-schema"><a href="#MySQL监控分析视图-sys-schema" class="headerlink" title="MySQL监控分析视图-sys schema"></a>MySQL监控分析视图-sys schema</h3><p><img src="image-20230719153402605.png" alt="image-20230719153402605"></p>
<h4 id="Sys-schema视图摘要"><a href="#Sys-schema视图摘要" class="headerlink" title="Sys schema视图摘要"></a>Sys schema视图摘要</h4><ol>
<li><strong>主机相关</strong>：以host_summary开头，主要汇总了IO延迟的信息。</li>
<li><strong>Innodb相关</strong>：以innodb开头，汇总了innodb buffer信息和事务等待innodb锁的信息。</li>
<li><strong>I&#x2F;o相关</strong>：以io开头，汇总了等待I&#x2F;O、I&#x2F;O使用量情况。</li>
<li><strong>内存使用情况</strong>：以memory开头，从主机、线程、事件等角度展示内存的使用情况</li>
<li><strong>连接与会话信息</strong>：processlist和session相关视图，总结了会话相关信息。</li>
<li><strong>表相关</strong>：以schema_table开头的视图，展示了表的统计信息。</li>
<li><strong>索引信息</strong>：统计了索引的使用情况，包含冗余索引和未使用的索引情况。</li>
<li><strong>语句相关</strong>：以statement开头，包含执行全表扫描、使用临时表、排序等的语句信息。</li>
<li><strong>用户相关</strong>：以user开头的视图，统计了用户使用的文件I&#x2F;O、执行语句统计信息。</li>
<li><strong>等待事件相关信息</strong>：以wait开头，展示等待事件的延迟情况。</li>
</ol>
<h4 id="Sys-schema视图使用场景"><a href="#Sys-schema视图使用场景" class="headerlink" title="Sys schema视图使用场景"></a>Sys schema视图使用场景</h4><p>索引情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span> 查询冗余索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.schema_redundant_indexes;</span><br><span class="line">#<span class="number">2.</span> 查询未使用过的索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.schema_unused_indexes;</span><br><span class="line">#<span class="number">3.</span> 查询索引的使用情况</span><br><span class="line"><span class="keyword">select</span> index_name,rows_selected,rows_inserted,rows_updated,rows_deleted</span><br><span class="line"><span class="keyword">from</span> sys.schema_index_statistics <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>表相关</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">1.</span> 查询表的访问量</span><br><span class="line"><span class="keyword">select</span> table_schema,table_name,<span class="built_in">sum</span>(io_read_requests<span class="operator">+</span>io_write_requests) <span class="keyword">as</span> io <span class="keyword">from</span></span><br><span class="line">sys.schema_table_statistics <span class="keyword">group</span> <span class="keyword">by</span> table_schema,table_name <span class="keyword">order</span> <span class="keyword">by</span> io <span class="keyword">desc</span>;</span><br><span class="line"># <span class="number">2.</span> 查询占用bufferpool较多的表</span><br><span class="line"><span class="keyword">select</span> object_schema,object_name,allocated,data</span><br><span class="line"><span class="keyword">from</span> sys.innodb_buffer_stats_by_table <span class="keyword">order</span> <span class="keyword">by</span> allocated limit <span class="number">10</span>;</span><br><span class="line"># <span class="number">3.</span> 查看表的全表扫描情况</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.statements_with_full_table_scans <span class="keyword">where</span> db<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>语句相关</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span> 监控<span class="keyword">SQL</span>执行的频率</span><br><span class="line"><span class="keyword">select</span> db,exec_count,query <span class="keyword">from</span> sys.statement_analysis</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> exec_count <span class="keyword">desc</span>;</span><br><span class="line">#<span class="number">2.</span> 监控使用了排序的<span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">select</span> db,exec_count,first_seen,last_seen,query</span><br><span class="line"><span class="keyword">from</span> sys.statements_with_sorting limit <span class="number">1</span>;</span><br><span class="line">#<span class="number">3.</span> 监控使用了临时表或者磁盘临时表的<span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">select</span> db,exec_count,tmp_tables,tmp_disk_tables,query</span><br><span class="line"><span class="keyword">from</span> sys.statement_analysis <span class="keyword">where</span> tmp_tables<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">or</span> tmp_disk_tables <span class="operator">&gt;</span><span class="number">0</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> (tmp_tables<span class="operator">+</span>tmp_disk_tables) <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p>IO相关</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span> 查看消耗磁盘IO的文件</span><br><span class="line"><span class="keyword">select</span> file,avg_read,avg_write,avg_read<span class="operator">+</span>avg_write <span class="keyword">as</span> avg_io</span><br><span class="line"><span class="keyword">from</span> sys.io_global_by_file_by_bytes <span class="keyword">order</span> <span class="keyword">by</span> avg_read limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>Innodb 相关</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span> 行锁阻塞情况</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure>

<p><img src="image-20220704192020603.png" alt="image-20220704192020603"></p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>查询是数据库中最频繁的操作，提高查询速度可以有效地提高MySQL数据库的性能。通过对查询语句的分析可以了解查询语句的执行情况，找出查询语句执行的瓶颈，从而优化查询语句。</p>
<h2 id="索引优化与查询优化"><a href="#索引优化与查询优化" class="headerlink" title="索引优化与查询优化"></a>索引优化与查询优化</h2><p>都有哪些维度可以进行数据库调优？简言之：</p>
<ul>
<li>索引失效、没有充分利用到索引——建立索引</li>
<li>关联查询太多JOIN（设计缺陷或不得已的需求）——SQL优化</li>
<li>服务器调优及各个参数设置（缓冲、线程数等）——调整my.cnf</li>
<li>数据过多——分库分表</li>
</ul>
<p>关于数据库调优的知识非常分散。不同的DBMS，不同的公司，不同的职位，不同的项目遇到的问题都不尽相同。这里我们分为三个章节进行细致讲解。</p>
<p>虽然SQL查询优化的技术有很多，但是大方向上完全可以分成<code>物理查询优化</code>和<code>逻辑查询优化</code>两大块。</p>
<ul>
<li>物理查询优化是通过<code>索引</code>和<code>表连接方式</code>等技术来进行优化，这里重点需要掌握索引的使用。</li>
<li>逻辑查询优化就是通过SQL<code>等价变换</code>提升查询效率，直白一点就是说，换一种查询写法效率可能更高。</li>
</ul>
<h3 id="索引失效案例"><a href="#索引失效案例" class="headerlink" title="索引失效案例"></a>索引失效案例</h3><p><img src="image-20230719154911290.png" alt="image-20230719154911290"></p>
<h4 id="全值匹配我最爱"><a href="#全值匹配我最爱" class="headerlink" title="全值匹配我最爱"></a>全值匹配我最爱</h4><h4 id="最佳左前缀法则"><a href="#最佳左前缀法则" class="headerlink" title="最佳左前缀法则"></a>最佳左前缀法则</h4><p>在MySQL建立联合索引时会遵守最佳左前缀原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<p>举例1：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>举例2：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.classId<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>举例3：索引<code>idx_age_classid_name</code>还能否正常使用？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.classId<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719155156549.png" alt="image-20230719155156549"></p>
<p>虽然可以正常使用，但是只有部分被使用到了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.classId<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719155214651.png" alt="image-20230719155214651"></p>
<p>完全没有使用上索引。</p>
<p>结论：MySQL可以为多个字段创建索引，一个索引可以包含16个字段。对于多列索引，<strong>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用</strong>。如果查询条件中没有用这些字段中第一个字段时，多列（或联合）索引不会被使用。</p>
<blockquote>
<p>拓展：Alibaba《Java开发手册》</p>
<p>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
</blockquote>
<h4 id="主键插入顺序"><a href="#主键插入顺序" class="headerlink" title="主键插入顺序"></a>主键插入顺序</h4><p><img src="image-20230719155646906.png" alt="image-20230719155646906"></p>
<p>如果此时再插入一条主键值为 9 的记录，那它插入的位置就如下图：</p>
<p><img src="image-20230719160211534.png" alt="image-20230719160211534"></p>
<p>可这个数据页已经满了，再插进来咋办呢？我们需要把当前 <code>页面分裂</code> 成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着： <code>性能损耗</code> ！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的 <code>主键值依次递增</code> ，这样就不会发生这样的性能损耗了。 所以我们建议：让主键具有 <code>AUTO_INCREMENT</code> ，让存储引擎自己为表生成主键，而不是我们手动插入 ， 比如： <code>person_info</code> 表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_info(</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    birthday <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    phone_number <span class="type">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    country <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    KEY idx_name_birthday_phone_number (name(<span class="number">10</span>), birthday, phone_number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>我们自定义的主键列 <code>id</code> 拥有 <code>AUTO_INCREMENT</code> 属性，在插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。</p>
<h4 id="计算、函数、类型转换-自动或手动-导致索引失效"><a href="#计算、函数、类型转换-自动或手动-导致索引失效" class="headerlink" title="计算、函数、类型转换(自动或手动)导致索引失效"></a>计算、函数、类型转换(自动或手动)导致索引失效</h4><ol>
<li><p>这两条sql哪种写法更好</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.name <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(student.name,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> student(NAME);</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一种：索引优化生效</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.name <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE <span class="string">&#x27;abc%&#x27;</span>;</span></span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| id | stuno | name | age | classId |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| 5301379 | 1233401 | AbCHEa | 164 | 259 |</span><br><span class="line">| 7170042 | 3102064 | ABcHeB | 199 | 161 |</span><br><span class="line">| 1901614 | 1833636 | ABcHeC | 226 | 275 |</span><br><span class="line">| 5195021 | 1127043 | abchEC | 486 | 72 |</span><br><span class="line">| 4047089 | 3810031 | AbCHFd | 268 | 210 |</span><br><span class="line">| 4917074 | 849096 | ABcHfD | 264 | 442 |</span><br><span class="line">| 1540859 | 141979 | abchFF | 119 | 140 |</span><br><span class="line">| 5121801 | 1053823 | AbCHFg | 412 | 327 |</span><br><span class="line">| 2441254 | 2373276 | abchFJ | 170 | 362 |</span><br><span class="line">| 7039146 | 2971168 | ABcHgI | 502 | 465 |</span><br><span class="line">| 1636826 | 1580286 | ABcHgK | 71 | 262 |</span><br><span class="line">| 374344 | 474345 | abchHL | 367 | 212 |</span><br><span class="line">| 1596534 | 169191 | AbCHHl | 102 | 146 |</span><br><span class="line">...</span><br><span class="line">| 5266837 | 1198859 | abclXe | 292 | 298 |</span><br><span class="line">| 8126968 | 4058990 | aBClxE | 316 | 150 |</span><br><span class="line">| 4298305 | 399962 | AbCLXF | 72 | 423 |</span><br><span class="line">| 5813628 | 1745650 | aBClxF | 356 | 323 |</span><br><span class="line">| 6980448 | 2912470 | AbCLXF | 107 | 78 |</span><br><span class="line">| 7881979 | 3814001 | AbCLXF | 89 | 497 |</span><br><span class="line">| 4955576 | 887598 | ABcLxg | 121 | 385 |</span><br><span class="line">| 3653460 | 3585482 | AbCLXJ | 130 | 174 |</span><br><span class="line">| 1231990 | 1283439 | AbCLYH | 189 | 429 |</span><br><span class="line">| 6110615 | 2042637 | ABcLyh | 157 | 40 |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">401 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种：索引优化失效</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(student.name,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719160930744.png" alt="image-20230719160930744"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = <span class="string">&#x27;abc&#x27;</span>;</span></span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| id | stuno | name | age | classId |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| 5301379 | 1233401 | AbCHEa | 164 | 259 |</span><br><span class="line">| 7170042 | 3102064 | ABcHeB | 199 | 161 |</span><br><span class="line">| 1901614 | 1833636 | ABcHeC | 226 | 275 |</span><br><span class="line">| 5195021 | 1127043 | abchEC | 486 | 72 |</span><br><span class="line">| 4047089 | 3810031 | AbCHFd | 268 | 210 |</span><br><span class="line">| 4917074 | 849096 | ABcHfD | 264 | 442 |</span><br><span class="line">| 1540859 | 141979 | abchFF | 119 | 140 |</span><br><span class="line">| 5121801 | 1053823 | AbCHFg | 412 | 327 |</span><br><span class="line">| 2441254 | 2373276 | abchFJ | 170 | 362 |</span><br><span class="line">| 7039146 | 2971168 | ABcHgI | 502 | 465 |</span><br><span class="line">| 1636826 | 1580286 | ABcHgK | 71 | 262 |</span><br><span class="line">| 374344 | 474345 | abchHL | 367 | 212 |</span><br><span class="line">| 1596534 | 169191 | AbCHHl | 102 | 146 |</span><br><span class="line">...</span><br><span class="line">| 5266837 | 1198859 | abclXe | 292 | 298 |</span><br><span class="line">| 8126968 | 4058990 | aBClxE | 316 | 150 |</span><br><span class="line">| 4298305 | 399962 | AbCLXF | 72 | 423 |</span><br><span class="line">| 5813628 | 1745650 | aBClxF | 356 | 323 |</span><br><span class="line">| 6980448 | 2912470 | AbCLXF | 107 | 78 |</span><br><span class="line">| 7881979 | 3814001 | AbCLXF | 89 | 497 |</span><br><span class="line">| 4955576 | 887598 | ABcLxg | 121 | 385 |</span><br><span class="line">| 3653460 | 3585482 | AbCLXJ | 130 | 174 |</span><br><span class="line">| 1231990 | 1283439 | AbCLYH | 189 | 429 |</span><br><span class="line">| 6110615 | 2042637 | ABcLyh | 157 | 40 |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">401 rows in set, 1 warning (3.62 sec)</span><br></pre></td></tr></table></figure>

<p>type为“ALL”，表示没有使用到索引，查询时间为 3.62 秒，查询效率较之前低很多。</p>
</li>
</ol>
<p><strong>再举例：</strong></p>
<ul>
<li><p>student表的字段stuno上设置有索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_sno <span class="keyword">ON</span> student(stuno);</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引优化失效：（假设：student表的字段stuno上设置有索引）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE id, stuno, NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stuno<span class="operator">+</span><span class="number">1</span> <span class="operator">=</span> <span class="number">900001</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>运行结果：</p>
<p>​	<img src="image-20230719161144949.png" alt="image-20230719161144949"></p>
<ul>
<li><p>索引优化生效：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE id, stuno, NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stuno <span class="operator">=</span> <span class="number">900000</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>再举例：</strong></p>
<ul>
<li><p>student表的字段name上设置有索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> student(NAME);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> id, stuno, name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="built_in">SUBSTRING</span>(name, <span class="number">1</span>,<span class="number">3</span>)<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719161241581.png" alt="image-20230719161241581"></p>
</li>
<li><p>索引优化生效</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> id, stuno, NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="image-20230719161302374.png" alt="image-20230719161302374"></p>
<h4 id="类型转换导致索引失效"><a href="#类型转换导致索引失效" class="headerlink" title="类型转换导致索引失效"></a>类型转换导致索引失效</h4><p>下列哪个sql语句可以用到索引。（假设name字段上设置有索引）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719161419430.png" alt="image-20230719161419430"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719161431240.png" alt="image-20230719161431240"></p>
<p>name&#x3D;123发生类型转换，索引失效。</p>
<h4 id="范围条件右边的列索引失效"><a href="#范围条件右边的列索引失效" class="headerlink" title="范围条件右边的列索引失效"></a>范围条件右边的列索引失效</h4><ol>
<li>系统经常出现的sql如下：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> INDEX idx_name;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> INDEX idx_age;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> INDEX idx_age_classid;</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.classId<span class="operator">&gt;</span><span class="number">20</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span> ;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719161522661.png" alt="image-20230719161522661"></p>
<ol start="2">
<li>那么索引 idx_age_classId_name 这个索引还能正常使用么？</li>
</ol>
<ul>
<li>不能，范围右边的列不能使用。比如：(&lt;) (&lt;&#x3D;) (&gt;) (&gt;&#x3D;) 和 between 等</li>
<li>如果这种sql出现较多，应该建立：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index idx_age_name_classId on student(age,name,classId);</span><br></pre></td></tr></table></figure>

<ul>
<li>将范围查询条件放置语句最后：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name = &#x27;abc&#x27; AND student.classId&gt;20;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（创建的联合索引中，务必把范围涉及到的字段写在最后）</p>
</blockquote>
<ol start="3">
<li><p>效果</p>
<p><img src="blog\architect\source_posts\Mysql索引及调优\image-20230724114031282.png" alt="image-20230724114031282"></p>
</li>
</ol>
<h4 id="不等于-x3D-或者-lt-gt-索引失效"><a href="#不等于-x3D-或者-lt-gt-索引失效" class="headerlink" title="不等于(!&#x3D; 或者&lt;&gt;)索引失效"></a>不等于(!&#x3D; 或者&lt;&gt;)索引失效</h4><ul>
<li>为name字段创建索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> student(NAME);</span><br></pre></td></tr></table></figure>

<ul>
<li>查看索引是否失效</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.name <span class="operator">&lt;&gt;</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="blog\architect\source_posts\Mysql索引及调优\image-20230724114337762.png" alt="image-20230724114337762"></p>
<h4 id="is-null可以使用索引，is-not-null无法使用索引"><a href="#is-null可以使用索引，is-not-null无法使用索引" class="headerlink" title="is null可以使用索引，is not null无法使用索引"></a>is null可以使用索引，is not null无法使用索引</h4><ul>
<li>IS NULL: 可以触发索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>IS NOT NULL: 无法触发索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>结论：最好在设计数据库的时候就将<code>字段设置为 NOT NULL 约束</code>，比如你可以将 INT 类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(‘’)。</p>
<p>扩展：同理，在查询中使用<code>not like</code>也无法使用索引，导致全表扫描。</p>
<h4 id="like以通配符-开头索引失效"><a href="#like以通配符-开头索引失效" class="headerlink" title="like以通配符%开头索引失效"></a>like以通配符%开头索引失效</h4><p>在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为’%’，索引就不会起作用。只有’%’不在第一个位置，索引才会起作用。</p>
<ul>
<li>使用到索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;ab%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>未使用到索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%ab%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="OR-前后存在非索引的列，索引失效"><a href="#OR-前后存在非索引的列，索引失效" class="headerlink" title="OR 前后存在非索引的列，索引失效"></a>OR 前后存在非索引的列，索引失效</h4><p>在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，<strong>OR前后的两个条件中的列都是索引时，查询中才使用索引。</strong></p>
<p>因为OR的含义就是两个只要满足一个即可，因此<code>只有一个条件列进行了索引是没有意义的</code>，只要有条件列没有进行索引，就会进行<code>全表扫描</code>，因此所以的条件列也会失效。</p>
<p>查询语句使用OR关键字的情况：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">10</span> <span class="keyword">OR</span> classid <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>因为classId字段上没有索引，所以上述查询语句没有使用索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">10</span> <span class="keyword">OR</span> name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>因为age字段和name字段上都有索引，所以查询中使用了索引。你能看到这里使用到了<code>index_merge</code>，简单来说index_merge就是对age和name分别进行了扫描，然后将这两个结果集进行了合并。这样做的好处就是<code>避免了全表扫描</code>。</p>
<h4 id="数据库和表的字符集统一使用utf8mb4"><a href="#数据库和表的字符集统一使用utf8mb4" class="headerlink" title="数据库和表的字符集统一使用utf8mb4"></a>数据库和表的字符集统一使用utf8mb4</h4><p>统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不 同的 <code>字符集</code> 进行比较前需要进行 <code>转换</code> 会造成索引失效。</p>
<h3 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h3><h4 id="join语句原理"><a href="#join语句原理" class="headerlink" title="join语句原理"></a>join语句原理</h4><p>join方式连接多个表，本质就是各个表之间数据的循环匹配。MySQL5.5版本之前，MySQL只支持一种表间关联方式，就是嵌套循环(Nested Loop Join)。如果关联表的数据量很大，则join关联的执行时间会很长。在MySQL5.5以后的版本中，MySQL通过引入BNLJ算法来优化嵌套执行。</p>
<h5 id="1-驱动表和被驱动表"><a href="#1-驱动表和被驱动表" class="headerlink" title="1. 驱动表和被驱动表"></a>1. 驱动表和被驱动表</h5><p>驱动表就是主表，被驱动表就是从表、非驱动表。</p>
<ul>
<li>对于内连接来说：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">JOIN</span> B <span class="keyword">ON</span> ...</span><br></pre></td></tr></table></figure>

<p>A一定是驱动表吗？不一定，优化器会根据你查询语句做优化，决定先查哪张表。先查询的那张表就是驱动表，反之就是被驱动表。通过explain关键字可以查看。</p>
<ul>
<li>对于外连接来说：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> ...</span><br><span class="line"># 或</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> B <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> A <span class="keyword">ON</span> ... </span><br></pre></td></tr></table></figure>

<p>通常，大家会认为A就是驱动表，B就是被驱动表。但也未必。</p>
<h5 id="2-Simple-Nested-Loop-Join-简单嵌套循环连接"><a href="#2-Simple-Nested-Loop-Join-简单嵌套循环连接" class="headerlink" title="2. Simple Nested-Loop Join (简单嵌套循环连接)"></a>2. Simple Nested-Loop Join (简单嵌套循环连接)</h5><p>算法相当简单，从表A中取出一条数据1，遍历表B，将匹配到的数据放到result.. 以此类推，驱动表A中的每一条记录与被驱动表B的记录进行判断：</p>
<p><img src="image-20230724143530242.png" alt="image-20230724143530242"></p>
<p>可以看到这种方式效率是非常低的，以上述表A数据100条，表B数据1000条计算，则A*B&#x3D;10万次。开销统计如下:<img src="image-20230724143647333.png" alt="image-20230724143647333"></p>
<p>当然mysql肯定不会这么粗暴的去进行表的连接，所以就出现了后面的两种对Nested-Loop Join优化算法。</p>
<h5 id="3-Index-Nested-Loop-Join-（索引嵌套循环连接）"><a href="#3-Index-Nested-Loop-Join-（索引嵌套循环连接）" class="headerlink" title="3. Index Nested-Loop Join （索引嵌套循环连接）"></a>3. Index Nested-Loop Join （索引嵌套循环连接）</h5><p>Index Nested-Loop Join其优化的思路主要是为了<code>减少内存表数据的匹配次数</code>，所以要求被驱动表上必须<code>有索引</code>才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内存表的每条记录去进行比较，这样极大的减少了对内存表的匹配次数。</p>
<p><img src="image-20230724143814272.png" alt="image-20230724143814272"></p>
<p>驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故mysql优化器都倾向于使用记录数少的表作为驱动表（外表）。</p>
<p><img src="image-20230724143926587.png" alt="image-20230724143926587"></p>
<p>如果被驱动表加索引，效率是非常高的，但如果索引不是主键索引，所以还得进行一次回表查询。相比，被驱动表的索引是主键索引，效率会更高。</p>
<h5 id="4-Block-Nested-Loop-Join（块嵌套循环连接）"><a href="#4-Block-Nested-Loop-Join（块嵌套循环连接）" class="headerlink" title="4. Block Nested-Loop Join（块嵌套循环连接）"></a>4. Block Nested-Loop Join（块嵌套循环连接）</h5><p><img src="image-20230724144010126-1690180811819-4.png" alt="image-20230724144010126"></p>
<blockquote>
<p>注意：</p>
<p>这里缓存的不只是关联表的列，select后面的列也会缓存起来。</p>
<p>在一个有N个join关联的sql中会分配N-1个join buffer。所以查询的时候尽量减少不必要的字段，可以让join buffer中可以存放更多的列。</p>
</blockquote>
<p><img src="image-20230724144138332.png" alt="image-20230724144138332"></p>
<p><img src="image-20230724144147508.png" alt="image-20230724144147508"></p>
<p>参数设置：</p>
<ul>
<li>block_nested_loop</li>
</ul>
<p>通过<code>show variables like &#39;%optimizer_switch%</code> 查看 <code>block_nested_loop</code>状态。默认是开启的。</p>
<ul>
<li>join_buffer_size</li>
</ul>
<p>驱动表能不能一次加载完，要看join buffer能不能存储所有的数据，默认情况下<code>join_buffer_size=256k</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%join_buffer%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>join_buffer_size的最大值在32位操作系统可以申请4G，而在64位操作系统下可以申请大于4G的Join Buffer空间（64位Windows除外，其大值会被截断为4GB并发出警告）。</p>
<h5 id="5-Join小结"><a href="#5-Join小结" class="headerlink" title="5. Join小结"></a>5. Join小结</h5><p>1、<strong>整体效率比较：INLJ &gt; BNLJ &gt; SNLJ</strong></p>
<p>2、永远用小结果集驱动大结果集（其本质就是减少外层循环的数据数量）（小的度量单位指的是表行数 * 每行大小）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.b,t2.<span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.b<span class="operator">=</span>t2.b) <span class="keyword">where</span> t2.id<span class="operator">&lt;=</span><span class="number">100</span>; # 推荐</span><br><span class="line"><span class="keyword">select</span> t1.b,t2.<span class="operator">*</span> <span class="keyword">from</span> t2 straight_join t1 <span class="keyword">on</span> (t1.b<span class="operator">=</span>t2.b) <span class="keyword">where</span> t2.id<span class="operator">&lt;=</span><span class="number">100</span>; # 不推荐</span><br></pre></td></tr></table></figure>

<p>3、为被驱动表匹配的条件增加索引(减少内存表的循环匹配次数)</p>
<p>4、增大join buffer size的大小（一次索引的数据越多，那么内层包的扫描次数就越少）</p>
<p>5、减少驱动表不必要的字段查询（字段越少，join buffer所缓存的数据就越多）</p>
<h5 id="6-Hash-Join"><a href="#6-Hash-Join" class="headerlink" title="6. Hash Join"></a>6. Hash Join</h5><p><strong>从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join</strong></p>
<ul>
<li><p>Nested Loop:</p>
<p>对于被连接的数据子集较小的情况，Nested Loop是个较好的选择。</p>
</li>
<li><p>Hash Join是做<code>大数据集连接</code>时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立<code>散列表</code>，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。</p>
<ul>
<li>这种方式适合于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。</li>
<li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成<code>若干不同的分区</code>，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I&#x2F;O的性能。</li>
<li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是Join的重型升降机。Hash Join只能应用于等值连接（如WHERE A.COL1 &#x3D; B.COL2），这是由Hash的特点决定的。</li>
</ul>
<p><img src="image-20230724144436345.png" alt="image-20230724144436345"></p>
</li>
</ul>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul>
<li>保证被驱动表的JOIN字段已经创建了索引</li>
<li>需要JOIN 的字段，数据类型保持绝对一致。</li>
<li>LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。</li>
<li>INNER JOIN 时，MySQL会自动将 小结果集的表选为驱动表 。选择相信MySQL优化策略。</li>
<li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)</li>
<li>不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询。</li>
<li>衍生表建不了索引</li>
</ul>
<h3 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h3><p>MySQL从4.1版本开始支持子查询，使用子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结 果作为另一个SELECT语句的条件。 <code>子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作</code> 。</p>
<p>子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，子查询的执行效率不高。原因：</p>
<p>① 执行子查询时，MySQL需要为内层查询语句的查询结果 建立一个临时表 ，然后外层查询语句从临时表 中查询记录。查询完毕后，再撤销这些临时表 。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</p>
<p>② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都 不会存在索引 ，所以查询性能会 受到一定的影响。</p>
<p>③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p>
<p><strong>在MySQL中，可以使用连接（JOIN）查询来替代子查询。</strong>连接查询 <code>不需要建立临时表</code> ，其 <code>速度比子查询</code> 要快 ，如果查询中使用索引的话，性能就会更好。</p>
<blockquote>
<p>结论：尽量不要使用NOT IN或者NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</p>
</blockquote>
<h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><p>在MySQL中，支持两种排序方式，分别是 <code>FileSort</code> 和 <code>Index</code> 排序。</p>
<ul>
<li>Index 排序中，索引可以保证数据的有序性，不需要再进行排序，<code>效率更高</code>。</li>
<li>FileSort 排序则一般在 <code>内存中</code> 进行排序，占用<code>CPU较多</code>。如果待排结果较大，会产生临时文件 I&#x2F;O 到磁盘进行排序的情况，效率较低。</li>
</ul>
<p><strong>优化建议：</strong></p>
<ol>
<li>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 <code>避免全表扫描</code> ，在 ORDER BY 子句 <code>避免使用 FileSort 排序</code> 。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</li>
<li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列； 如果不同就使用联合索引。</li>
<li>无法使用 Index 时，需要对 FileSort 方式进行调优。</li>
</ol>
<p><strong>order by 时不limit,索引失效</strong></p>
<p><strong>order by 时顺序错误，索引失效</strong></p>
<p><strong>order by 时规则不一致，索引失效（顺序错，不索引；方向反，不索引）</strong></p>
<p><strong>无过滤，不索引</strong></p>
<p><strong>小结</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INDEX a_b_c(a,b,c)</span><br><span class="line">order by 能使用索引最左前缀</span><br><span class="line">- ORDER BY a</span><br><span class="line">- ORDER BY a,b</span><br><span class="line">- ORDER BY a,b,c</span><br><span class="line">- ORDER BY a DESC,b DESC,c DESC</span><br><span class="line">如果WHERE使用索引的最左前缀定义为常量，则order by 能使用索引</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b = const ORDER BY c</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b &gt; const ORDER BY b,c</span><br><span class="line">不能使用索引进行排序</span><br><span class="line">- ORDER BY a ASC,b DESC,c DESC /* 排序不一致 */</span><br><span class="line">- WHERE g = const ORDER BY b,c /*丢失a索引*/</span><br><span class="line">- WHERE a = const ORDER BY c /*丢失b索引*/</span><br><span class="line">- WHERE a = const ORDER BY a,d /*d不是索引的一部分*/</span><br><span class="line">- WHERE a in (...) ORDER BY b,c /*对于排序来说，多个相等条件也是范围查询*/</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ol>
<li>两个索引同时存在，mysql自动选择最优的方案。但是， <code>随着数据量的变化，选择的索引也会随之变化的 </code>。</li>
<li><strong>当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过 滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</strong></li>
</ol>
<h4 id="filesort算法：双路排序和单路排序"><a href="#filesort算法：双路排序和单路排序" class="headerlink" title="filesort算法：双路排序和单路排序"></a>filesort算法：双路排序和单路排序</h4><p>排序的字段若不在索引列上，则filesort会有两种算法：双路排序和单路排序</p>
<p><strong>双路排序 （慢）</strong></p>
<ul>
<li>MySQL 4.1之前是使用双路排序 ，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和 order by列 ，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li>
<li>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段 。</li>
</ul>
<p>取一批数据，要对磁盘进行两次扫描，众所周知，IO是很耗时的，所以在mysql4.1之后，出现了第二种 改进的算法，就是单路排序。</p>
<p><strong>单路排序 （快）</strong></p>
<p>从磁盘读取查询需要的 所有列 ，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。</p>
<p><strong>结论及引申出的问题</strong></p>
<ul>
<li>由于单路是后出的，总体而言好过双路</li>
<li>但是用单路有问题<ul>
<li>在sort_buffer中，单路要比多路多占用很多空间，因为单路是把所有字段都取出，所以有可能取出的数据的总大小超出了<code>sort_buffer</code>的容量，导致每次只能取<code>sort_buffer</code>容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取sort_buffer容量大小，再排…从而多次I&#x2F;O。</li>
<li>单路本来想省一次I&#x2F;O操作，反而导致了大量的I&#x2F;O操作，反而得不偿失。</li>
</ul>
</li>
</ul>
<p><strong>优化策略</strong></p>
<p><strong>1. 尝试提高 sort_buffer_size</strong></p>
<p><img src="image-20230725150209948.png" alt="image-20230725150209948"></p>
<p><strong>2. 尝试提高 max_length_for_sort_data</strong></p>
<p><img src="image-20230725150234449.png" alt="image-20230725150234449"></p>
<p><strong>3. Order by 时select * 是一个大忌。最好只Query需要的字段。</strong></p>
<p><img src="image-20230725150317521.png" alt="image-20230725150317521"></p>
<h3 id="GROUP-BY优化"><a href="#GROUP-BY优化" class="headerlink" title="GROUP BY优化"></a>GROUP BY优化</h3><ul>
<li>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。</li>
<li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li>
<li>当无法使用索引列，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置</li>
<li>where效率高于having，能写在where限定的条件就不要写在having中了</li>
<li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li>
<li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行 以内，否则SQL会很慢。</li>
</ul>
<h3 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询"></a>优化分页查询</h3><p><img src="image-20230725151145228.png" alt="image-20230725151145228"></p>
<p><strong>优化思路一</strong></p>
<p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p>
<p><strong>优化思路二</strong></p>
<p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。</p>
<h3 id="优先考虑覆盖索引"><a href="#优先考虑覆盖索引" class="headerlink" title="优先考虑覆盖索引"></a>优先考虑覆盖索引</h3><h4 id="什么是覆盖索引？"><a href="#什么是覆盖索引？" class="headerlink" title="什么是覆盖索引？"></a>什么是覆盖索引？</h4><p><strong>理解方式一</strong>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。<strong>一个索引包含了满足查询结果的数据就叫做覆盖索引</strong>。</p>
<p><strong>理解方式二</strong>：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列 （即建索引的字段正好是覆盖查询条件中所涉及的字段）。</p>
<p>简单说就是， <code>索引列+主键</code> 包含 <code>SELECT 到 FROM之间查询的列</code> 。</p>
<h4 id="覆盖索引的利弊"><a href="#覆盖索引的利弊" class="headerlink" title="覆盖索引的利弊"></a>覆盖索引的利弊</h4><p><img src="image-20230725151549435.png" alt="image-20230725151549435"></p>
<h3 id="如何给字符串添加索引"><a href="#如何给字符串添加索引" class="headerlink" title="如何给字符串添加索引"></a>如何给字符串添加索引</h3><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>MySQL是支持前缀索引的。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字 符串。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> teacher <span class="keyword">add</span> index index1(email);</span><br><span class="line">#或</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> teacher <span class="keyword">add</span> index index2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<p>这两种不同的定义在数据结构和存储上有什么区别呢？下图就是这两个索引的示意图。</p>
<p><img src="image-20230725151659989.png" alt="image-20230725151659989"></p>
<p>以及</p>
<p><img src="image-20230725151722370.png" alt="image-20230725151722370"></p>
<p><strong>如果使用的是index1</strong>（即email整个字符串的索引结构），执行顺序是这样的：</p>
<ol>
<li>从index1索引树找到满足索引值是’ <a href="mailto:zhangssxyz@xxx.com">zhangssxyz@xxx.com</a>’的这条记录，取得ID2的值；</li>
<li>到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；</li>
<li>取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email&#x3D;’ <a href="mailto:zhangssxyz@xxx.com">zhangssxyz@xxx.com</a> ’的 条件了，循环结束。</li>
</ol>
<p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p>
<p><strong>如果使用的是index2</strong>（即email(6)索引结构），执行顺序是这样的：</p>
<ol>
<li>从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1；</li>
<li>到主键上查到主键值是ID1的行，判断出email的值不是’ <a href="mailto:zhangssxyz@xxx.com">zhangssxyz@xxx.com</a> ’，这行记录丢弃；</li>
<li>取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然 后判断，这次值对了，将这行记录加入结果集；</li>
<li>重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。</li>
</ol>
<p>也就是说<strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong>前面 已经讲过区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。</p>
<h4 id="前缀索引对覆盖索引的影响"><a href="#前缀索引对覆盖索引的影响" class="headerlink" title="前缀索引对覆盖索引的影响"></a>前缀索引对覆盖索引的影响</h4><blockquote>
<p>结论： 使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。</p>
</blockquote>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><h4 id="使用前后对比"><a href="#使用前后对比" class="headerlink" title="使用前后对比"></a>使用前后对比</h4><p>Index Condition Pushdown(ICP)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式。</p>
<p><img src="image-20230725151906852.png" alt="image-20230725151906852"></p>
<h4 id="ICP的开启-x2F-关闭"><a href="#ICP的开启-x2F-关闭" class="headerlink" title="ICP的开启&#x2F;关闭"></a>ICP的开启&#x2F;关闭</h4><ul>
<li>默认情况下启动索引条件下推。可以通过设置系统变量<code>optimizer_switch</code>控制：<code>index_condition_pushdown</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 打开索引下推</span><br><span class="line"><span class="keyword">SET</span> optimizer_switch <span class="operator">=</span> <span class="string">&#x27;index_condition_pushdown=on&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 关闭索引下推</span><br><span class="line"><span class="keyword">SET</span> optimizer_switch <span class="operator">=</span> <span class="string">&#x27;index_condition_pushdown=off&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>当使用索引条件下推是，<code>EXPLAIN</code>语句输出结果中<code>Extra</code>列内容显示为<code>Using index condition</code>。</li>
</ul>
<h4 id="ICP的使用条件"><a href="#ICP的使用条件" class="headerlink" title="ICP的使用条件"></a>ICP的使用条件</h4><ol>
<li>如果表的访问类型为 range 、 ref 、 eq_ref 或者 ref_or_null 可以使用ICP。</li>
<li>ICP可以使用<code>InnDB</code>和<code>MyISAM</code>表，包括分区表<code>InnoDB</code>和<code>MyISAM</code>表</li>
<li>对于<code>InnoDB</code>表，ICP仅用于<code>二级索引</code>。ICP的目标是减少全行读取次数，从而减少I&#x2F;O操作。</li>
<li>当SQL使用覆盖索引时，不支持ICP优化方法。因为这种情况下使用ICP不会减少I&#x2F;O。</li>
<li>相关子查询的条件不能使用ICP</li>
</ol>
<h3 id="普通索引-vs-唯一索引"><a href="#普通索引-vs-唯一索引" class="headerlink" title="普通索引 vs 唯一索引"></a>普通索引 vs 唯一索引</h3><h4 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h4><p>假设，执行查询的语句是 select id from test where k&#x3D;5。</p>
<ul>
<li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一 个不满足k&#x3D;5条件的记录。</li>
<li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检 索。</li>
</ul>
<p>那么，这个不同带来的性能差距会有多少呢？答案是， 微乎其微 。</p>
<h4 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h4><p>为了说明普通索引和唯一索引对更新语句性能的影响这个问题，介绍一下change buffer。</p>
<p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话， 在不影响数据一致性的前提下， <code>InooDB会将这些更新操作缓存在change buffer中</code> ，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p>
<p>将change buffer中的操作应用到原数据页，得到最新结果的过程称为 merge 。除了 <code>访问这个数据页</code> 会触 发merge外，系统有 <code>后台线程会定期</code> merge。在 <code>数据库正常关闭（shutdown）</code> 的过程中，也会执行merge 操作。</p>
<p>如果能够将更新操作先记录在change buffer， <code>减少读磁盘</code> ，语句的执行速度会得到明显的提升。而且， 数据读入内存是需要占用 buffer pool 的，所以这种方式还能够 <code>避免占用内存 </code>，提高内存利用率。</p>
<p><code>唯一索引的更新就不能使用change buffer</code> ，实际上也只有普通索引可以使用。</p>
<h4 id="change-buffer的使用场景"><a href="#change-buffer的使用场景" class="headerlink" title="change buffer的使用场景"></a>change buffer的使用场景</h4><ol>
<li>普通索引和唯一索引应该怎么选择？其实，这两类索引在查询能力上是没差别的，主要考虑的是 对 更新性能 的影响。所以，建议你 尽量选择普通索引 。</li>
<li>在实际使用中会发现， 普通索引 和 change buffer 的配合使用，对于 数据量大 的表的更新优化 还是很明显的。</li>
<li>如果所有的更新后面，都马上 伴随着对这个记录的查询 ，那么你应该 关闭change buffer 。而在 其他情况下，change buffer都能提升更新性能。</li>
<li>由于唯一索引用不上change buffer的优化机制，因此如果 业务可以接受 ，从性能角度出发建议优 先考虑非唯一索引。但是如果”业务可能无法确保”的情况下，怎么处理呢？<ul>
<li>首先， 业务正确性优先 。我们的前提是“业务代码已经保证不会写入重复数据”的情况下，讨论性能 问题。如果业务不能保证，或者业务就是要求数据库来做约束，那么没得选，必须创建唯一索引。 这种情况下，本节的意义在于，如果碰上了大量插入数据慢、内存命中率低的时候，给你多提供一 个排查思路。</li>
<li>然后，在一些“ 归档库 ”的场景，你是可以考虑使用唯一索引的。比如，线上数据只需要保留半年， 然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。要提高归档效率， 可以考虑把表里面的唯一索引改成普通索引。</li>
</ul>
</li>
</ol>
<h3 id="其它查询优化策略"><a href="#其它查询优化策略" class="headerlink" title="其它查询优化策略"></a>其它查询优化策略</h3><h4 id="EXISTS-和-IN-的区分"><a href="#EXISTS-和-IN-的区分" class="headerlink" title="EXISTS 和 IN 的区分"></a>EXISTS 和 IN 的区分</h4><p><img src="image-20230726145628244.png" alt="image-20230726145628244"></p>
<h4 id="COUNT-与COUNT-具体字段-效率"><a href="#COUNT-与COUNT-具体字段-效率" class="headerlink" title="COUNT(*)与COUNT(具体字段)效率"></a>COUNT(*)与COUNT(具体字段)效率</h4><p><img src="image-20230726174542607.png" alt="image-20230726174542607"></p>
<h4 id="关于SELECT"><a href="#关于SELECT" class="headerlink" title="关于SELECT(*)"></a>关于SELECT(*)</h4><p>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT &lt;字段列表&gt; 查询。原因：</p>
<p>① MySQL 在解析的过程中，会通过查询数据字典 将”*”按序转换成所有列名，这会大大的耗费资源和时间。</p>
<p>② 无法使用 覆盖索</p>
<h4 id="LIMIT-1-对优化的影响"><a href="#LIMIT-1-对优化的影响" class="headerlink" title="LIMIT 1 对优化的影响"></a>LIMIT 1 对优化的影响</h4><p>针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上 LIMIT 1 的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p>
<p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上 LIMIT 1 了。</p>
<h4 id="多使用COMMIT"><a href="#多使用COMMIT" class="headerlink" title="多使用COMMIT"></a>多使用COMMIT</h4><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放 的资源而减少。</p>
<p>COMMIT 所释放的资源：</p>
<ul>
<li>回滚段上用于恢复数据的信息</li>
<li>被程序语句获得的锁</li>
<li>redo &#x2F; undo log buffer 中的空间</li>
<li>管理上述 3 种资源中的内部花费</li>
</ul>
<h3 id="淘宝数据库，主键如何设计的？"><a href="#淘宝数据库，主键如何设计的？" class="headerlink" title="淘宝数据库，主键如何设计的？"></a>淘宝数据库，主键如何设计的？</h3><h4 id="自增ID的问题"><a href="#自增ID的问题" class="headerlink" title="自增ID的问题"></a>自增ID的问题</h4><p>自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除 了简单，其他都是缺点，总体来看存在以下几方面的问题：</p>
<ol>
<li><p><strong>可靠性不高</strong></p>
<p>存在自增ID回溯的问题，这个问题直到最新版本的MySQL 8.0才修复。</p>
</li>
<li><p>**安全性不高 **</p>
<p>对外暴露的接口可以非常容易猜测对应的信息。比如：&#x2F;User&#x2F;1&#x2F;这样的接口，可以非常容易猜测用户ID的 值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。</p>
</li>
<li><p><strong>性能差</strong></p>
<p>自增ID的性能较差，需要在数据库服务器端生成。</p>
</li>
<li><p><strong>交互多</strong></p>
<p>业务还需要额外执行一次类似 last_insert_id() 的函数才能知道刚才插入的自增值，这需要多一次的 网络交互。在海量并发的系统中，多1条SQL，就多一次性能上的开销。</p>
</li>
<li><p>**局部唯一性 **</p>
<p>最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都 是唯一的。对于目前分布式系统来说，这简直就是噩梦。</p>
</li>
</ol>
<h4 id="业务字段做主键"><a href="#业务字段做主键" class="headerlink" title="业务字段做主键"></a>业务字段做主键</h4><p>为了能够唯一地标识一个会员的信息，需要为 会员信息表 设置一个主键。那么，怎么为这个表设置主 键，才能达到我们理想的目标呢？ 这里我们考虑业务字段做主键。</p>
<p>表数据如下：</p>
<p><img src="image-20230728142608606.png" alt="image-20230728142608606"></p>
<p>在这个表里，哪个字段比较合适呢？</p>
<ul>
<li><strong>选择卡号（cardno）</strong></li>
</ul>
<p>会员卡号（cardno）看起来比较合适，因为会员卡号不能为空，而且有唯一性，可以用来 标识一条会员 记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo.membermaster</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> (</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> cardno <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">PRIMARY</span> KEY, <span class="comment">-- 会员卡号为主键</span></span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> membername TEXT,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> memberphone TEXT,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> memberpid TEXT,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> memberaddress TEXT,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> sex TEXT,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> birthday DATETIME</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> );</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.06</span> sec)</span><br></pre></td></tr></table></figure>

<p>不同的会员卡号对应不同的会员，字段“cardno”唯一地标识某一个会员。如果都是这样，会员卡号与会 员一一对应，系统是可以正常运行的。</p>
<p>但实际情况是， 会员卡号可能存在重复使用 的情况。比如，张三因为工作变动搬离了原来的地址，不再 到商家的门店消费了 （退还了会员卡），于是张三就不再是这个商家门店的会员了。但是，商家不想让 这个会 员卡空着，就把卡号是“10000001”的会员卡发给了王五。</p>
<p>从系统设计的角度看，这个变化只是修改了会员信息表中的卡号是“10000001”这个会员 信息，并不会影 响到数据一致性。也就是说，修改会员卡号是“10000001”的会员信息， 系统的各个模块，都会获取到修 改后的会员信息，不会出现“有的模块获取到修改之前的会员信息，有的模块获取到修改后的会员信息， 而导致系统内部数据不一致”的情况。因此，从 信息系统层面 上看是没问题的。</p>
<p>但是从使用 系统的业务层面 来看，就有很大的问题 了，会对商家造成影响。</p>
<p>比如，我们有一个销售流水表（trans），记录了所有的销售流水明细。2020 年 12 月 01 日，张三在门店 购买了一本书，消费了 89 元。那么，系统中就有了张三买书的流水记录，如下所示：</p>
<p><img src="image-20230728142712172.png" alt="image-20230728142712172"></p>
<p>接着，我们查询一下 2020 年 12 月 01 日的会员销售记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> b.membername,c.goodsname,a.quantity,a.salesvalue,a.transdate</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> demo.trans <span class="keyword">AS</span> a</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">JOIN</span> demo.membermaster <span class="keyword">AS</span> b</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">JOIN</span> demo.goodsmaster <span class="keyword">AS</span> c</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> (a.cardno <span class="operator">=</span> b.cardno <span class="keyword">AND</span> a.itemnumber<span class="operator">=</span>c.itemnumber);</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> membername <span class="operator">|</span> goodsname <span class="operator">|</span> quantity <span class="operator">|</span> salesvalue <span class="operator">|</span> transdate <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span>     张三   <span class="operator">|</span> 书         <span class="operator">|</span> <span class="number">1.000</span>    <span class="operator">|</span> <span class="number">89.00</span>      <span class="operator">|</span> <span class="number">2020</span><span class="number">-12</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>如果会员卡“10000001”又发给了王五，我们会更改会员信息表。导致查询时：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> b.membername,c.goodsname,a.quantity,a.salesvalue,a.transdate</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> demo.trans <span class="keyword">AS</span> a</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">JOIN</span> demo.membermaster <span class="keyword">AS</span> b</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">JOIN</span> demo.goodsmaster <span class="keyword">AS</span> c</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> (a.cardno <span class="operator">=</span> b.cardno <span class="keyword">AND</span> a.itemnumber<span class="operator">=</span>c.itemnumber);</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> membername <span class="operator">|</span> goodsname <span class="operator">|</span> quantity <span class="operator">|</span> salesvalue <span class="operator">|</span> transdate <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> 王五        <span class="operator">|</span> 书        <span class="operator">|</span> <span class="number">1.000</span>    <span class="operator">|</span> <span class="number">89.00</span>      <span class="operator">|</span> <span class="number">2020</span><span class="number">-12</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>这次得到的结果是：王五在 2020 年 12 月 01 日，买了一本书，消费 89 元。显然是错误的！结论：千万 不能把会员卡号当做主键。</p>
<ul>
<li><strong>选择会员电话 或 身份证号</strong></li>
</ul>
<p>会员电话可以做主键吗？不行的。在实际操作中，手机号也存在 被运营商收回 ，重新发给别人用的情况。</p>
<p>那身份证号行不行呢？好像可以。因为身份证决不会重复，身份证号与一个人存在一一对 应的关系。可 问题是，身份证号属于 个人隐私 ，顾客不一定愿意给你。要是强制要求会员必须登记身份证号，会把很 多客人赶跑的。其实，客户电话也有这个问题，这也是我们在设计会员信息表的时候，允许身份证号和 电话都为空的原因。</p>
<p><strong>所以，建议尽量不要用跟业务有关的字段做主键。毕竟，作为项目设计的技术人员，我们谁也无法预测 在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现。</strong></p>
<blockquote>
<p>经验： 刚开始使用 MySQL 时，很多人都很容易犯的错误是喜欢用业务字段做主键，想当然地认为了解业 务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高。</p>
</blockquote>
<h4 id="推荐的主键设计"><a href="#推荐的主键设计" class="headerlink" title="推荐的主键设计"></a>推荐的主键设计</h4><p><strong>非核心业务</strong> ：对应表的主键自增ID，如告警、日志、监控等信息。</p>
<p><strong>核心业务</strong> ：<code>主键设计至少应该是全局唯一且是单调递增</code>。全局唯一保证在各系统之间都是唯一的，单调 递增是希望插入时不影响数据库性能。</p>
<p>这里推荐最简单的一种主键设计：UUID。</p>
<p><strong>UUID的特点：</strong></p>
<p>全局唯一，占用36字节，数据无序，插入性能差。</p>
<p><strong>认识UUID：</strong></p>
<ul>
<li>为什么UUID是全局唯一的？</li>
<li>为什么UUID占用36个字节？</li>
<li>为什么UUID是无序的？</li>
</ul>
<p>MySQL数据库的UUID组成如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UUID = 时间+UUID版本（16字节）- 时钟序列（4字节） - MAC地址（12字节）</span><br></pre></td></tr></table></figure>

<p>我们以UUID值e0ea12d4-6473-11eb-943c-00155dbaa39d举例：</p>
<p><img src="image-20230728142908005.png" alt="image-20230728142908005"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为什么UUID是全局唯一的？</span><br></pre></td></tr></table></figure>

<p>在UUID中时间部分占用60位，存储的类似TIMESTAMP的时间戳，但表示的是从1582-10-15 00：00：00.00 到现在的100ns的计数。可以看到UUID存储的时间精度比TIMESTAMPE更高，时间维度发生重复的概率降 低到1&#x2F;100ns。</p>
<p>时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC地址用于全局唯一。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为什么UUID占用36个字节？</span><br></pre></td></tr></table></figure>

<p>UUID根据字符串进行存储，设计时还带有无用”-“字符串，因此总共需要36个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为什么UUID是随机无序的呢？</span><br></pre></td></tr></table></figure>

<p>因为UUID的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。</p>
<p><strong>改造UUID</strong></p>
<p>若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MySQL 8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。</p>
<p>MySQL 8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的”-“字符串，并且将字符串用二进制类型保存，这样存储空间降低为了16字节。</p>
<p>可以通过MySQL8.0提供的uuid_to_bin函数实现上述功能，同样的，MySQL也提供了bin_to_uuid函数进行转化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @uuid = UUID();</span><br><span class="line">SELECT @uuid,uuid_to_bin(@uuid),uuid_to_bin(@uuid,TRUE);</span><br></pre></td></tr></table></figure>

<p><img src="image-20230728142943472.png" alt="image-20230728142943472"></p>
<p><strong>通过函数uuid_to_bin(@uuid,true)将UUID转化为有序UUID了</strong>。全局唯一 + 单调递增，这不就是我们想要的主键！</p>
<p><strong>有序UUID性能测试</strong></p>
<p>16字节的有序UUID，相比之前8字节的自增ID，性能和存储空间对比究竟如何呢？</p>
<p>我们来做一个测试，插入1亿条数据，每条数据占用500字节，含有3个二级索引，最终的结果如下所示：</p>
<p><img src="image-20230728143001825.png" alt="image-20230728143001825"></p>
<p>从上图可以看到插入1亿条数据有序UUID是最快的，而且在实际业务使用中有序UUID在 <code>业务端就可以生成</code> 。还可以进一步减少SQL的交互次数。</p>
<p>另外，虽然有序UUID相比自增ID多了8个字节，但实际只增大了3G的存储空间，还可以接受。</p>
<blockquote>
<p>在当今的互联网环境中，非常不推荐自增ID作为主键的数据库设计。更推荐类似有序UUID的全局 唯一的实现。</p>
<p>另外在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。这样 的主键设计就更为考验架构师的水平了。</p>
</blockquote>
<p><strong>如果不是MySQL8.0 肿么办？</strong></p>
<p>手动赋值字段做主键！</p>
<p>比如，设计各个分店的会员表的主键，因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题。</p>
<p>可以在总部 MySQL 数据库中，有一个管理信息表，在这个表中添加一个字段，专门用来记录当前会员编号的最大值。</p>
<p>门店在添加会员的时候，先到总部 MySQL 数据库中获取这个最大值，在这个基础上加 1，然后用这个值 作为新会员的“id”，同时，更新总部 MySQL 数据库管理信息表中的当前会员编号的最大值。</p>
<p>这样一来，各个门店添加会员的时候，都对同一个总部 MySQL 数据库中的数据表字段进行操作，就解 决了各门店添加会员时会员编号冲突的问题。</p>
<h2 id="数据库的设计规范"><a href="#数据库的设计规范" class="headerlink" title="数据库的设计规范"></a>数据库的设计规范</h2><h3 id="为什么需要数据库设计"><a href="#为什么需要数据库设计" class="headerlink" title="为什么需要数据库设计"></a>为什么需要数据库设计</h3><p><img src="image-20230728143132063.png" alt="image-20230728143132063"></p>
<h3 id="范-式"><a href="#范-式" class="headerlink" title="范 式"></a>范 式</h3><h4 id="范式简介"><a href="#范式简介" class="headerlink" title="范式简介"></a>范式简介</h4><p>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。可以理解为，一张数据表的设计结 构需要满足的某种设计标准的 级别 。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p>
<h4 id="范式都包括哪些"><a href="#范式都包括哪些" class="headerlink" title="范式都包括哪些"></a>范式都包括哪些</h4><p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式 （2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</p>
<p>数据库的范式设计越高阶，夯余度就越低，同时高阶的范式一定符合低阶范式的要求，满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范的要求称为第二范式（2NF），其余范式以此类推。</p>
<p>一般来说，在关系型数据库设计中，最高也就遵循到<code>BCNF</code>, 普遍还是<code>3NF</code>。但也不绝对，有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是<code>反规范化</code>。</p>
<p><img src="image-20230728143252520.png" alt="image-20230728143252520"></p>
<h4 id="键和相关属性的概念"><a href="#键和相关属性的概念" class="headerlink" title="键和相关属性的概念"></a>键和相关属性的概念</h4><p><img src="image-20230728143330716-1690526011905-1.png" alt="image-20230728143330716"></p>
<p><strong>举例:</strong></p>
<p>这里有两个表：</p>
<p><code>球员表(player)</code> ：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号</p>
<p><code>球队表(team) </code>：球队编号 | 主教练 | 球队所在地</p>
<ul>
<li>超键 ：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号） （球员编号，姓名）（身份证号，年龄）等。</li>
<li>候选键 ：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。</li>
<li>主键 ：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。</li>
<li>外键 ：球员表中的球队编号。</li>
<li>主属性 、 非主属性 ：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名） （年龄）（球队编号）都是非主属性。</li>
</ul>
<h4 id="第一范式-1st-NF"><a href="#第一范式-1st-NF" class="headerlink" title="第一范式(1st NF)"></a>第一范式(1st NF)</h4><p>第一范式主要确保数据库中每个字段的值必须具有<code>原子性</code>，也就是说数据表中每个字段的值为<code>不可再次拆分</code>的最小数据单元。</p>
<p>我们在设计某个字段的时候，对于字段X来说，不能把字段X拆分成字段X-1和字段X-2。事实上，任何的DBMS都会满足第一范式的要求，不会将字段进行拆分。</p>
<h4 id="第二范式-2nd-NF"><a href="#第二范式-2nd-NF" class="headerlink" title="第二范式(2nd NF)"></a>第二范式(2nd NF)</h4><p>第二范式要求，在满足第一范式的基础上，还要<strong>满足数据库里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分</strong>。如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。（要求中的主键，其实可以扩展替换为候选键）。</p>
<h4 id="第三范式-3rd-NF"><a href="#第三范式-3rd-NF" class="headerlink" title="第三范式(3rd NF)"></a>第三范式(3rd NF)</h4><p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，<strong>要求数据表中的所有非主键字段不能依赖于其他非主键字段</strong>。（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在“A-&gt;B-&gt;C”的决定关系）通俗地讲，该规则的意思是所有<code>非主键属性</code>之间不能由依赖关系，必须<code>相互独立</code>。</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p><img src="image-20230728153559784.png" alt="image-20230728153559784"></p>
<h3 id="反范式化"><a href="#反范式化" class="headerlink" title="反范式化"></a>反范式化</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><img src="image-20230728153651374.png" alt="image-20230728153651374"></p>
<p><strong>规范化 vs 性能</strong></p>
<blockquote>
<ol>
<li>为满足某种商业目标 , 数据库性能比规范化数据库更重要</li>
<li>在数据规范化的同时 , 要综合考虑数据库的性能</li>
<li>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间</li>
<li>通过在给定的表中插入计算列，以方便查询</li>
</ol>
</blockquote>
<h4 id="反范式的新问题"><a href="#反范式的新问题" class="headerlink" title="反范式的新问题"></a>反范式的新问题</h4><ul>
<li>存储 空间变大了</li>
<li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则 数据不一致</li>
<li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常 消耗系统资源</li>
<li>在 数据量小 的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加复杂</li>
</ul>
<h4 id="反范式的适用场景"><a href="#反范式的适用场景" class="headerlink" title="反范式的适用场景"></a>反范式的适用场景</h4><p>当冗余信息有价值或者能 <code>大幅度提高查询效率</code> 的时候，我们才会采取反范式的优化。</p>
<h5 id="1-增加冗余字段的建议"><a href="#1-增加冗余字段的建议" class="headerlink" title="1. 增加冗余字段的建议"></a>1. 增加冗余字段的建议</h5><p>增加冗余字段一定要符合如下两个条件。只要满足这两个条件，才可以考虑增加夯余字段。</p>
<p>1）这个冗余字段<code>不需要经常进行修改</code>。</p>
<p>2）这个冗余字段<code>查询的时候不可或缺</code>。</p>
<h5 id="2-历史快照、历史数据的需要"><a href="#2-历史快照、历史数据的需要" class="headerlink" title="2. 历史快照、历史数据的需要"></a>2. 历史快照、历史数据的需要</h5><p>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每 次发生的 <code>订单收货信息</code> 都属于 <code>历史快照</code> ，需要进行保存，但用户可以随时修改自己的信息，这时保存这 些冗余信息是非常有必要的。</p>
<p>反范式优化也常用在 <code>数据仓库</code> 的设计中，因为数据仓库通常<code>存储历史数据</code> ，对增删改的实时性要求不 强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p>
<p>我简单总结下数据仓库和数据库在使用上的区别：</p>
<ol>
<li>数据库设计的目的在于<code>捕捉数据</code>，而数据仓库设计的目的在于<code>分析数据</code>。</li>
<li>数据库对数据的<code>增删改实时性</code>要求强，需要存储在线的用户数据，而数据仓库存储的一般是<code>历史数据</code>。</li>
<li>数据库设计需要<code>尽量避免冗余</code>，但为了提高查询效率也允许一定的<code>冗余度</code>，而数据仓库在设计上更偏向采用反范式设计，</li>
</ol>
<h3 id="BCNF-巴斯范式"><a href="#BCNF-巴斯范式" class="headerlink" title="BCNF(巴斯范式)"></a>BCNF(巴斯范式)</h3><p>人们在3NF的基础上进行了改进，提出了巴斯范式（BCNF），页脚巴斯 - 科德范式（Boyce - Codd Normal Form）。BCNF被认为没有新的设计规范加入，只是对第三范式中设计规范要求更强，使得数据库冗余度更小。所以，称为是<code>修正的第三范式</code>，或<code>扩充的第三范式</code>，BCNF不被称为第四范式。</p>
<h3 id="第四范式"><a href="#第四范式" class="headerlink" title="第四范式"></a>第四范式</h3><p>多值依赖的概念：</p>
<ul>
<li><code>多值依赖</code>即属性之间的一对多关系，记为K—&gt;—&gt;A。</li>
<li><code>函数依赖</code>事实上是单值依赖，所以不能表达属性值之间的一对多关系。</li>
<li><code>平凡的多值依赖</code>：全集U&#x3D;K+A，一个K可以对应于多个A，即K—&gt;—&gt;A。此时整个表就是一组一对多关系。</li>
<li><code>非平凡的多值依赖</code>：全集U&#x3D;K+A+B，一个K可以对应于多个A，也可以对应于多个B，A与B相互独立，即K—&gt;—&gt;A，K—&gt;—&gt;B。整个表有多组一对多关系，且有：”一”部分是相同的属性集合，“多”部分是相互独立的属性集合。</li>
</ul>
<p>第四范式即在满足巴斯 - 科德范式（BCNF）的基础上，消除非平凡且非函数依赖的多值依赖（即把同一表的多对多关系删除）。</p>
<h3 id="第五范式、域键范式"><a href="#第五范式、域键范式" class="headerlink" title="第五范式、域键范式"></a>第五范式、域键范式</h3><p>除了第四范式外，我们还有更高级的第五范式（又称完美范式）和域键范式（DKNF）。</p>
<p>在满足第四范式（4NF）的基础上，消除不是由候选键所蕴含的连接依赖。<strong>如果关系模式R中的每一个连 接依赖均由R的候选键所隐含</strong>，则称此关系模式符合第五范式。</p>
<p>函数依赖是多值依赖的一种特殊的情况，而多值依赖实际上是连接依赖的一种特殊情况。但连接依赖不 像函数依赖和多值依赖可以由 <code>语义直接导出</code> ，而是在 <code>关系连接运算</code> 时才反映出来。存在连接依赖的关系 模式仍可能遇到数据冗余及插入、修改、删除异常等问题。</p>
<p>第五范式处理的是 <code>无损连接问题</code> ，这个范式基本 <code>没有实际意义</code> ，因为无损连接很少出现，而且难以察觉。而域键范式试图定义一个 <code>终极范式</code> ，该范式考虑所有的依赖和约束类型，但是实用价值也是最小的，只存在理论研究中。</p>
<h3 id="ER模型"><a href="#ER模型" class="headerlink" title="ER模型"></a>ER模型</h3><p><img src="image-20230728164420172.png" alt="image-20230728164420172"></p>
<h4 id="ER模型包括哪些要素？"><a href="#ER模型包括哪些要素？" class="headerlink" title="ER模型包括哪些要素？"></a>ER模型包括哪些要素？</h4><p><strong>ER 模型中有三个要素，分别是实体、属性和关系。</strong></p>
<p><code>实体</code> ，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用 矩形 来表 示。实体分为两类，分别是 强实体 和 弱实体 。强实体是指不依赖于其他实体的实体；弱实体是指对另 一个实体有很强的依赖关系的实体。</p>
<p><code>属性</code> ，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用 椭圆形 来表示。</p>
<p><code>关系</code> ，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模 型中用 菱形 来表示。</p>
<p>注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，<strong>可以独立存在的是实体，不可再分的是属性</strong>。也就是说，属性不能包含其他属性。</p>
<h4 id="关系的类型"><a href="#关系的类型" class="headerlink" title="关系的类型"></a>关系的类型</h4><p>在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是 一对一、一对多、多对多。</p>
<p><code>一对一</code> ：指实体之间的关系是一一对应的，比如个人与身份证信息之间的关系就是一对一的关系。一个人只能有一个身份证信息，一个身份证信息也只属于一个人。</p>
<p><code>一对多</code> ：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体。比如说，我们新建一个班级表，而每个班级都有多个学生，每个学 生则对应一个班级，班级对学生就是一对多的关系。</p>
<p><code>多对多</code> ：指关系两边的实体都可以通过关系对应多个对方的实体。比如在进货模块中，供货商与超市之 间的关系就是多对多的关系，一个供货商可以给多个超市供货，一个超市也可以从多个供货商那里采购 商品。再比如一个选课表，有许多科目，每个科目有很多学生选，而每个学生又可以选择多个科目，这 就是多对多的关系。</p>
<h4 id="建模分析"><a href="#建模分析" class="headerlink" title="建模分析"></a>建模分析</h4><p>ER 模型看起来比较麻烦，但是对我们把控项目整体非常重要。如果你只是开发一个小应用，或许简单设 计几个表够用了，一旦要设计有一定规模的应用，在项目的初始阶段，建立完整的 ER 模型就非常关键 了。开发应用项目的实质，其实就是 建模 。</p>
<h3 id="数据表的设计原则"><a href="#数据表的设计原则" class="headerlink" title="数据表的设计原则"></a>数据表的设计原则</h3><p>综合以上内容，总结出数据表设计的一般原则：”三少一多”</p>
<p><strong>1. 数据表的个数越少越好</strong></p>
<p><img src="image-20230731133244497.png" alt="image-20230731133244497"></p>
<p><strong>2. 数据表中的字段个数越少越好</strong></p>
<p><img src="image-20230731133303415.png" alt="image-20230731133303415"></p>
<p><strong>3. 数据表中联合主键的字段个数越少越好</strong></p>
<p><img src="image-20230731133319904.png" alt="image-20230731133319904"></p>
<p><strong>4. 使用主键和外键越多越好</strong></p>
<p><img src="image-20230731133336238.png" alt="image-20230731133336238"></p>
<h3 id="数据库对象编写建议"><a href="#数据库对象编写建议" class="headerlink" title="数据库对象编写建议"></a>数据库对象编写建议</h3><h4 id="关于库"><a href="#关于库" class="headerlink" title="关于库"></a>关于库</h4><ol>
<li>【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字 母开头。</li>
<li>【强制】库名中英文 一律小写 ，不同单词采用 下划线 分割。须见名知意。</li>
<li>【强制】库的名称格式：业务系统名称_子系统名。</li>
<li>【强制】库名禁止使用关键字（如type,order等）。</li>
<li>【强制】创建数据库时必须 显式指定字符集 ，并且字符集只能是utf8或者utf8mb4。 创建数据库SQL举例：CREATE DATABASE crm_fund DEFAULT CHARACTER SET ‘utf8’ ;</li>
<li>【建议】对于程序连接数据库账号，遵循 权限最小原则 使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号 原则上不准有drop权限 。</li>
<li>【建议】临时库以 tmp_ 为前缀，并以日期为后缀； 备份库以 bak_ 为前缀，并以日期为后缀。</li>
</ol>
<h4 id="关于表、列"><a href="#关于表、列" class="headerlink" title="关于表、列"></a>关于表、列</h4><ol>
<li><p>【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议 以 英文字母开头 。</p>
</li>
<li><p>【强制】 表名、列名一律小写 ，不同单词采用下划线分割。须见名知意。</p>
</li>
<li><p>【强制】表名要求有模块名强相关，同一模块的表名尽量使用 统一前缀 。比如：crm_fund_item</p>
</li>
<li><p>【强制】创建表时必须 显式指定字符集 为utf8或utf8mb4。</p>
</li>
<li><p>【强制】表名、列名禁止使用关键字（如type,order等）。</p>
</li>
<li><p>【强制】创建表时必须 显式指定表存储引擎 类型。如无特殊需求，一律为InnoDB。</p>
</li>
<li><p>【强制】建表必须有comment。</p>
</li>
<li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或 缩写 。如：公司 ID，不要使用 corporation_id, 而用corp_id 即可。</p>
</li>
<li><p>【强制】布尔值类型的字段命名为 is_描述 。如member表上表示是否为enabled的会员的字段命 名为 is_enabled。</p>
</li>
<li><p>【强制】禁止在数据库中存储图片、文件等大的二进制数据 通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随 机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。</p>
</li>
<li><p>【建议】建表时关于主键： 表必须有主键</p>
<p>(1)强制要求主键为id，类型为int或bigint，且为 auto_increment 建议使用unsigned无符号型。</p>
<p>(2)标识表里每一行主体的字段不要设为主键，建议 设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机 插入，则会导致innodb内部页分裂和大量随机I&#x2F;O，性能下降。</p>
</li>
<li><p>【建议】核心表（如用户表）必须有行数据的 创建时间字段 （create_time）和 最后更新时间字段 （update_time），便于查问题。</p>
</li>
<li><p>【建议】表中所有字段尽量都是 NOT NULL 属性，业务可以根据需要定义 DEFAULT值 。 因为使用 NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问 题。</p>
</li>
<li><p>【建议】所有存储相同数据的 列名和列类型必须一致 （一般作为关联列，如果查询时关联列类型 不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。</p>
</li>
<li><p>【建议】中间表（或临时表）用于保留中间结果集，名称以 tmp_ 开头。 备份表用于备份或抓取源表快照，名称以 bak_ 开头。中间表和备份表定期清理。 </p>
</li>
<li><p>【示范】一个较为规范的建表语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE user_info (</span><br><span class="line">`id` int unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增主键&#x27;,</span><br><span class="line">`user_id` bigint(11) NOT NULL COMMENT &#x27;用户id&#x27;,</span><br><span class="line">`username` varchar(45) NOT NULL COMMENT &#x27;真实姓名&#x27;,</span><br><span class="line">`email` varchar(30) NOT NULL COMMENT &#x27;用户邮箱&#x27;,</span><br><span class="line">`nickname` varchar(45) NOT NULL COMMENT &#x27;昵称&#x27;,</span><br><span class="line">`birthday` date NOT NULL COMMENT &#x27;生日&#x27;,</span><br><span class="line">`sex` tinyint(4) DEFAULT &#x27;0&#x27; COMMENT &#x27;性别&#x27;,</span><br><span class="line">`short_introduce` varchar(150) DEFAULT NULL COMMENT &#x27;一句话介绍自己，最多50个汉字&#x27;,</span><br><span class="line">`user_resume` varchar(300) NOT NULL COMMENT &#x27;用户提交的简历存放地址&#x27;,</span><br><span class="line">`user_register_ip` int NOT NULL COMMENT &#x27;用户注册时的源ip&#x27;,</span><br><span class="line">`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE</span><br><span class="line">CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">`user_review_status` tinyint NOT NULL COMMENT &#x27;用户资料审核状态，1为通过，2为审核中，3为未</span><br><span class="line">通过，4为还未提交审核&#x27;,</span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">UNIQUE KEY `uniq_user_id` (`user_id`),</span><br><span class="line">KEY `idx_username`(`username`),</span><br><span class="line">KEY `idx_create_time_status`(`create_time`,`user_review_status`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;网站用户基本信息</span><br></pre></td></tr></table></figure>
</li>
<li><p>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。</p>
<p>实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。</p>
<p>可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。</p>
</li>
</ol>
<h4 id="关于索引"><a href="#关于索引" class="headerlink" title="关于索引"></a>关于索引</h4><ol>
<li>【强制】InnoDB表必须主键为id int&#x2F;bigint auto_increment，且主键值 禁止被更新 。</li>
<li>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为 BTREE 。</li>
<li>【建议】主键的名称以 pk_ 开头，唯一键以 uni_ 或 uk_ 开头，普通索引以 idx_ 开头，一律使用小写格式，以字段的名称或缩写作为后缀。</li>
<li>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如: sample 表 member_id 上的索引：idx_sample_mid。</li>
<li>【建议】单个表上的索引个数 不能超过6个 。</li>
<li>【建议】在建立索引时，多考虑建立 联合索引 ，并把区分度最高的字段放在最前面。</li>
<li>【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。</li>
<li>【建议】建表或加索引时，保证表里互相不存在 冗余索引 。 比如：如果表里已经存在key(a,b)， 则key(a)为冗余索引，需要删除。</li>
</ol>
<h4 id="SQL编写"><a href="#SQL编写" class="headerlink" title="SQL编写"></a>SQL编写</h4><ol>
<li>【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。</li>
<li>【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。</li>
<li>【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。</li>
<li>【建议】INSERT INTO…VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很 快，但会引起主从同步延迟。</li>
<li>【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以 内。</li>
<li>【建议】线上环境，多表 JOIN 不要超过5个表。</li>
<li>【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li>
<li>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果 集请保持在1000行以内，否则SQL会很慢。</li>
<li>【建议】对单表的多次alter操作必须合并为一次 对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整 合在一起。 因为alter table会产生 表锁 ，期间阻塞对于该表的所有写入，对于业务可能会产生极 大影响。</li>
<li>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。</li>
<li>【建议】事务里包含SQL不超过5个。 因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</li>
<li>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id&#x3D;XX; 否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</li>
</ol>
<h3 id="PowerDesigner的使用"><a href="#PowerDesigner的使用" class="headerlink" title="PowerDesigner的使用"></a>PowerDesigner的使用</h3><h2 id="数据库其它调优策略"><a href="#数据库其它调优策略" class="headerlink" title="数据库其它调优策略"></a>数据库其它调优策略</h2><h3 id="数据库调优的措施"><a href="#数据库调优的措施" class="headerlink" title="数据库调优的措施"></a>数据库调优的措施</h3><h4 id="调优的目标"><a href="#调优的目标" class="headerlink" title="调优的目标"></a>调优的目标</h4><ul>
<li>尽可能节省系统资源 ，以便系统可以提供更大负荷的服务。（吞吐量更大）</li>
<li>合理的结构设计和参数调整，以提高用户操作响应的速度 。（响应速度更快）</li>
<li>减少系统的瓶颈，提高MySQL数据库整体的性能。</li>
</ul>
<h4 id="如何定位调优问题"><a href="#如何定位调优问题" class="headerlink" title="如何定位调优问题"></a>如何定位调优问题</h4><p><img src="image-20230731134556472.png" alt="image-20230731134556472"></p>
<p>如何确定呢？一般情况下，有如下几种方式：</p>
<p><img src="image-20230731134820643.png" alt="image-20230731134820643"></p>
<h4 id="调优的维度和步骤"><a href="#调优的维度和步骤" class="headerlink" title="调优的维度和步骤"></a>调优的维度和步骤</h4><p>我们需要调优的对象是整个数据库管理系统，它不仅包括 SQL 查询，还包括数据库的部署配置、架构 等。从这个角度来说，我们思考的维度就不仅仅局限在 SQL 优化上了。通过如下的步骤我们进行梳理：</p>
<h5 id="第1步：选择适合的-DBMS"><a href="#第1步：选择适合的-DBMS" class="headerlink" title="第1步：选择适合的 DBMS"></a>第1步：选择适合的 DBMS</h5><p><img src="image-20230731134857677.png" alt="image-20230731134857677"></p>
<h5 id="第2步：优化表设计"><a href="#第2步：优化表设计" class="headerlink" title="第2步：优化表设计"></a>第2步：优化表设计</h5><p><img src="image-20230731134929751.png" alt="image-20230731134929751"></p>
<h5 id="第3步：优化逻辑查询"><a href="#第3步：优化逻辑查询" class="headerlink" title="第3步：优化逻辑查询"></a>第3步：优化逻辑查询</h5><p><img src="image-20230731134948549-1690782589805-3.png" alt="image-20230731134948549"></p>
<h5 id="第4步：优化物理查询"><a href="#第4步：优化物理查询" class="headerlink" title="第4步：优化物理查询"></a>第4步：优化物理查询</h5><p>物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术（比如索引等），通过计算代价模型对 各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。<strong>在这个部分中，我们需要掌握的重点是对索引的创建和使用。</strong></p>
<p><img src="image-20230731135012986.png" alt="image-20230731135012986"></p>
<h5 id="第5步：使用-Redis-或-Memcached-作为缓存"><a href="#第5步：使用-Redis-或-Memcached-作为缓存" class="headerlink" title="第5步：使用 Redis 或 Memcached 作为缓存"></a>第5步：使用 Redis 或 Memcached 作为缓存</h5><p>除了可以对 SQL 本身进行优化以外，我们还可以请外援提升查询的效率。</p>
<p>因为数据都是存放到数据库中，我们需要从数据库层中取出数据放到内存中进行业务逻辑的操作，当用 户量增大的时候，如果频繁地进行数据查询，会消耗数据库的很多资源。如果我们将常用的数据直接放 到内存中，就会大幅提升查询的效率。</p>
<p>键值存储数据库可以帮我们解决这个问题。</p>
<p>常用的键值存储数据库有 Redis 和 Memcached，它们都可以将数据存放到内存中。</p>
<p><img src="image-20230731135036769.png" alt="image-20230731135036769"></p>
<h5 id="第6步：库级优化"><a href="#第6步：库级优化" class="headerlink" title="第6步：库级优化"></a>第6步：库级优化</h5><p><img src="image-20230731135054429.png" alt="image-20230731135054429"></p>
<p><img src="image-20230731135127075.png" alt="image-20230731135127075"></p>
<p><img src="image-20230731135137712.png" alt="image-20230731135137712"></p>
<p><img src="image-20230731135201279.png" alt="image-20230731135201279"></p>
<blockquote>
<p>但需要注意的是，分拆在提升数据库性能的同时，也会增加维护和使用成本。</p>
</blockquote>
<h3 id="优化MySQL服务器"><a href="#优化MySQL服务器" class="headerlink" title="优化MySQL服务器"></a>优化MySQL服务器</h3><p><img src="image-20230801111133570.png" alt="image-20230801111133570"></p>
<h4 id="优化服务器硬件"><a href="#优化服务器硬件" class="headerlink" title="优化服务器硬件"></a>优化服务器硬件</h4><p>服务器的硬件性能直接决定着MySQL数据库的性能。硬件的性能瓶颈直接决定MySQL数据库的运行速度 和效率。针对性能瓶颈提高硬件配置，可以提高MySQL数据库查询、更新的速度。</p>
<p>（1） <code>配置较大的内存</code> 。足够大的显存是提高MySQL数据库性能的方法之一。内存的速度比磁盘I&#x2F;O快得多，可以通过增加系统的<code>缓冲区容量</code>使数据在内存中停留的时间更长，以<code>减少磁盘I/O</code>。</p>
<p>（2） <code>配置高速磁盘系统 </code>，以减少读盘的等待时间，提高响应速度。磁盘的I&#x2F;O能力，也就是它的寻道能力，目前的SCSI高速旋转的是7200转&#x2F;分钟，这样的速度，一旦访问的用户量上去，磁盘的压力就会过大，如果是每天的网站pv (page view) 在150w，这样的一般的配置就无法满足这样的需求了。现在SSD盛行，在SSD上随机访问和顺序访问性能差不多，使用SSD可以减少随机IO带来的性能损耗。</p>
<p>（3） <code>合理分布磁盘I/O</code>，把磁盘I&#x2F;O分散在多个设备，以减少资源竞争，提高操作能力。</p>
<p>（4） <code>配置多处理器</code>, MySQL是多线程的数据库，多处理器可同时执行多个线程。</p>
<h4 id="优化MySQL的参数"><a href="#优化MySQL的参数" class="headerlink" title="优化MySQL的参数"></a>优化MySQL的参数</h4><p><img src="image-20230801111313769.png" alt="image-20230801111313769"></p>
<ul>
<li><p>innodb_buffer_pool_size ：这个参数是Mysql数据库最重要的参数之一，表示InnoDB类型的 表 和索引的最大缓存 。它不仅仅缓存 索引数据 ，还会缓存 表的数据 。这个值越大，查询的速度就会越 快。但是这个值太大会影响操作系统的性能。</p>
</li>
<li><p>key_buffer_size ：表示 索引缓冲区的大小 。索引缓冲区是所有的 线程共享 。增加索引缓冲区可 以得到更好处理的索引（对所有读和多重写）。当然，这个值不是越大越好，它的大小取决于内存 的大小。如果这个值太大，就会导致操作系统频繁换页，也会降低系统性能。对于内存在 4GB 左右 的服务器该参数可设置为 256M 或 384M 。</p>
</li>
<li><p>table_cache ：表示 同时打开的表的个数 。这个值越大，能够同时打开的表的个数越多。物理内存越大，设置就越大。默认为2402，调到512-1024最佳。这个值不是越大越好，因为同时打开的表 太多会影响操作系统的性能。</p>
</li>
<li><p>query_cache_size ：表示 查询缓冲区的大小 。可以通过在MySQL控制台观察，如果 Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，就要增加Query_cache_size 的值；如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效 率，那么可以考虑不用查询缓存；Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很 多。MySQL8.0之后失效。该参数需要和query_cache_type配合使用。</p>
</li>
<li><p>query_cache_type 的值是0时，所有的查询都不使用查询缓存区。但是query_cache_type&#x3D;0并不 会导致MySQL释放query_cache_size所配置的缓存区内存。</p>
<ul>
<li>当query_cache_type&#x3D;1时，所有的查询都将使用查询缓存区，除非在查询语句中指定 SQL_NO_CACHE ，如SELECT SQL_NO_CACHE * FROM tbl_name。</li>
<li>当query_cache_type&#x3D;2时，只有在查询语句中使用 SQL_CACHE 关键字，查询才会使用查询缓 存区。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的 查询操作的情况。</li>
</ul>
</li>
<li><p>sort_buffer_size ：表示每个 需要进行排序的线程分配的缓冲区的大小 。增加这个参数的值可以 提高 ORDER BY 或 GROUP BY 操作的速度。默认数值是2 097 144字节（约2MB）。对于内存在4GB 左右的服务器推荐设置为6-8M，如果有100个连接，那么实际分配的总共排序缓冲区大小为100 × 6 ＝ 600MB。</p>
</li>
<li><p>join_buffer_size &#x3D; 8M ：表示 联合查询操作所能使用的缓冲区大小 ，和sort_buffer_size一样， 该参数对应的分配内存也是每个连接独享。</p>
</li>
<li><p>read_buffer_size ：表示 每个线程连续扫描时为扫描的每个表分配的缓冲区的大小（字节） 。当线 程从表中连续读取记录时需要用到这个缓冲区。SET SESSION read_buffer_size&#x3D;n可以临时设置该参 数的值。默认为64K，可以设置为4M。</p>
</li>
<li><p>innodb_flush_log_at_trx_commit ：表示 何时将缓冲区的数据写入日志文件 ，并且将日志文件 写入磁盘中。该参数对于innoDB引擎非常重要。该参数有3个值，分别为0、1和2。该参数的默认值 为1。</p>
<ul>
<li>值为 0 时，表示 每秒1次 的频率将数据写入日志文件并将日志文件写入磁盘。每个事务的 commit并不会触发前面的任何操作。该模式速度最快，但不太安全，mysqld进程的崩溃会导 致上一秒钟所有事务数据的丢失。</li>
<li>值为 1 时，表示 每次提交事务时 将数据写入日志文件并将日志文件写入磁盘进行同步。该模 式是最安全的，但也是最慢的一种方式。因为每次事务提交或事务外的指令都需要把日志写入 （flush）硬盘。</li>
<li>值为 2 时，表示 每次提交事务时 将数据写入日志文件， 每隔1秒 将日志文件写入磁盘。该模 式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数 据才可能丢失。</li>
</ul>
</li>
<li><p>innodb_log_buffer_size ：这是 InnoDB 存储引擎的 事务日志所使用的缓冲区 。为了提高性能， 也是先将信息写入 Innodb Log Buffer 中，当满足 innodb_flush_log_trx_commit 参数所设置的相应条 件（或者日志缓冲区写满）之后，才会将日志写到文件（或者同步到磁盘）中。</p>
</li>
<li><p>max_connections ：表示 允许连接到MySQL数据库的最大数量 ，默认值是 151 。如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接 数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。在Linux 平台下，性能好的 服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。这个连接数 不是越大 越好 ，因为这些连接会浪费内存的资源。过多的连接可能会导致MySQL服务器僵死。</p>
</li>
<li><p>back_log ：用于 控制MySQL监听TCP端口时设置的积压请求栈大小 。如果MySql的连接数达到 max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即 back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默 认值为 50 ， 之后的版本默认为 50 + （max_connections &#x2F; 5）， 对于Linux系统推荐设置为小于512 的整数，但最大不超过900。</p>
<p>如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</p>
</li>
<li><p>thread_cache_size ： 线程池缓存线程数量的大小 ，当客户端断开连接后将当前线程缓存起来， 当在接到新的连接请求时快速响应无需创建新的线程 。这尤其对那些使用短连接的应用程序来说可 以极大的提高创建连接的效率。那么为了提高性能可以增大该参数的值。默认为60，可以设置为 120。</p>
<p>可以通过如下几个MySQL状态值来适当调整线程池的大小：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Thread%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Threads_cached <span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Threads_connected <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Threads_created <span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Threads_running <span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>当 Threads_cached 越来越少，但 Threads_connected 始终不降，且 Threads_created 持续升高，可 适当增加 thread_cache_size 的大小。</p>
</li>
<li><p>wait_timeout ：指定 一个请求的最大连接时间 ，对于4GB左右内存的服务器可以设置为5-10。</p>
</li>
<li><p>interactive_timeout ：表示服务器在关闭连接前等待行动的秒数。</p>
</li>
</ul>
<p>这里给出一份my.cnf的参考配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mysqld]</span></span><br><span class="line"><span class="attr">port</span> = <span class="string">3306 </span></span><br><span class="line"><span class="attr">serverid</span> = <span class="string">1 </span></span><br><span class="line"><span class="attr">socket</span> = <span class="string">/tmp/mysql.sock </span></span><br><span class="line"><span class="attr">skip-locking</span> <span class="string">#避免MySQL的外部锁定，减少出错几率增强稳定性。 </span></span><br><span class="line"><span class="attr">skip-name-resolve</span> <span class="string">#禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求！ </span></span><br><span class="line"><span class="attr">back_log</span> = <span class="string">384</span></span><br><span class="line"><span class="attr">key_buffer_size</span> = <span class="string">256M </span></span><br><span class="line"><span class="attr">max_allowed_packet</span> = <span class="string">4M </span></span><br><span class="line"><span class="attr">thread_stack</span> = <span class="string">256K</span></span><br><span class="line"><span class="attr">table_cache</span> = <span class="string">128K </span></span><br><span class="line"><span class="attr">sort_buffer_size</span> = <span class="string">6M </span></span><br><span class="line"><span class="attr">read_buffer_size</span> = <span class="string">4M</span></span><br><span class="line"><span class="attr">read_rnd_buffer_size</span>=<span class="string">16M </span></span><br><span class="line"><span class="attr">join_buffer_size</span> = <span class="string">8M </span></span><br><span class="line"><span class="attr">myisam_sort_buffer_size</span> =<span class="string">64M </span></span><br><span class="line"><span class="attr">table_cache</span> = <span class="string">512 </span></span><br><span class="line"><span class="attr">thread_cache_size</span> = <span class="string">64 </span></span><br><span class="line"><span class="attr">query_cache_size</span> = <span class="string">64M</span></span><br><span class="line"><span class="attr">tmp_table_size</span> = <span class="string">256M </span></span><br><span class="line"><span class="attr">max_connections</span> = <span class="string">768 </span></span><br><span class="line"><span class="attr">max_connect_errors</span> = <span class="string">10000000</span></span><br><span class="line"><span class="attr">wait_timeout</span> = <span class="string">10 </span></span><br><span class="line"><span class="attr">thread_concurrency</span> = <span class="string">8 #该参数取值为服务器逻辑CPU数量*2，在本例中，服务器有2颗物理CPU，而每颗物理CPU又支持H.T超线程，所以实际取值为4*2=8</span></span><br><span class="line"><span class="attr">skip-networking</span> <span class="string">#开启该选项可以彻底关闭MySQL的TCP/IP连接方式，如果WEB服务器是以远程连接的方式访问MySQL数据库服务器则不要开启该选项！否则将无法正常连接！ </span></span><br><span class="line"><span class="attr">table_cache</span>=<span class="string">1024</span></span><br><span class="line"><span class="attr">innodb_additional_mem_pool_size</span>=<span class="string">4M #默认为2M </span></span><br><span class="line"><span class="attr">innodb_flush_log_at_trx_commit</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">innodb_log_buffer_size</span>=<span class="string">2M #默认为1M </span></span><br><span class="line"><span class="attr">innodb_thread_concurrency</span>=<span class="string">8 #你的服务器CPU有几个就设置为几。建议用默认一般为8 </span></span><br><span class="line"><span class="attr">tmp_table_size</span>=<span class="string">64M #默认为16M，调到64-256最挂</span></span><br><span class="line"><span class="attr">thread_cache_size</span>=<span class="string">120 </span></span><br><span class="line"><span class="attr">query_cache_size</span>=<span class="string">32M</span></span><br></pre></td></tr></table></figure>

<p>很多情况还需要具体情况具体分析！</p>
<p><strong>举例：</strong></p>
<p><img src="image-20230801140220275.png" alt="image-20230801140220275"></p>
<p><strong>(1) 调整系统参数 InnoDB_flush_log_at_trx_commit</strong></p>
<p><img src="image-20230801140251739.png" alt="image-20230801140251739"></p>
<p><strong>(2) 调整系统参数 InnoDB_buffer_pool_size</strong></p>
<p><img src="image-20230801140342582.png" alt="image-20230801140342582"></p>
<p><strong>(3) 调整系统参数 InnoDB_buffer_pool_instances</strong></p>
<p><img src="image-20230801140425038.png" alt="image-20230801140425038"></p>
<h3 id="优化数据库结构"><a href="#优化数据库结构" class="headerlink" title="优化数据库结构"></a>优化数据库结构</h3><p><img src="image-20230801143253320.png" alt="image-20230801143253320"></p>
<h4 id="拆分表：冷热数据分离"><a href="#拆分表：冷热数据分离" class="headerlink" title="拆分表：冷热数据分离"></a>拆分表：冷热数据分离</h4><p><img src="image-20230801143347432.png" alt="image-20230801143347432"></p>
<h4 id="增加中间表"><a href="#增加中间表" class="headerlink" title="增加中间表"></a>增加中间表</h4><p><img src="image-20230801143439562.png" alt="image-20230801143439562"></p>
<h4 id="增加冗余字段"><a href="#增加冗余字段" class="headerlink" title="增加冗余字段"></a>增加冗余字段</h4><p>设计数据库表时应尽量遵循范式理论的规约，尽可能减少冗余字段，让数据库设计看起来精致、优雅。 但是，合理地加入冗余字段可以提高查询速度。</p>
<p>表的规范化程度越高，表与表之间的关系就越多，需要连接查询的情况也就越多。尤其在数据量大，而 且需要频繁进行连接的时候，为了提升效率，我们也可以考虑增加冗余字段来减少连接。</p>
<p>这部分内容在《第11章_数据库的设计规范》章节中 反范式化小节 中具体展开讲解了。这里省略。</p>
<h4 id="优化数据类型"><a href="#优化数据类型" class="headerlink" title="优化数据类型"></a>优化数据类型</h4><p><img src="image-20230801143616179.png" alt="image-20230801143616179"></p>
<p><strong>情况1：对整数类型数据进行优化。</strong></p>
<p>遇到整数类型的字段可以用 INT 型 。这样做的理由是，INT 型数据有足够大的取值范围，不用担心数 据超出取值范围的问题。刚开始做项目的时候，首先要保证系统的稳定性，这样设计字段类型是可以 的。但在数据量很大的时候，数据类型的定义，在很大程度上会影响到系统整体的执行效率。</p>
<p>对于 非负型 的数据（如自增ID、整型IP）来说，要优先使用无符号整型 UNSIGNED 来存储。因为无符号 相对于有符号，同样的字节数，存储的数值范围更大。如tinyint有符号为-128-127，无符号为0-255，多 出一倍的存储空间。</p>
<p><strong>情况2：既可以使用文本类型也可以使用整数类型的字段，要选择使用整数类型。</strong></p>
<p>跟文本类型数据相比，大整数往往占用更少的存储空间 ，因此，在存取和比对的时候，可以占用更少的 内存空间。所以，在二者皆可用的情况下，尽量使用整数类型，这样可以提高查询的效率。如：将IP地 址转换成整型数据。</p>
<p><strong>情况3：避免使用TEXT、BLOB数据类型</strong></p>
<p><img src="image-20230801143649674.png" alt="image-20230801143649674"></p>
<p><strong>情况4：避免使用ENUM类型</strong></p>
<p>修改ENUM值需要使用ALTER语句。</p>
<p>ENUM类型的ORDER BY 操作效率低，需要额外操作。使用TINYINT来代替ENUM类型。</p>
<p><strong>情况5：使用TIMESTAMP存储时间</strong></p>
<p>TIMESTAMP存储的时间范围1970-01-01 00:00:01 ~ 2038-01_19-03:14:07。TIMESTAMP使用4字节，DATETIME使用8个字节，同时TIMESTAMP具有自动赋值以及自动更新的特性。</p>
<p><strong>情况6：用DECIMAL代替FLOAT和DOUBLE存储精确浮点数</strong></p>
<ol>
<li>非精准浮点： float, double</li>
<li>精准浮点：decimal</li>
</ol>
<p>Decimal类型为精准浮点数，在计算时不会丢失精度，尤其是财务相关的金融类数据。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。</p>
<p><strong>总之，遇到数据量大的项目时，一定要在充分了解业务需求的前提下，合理优化数据类型，这样才能充 分发挥资源的效率，使系统达到最优。</strong></p>
<h4 id="优化插入记录的速度"><a href="#优化插入记录的速度" class="headerlink" title="优化插入记录的速度"></a>优化插入记录的速度</h4><p>插入记录时，影响插入速度的主要是索引、唯一性校验、一次插入记录条数等。根据这些情况可以分别进行优化。这里我们分为MyISAM引擎和InnoDB引擎来讲。</p>
<p><strong>1. MyISAM引擎的表：</strong></p>
<p><strong>① 禁用索引</strong></p>
<p><img src="image-20230801143857381.png" alt="image-20230801143857381"></p>
<p><strong>② 禁用唯一性检查</strong></p>
<p><img src="image-20230801143916012.png" alt="image-20230801143916012"></p>
<p><strong>③ 使用批量插入</strong></p>
<p>插入多条记录时，可以使用一条INSERT语句插入一条数据，也可以使用一条INSERT语句插入多条数据。插入一条记录的INSERT语句情形如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;zhangsan&#x27;</span>,<span class="number">18</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="number">17</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;wangwu&#x27;</span>,<span class="number">17</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;zhaoliu&#x27;</span>,<span class="number">19</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>使用一条INSERT语句插入多条记录的情形如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;zhangsan&#x27;</span>,<span class="number">18</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="number">17</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;wangwu&#x27;</span>,<span class="number">17</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">4</span>,<span class="string">&#x27;zhaoliu&#x27;</span>,<span class="number">19</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>第2种情形的插入速度要比第1种情形快。</p>
<p><strong>④ 使用LOAD DATA INFILE 批量导入</strong></p>
<p>当需要批量导入数据时，如果能用LOAD DATA INFILE语句，就尽量使用。因为LOAD DATA INFILE语句导入数据的速度比INSERT语句块。</p>
<p><strong>2. InnoDB引擎的表：</strong></p>
<p><strong>① 禁用唯一性检查</strong></p>
<p>插入数据之前执行<code>set unique_checks=0</code>来禁止对唯一索引的检查，数据导入完成之后再运行<code>set unique_check=1</code>。这个和MyISAM引擎的使用方法一样。</p>
<p><strong>② 禁用外键检查</strong></p>
<p><img src="image-20230801143944689.png" alt="image-20230801143944689"></p>
<p><strong>③ 禁止自动提交</strong></p>
<p><img src="image-20230801143959162.png" alt="image-20230801143959162"></p>
<h4 id="使用非空约束"><a href="#使用非空约束" class="headerlink" title="使用非空约束"></a>使用非空约束</h4><p><img src="image-20230801144445760.png" alt="image-20230801144445760"></p>
<h4 id="分析表、检查表与优化表"><a href="#分析表、检查表与优化表" class="headerlink" title="分析表、检查表与优化表"></a>分析表、检查表与优化表</h4><p>MySQL提供了分析表、检查表和优化表的语句。<code>分析表</code>主要是分析关键字的分布，<code>检查表</code>主要是检查表是否存在错误，<code>优化表</code>主要是消除删除或者更新造成的空间浪费。</p>
<h4 id="1-分析表"><a href="#1-分析表" class="headerlink" title="1. 分析表"></a>1. 分析表</h4><p>MySQL中提供了ANALYZE TABLE语句分析表，ANALYZE TABLE语句的基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ANALYZE [<span class="keyword">LOCAL</span> <span class="operator">|</span> NO_WRITE_TO_BINLOG] <span class="keyword">TABLE</span> tbl_name[,tbl_name]…</span><br></pre></td></tr></table></figure>

<p>默认的，MySQL服务会将 ANALYZE TABLE语句写到binlog中，以便在主从架构中，从服务能够同步数据。 可以添加参数LOCAL 或者 NO_WRITE_TO_BINLOG取消将语句写到binlog中。</p>
<p>使用 <code>ANALYZE TABLE</code> 分析表的过程中，数据库系统会自动对表加一个 <code>只读锁</code> 。在分析期间，只能读取 表中的记录，不能更新和插入记录。ANALYZE TABLE语句能够分析InnoDB和MyISAM类型的表，但是不能作用于视图。</p>
<p>ANALYZE TABLE分析后的统计结果会反应到 <code>cardinality</code> 的值，该值统计了表中某一键所在的列不重复 的值的个数。<strong>该值越接近表中的总行数，则在表连接查询或者索引查询时，就越优先被优化器选择使用</strong>。也就是索引列的cardinality的值与表中数据的总条数差距越大，即使查询的时候使用了该索引作为查 询条件，存储引擎实际查询的时候使用的概率就越小。下面通过例子来验证下。cardinality可以通过 SHOW INDEX FROM 表名查看。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> ANALYZE <span class="keyword">TABLE</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+---------+----------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>        <span class="operator">|</span> Op      <span class="operator">|</span> Msg_type <span class="operator">|</span>Msg_text <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+---------+----------+---------+</span></span><br><span class="line"><span class="operator">|</span> atguigu.user <span class="operator">|</span> analyze <span class="operator">|</span> status   <span class="operator">|</span> Ok      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+----------+---------+---------+</span></span><br></pre></td></tr></table></figure>

<p>上面结果显示的信息说明如下：</p>
<ul>
<li>Table: 表示分析的表的名称。</li>
<li>Op: 表示执行的操作。analyze表示进行分析操作。</li>
<li>Msg_type: 表示信息类型，其值通常是状态 (status) 、信息 (info) 、注意 (note) 、警告 (warning) 和 错误 (error) 之一。</li>
<li>Msg_text: 显示信息。</li>
</ul>
<h4 id="2-检查表"><a href="#2-检查表" class="headerlink" title="2. 检查表"></a>2. 检查表</h4><p>MySQL中可以使用 <code>CHECK TABLE</code> 语句来检查表。CHECK TABLE语句能够检查InnoDB和MyISAM类型的表 是否存在错误。CHECK TABLE语句在执行过程中也会给表加上 <code>只读锁</code> 。</p>
<p>对于MyISAM类型的表，CHECK TABLE语句还会更新关键字统计数据。而且，CHECK TABLE也可以检查视 图是否有错误，比如在视图定义中被引用的表已不存在。该语句的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;</span><br></pre></td></tr></table></figure>

<p>其中，tbl_name是表名；option参数有5个取值，分别是QUICK、FAST、MEDIUM、EXTENDED和 CHANGED。各个选项的意义分别是：</p>
<ul>
<li>QUICK ：不扫描行，不检查错误的连接。</li>
<li>FAST ：只检查没有被正确关闭的表。</li>
<li>CHANGED ：只检查上次检查后被更改的表和没有被正确关闭的表。</li>
<li>MEDIUM ：扫描行，以验证被删除的连接是有效的。也可以计算各行的关键字校验和，并使用计算出的校验和验证这一点。</li>
<li>EXTENDED ：对每行的所有关键字进行一个全面的关键字查找。这可以确保表是100%一致的，但 是花的时间较长。</li>
</ul>
<p>option只对MyISAM类型的表有效，对InnoDB类型的表无效。比如：</p>
<p><img src="image-20230801144521216.png" alt="image-20230801144521216"></p>
<p>该语句对于检查的表可能会产生多行信息。最后一行有一个状态的 Msg_type 值，Msg_text 通常为 OK。 如果得到的不是 OK，通常要对其进行修复；是 OK 说明表已经是最新的了。表已经是最新的，意味着存 储引擎对这张表不必进行检查。</p>
<h4 id="3-优化表"><a href="#3-优化表" class="headerlink" title="3. 优化表"></a>3. 优化表</h4><p><strong>方式1：OPTIMIZE TABLE</strong></p>
<p>MySQL中使用 <code>OPTIMIZE TABLE</code> 语句来优化表。但是，OPTILMIZE TABLE语句只能优化表中的 <code>VARCHAR</code> 、 <code>BLOB</code> 或 <code>TEXT</code> 类型的字段。一个表使用了这些字段的数据类型，若已经 <code>删除</code> 了表的一大部 分数据，或者已经对含有可变长度行的表（含有VARCHAR、BLOB或TEXT列的表）进行了很多 <code>更新</code> ，则 应使用OPTIMIZE TABLE来重新利用未使用的空间，并整理数据文件的 <code>碎片</code> 。</p>
<p>OPTIMIZE TABLE 语句对InnoDB和MyISAM类型的表都有效。该语句在执行过程中也会给表加上 <code>只读锁</code> 。</p>
<p>OPTILMIZE TABLE语句的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure>

<p>LOCAL | NO_WRITE_TO_BINLOG关键字的意义和分析表相同，都是指定不写入二进制日志。</p>
<p><img src="image-20230801144544445.png" alt="image-20230801144544445"></p>
<p>执行完毕，Msg_text显示</p>
<blockquote>
<p>‘numysql.SYS_APP_USER’, ‘optimize’, ‘note’, ‘Table does not support optimize, doing recreate + analyze instead’</p>
</blockquote>
<p>原因是我服务器上的MySQL是InnoDB存储引擎。</p>
<p>到底优化了没有呢？看官网！</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/optimize-table.html">MySQL :: MySQL 8.0 Reference Manual :: 13.7.3.4 OPTIMIZE TABLE Statement</a></p>
<p>在MyISAM中，是先分析这张表，然后会整理相关的MySQL datafile，之后回收未使用的空间；在InnoDB 中，回收空间是简单通过Alter table进行整理空间。在优化期间，MySQL会创建一个临时表，优化完成之 后会删除原始表，然后会将临时表rename成为原始表。</p>
<blockquote>
<p>说明： 在多数的设置中，根本不需要运行OPTIMIZE TABLE。即使对可变长度的行进行了大量的更 新，也不需要经常运行，<code> 每周一次</code> 或 <code>每月一次</code> 即可，并且只需要对 <code>特定的表</code> 运行。</p>
</blockquote>
<p><img src="image-20230801144606430.png" alt="image-20230801144606430"></p>
<p><strong>方式二：使用mysqlcheck命令</strong></p>
<p><img src="image-20230801144628607.png" alt="image-20230801144628607"></p>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>上述这些方法都是有利有弊的。比如：</p>
<ul>
<li>修改数据类型，节省存储空间的同时，你要考虑到数据不能超过取值范围；</li>
<li>增加冗余字段的时候，不要忘了确保数据一致性；</li>
<li>把大表拆分，也意味着你的查询会增加新的连接，从而增加额外的开销和运维的成本。</li>
</ul>
<p>因此，你一定要结合实际的业务需求进行权衡。</p>
<h3 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h3><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<h4 id="限定查询的范围"><a href="#限定查询的范围" class="headerlink" title="限定查询的范围"></a>限定查询的范围</h4><p>禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制 在一个月的范围内；</p>
<h4 id="读-x2F-写分离"><a href="#读-x2F-写分离" class="headerlink" title="读&#x2F;写分离"></a>读&#x2F;写分离</h4><p>经典的数据库拆分方案，主库负责写，从库负责读。</p>
<ul>
<li>一主一从模式：</li>
</ul>
<p>  <img src="image-20230801144932854.png" alt="image-20230801144932854"></p>
<ul>
<li><p>双主双从模式：</p>
<p><img src="image-20230801144947350.png" alt="image-20230801144947350"></p>
</li>
</ul>
<h4 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h4><p>当数据量级达到 <code>千万级</code> 以上时，有时候我们需要把一个数据库切成多份，放到不同的数据库服务器上， 减少对单一数据库服务器的访问压力。</p>
<p><img src="image-20230801145014208.png" alt="image-20230801145014208"></p>
<ul>
<li>如果数据库的数据表过多，可以采用<code>垂直分库</code>的方式，将关联的数据库部署在同一个数据库上。</li>
<li>如果数据库中的列过多，可以采用<code>垂直分表</code>的方式，将一张数据表分拆成多张数据表，把经常一起使用的列放在同一张表里。<img src="image-20230801145050384.png" alt="image-20230801145050384"></li>
</ul>
<p><code>垂直拆分的优点</code>： 可以使得列数据变小，在查询时减少读取的Block数，减少I&#x2F;O次数。此外，垂直分区可以简化表的结构，易于维护。</p>
<p><code>垂直拆分的缺点</code>： 主键会出现冗余，需要管理冗余列，并会引起 JOIN 操作。此外，垂直拆分会让事务变得更加复杂。</p>
<h4 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h4><p><img src="image-20230801145128207.png" alt="image-20230801145128207"></p>
<p><img src="image-20230801145136867.png" alt="image-20230801145136867"></p>
<p><img src="image-20230801145152903.png" alt="image-20230801145152903"></p>
<p>下面补充一下数据库分片的两种常见方案：</p>
<ul>
<li><strong>客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。</li>
<li><strong>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong>我们现在 谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>
</ul>
<h3 id="其它调优策略"><a href="#其它调优策略" class="headerlink" title="其它调优策略"></a>其它调优策略</h3><h4 id="服务器语句超时处理"><a href="#服务器语句超时处理" class="headerlink" title="服务器语句超时处理"></a>服务器语句超时处理</h4><p>在MySQL 8.0中可以设置 服务器语句超时的限制 ，单位可以达到 毫秒级别 。当中断的执行语句超过设置的 毫秒数后，服务器将终止查询影响不大的事务或连接，然后将错误报给客户端。</p>
<p>设置服务器语句超时的限制，可以通过设置系统变量 MAX_EXECUTION_TIME 来实现。默认情况下， MAX_EXECUTION_TIME的值为0，代表没有时间限制。 例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> MAX_EXECUTION_TIME<span class="operator">=</span><span class="number">2000</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET SESSION MAX_EXECUTION_TIME=2000; #指定该会话中SELECT语句的超时时间</span><br></pre></td></tr></table></figure>

<h4 id="创建全局通用表空间"><a href="#创建全局通用表空间" class="headerlink" title="创建全局通用表空间"></a>创建全局通用表空间</h4><p><img src="image-20230801145409948.png" alt="image-20230801145409948"></p>
<p>所以首先应该删除以来该表空间的数据表，SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> test;</span><br></pre></td></tr></table></figure>

<p>最后即可删除表空间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DTOP TABLESPACE 表空间</span><br></pre></td></tr></table></figure>

<h4 id="MySQL-8-0新特性：隐藏索引对调优的帮助"><a href="#MySQL-8-0新特性：隐藏索引对调优的帮助" class="headerlink" title="MySQL 8.0新特性：隐藏索引对调优的帮助"></a>MySQL 8.0新特性：隐藏索引对调优的帮助</h4><p><img src="image-20230801145652147.png" alt="image-20230801145652147"></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>调优</tag>
      </tags>
  </entry>
</search>
