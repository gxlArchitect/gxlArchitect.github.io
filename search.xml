<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RPC框架</title>
    <url>/2023/02/02/RPC%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>RPC 的主要功能目标是让构建分布式计算（应用）更容易，是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议规范，简单的来说就是像调用本地服务一样调用远程服务，对开发者而言是透明的。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1、RPC框架一般使用长链接，不必每次通信都要3次握手，减少网络开销</p>
<p>2、RPC框架一般都有注册中心，有丰富的监控管理</p>
<p>3、发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作</p>
<p>4、协议私密，安全性较高</p>
<p>5、rpc 能做到协议更简单内容更小，效率更高</p>
<p>6、rpc是面向服务的更高级的抽象，支持服务注册发现，负载均衡，超时重试，熔断降级等高级特性</p>
<h2 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h2><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>在高可用的生产环境中，服务一般都以集群方式提供服务，集群里面的IP等重要参数信息可能随时会发生变化，节点也可能会动态扩缩容，客户端需要能够及时感知服务端的变化，获取集群最新服务节点的连接信息，而这些变化要求是要对调用方应用无感知的。</p>
<p>常用的注册中心：<strong>Zookeeper</strong>，<strong>Consul</strong>，<strong>Nacos</strong></p>
]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper入门篇</title>
    <url>/2023/02/02/Zookeeper%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>Zookeeper 是 Apache Hadoop 项目下的一个子项目，是一个树形目录服务。</li>
<li>Zookeeper 翻译过来就是 动物园管理员，他是用来管 Hadoop（大象）、Hive(蜜蜂)、Pig(小 猪)的管理员。简称zk。</li>
<li>Zookeeper 是一个分布式的、开源的分布式应用程序的协调服务。</li>
<li>Zookeeper 提供的主要功能包括：配置管理、分布式锁、集群管理</li>
</ul>
<h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>ZooKeeper服务器是用Java创建的，它运行在JVM之上。需要安装JDK 7或更高版本。</p>
<h4 id="上传安装包"><a href="#上传安装包" class="headerlink" title="上传安装包"></a>上传安装包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打开 opt目录</span></span><br><span class="line">cd /opt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建zooKeeper目录</span></span><br><span class="line">mkdir  zooKeeper</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将zookeeper安装包上传到当前目录</span></span><br></pre></td></tr></table></figure>

<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><p>将tar包解压到&#x2F;opt&#x2F;zookeeper目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-ZooKeeper-3.5.6-bin.tar.gz </span><br></pre></td></tr></table></figure>

<h3 id="配置启动"><a href="#配置启动" class="headerlink" title="配置启动"></a>配置启动</h3><h4 id="配置zoo-cfg"><a href="#配置zoo-cfg" class="headerlink" title="配置zoo.cfg"></a>配置zoo.cfg</h4><p>进入到conf目录拷贝一个zoo_sample.cfg并完成配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入到conf目录</span></span><br><span class="line">cd /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/conf/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拷贝</span></span><br><span class="line">cp  zoo_sample.cfg  zoo.cfg</span><br></pre></td></tr></table></figure>

<p>修改zoo.cfg</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打开目录</span></span><br><span class="line">cd /opt/zooKeeper/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建zooKeeper存储目录</span></span><br><span class="line">mkdir  zkdata</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改zoo.cfg</span></span><br><span class="line">vim /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/conf/zoo.cfg</span><br></pre></td></tr></table></figure>

<p><img src="/.com//1577548250377.png" alt="1577548250377"></p>
<p>修改存储目录：dataDir&#x3D;&#x2F;opt&#x2F;zookeeper&#x2F;zkdata</p>
<h4 id="启动ZooKeeper"><a href="#启动ZooKeeper" class="headerlink" title="启动ZooKeeper"></a>启动ZooKeeper</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/bin/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动</span></span><br><span class="line">./zkServer.sh  start</span><br></pre></td></tr></table></figure>

<p><img src="/.com//1577548052037.png" alt="1577548052037"></p>
<p>看到上图表示ZooKeeper成功启动</p>
<h2 id="ZooKeeper-命令操作"><a href="#ZooKeeper-命令操作" class="headerlink" title="ZooKeeper 命令操作"></a>ZooKeeper 命令操作</h2><h3 id="Zookeeper命令操作数据模型"><a href="#Zookeeper命令操作数据模型" class="headerlink" title="Zookeeper命令操作数据模型"></a>Zookeeper命令操作数据模型</h3><ul>
<li><p>ZooKeeper 是一个树形目录服务,其数据模型和Unix的文件系统目录树很类似，拥有一个层次化结构。</p>
</li>
<li><p>这里面的每一个节点都被称为： ZNode，每个节点上都会保存自己的数据和节点信息。 </p>
</li>
<li><p>节点可以拥有子节点，同时也允许少量（1MB）数据存储在该节点之下。</p>
</li>
<li><p>节点可以分为四大类：</p>
<ol>
<li><p>PERSISTENT 持久化节点 </p>
</li>
<li><p>EPHEMERAL 临时节点 ：-e</p>
</li>
<li><p>PERSISTENT_SEQUENTIAL 持久化顺序节点 ：-s</p>
</li>
<li><p>EPHEMERAL_SEQUENTIAL 临时顺序节点  ：-es</p>
</li>
</ol>
</li>
</ul>
<p><img src="/.com//1592054828485.png" alt="1592054828485"></p>
<p><img src="/.com//1592054844023.png" alt="1592054844023"></p>
<h3 id="Zookeeper命令操作服务端命令"><a href="#Zookeeper命令操作服务端命令" class="headerlink" title="Zookeeper命令操作服务端命令"></a>Zookeeper命令操作服务端命令</h3><ul>
<li><p>启动 ZooKeeper 服务: .&#x2F;zkServer.sh start</p>
</li>
<li><p>查看 ZooKeeper 服务状态: .&#x2F;zkServer.sh status</p>
</li>
<li><p>停止 ZooKeeper 服务: .&#x2F;zkServer.sh stop </p>
</li>
<li><p>重启 ZooKeeper 服务: .&#x2F;zkServer.sh restart</p>
</li>
</ul>
<h3 id="Zookeeper客户端常用命令"><a href="#Zookeeper客户端常用命令" class="headerlink" title="Zookeeper客户端常用命令"></a>Zookeeper客户端常用命令</h3><ul>
<li>连接ZooKeeper服务端</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./zkCli.sh –server ip:port</span><br></pre></td></tr></table></figure>

<ul>
<li>断开连接</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure>

<ul>
<li>查看命令帮助</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">help</span><br></pre></td></tr></table></figure>

<ul>
<li>显示指定目录下节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls 目录</span><br></pre></td></tr></table></figure>

<ul>
<li>创建节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create /节点path value</span><br></pre></td></tr></table></figure>

<ul>
<li>获取节点值</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">get /节点path</span><br></pre></td></tr></table></figure>

<ul>
<li>设置节点值</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set /节点path value</span><br></pre></td></tr></table></figure>

<ul>
<li>删除单个节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">delete /节点path</span><br></pre></td></tr></table></figure>

<ul>
<li>删除带有子节点的节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deleteall /节点path</span><br></pre></td></tr></table></figure>

<h3 id="客户端命令-创建临时有序节点"><a href="#客户端命令-创建临时有序节点" class="headerlink" title="客户端命令-创建临时有序节点"></a>客户端命令-创建临时有序节点</h3><ul>
<li>创建临时节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create -e /节点path value</span><br></pre></td></tr></table></figure>

<ul>
<li>创建顺序节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create -s /节点path value</span><br></pre></td></tr></table></figure>

<ul>
<li>查询节点详细信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls –s /节点path </span><br></pre></td></tr></table></figure>

<ol>
<li><p>czxid：节点被创建的事务ID </p>
</li>
<li><p>ctime: 创建时间 </p>
</li>
<li><p>mzxid: 最后一次被更新的事务ID </p>
</li>
<li><p>mtime: 修改时间 </p>
</li>
<li><p>pzxid：子节点列表最后一次被更新的事务ID</p>
</li>
<li><p>cversion：子节点的版本号 </p>
</li>
<li><p>dataversion：数据版本号 </p>
</li>
<li><p>aclversion：权限版本号 </p>
</li>
<li><p>ephemeralOwner：用于临时节点，代表临时节点的事务ID，如果为持久节点则为0 </p>
</li>
<li><p>dataLength：节点存储的数据的长度 </p>
</li>
<li><p>numChildren：当前节点的子节点个数</p>
</li>
</ol>
<h2 id="ZooKeeper-JavaAPI-操作"><a href="#ZooKeeper-JavaAPI-操作" class="headerlink" title="ZooKeeper JavaAPI 操作"></a>ZooKeeper JavaAPI 操作</h2>]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2022/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">线性结构分为两种数据存储方式，一种是顺序存储，一种链式存储</span><br></pre></td></tr></table></figure>

<h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><p><strong>API设计</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>SequenceList</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>SequenceList(int capacity)：创建容量为capacity的SequenceList对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public void clear()：空置对象<br>2.public boolean isEmpty()：判断线性表是否为空，是返回true，否返回false<br>3.public int length():获取线性表中元素的个数<br>4.public T get(int i):读取并返回线性表中的第i个元素的值<br>5.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。<br>6.public void insert(T t):向线性表中添加一个元素t<br>7.public T remove(int i):删除并返回线性表中第i个数据元素。<br>8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回1</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] eles：存储元素的数组<br>2.private int N:当前线性表的长度</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 顺序数据结果实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-12-18</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequenceList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> T[] eles;</span><br><span class="line">    <span class="comment">//当前线性表长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SequenceList</span><span class="params">(<span class="type">int</span> capcity)</span>&#123;</span><br><span class="line">        eles = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capcity];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空置对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断线性表是否为空，是返回true，否返回false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取线性表中元素的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取并返回线性表中的第i个元素的值</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;当前元素不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eles[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在线性表的第i个元素之前插入一个值为t的数据元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> i,T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;插入位置不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(N== eles.length)&#123;</span><br><span class="line">            resize(<span class="number">2</span>*N);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把i位置空出来，i位置及其后面元素一次后移一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N;index&gt;i;index--)&#123;</span><br><span class="line">            eles[index] = eles[index-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把i位置赋值</span></span><br><span class="line">        eles[i] = t;</span><br><span class="line">        <span class="comment">//数量加1</span></span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向线性表中添加一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N== eles.length)&#123;</span><br><span class="line">            resize(<span class="number">2</span>*N);</span><br><span class="line">        &#125;</span><br><span class="line">        eles[N++] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除并返回线性表中第i个数据元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">remove</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;插入位置不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录i位置元素</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> eles[i];</span><br><span class="line">        <span class="comment">//i位置后面的元素都向前一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> index=i;index&lt;N-<span class="number">1</span>;index++)&#123;</span><br><span class="line">            eles[index] = eles[index+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前元素数量-1</span></span><br><span class="line">        N--;</span><br><span class="line">        <span class="comment">//当元素已经不足数组大小的1/4,则重置数组的大小</span></span><br><span class="line">        <span class="keyword">if</span> (N&gt;<span class="number">0</span>&amp;&amp;N&lt; eles.length/<span class="number">4</span>)&#123;</span><br><span class="line">            resize(eles.length/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;查找元素不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eles[i].equals(t))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> cur;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SIterator</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.cur=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cur&lt;N;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> eles[cur++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现扩容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newSize)</span>&#123;</span><br><span class="line">        T[] temp = eles;</span><br><span class="line">        eles = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[newSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            eles[i]=temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取数组长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> eles.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h5 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h5><p>单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据，</p>
<p>指针域用来指向其后继结点。链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。</p>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>LinkList</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>LinkList()：创建LinkList对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public void clear()：空置链表 <br>2.public boolean isEmpty()：判断线性表是否为空，是返回true，否返回false<br>3.public int length():获取线性表中元素的个数<br>4.public T get(int i):读取并返回线性表中的第i个元素的值<br>5.public void insert(T t)：往线性表中添加一个元素；<br>6.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。<br>7.public T remove(int i):删除并返回线性表中第i个数据元素。<br>8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1</td>
</tr>
<tr>
<td>成员内部类</td>
<td>private class Node:结点类</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node head:记录首结点<br>2.private int N:记录链表的长度</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.dc.pr.PRError;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 单向链表API实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-12-29</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkList</span><span class="params">()</span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空置链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">        head.next=<span class="literal">null</span>;</span><br><span class="line">        head.item=<span class="literal">null</span>;</span><br><span class="line">        N=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断线性表是否为空，是返回true，否返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N==<span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取线性表中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;位置不合法！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往线性表中添加一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//找到最后一个结点</span></span><br><span class="line">        <span class="keyword">while</span> (n.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建新结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t,<span class="literal">null</span>);</span><br><span class="line">        n.next = newNode;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在线性表的第i个元素之前插入一个值为t的数据元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> i,T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;位置不合法！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到i结点的上一个结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">//创建新结点并把next结点赋值为i结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t,temp);</span><br><span class="line">        <span class="comment">//将上个结点的next指向新结点</span></span><br><span class="line">        node.next = newNode;</span><br><span class="line">        <span class="comment">//数量加1</span></span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除并返回线性表中第i个数据元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">remove</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;位置不合法！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到i结点的上一个结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> node.next;</span><br><span class="line">        node.next=cur.next;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> cur.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; node.next!=<span class="literal">null</span>; i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="keyword">if</span> (t.equals(cur.item))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Node node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LIterator</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.node=head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node.next!=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            <span class="keyword">return</span> node.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结点类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T item;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T item, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = item;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><p>双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用</p>
<p>来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存</p>
<p>储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。</p>
<p><strong>结点API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Node</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(T t,Node pre,Node next)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>T item:存储数据<br>Node next：指向下一个结点<br>Node pre:指向上一个结点</td>
</tr>
</tbody></table>
<p><strong>双向链表API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>TwoWayLinkList</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>TwoWayLinkList()：创建TwoWayLinkList对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public void clear()：空置链表 <br>2.public boolean isEmpty()：判断线性表是否为空，是返回true，否返回false<br>3.public int length():获取线性表中元素的个数<br>4.public T get(int i):读取并返回线性表中的第i个元素的值<br>5.public void insert(T t)：往线性表中添加一个元素；<br>6.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。<br>7.public T remove(int i):删除并返回线性表中第i个数据元素。<br>8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1<br>9.public T getFirst():获取第一个元素<br>10.public T getLast():获取最后一个元素</td>
</tr>
<tr>
<td>成员内部类</td>
<td>private class Node:结点类</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node head:记录首结点<br>2.private Node last:记录尾结点<br>3.private int N:记录链表的长度</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 双向链表API实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-12-30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoWayLinkList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录首结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录尾结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录链表的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TwoWayLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空置链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">        head.next = last;</span><br><span class="line">        head.pre = <span class="literal">null</span>;</span><br><span class="line">        head.item = <span class="literal">null</span>;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断线性表是否为空，是返回true，否返回false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取线性表中元素的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取并返回线性表中的第i个元素的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;查找位置不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往线性表中添加一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (last==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果当前链表为空</span></span><br><span class="line">            <span class="comment">//直接将尾结点赋值，并将head和last连接</span></span><br><span class="line">            last = <span class="keyword">new</span> <span class="title class_">Node</span>(t,head,<span class="literal">null</span>);</span><br><span class="line">            head.next = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果链表尾结点存在值，创建新的结点连接到原尾结点，并将新结点赋值给尾结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">oldLastNode</span> <span class="operator">=</span> last;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t,oldLastNode,<span class="literal">null</span>);</span><br><span class="line">            oldLastNode.next = node;</span><br><span class="line">            last = node;</span><br><span class="line">        &#125;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在线性表的第i个元素之前插入一个值为t的数据元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> i,T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;查找位置不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先找到i结点前置结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到i结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="comment">//创建新结点，前置结点为原前置结点，后置结点为原i位置结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t,pre,cur);</span><br><span class="line">        <span class="comment">//原前置结点next指向新结点</span></span><br><span class="line">        pre.next = n;</span><br><span class="line">        <span class="comment">//原i结点前置指向n</span></span><br><span class="line">        cur.pre = n;</span><br><span class="line">        <span class="comment">//数量加1</span></span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除并返回线性表中第i个数据元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">remove</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;查找位置不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先找到i结点前置结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到i结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="comment">//找到i结点的后置结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        <span class="comment">//将前置结点和后置结点连接</span></span><br><span class="line">        pre.next = next;</span><br><span class="line">        next.pre = pre;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> cur.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; node.next!=<span class="literal">null</span> ; i++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            <span class="keyword">if</span> (node.item.equals(t))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取第一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取最后一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n.next!=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">            <span class="keyword">return</span> n.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 存储数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> T item;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 指向下一个结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Node pre;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 指向上一个结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T t,Node pre,Node next)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.item = t;</span><br><span class="line">            <span class="built_in">this</span>.pre = pre;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h5><p>使用递归方式实现链表的反转</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (N==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="comment">//当前列表为空，不需要反转</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       reverse(head.next);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Node <span class="title function_">reverse</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node.next==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="comment">//说明已经到最后一个结点，将头结点指向当前结点</span></span><br><span class="line">           head.next = node;</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//递归调用2反转方法</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> reverse(node.next);</span><br><span class="line">       <span class="comment">//将返回结点后置结点指向当前结点</span></span><br><span class="line">       pre.next = node;</span><br><span class="line">       <span class="comment">//当前结点后置结点置为null</span></span><br><span class="line">       node.next = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h5><p>快慢指针指的是定义两个指针，这两个指针的移动速度一块一慢，以此来制造出自己想要的差值，这个差值可以然</p>
<p>我们找到链表上相应的结点。一般情况下，快指针的移动步长为慢指针的两倍</p>
<p><strong>中间值问题</strong></p>
<p>定义一个链表，想获取中间值</p>
<p>使用快慢指针解决，定义两个指针，一个指针的步长为另一个指针的步长的二倍，当快指针到达尾部，慢指针停在的位置即为中间位置</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getMid</span><span class="params">(Node&lt;String&gt; first)</span>&#123;</span><br><span class="line">       Node&lt;String&gt; slow = first;</span><br><span class="line">       Node&lt;String&gt; fast = first;</span><br><span class="line">       <span class="keyword">while</span> (slow.next!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">           fast = fast.next.next;</span><br><span class="line">           slow = slow.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> slow.item;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>单向链表是否有环问题</strong></p>
<p>使用快慢指针，如果一个环状链表，两个速度有差异的指针一定会相遇</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCircle</span><span class="params">(Node&lt;String&gt; first)</span>&#123;</span><br><span class="line">    Node&lt;String&gt; slow = first;</span><br><span class="line">    Node&lt;String&gt; fast = first;</span><br><span class="line">    <span class="keyword">while</span> (slow.next!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        fast = first.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast.equals(slow))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>有环链表入口问题</strong></p>
<p>当快慢指针相遇时，我们可以判断到链表中有环，这时重新设定一个新指针指向链表的起点，且步长与慢指针一样</p>
<p>为1，则慢指针与“新”指针相遇的地方就是环的入口</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Node&lt;String&gt; <span class="title function_">getEntrance</span><span class="params">(Node&lt;String&gt; first)</span> &#123;</span><br><span class="line">    Node&lt;String&gt; slow = first;</span><br><span class="line">    Node&lt;String&gt; fast = first;</span><br><span class="line">    Node&lt;String&gt; temp = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">null</span> &amp;&amp; fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast.equals(slow))&#123;</span><br><span class="line">            temp = first;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp!=<span class="literal">null</span>)&#123;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">            <span class="keyword">if</span> (temp.equals(slow))&#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h5><p>循环链表，顾名思义，链表整体要形成一个圆环状。在单向链表中，最后一个节点的指针为null，不指向任何结</p>
<p>点，因为没有下一个元素了。要实现循环链表，我们只需要让单向链表的最后一个节点的指针指向头结点即可。</p>
<h5 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h5><p><strong>问题描述：</strong></p>
<p>传说有这样一个故事，在罗马人占领乔塔帕特后，39 个犹太人与约瑟夫及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，第一个人从1开始报数，依次后，如果有人报数到3，那么这个人就必须自杀，然后再由他的下一个人重新从1开始报数，直到所有人都自杀身亡为止。然而约瑟夫和他的朋友并不想遵从。于是，约瑟夫要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，从而逃过了这场死亡游戏 。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 约瑟夫经典问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-02</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Joseph</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//构建循环链表</span></span><br><span class="line">        Node&lt;Integer&gt; first = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//记录前一个结点</span></span><br><span class="line">        Node&lt;Integer&gt; pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">41</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//第一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">1</span>)&#123;</span><br><span class="line">                first = <span class="keyword">new</span> <span class="title class_">Node</span>(i,<span class="literal">null</span>);</span><br><span class="line">                pre = first;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Node&lt;Integer&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(i,<span class="literal">null</span>);</span><br><span class="line">            pre.next = node;</span><br><span class="line">            pre = node;</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">41</span>)&#123;</span><br><span class="line">                <span class="comment">//让最后一个结点指向第一个结点</span></span><br><span class="line">                pre.next = first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用count记录当前的报数值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历链表，没循环一次count++</span></span><br><span class="line">        Node&lt;Integer&gt; n = first;</span><br><span class="line">        Node&lt;Integer&gt; before = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (n!=n.next)&#123;</span><br><span class="line">            <span class="comment">//判断count的值，如果是3，则从链表中删除这个结点并打印，把count重置为0</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="comment">//删除当前结点</span></span><br><span class="line">                before.next = n.next;</span><br><span class="line">                System.out.println(n.item);</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                n = n.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                before = n;</span><br><span class="line">                n = n.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(n.item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈是一种基于先进后出(FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出</p>
<p>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一</p>
<p>个数据被第一个读出来）。</p>
<p><strong>链表实现栈API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>StackLink</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>StackLink()：创建StackLink对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false<br>2.public int size():获取栈中元素的个数<br>3.public T pop():弹出栈顶元素<br>4.public void push(T t)：向栈中压入元素t</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node head:记录首结点<br>2.private int N:记录链表的长度</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 栈API实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackLink</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录首结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前栈的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StackLink</span><span class="params">()</span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断栈是否为空，是返回true，否返回false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取栈中元素的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出栈顶元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">oldNode</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">if</span> (oldNode==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = head.next.next;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> oldNode.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向栈中压入元素t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">oldNode</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t,oldNode);</span><br><span class="line">        head.next = node;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StackIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">StackIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n.next!=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> n.next;</span><br><span class="line">            n = n.next;</span><br><span class="line">            <span class="keyword">return</span> node.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> T item;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T item, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = item;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组实现栈API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>StackArray</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>StackArray()：创建StackArray对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false<br>2.public int size():获取栈中元素的个数<br>3.public T pop():弹出栈顶元素<br>4.public void push(T t)：向栈中压入元素t</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] data:存储数据的顺序表<br>2.private int N:记录链表的长度</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 栈结构API数组实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackArray</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T[] data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StackArray</span><span class="params">(<span class="type">int</span> capcity)</span>&#123;</span><br><span class="line">        data = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capcity];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N&gt;=data.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈已满&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[N++] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> data[N-<span class="number">1</span>];</span><br><span class="line">        data[N-<span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StackIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> cur;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cur&lt;N;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data[cur++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两栈共享</strong></p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p><strong>括号匹配问题</strong></p>
<p><strong>问题描述：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">给定一个字符串，里边可能包含&quot;()&quot;小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。</span><br><span class="line">例如：</span><br><span class="line"><span class="code">    &quot;(上海)(长安)&quot;：正确匹配</span></span><br><span class="line"><span class="code">    &quot;上海((长安))&quot;：正确匹配</span></span><br><span class="line"><span class="code">    &quot;上海(长安(北京)(深圳)南京)&quot;:正确匹配</span></span><br><span class="line"><span class="code">    &quot;上海(长安))&quot;：错误匹配</span></span><br><span class="line"><span class="code">    &quot;((上海)长安&quot;：错误匹配</span></span><br></pre></td></tr></table></figure>

<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断str中的括号是否匹配</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> str 括号组成的字符串</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 如果匹配，返回true，如果不匹配，返回false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String str)</span>&#123;</span><br><span class="line">      StackLink&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">StackLink</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> String.valueOf(str.charAt(i));</span><br><span class="line">          <span class="keyword">if</span> (<span class="string">&quot;(&quot;</span>.equals(c))&#123;</span><br><span class="line">              stack.push(c);</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;)&quot;</span>.equals(c))&#123;</span><br><span class="line">              <span class="type">String</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">              <span class="keyword">if</span> (pop==<span class="literal">null</span>||<span class="string">&quot;&quot;</span>.equals(pop))&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (stack.size()==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>逆波兰表达式求值问题</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> notaion 逆波兰表达式的数组表示方式</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 逆波兰表达式的计算结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">caculate</span><span class="params">(String[] notaion)</span>&#123;</span><br><span class="line">       StackLink&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">StackLink</span>&lt;&gt;();</span><br><span class="line">       Integer o1;</span><br><span class="line">       Integer o2;</span><br><span class="line">       Integer result;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; notaion.length; i++) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">curr</span> <span class="operator">=</span> notaion[i];</span><br><span class="line">           <span class="keyword">switch</span> (curr)&#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                   o1 = stack.pop();</span><br><span class="line">                   o2 = stack.pop();</span><br><span class="line">                   result = o1 + o2;</span><br><span class="line">                   stack.push(result);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                   o1 = stack.pop();</span><br><span class="line">                   o2 = stack.pop();</span><br><span class="line">                   result = o2 - o1;</span><br><span class="line">                   stack.push(result);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                   o1 = stack.pop();</span><br><span class="line">                   o2 = stack.pop();</span><br><span class="line">                   result = o1 * o2;</span><br><span class="line">                   stack.push(result);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                   o1 = stack.pop();</span><br><span class="line">                   o2 = stack.pop();</span><br><span class="line">                   result = o2 / o1;</span><br><span class="line">                   stack.push(result);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   stack.push(Integer.valueOf(curr));</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       result = stack.pop();</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列是一种基于先进先出(FIFO)的数据结构，是一种只能在一端进行插入,在另一端进行删除操作的特殊线性表，它</p>
<p>按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。</p>
<h5 id="数组实现队列"><a href="#数组实现队列" class="headerlink" title="数组实现队列"></a>数组实现队列</h5><p>1、入队列，在队列增加元素；出队列，在队头弹出数据，同时数据整体向队头移动，保证队头有数据</p>
<p>2、由于每次移动数据，增加时间复杂度。于是增加队头队尾指针，通过移动指针来操作队列数据，但是不能重复利用数组空间</p>
<p>3、为了能重复利用，引出循环队列概念，当队尾指针最大后，再移动到队头开始，当front和rear相等，有可能是队列为空也有可能是队列满了</p>
<p>4、进而将rear指针定义为队尾的下一位置，从而得出结论front&#x3D;rear说明队列为空，(front+1)%quenenSize&#x3D;front，说明队列已满；并得出队列长度公式：(rear-front+quenenSize)%quenenSize</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用数组实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-05</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuenenArray</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] data;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队头指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队尾下一个结点指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuenenArray</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        data = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpety</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//头指针和尾指针相等</span></span><br><span class="line">        <span class="keyword">return</span> front==rear;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear-front+capacity)%capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向队列添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((rear+<span class="number">1</span>)%capacity==front)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列已满&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[rear] = t;</span><br><span class="line">        rear = (rear+<span class="number">1</span>)%capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rear==front)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> data[front];</span><br><span class="line">        front = (front+<span class="number">1</span>)%capacity;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showDatas</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T t : data) &#123;</span><br><span class="line">            System.out.print(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a>链表实现队列</h5><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 链表实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuenenLink</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//记录首结点</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">//记录最后一个结点</span></span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="comment">//记录队列中元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuenenLink</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回队列中元素的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向队列中插入元素t</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>) &#123;</span><br><span class="line">            last = <span class="keyword">new</span> <span class="title class_">Node</span>(t, <span class="literal">null</span>);</span><br><span class="line">            head.next = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">oldLast</span> <span class="operator">=</span> last;</span><br><span class="line">            last = <span class="keyword">new</span> <span class="title class_">Node</span>(t, <span class="literal">null</span>);</span><br><span class="line">            oldLast.next = last;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//个数+1</span></span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中拿出一个元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">oldFirst</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = oldFirst.next;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            last = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldFirst.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">QIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">QIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n.next != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> n.next;</span><br><span class="line">            n = n.next;</span><br><span class="line">            <span class="keyword">return</span> node.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> T item;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T item, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = item;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h3><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><p>树是由n（n&gt;&#x3D;1）个有限结点组成一个具有层次关系的集合。</p>
<p>树具有以下特点：</p>
<p> 1.每个结点有零个或多个子结点；</p>
<p> 2.没有父结点的结点为根结点；</p>
<p> 3.每一个非根结点只有一个父结点；</p>
<p> 4.每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树；</p>
<h4 id="树的相关概念"><a href="#树的相关概念" class="headerlink" title="树的相关概念"></a>树的相关概念</h4><p><strong>结点的度：</strong></p>
<p>一个结点含有的子树的个数称为该结点的度；</p>
<p><strong>叶结点：</strong></p>
<p>度为0的结点称为叶结点，也可以叫做终端结点</p>
<p><strong>分支结点：</strong></p>
<p>度不为0的结点称为分支结点，也可以叫做非终端结点</p>
<p><strong>结点的层次：</strong></p>
<p>从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推</p>
<p><strong>结点的层序编号：</strong></p>
<p>将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。</p>
<p><strong>树的度：</strong></p>
<p>树中所有结点的度的最大值</p>
<p><strong>树的高度(深度)：</strong></p>
<p>树中结点的最大层次</p>
<p><strong>森林：</strong></p>
<p> m（m&gt;&#x3D;0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根</p>
<p>结点，森林就变成一棵</p>
<p><strong>孩子结点：</strong></p>
<p>一个结点的直接后继结点称为该结点的孩子结点</p>
<p><strong>双亲结点(父结点)：</strong></p>
<p>一个结点的直接前驱称为该结点的双亲结点</p>
<p><strong>兄弟结点：</strong></p>
<p>同一双亲结点的孩子结点间互称兄弟结点</p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><h5 id="基本定义-1"><a href="#基本定义-1" class="headerlink" title="基本定义"></a>基本定义</h5><p>二叉树就是度不超过2的树(每个结点最多有两个子结点)</p>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p><strong>满二叉树：</strong></p>
<p>一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。</p>
<p><strong>完全二叉树：</strong></p>
<p>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p><strong>结点类：</strong></p>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>Node&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(Key key, Value value, Node left, Node right)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.public Node left:记录左子结点<br>2.public Node right:记录右子结点<br>3.public Key key:存储键<br>4.public Value value:存储值</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 结点类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;Key,Value&gt;&#123;</span><br><span class="line">      <span class="comment">//存储键</span></span><br><span class="line">      <span class="keyword">private</span> Key key;</span><br><span class="line">      <span class="comment">//存储值</span></span><br><span class="line">      <span class="keyword">private</span> Value value;</span><br><span class="line">      <span class="comment">//左结点</span></span><br><span class="line">      <span class="keyword">private</span> Node left;</span><br><span class="line">      <span class="comment">//右结点</span></span><br><span class="line">      <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 构造方法</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Key key, Value value, Node left, Node right)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.key = key;</span><br><span class="line">          <span class="built_in">this</span>.value = value;</span><br><span class="line">          <span class="built_in">this</span>.left = left;</span><br><span class="line">          <span class="built_in">this</span>.right = right;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉树API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>BinaryTree&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>BinaryTree()：创建BinaryTree对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node root:记录根结点<br>2.private int N:记录树中元素的个数</td>
</tr>
<tr>
<td>成员方法</td>
<td>1. public void put(Key key,Value value):向树中插入一个键值对<br>2.private Node put(Node x, Key key, Value val)：给指定树x上，添加键一个键值对，并返回添加后的新树<br>3.public Value get(Key key):根据key，从树中找出对应的值<br>4.private Value get(Node x, Key key):从指定的树x中，找出key对应的值<br>5.public void delete(Key key):根据key，删除树中对应的键值对<br>6.private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的新树<br>7.public int size():获取树中元素的个数</td>
</tr>
</tbody></table>
<p><strong>插入方法put实现思想：</strong></p>
<p>1.如果当前树中没有任何一个结点，则直接把新结点当做根结点使用</p>
<p>2.如果当前树不为空，则从根结点开始：</p>
<p> 2.1如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；</p>
<p> 2.2如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；</p>
<p> 2.3如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。</p>
<p><strong>查询方法get实现思想：</strong></p>
<p>从根节点开始：</p>
<p> 1.如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；</p>
<p> 2.如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；</p>
<p> 3.如果要查询的key等于当前结点的key，则树中返回当前结点的value。</p>
<p><strong>删除方法delete实现思想：</strong></p>
<p> 1.找到被删除结点；</p>
<p> 2.找到被删除结点右子树中的最小结点minNode</p>
<p> 3.删除右子树中的最小结点</p>
<p> 4.让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子</p>
<p>树</p>
<p> 5.让被删除结点的父节点指向最小结点minNode</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 二叉树实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span>&lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;,Value&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 树中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryTree</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向树中插入一个键值对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Key key,Value value)</span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给指定树x上，添加键一个键值对，并返回添加后的新树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">put</span><span class="params">(Node x, Key key, Value val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="literal">null</span>)&#123;</span><br><span class="line">            N++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key,val,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//新结点的key大于当前结点key，继续找当前结点的右子结点</span></span><br><span class="line">            x.right = put(x.right,key,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//新结点的key小于当前结点key，继续找当前结点的左子结点</span></span><br><span class="line">            x.left = put(x.left,key,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            x.value = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key，从树中找出对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Value <span class="title function_">get</span><span class="params">(Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从指定的树x中，找出key对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Value <span class="title function_">get</span><span class="params">(Node x,Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> get(x.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> get(x.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除树中对应的键值对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Key key)</span>&#123;</span><br><span class="line">        delete(root,key);</span><br><span class="line">        <span class="comment">//个数-1</span></span><br><span class="line">        N--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定树x上的键为key的键值对，并返回删除后的新树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">delete</span><span class="params">(Node x,Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            x.right = delete(x.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x.left = delete(x.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//新结点的key等于当前结点的key,当前x就是要删除的结点</span></span><br><span class="line">            <span class="comment">//1.如果当前结点的右子树不存在，则直接返回当前结点的左子结点</span></span><br><span class="line">            <span class="keyword">if</span> (x.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> x.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.如果当前结点的左子树不存在，则直接返回当前结点的右子结点</span></span><br><span class="line">            <span class="keyword">if</span> (x.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> x.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.当前结点的左右子树都存在</span></span><br><span class="line">            <span class="comment">//3.1找到右子树中最小的结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">minNode</span> <span class="operator">=</span> x.right;</span><br><span class="line">            <span class="keyword">while</span> (minNode.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                minNode = minNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.2删除右子树中最小的结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> x.right;</span><br><span class="line">            <span class="keyword">while</span> (n.left != <span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span> (n.left.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                   n.left = <span class="literal">null</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   n = n.left;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.3让被删除结点的左子树成为最小结点minNode的左子树，让被删除结点的右子树成为最小结点minNode的右子树</span></span><br><span class="line">            minNode.left = x.left;</span><br><span class="line">            minNode.right = x.right;</span><br><span class="line">            <span class="comment">//3.4让被删除结点的父节点指向最小结点minNode</span></span><br><span class="line">            x = minNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取树中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结点类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="comment">//存储键</span></span><br><span class="line">        <span class="keyword">private</span> Key key;</span><br><span class="line">        <span class="comment">//存储值</span></span><br><span class="line">        <span class="keyword">private</span> Value value;</span><br><span class="line">        <span class="comment">//左结点</span></span><br><span class="line">        <span class="keyword">private</span> Node left;</span><br><span class="line">        <span class="comment">//右结点</span></span><br><span class="line">        <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Key key, Value value, Node left, Node right)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找二叉树中的最小键</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找出整个树中最小的键</span></span><br><span class="line">   <span class="keyword">public</span> Key <span class="title function_">min</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> min(root).key;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//找出指定树x中最小的键所在的结点</span></span><br><span class="line">   <span class="keyword">public</span> Node <span class="title function_">min</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> min(x.left);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找二叉树中最大的键</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找出整个树中最大的键</span></span><br><span class="line">   <span class="keyword">public</span> Key <span class="title function_">max</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> max(root).key;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//找出指定树x中最小的键所在的结点</span></span><br><span class="line">   <span class="keyword">public</span> Node <span class="title function_">max</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> max(x.right);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h5><p><strong>前序遍历</strong></p>
<p>先访问根结点，然后再访问左子树，最后访问右子树</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用前序遍历，获取整个树中的所有键</span></span><br><span class="line">   <span class="keyword">public</span> QuenenLink&lt;Key&gt; <span class="title function_">preErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">       QuenenLink&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">       preErgodic(root,keys);</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用前序遍历，把指定树x中的所有键放入到keys队列中</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preErgodic</span><span class="params">(Node x,QuenenLink&lt;Key&gt; keys)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1.把当前结点的key放入到队列中;</span></span><br><span class="line">       keys.enqueue(x.key);</span><br><span class="line">       <span class="comment">//2.找到当前结点的左子树，如果不为空，递归遍历左子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           preErgodic(x.left,keys);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3.找到当前结点的右子树，如果不为空，递归遍历右子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">           preErgodic(x.right,keys);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>中序遍历</strong></p>
<p>先访问左子树，中间访问根节点，最后访问右子树</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用中序遍历，获取整个树中的所有键</span></span><br><span class="line">   <span class="keyword">public</span> QuenenLink&lt;Key&gt; <span class="title function_">midErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">       QuenenLink&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">       midErgodic(root,keys);</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用中序遍历，把指定树x中的所有键放入到keys队列中</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">midErgodic</span><span class="params">(Node x,QuenenLink&lt;Key&gt; keys)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1.找到当前结点的左子树，如果不为空，递归遍历左子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           midErgodic(x.left,keys);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2.把当前结点的key放入到队列中;</span></span><br><span class="line">       keys.enqueue(x.key);</span><br><span class="line">       <span class="comment">//3.找到当前结点的右子树，如果不为空，递归遍历右子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">           midErgodic(x.right,keys);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>后序遍历</strong></p>
<p>先访问左子树，再访问右子树，最后访问根节点</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用后序遍历，获取整个树中的所有键</span></span><br><span class="line">   <span class="keyword">public</span> QuenenLink&lt;Key&gt; <span class="title function_">afterErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">       QuenenLink&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">       afterErgodic(root,keys);</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用后序遍历，把指定树x中的所有键放入到keys队列中</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">afterErgodic</span><span class="params">(Node x,QuenenLink&lt;Key&gt; keys)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1.找到当前结点的左子树，如果不为空，递归遍历左子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           afterErgodic(x.left,keys);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2.找到当前结点的右子树，如果不为空，递归遍历右子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">           afterErgodic(x.right,keys);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3.把当前结点的key放入到队列中;</span></span><br><span class="line">       keys.enqueue(x.key);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>层序遍历</strong></p>
<p>所谓的层序遍历，就是从根节点（第一层）开始，依次向下，获取每一层所有结点的值</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用层序遍历得到树中所有的键</span></span><br><span class="line">   <span class="keyword">public</span> QuenenLink&lt;Key&gt; <span class="title function_">layerErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">       QuenenLink&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">       QuenenLink&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">       nodes.enqueue(root);</span><br><span class="line">       <span class="keyword">while</span> (!nodes.isEmpty())&#123;</span><br><span class="line">           <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nodes.dequeue();</span><br><span class="line">           keys.enqueue(node.key);</span><br><span class="line">           <span class="keyword">if</span> (node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">               nodes.enqueue(node.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">               nodes.enqueue(node.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="二叉树的最大深度问题"><a href="#二叉树的最大深度问题" class="headerlink" title="二叉树的最大深度问题"></a><strong>二叉树的最大深度问题</strong></h5><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算整个树的最大深度</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> maxDepth(root);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//计算指定树x的最大深度</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">       <span class="comment">//1.如果根结点为空，则最大深度为0；</span></span><br><span class="line">       <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//2.计算左子树的最大深度；</span></span><br><span class="line">       <span class="keyword">if</span> (x.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           maxL = maxDepth(x.left);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3.计算右子树的最大深度；</span></span><br><span class="line">       <span class="keyword">if</span> (x.right != <span class="literal">null</span>)&#123;</span><br><span class="line">           maxR = maxDepth(x.right);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4.当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1</span></span><br><span class="line">       max = maxL &gt; maxR ? maxL + <span class="number">1</span> : maxR + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h4><p>二叉查找树是最常用的一种二叉树，它支持快速插入、删除、查找操作，各个操作的时间复杂度跟树的高度成正比，最佳时间复杂度是 O(log­n)。</p>
<p>不过，由于二叉排序树本身为有序，当<strong>插入一个有序程度十分高的序列</strong>时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致<strong>最终的二叉排序树会退化为链表</strong>，从而使得二叉树的查询和插入效率恶化。**时间复杂度会退化到 O(n)**。</p>
<p>因此一般的<strong>二叉查找树不适用于数据经常变动（加入或删除）的情况</strong>。而是比较适合不会变动的数据，例如编程语言中的“保留字”等。</p>
<p>为了能够尽量降低查找所需要的时间，快速找到所要的键值，或者很快地知道当前的树中没有我们要的键值，必须让树的高度越小越好。要解决这个时间复杂度退化的问题，我们需要设计一种平衡二叉查找树。</p>
<h5 id="avl平衡树"><a href="#avl平衡树" class="headerlink" title="avl平衡树"></a>avl平衡树</h5><p>平衡二叉树（Balanced Binary Tree）又称 <strong>AVL</strong> 树（由 Adelse-Velskil 和 Landis 两个人发明），本身也是一棵二叉查找树，其产生是为了解决二叉排序树在插入时发生线性排列的现象。</p>
<p>平衡二叉树的严格定义是这样的：</p>
<ol>
<li>满足二叉查找树的性质，左子树所有值小于父节点，右子树所有值大于等于父节点。</li>
<li>作为一棵平衡二叉树，它需要满足任意一个节点的左右子树的高度相差不能大于 1。</li>
</ol>
<p>在平衡二叉树中，<strong>每次在插入数据和删除数据后，必要时就会对二叉树做一些高度的调整（左旋和右旋）</strong>，<strong>来让二叉查找树的高度随时维持平衡，将查找、插入、删除操作的时间复杂度保证在 O(log­n) 范围内</strong>。通常只有从那些插入点到根节点的路径上的节点的平衡性可能被改变，因为只有这些节点的子树可能变化。</p>
<p>平衡二叉树适用于动态数据，这就完成了哈希表不便完成的工作——动态性。所以：</p>
<ul>
<li>如果输入集合确定，所需要的就是查询，则可以考虑使用哈希表。</li>
<li>如果输入集合不确定，则考虑使用平衡二叉树&#x2F;红黑树，保证达到最大效率。</li>
</ul>
<p><strong>平衡二叉树主要优点集中在快速查找，</strong>频繁旋转会使插入和删除牺牲掉 O(log­n) 左右的时间，不过相对二叉查找树来说，时间上稳定了很多。<br><strong>Node结点类：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>Node&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(Key,Value)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.public K key:键<br>2.private V value:值<br>3.private Node left,right:左右结点<br>4.private int height:高度</td>
</tr>
</tbody></table>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>AvlTree&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>AvlTree()：创建AvlTree对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node root:记录根结点<br>2.private int N:记录树中元素的个数:</td>
</tr>
<tr>
<td>成员方法</td>
<td>1. public void put(Key key,Value value):向树中插入一个键值对<br>2.private Node put(Node x, Key key, Value val)：给指定树x上，添加键一个键值对，并返回添加后的新树<br>3.public Value get(Key key):根据key，从树中找出对应的值<br>4.private Value get(Node x, Key key):从指定的树x中，找出key对应的值<br>5.public void delete(Key key):根据key，删除树中对应的键值对<br>6.private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的新树<br>7.public int size():获取树中元素的个数<br>8.public Node rightRotate(Node x):右旋<br>9.public Node leftRotate(Node x):左旋</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: avl数实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AvlTree</span>&lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;,Value&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Key key;</span><br><span class="line">        <span class="keyword">private</span> Value value;</span><br><span class="line">        <span class="keyword">public</span> Node left,right;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Key key,Value value)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            left = <span class="literal">null</span>;</span><br><span class="line">            right = <span class="literal">null</span>;</span><br><span class="line">            height = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AvlTree</span><span class="params">()</span>&#123;</span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取树高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取平衡因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getBalanceFactor</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getHeight(node.left) - getHeight(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右旋</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">rightRotate</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="comment">//获取根结点的左子节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">left</span> <span class="operator">=</span> node.left;</span><br><span class="line">        <span class="comment">//获取左子节点的右子节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">lright</span> <span class="operator">=</span> left.right;</span><br><span class="line">        <span class="comment">//left为根结点，node为其右子节点，并lright调整为node的左子节点</span></span><br><span class="line">        left.right = node;</span><br><span class="line">        node.left = lright;</span><br><span class="line">        <span class="comment">//更新height</span></span><br><span class="line">        left.height = Math.max(getHeight(left.left),getHeight(left.right)) + <span class="number">1</span>;</span><br><span class="line">        node.height = Math.max(getHeight(node.left),getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左旋</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">leftRotate</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="comment">//获取根结点的右子节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> node.right;</span><br><span class="line">        <span class="comment">//获取右子节点的左子节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">rleft</span> <span class="operator">=</span> right.left;</span><br><span class="line">        <span class="comment">//right为根结点，node为其左子节点，并rleft调整为node的右子节点</span></span><br><span class="line">        right.left = node;</span><br><span class="line">        node.right = rleft;</span><br><span class="line">        <span class="comment">//更新height</span></span><br><span class="line">        right.height = Math.max(getHeight(right.left),getHeight(right.right)) + <span class="number">1</span>;</span><br><span class="line">        node.height = Math.max(getHeight(node.left),getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Key key,Value value)</span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">put</span><span class="params">(Node node,Key key,Value value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果为空，即空树添加结点</span></span><br><span class="line">            <span class="comment">//元素个数加1</span></span><br><span class="line">            N++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key,value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(node.key)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            node.left = put(node.left,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            node.right = put(node.right,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key)==<span class="number">0</span>)&#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新每个结点的height</span></span><br><span class="line">        node.height = Math.max(getHeight(node.left),getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//计算平衡因子</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">balanceFactor</span> <span class="operator">=</span> getBalanceFactor(node);</span><br><span class="line">        <span class="comment">//右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先左旋再右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.left = leftRotate(node.left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先右旋再左旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.right = rightRotate(node.right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据key，从树中找出对应的值</span></span><br><span class="line">    <span class="keyword">public</span> Value <span class="title function_">get</span><span class="params">(Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从指定的树x中，找出key对应的值</span></span><br><span class="line">    <span class="keyword">private</span> Value <span class="title function_">get</span><span class="params">(Node node,Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(node.key)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> get(node.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> get(node.right,key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据key，删除树中对应的键值对</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Key key)</span>&#123;</span><br><span class="line">        root = delete(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除指定树x上的键为key的键值对，并返回删除后的新树</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">delete</span><span class="params">(Node node,Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义新树</span></span><br><span class="line">        Node newNode;</span><br><span class="line">        <span class="comment">//找到key对应的位置</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.left = delete(node.left,key);</span><br><span class="line">            newNode = node;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.right = delete(node.right,key);</span><br><span class="line">            newNode = node;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//找到key的位置</span></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> node.right;</span><br><span class="line">                node.right = <span class="literal">null</span>;</span><br><span class="line">                N--;</span><br><span class="line">                newNode = rightNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> node.left;</span><br><span class="line">                node.left = <span class="literal">null</span>;</span><br><span class="line">                N--;</span><br><span class="line">                newNode = leftNode;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">                <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">minimum</span> <span class="operator">=</span> minimum(node.right);</span><br><span class="line">                minimum.right = delete(node.right,minimum.key);</span><br><span class="line">                minimum.left = node.left;</span><br><span class="line">                node.left = node.right = <span class="literal">null</span>;</span><br><span class="line">                newNode = minimum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新height</span></span><br><span class="line">        newNode.height = <span class="number">1</span> + Math.max(getHeight(newNode.left), getHeight(newNode.right));</span><br><span class="line">        <span class="comment">//计算平衡因子</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">balanceFactor</span> <span class="operator">=</span> getBalanceFactor(newNode);</span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(newNode.left) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rightRotate(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(newNode.right) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftRotate(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先左旋再右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(newNode.left) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            newNode.left = leftRotate(newNode.left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先右旋再左旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(newNode.right) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            newNode.right = rightRotate(newNode.right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根的二分搜索树的最小值所在的节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">minimum</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h5><p>为了保证查找树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个结点保存多个键。确切的说，我</p>
<p>们将一棵标准的二叉查找树中的结点称为2-结点(含有一个键和两条链)，而现在我们引入3-结点，它含有两个键和</p>
<p>三条链。2-结点和3-结点中的每条链都对应着其中保存的键所分割产生的一个区间。</p>
<p>一棵2-3查找树要么为空，要么满足满足下面两个要求：</p>
<p><strong>2-结点：</strong></p>
<p>含有一个键(及其对应的值)和两条链，左链接指向2-3树中的键都小于该结点，右链接指向的2-3树中的键都大</p>
<p>于该结点。</p>
<p><strong>3-结点：</strong></p>
<p>含有两个键(及其对应的值)和三条链，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都</p>
<p>位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。</p>
<p><strong>查找</strong></p>
<p>将二叉查找树的查找算法一般化我们就能够直接得到2-3树的查找算法。要判断一个键是否在树中，我们先将它和</p>
<p>根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的连</p>
<p>接，并在其指向的子树中递归地继续查找。如果这个是空链接，查找未命中。</p>
<p> <strong>插入</strong></p>
<p><strong>向2-结点中插入新键</strong></p>
<h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><p>红黑树是一种特殊的二叉查找树，每个结点都要储存位表示结点的颜色，或红或黑</p>
<p><strong>特点：</strong></p>
<ul>
<li>每个结点或红或黑</li>
<li>根结点是黑色</li>
<li>空叶子结点是黑色</li>
<li>如果一个几点是红色，那么他的子节点是黑色</li>
<li>从任意一个结点出发到空的叶子结点经过的黑色结点个数相同</li>
</ul>
<p><strong>Node结点类：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>Node&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(Key,Value)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.public K key:键<br>2.private V value:值<br>3.private Node left,right:左右结点<br>4.private boolean color:结点颜色</td>
</tr>
</tbody></table>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>RedBlackTree&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>RedBlackTree()：创建RedBlackTree对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node root:记录根结点<br>2.private int N:记录树中元素的个数:</td>
</tr>
<tr>
<td>成员方法</td>
<td>1. public void put(Key key,Value value):向树中插入一个键值对<br>2.private Node put(Node x, Key key, Value val)：给指定树x上，添加键一个键值对，并返回添加后的新树<br>3.public Value get(Key key):根据key，从树中找出对应的值<br>4.private Value get(Node x, Key key):从指定的树x中，找出key对应的值<br>5.public void delete(Key key):根据key，删除树中对应的键值对<br>6.private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的新树<br>7.public int size():获取树中元素的个数<br>8.public Node rightRotate(Node x):右旋<br>9.public Node leftRotate(Node x):左旋</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<h5 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h5><p><strong>特点</strong></p>
<p>B树中允许一个结点中包含多个key，可以是3个、4个、5个甚至更多，并不确定，需要看具体的实现。现在我们选</p>
<p>择一个参数M，来构造一个B树，我们可以把它称作是M阶的B树，那么该树会具有如下特点：</p>
<ul>
<li>每个结点最多有M-1个key，并且以升序排列；</li>
<li>每个结点最多能有M个子结点；</li>
<li>根结点至少有两个子结点</li>
</ul>
<p><strong>B树在磁盘文件中的应用</strong></p>
<p>​		在我们的程序中，不可避免的需要通过IO操作文件，而我们的文件是存储在磁盘上的。计算机操作磁盘上的文件是通过文件系统进行操作的，在文件系统中就使用到了B树这种数据结构。</p>
<p><strong>磁盘</strong></p>
<p>​		磁盘能够保存大量的数据，从GB一直到TB级，但是 他的读取速度比较慢，因为涉及到机器操作，读取速度为毫秒级 。磁盘由盘片构成,每个盘片有两面，又称为盘面 。盘片中央有一个可以旋转的主轴，他使得盘片以固定的旋转速率旋转，通常是5400rpm或者是7200rpm,一个磁盘中包含了多个这样的盘片并封装在一个密封的容器内 。盘片的每个表面是由一组称为磁道同心圆组成的 ，每个磁道被划分为了一组扇区 ，每个扇区包含相等数量的数据位，通常是512个子节，扇区之间由一些间隙隔开,这些间隙中不存储数据 。</p>
<p><strong>磁盘IO</strong></p>
<p>​		磁盘用磁头来读写存储在盘片表面的位，而磁头连接到一个移动臂上，移动臂沿着盘片半径前后移动，可以将磁头定位到任何磁道上，这称之为寻道操作。一旦定位到磁道后，盘片转动，磁道上的每个位经过磁头时，读写磁头就可以感知到该位的值，也可以修改值。对磁盘的访问时间分为 <strong>寻道时间</strong>，<strong>旋转时间</strong>，以及<strong>传送时间</strong>。</p>
<p>​		由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，因此为了提高效率，要尽量减少磁盘I&#x2F;O，减少读写操作。 为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此预读可以提高I&#x2F;O效率。,</p>
<p>​		页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（1024个字节或其整数倍），预读的长度一般为页的整倍数。主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<p>​		文件系统的设计者利用了磁盘预读原理，将一个结点的大小设为等于一个页（1024个字节或其整数倍），这样每个结点只需要一次I&#x2F;O就可以完全载入。那么3层的B树可以容纳1024<em>1024</em>1024差不多10亿个数据，如果换成二叉查找树，则需要30层！假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在10亿个数据中查找目标值，只需要小于3次硬盘读取就可以找到目标值，但红黑树需要小于30次，因此B树大大提高了IO的操作效率。</p>
<h5 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h5><p>B+树是对B树的一种变形树，它与B树的差异在于：</p>
<ul>
<li>非叶结点仅具有索引作用，也就是说，非叶子结点只存储key，不存储value；</li>
<li>树的所有叶结点构成一个有序链表，可以按照key排序的次序遍历全部数据。</li>
</ul>
<p><strong>B+树和B树的对比</strong></p>
<p><strong>B+</strong> <strong>树的优点在于：</strong></p>
<ul>
<li>由于B+树在非叶子结点上不包含真正的数据，只当做索引使用，因此在内存相同的情况下，能够存放更多的key。 </li>
<li>B+树的叶子结点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。</li>
</ul>
<p><strong>B树的优点在于：</strong></p>
<p>​		由于B树的每一个节点都包含key和value，因此我们根据key查找value时，只需要找到key所在的位置，就能找到value，但B+树只有叶子结点存储数据，索引每一次查找，都必须一次一次，一直找到树的最大深度处，也就是叶子结点的深度，才能找到value。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h4><p>堆是计算机科学中一类特殊的数据结构的统称，堆通常可以被看做是一棵完全二叉树的数组对象。</p>
<p><strong>堆的特性</strong></p>
<ul>
<li>它是完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求左满右不满。</li>
<li>它通常用数组来实现。如果一个结点的位置为k，则它的父结点的位置为[k&#x2F;2],而它的两个子结点的位置则分别为2k和2k+1。这样，在不使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动：从a[k]向上一层，就令k等于k&#x2F;2,向下一层就令k等于2k或2k+1。</li>
<li>每个结点都大于等于它的两个子结点。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的。</li>
</ul>
<h4 id="堆的API设计"><a href="#堆的API设计" class="headerlink" title="堆的API设计"></a>堆的API设计</h4><table>
<thead>
<tr>
<th>类名</th>
<th><strong>Heap</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Heap(int capacity)：创建容量为capacity的Heap对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br>2.private void exch(int i,int j):交换堆中i索引和j索引处的值<br>3.public T delMax():删除堆中最大的元素,并返回这个最大元素<br>4.public void insert(T t)：往堆中插入一个元素<br>5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br>6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] imtes : 用来存储元素的数组<br>2.private int N：记录堆中元素的个数</td>
</tr>
</tbody></table>
<h4 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a><strong>堆的实现</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.generic.IF_ACMPEQ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储堆中的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录堆中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j])&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换堆中i索引和j索引处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往堆中插入一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        <span class="comment">//上浮算法</span></span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除堆中最大的元素,并返回这个最大元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> items[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//交换索引1处和索引N处的值</span></span><br><span class="line">        exch(<span class="number">1</span>,N);</span><br><span class="line">        <span class="comment">//删除最后位置上的元素</span></span><br><span class="line">        items[N]=<span class="literal">null</span>;</span><br><span class="line">        N--;<span class="comment">//个数-1</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//如果已经到了根结点，就不需要循环了</span></span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//比较当前结点和其父节点</span></span><br><span class="line">            <span class="keyword">if</span> (less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">                <span class="comment">//父节点小于当前节点，则交换</span></span><br><span class="line">                exch(k/<span class="number">2</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//如果当前已经是最底层了，就不需要循环了</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k&lt;=N)&#123;</span><br><span class="line">            <span class="comment">//找到子节点中的较大者</span></span><br><span class="line">            <span class="type">int</span> max;</span><br><span class="line">            <span class="comment">//判断是否存在右结点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span>*k+<span class="number">1</span>&lt;=N)&#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span>*k,<span class="number">2</span>*k+<span class="number">1</span>))&#123;</span><br><span class="line">                    max = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    max = <span class="number">2</span>*k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                max = <span class="number">2</span>*k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较当前结点和子节点中较大者，如果当前结点不小，则结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (!less(k,max))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前结点小，则交换</span></span><br><span class="line">            exch(k,max);</span><br><span class="line">            k = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.generic.IF_ACMPEQ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储堆中的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录堆中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j])&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换堆中i索引和j索引处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往堆中插入一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        <span class="comment">//上浮算法</span></span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除堆中最大的元素,并返回这个最大元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> items[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//交换索引1处和索引N处的值</span></span><br><span class="line">        exch(<span class="number">1</span>,N);</span><br><span class="line">        <span class="comment">//删除最后位置上的元素</span></span><br><span class="line">        items[N]=<span class="literal">null</span>;</span><br><span class="line">        N--;<span class="comment">//个数-1</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//如果已经到了根结点，就不需要循环了</span></span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//比较当前结点和其父节点</span></span><br><span class="line">            <span class="keyword">if</span> (less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">                <span class="comment">//父节点小于当前节点，则交换</span></span><br><span class="line">                exch(k/<span class="number">2</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//如果当前已经是最底层了，就不需要循环了</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k&lt;=N)&#123;</span><br><span class="line">            <span class="comment">//找到子节点中的较大者</span></span><br><span class="line">            <span class="type">int</span> max;</span><br><span class="line">            <span class="comment">//判断是否存在右结点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span>*k+<span class="number">1</span>&lt;=N)&#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span>*k,<span class="number">2</span>*k+<span class="number">1</span>))&#123;</span><br><span class="line">                    max = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    max = <span class="number">2</span>*k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                max = <span class="number">2</span>*k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较当前结点和子节点中较大者，如果当前结点不小，则结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (!less(k,max))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前结点小，则交换</span></span><br><span class="line">            exch(k,max);</span><br><span class="line">            k = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><strong>AP设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>HeapSort</strong></th>
</tr>
</thead>
<tbody><tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] source)：对source数组中的数据从小到大排序<br>2.private static void createHeap(Comparable[] source, Comparable[] heap):根据原数组source，构造出堆heap<br>3.private static boolean less(Comparable[] heap, int i, int j)：判断heap堆中索引i处的元素是否小于索引j处的元素<br>4.private static void exch(Comparable[] heap, int i, int j):交换heap堆中i索引和j索引处的值<br>5.private static void sink(Comparable[] heap, int target, int range):在heap堆中，对target处的元素做下沉，范围是0~range。</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 堆排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对source数组中的数据从小到大排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] source)</span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个比原数组大1的数组</span></span><br><span class="line">        Comparable[] heap = <span class="keyword">new</span> <span class="title class_">Comparable</span>[source.length + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//2.构造堆</span></span><br><span class="line">        createHeap(source,heap);</span><br><span class="line">        <span class="comment">//3.堆排序</span></span><br><span class="line">        <span class="comment">//3.1定义一个变量，记录heap中未排序的所有元素中最大的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> heap.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (N != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//3.2交换heap中索引1处的元素和N处的元素</span></span><br><span class="line">            exch(heap,<span class="number">1</span>,N);</span><br><span class="line">            N--;</span><br><span class="line">            sink(heap,<span class="number">1</span>,N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.heap中的数据已经有序，拷贝到source中</span></span><br><span class="line">        System.arraycopy(heap,<span class="number">1</span>,source,<span class="number">0</span>,source.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据原数组source，构造出堆heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createHeap</span><span class="params">(Comparable[] source, Comparable[] heap)</span>&#123;</span><br><span class="line">        <span class="comment">//1.把source中的数据拷贝到heap中，从heap的1索引处开始填充</span></span><br><span class="line">        System.arraycopy(source,<span class="number">0</span>,heap,<span class="number">1</span>,source.length);</span><br><span class="line">        <span class="comment">//2.从heap索引的一半处开始倒叙遍历，对得到的每一个元素做下沉操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (heap.length-<span class="number">1</span>)/<span class="number">2</span>; i &gt; <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            sink(heap,i, heap.length-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断heap堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(Comparable[] heap, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap[i].compareTo(heap[j])&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换heap堆中i索引和j索引处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] heap, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable tmp=heap[i];</span><br><span class="line">        heap[i]=heap[j];</span><br><span class="line">        heap[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在heap堆中，对target处的元素做下沉，范围是0~range。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> range</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(Comparable[] heap, <span class="type">int</span> target, <span class="type">int</span> range)</span>&#123;</span><br><span class="line">        <span class="comment">//没有子结点了</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*target&lt;=range) &#123;</span><br><span class="line">            <span class="comment">//1.找出target结点的两个子结点中的较大值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">2</span> * target;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * target + <span class="number">1</span> &lt;= range) &#123;</span><br><span class="line">                <span class="comment">//存在右子结点</span></span><br><span class="line">                <span class="keyword">if</span> (less(heap, <span class="number">2</span> * target, <span class="number">2</span> * target + <span class="number">1</span>)) &#123;</span><br><span class="line">                    max = <span class="number">2</span> * target + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.如果当前结点的值小于子结点中的较大值，则交换</span></span><br><span class="line">            <span class="keyword">if</span> (less(heap, target, max)) &#123;</span><br><span class="line">                exch(heap, target, max);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.更新target的值</span></span><br><span class="line">            target = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;S&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;P&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        HeapSort.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>​		普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在某些情况下，我们可能需要找出队列中的最大值或者最小值，例如使用一个队列保存计算机的任务，一般情况下计算机的任务都是有优先级的，我们需要在这些计算机的任务中找出优先级最高的任务先执行，执行完毕后就需要把这个任务从队列中移除。普通的队列要完成这样的功能，需要每次遍历队列中的所有元素，比较并找出最大值，效率不是很高，这个时候，我们就可以使用一种特殊的队列来完成这种需求，优先队列。</p>
<h4 id="最大优先队列"><a href="#最大优先队列" class="headerlink" title="最大优先队列"></a><strong>最大优先队列</strong></h4><p><strong>最大优先队列API设计</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>MaxPriorityQueue</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>MaxPriorityQueue(int capacity)：创建容量为capacity的MaxPriorityQueue对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br>2.private void exch(int i,int j):交换堆中i索引和j索引处的值<br>3.public T delMax():删除队列中最大的元素,并返回这个最大元素<br>4.public void insert(T t)：往队列中插入一个元素<br>5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br>6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置<br>7.public int size():获取队列中元素的个数<br>8.public boolean isEmpty():判断队列是否为空</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] imtes : 用来存储元素的数组<br>2.private int N：记录堆中元素的个数</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.awt.geom.AreaOp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 最大优先队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-20</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPriorityQueue</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存储元素的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录堆中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxPriorityQueue</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换堆中i索引和j索引处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除队列中最大的元素,并返回这个最大元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> items[<span class="number">1</span>];</span><br><span class="line">        exch(<span class="number">1</span>,N);</span><br><span class="line">        items[N] = <span class="literal">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往队列中插入一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//比较当前节点与其父节点</span></span><br><span class="line">            <span class="keyword">if</span> (less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">                exch(k/<span class="number">2</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k&lt;=N)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= N)&#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span> * k,<span class="number">2</span> * k + <span class="number">1</span>))&#123;</span><br><span class="line">                    max = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!less(k,max))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(k,max);</span><br><span class="line">            k = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列中元素的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;S&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;P&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        MaxPriorityQueue&lt;String&gt; maxpq = <span class="keyword">new</span> <span class="title class_">MaxPriorityQueue</span>&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">            maxpq.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(maxpq.size());</span><br><span class="line">        String del;</span><br><span class="line">        <span class="keyword">while</span>(!maxpq.isEmpty())&#123;</span><br><span class="line">            del = maxpq.delMax();</span><br><span class="line">            System.out.print(del+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最小优先队列"><a href="#最小优先队列" class="headerlink" title="最小优先队列"></a>最小优先队列</h4><p>其实我们之前实现的堆可以把它叫做最大堆，我们可以用相反的思想实现最小堆，让堆中存放数据元素的数组满足</p>
<p>如下特性：</p>
<p>1.最小的元素放在数组的索引1处。</p>
<p>2.每个结点的数据总是小于等于它的两个子结点的数据。</p>
<p><strong>最小优先队列API设计</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>MinPriorityQueue</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>MinPriorityQueue(int capacity)：创建容量为capacity的MinPriorityQueue对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br>2.private void exch(int i,int j):交换堆中i索引和j索引处的值<br>3.public T delMax():删除队列中最大的元素,并返回这个最大元素<br>4.public void insert(T t)：往队列中插入一个元素<br>5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br>6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置<br>7.public int size():获取队列中元素的个数<br>8.public boolean isEmpty():判断队列是否为空</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] imtes : 用来存储元素的数组<br>2.private int N：记录堆中元素的个数</td>
</tr>
</tbody></table>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 最小优先队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-20</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinPriorityQueue</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存储元素的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录堆中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinPriorityQueue</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换堆中i索引和j索引处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除队列中最大的元素,并返回这个最大元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> items[<span class="number">1</span>];</span><br><span class="line">        exch(<span class="number">1</span>,N);</span><br><span class="line">        items[N] = <span class="literal">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往队列中插入一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//比较当前节点与其父节点</span></span><br><span class="line">            <span class="keyword">if</span> (less(k,k/<span class="number">2</span>))&#123;</span><br><span class="line">                exch(k/<span class="number">2</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k&lt;=N)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= N)&#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span> * k + <span class="number">1</span>,<span class="number">2</span> * k ))&#123;</span><br><span class="line">                    min = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (less(k,min))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(k,min);</span><br><span class="line">            k = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列中元素的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;S&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;P&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        MinPriorityQueue&lt;String&gt; maxpq = <span class="keyword">new</span> <span class="title class_">MinPriorityQueue</span>&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">            maxpq.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(maxpq.size());</span><br><span class="line">        String del;</span><br><span class="line">        <span class="keyword">while</span>(!maxpq.isEmpty())&#123;</span><br><span class="line">            del = maxpq.delMax();</span><br><span class="line">            System.out.print(del+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="索引优先队列"><a href="#索引优先队列" class="headerlink" title="索引优先队列"></a>索引优先队列</h4><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="图的定义及分类"><a href="#图的定义及分类" class="headerlink" title="图的定义及分类"></a>图的定义及分类</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h5><p>图是由一组顶点和一组能够将两个顶点相连的边组成的</p>
<h5 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a><strong>分类</strong></h5><p>按照连接两个顶点的边的不同，可以把图分为以下两种：</p>
<ul>
<li>无向图：边仅仅连接两个顶点，没有其他含义；</li>
<li>有向图：边不仅连接两个顶点，并且具有方向；</li>
</ul>
<h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><h5 id="图的相关术语"><a href="#图的相关术语" class="headerlink" title="图的相关术语"></a>图的相关术语</h5><p><strong>相邻顶点：</strong></p>
<p>当两个顶点通过一条边相连时，我们称这两个顶点是相邻的，并且称这条边依附于这两个顶点。</p>
<p><strong>度：</strong></p>
<p>某个顶点的度就是依附于该顶点的边的个数</p>
<p><strong>子图：</strong></p>
<p>是一幅图的所有边的子集(包含这些边依附的顶点)组成的图；</p>
<p><strong>路径：</strong></p>
<p>是由边顺序连接的一系列的顶点组成</p>
<p><strong>环：</strong></p>
<p>是一条至少含有一条边且终点和起点相同的路径</p>
<p><strong>连通图：</strong></p>
<p>如果图中任意一个顶点都存在一条路径到达另外一个顶点，那么这幅图就称之为连通图</p>
<p><strong>连通子图：</strong></p>
<p>一个非连通图由若干连通的部分组成，每一个连通的部分都可以称为该图的连通子图</p>
<h5 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a><strong>图的存储结构</strong></h5><p>要表示一幅图，只需要表示清楚以下两部分内容即可：</p>
<ol>
<li>图中所有的顶点；</li>
<li>所有连接顶点的边；</li>
</ol>
<p>常见的图的存储结构有两种：邻接矩阵和邻接表</p>
<p> <strong>邻接矩阵</strong></p>
<ol>
<li>使用一个V*V的二维数组int[V][V] adj,把索引的值看做是顶点；</li>
<li>如果顶点v和顶点w相连，我们只需要将adj[v][w]和adj[w][v]的值设置为1,否则设置为0即可。</li>
</ol>
<p>邻接矩阵这种存储方式的空间复杂度是V^2的，如果我们处理的问题规模比较大的话，内存空间极有可能不够用。</p>
<p><strong>邻接表</strong></p>
<ol>
<li>使用一个大小为V的数组 Queue[V] adj，把索引看做是顶点；</li>
<li>每个索引处adj[v]存储了一个队列，该队列中存储的是所有与该顶点相邻的其他顶点</li>
</ol>
<p>邻接表的空间并不是是线性级别的，采用邻接表这种存储形式来表示图</p>
<h5 id="图的实现"><a href="#图的实现" class="headerlink" title="图的实现"></a><strong>图的实现</strong></h5><p><strong>API设计</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>UndirectedGraph</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>UndirectedGraph(int V)：创建一个包含V个顶点但不包含边的图</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public int V():获取图中顶点的数量<br>2.public int E():获取图中边的数量<br>3.public void addEdge(int v,int w):向图中添加一条边 v-w<br>4.public Queue adj(int v)：获取和顶点v相邻的所有顶点</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private int V: 记录顶点数量<br>2.private int E: 记录边数量<br>3.private Queue[] adj: 邻接表</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.graph;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 无向图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-21</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UndirectedGraph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="comment">//边的数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> E;</span><br><span class="line">    <span class="comment">//邻接表</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt;[] adj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UndirectedGraph</span><span class="params">(<span class="type">int</span> V)</span>&#123;</span><br><span class="line">        <span class="comment">//初始化顶点数量</span></span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        <span class="comment">//初始化边的数量</span></span><br><span class="line">        <span class="built_in">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化邻接表</span></span><br><span class="line">        <span class="built_in">this</span>.adj = <span class="keyword">new</span> <span class="title class_">Queue</span>[V];</span><br><span class="line">        <span class="comment">//初始化邻接表中的空队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; adj.length; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> <span class="title class_">Queue</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取顶点数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">V</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取图中边的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">E</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向图中添加一条边 v-w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">        <span class="comment">//把w添加到v的链表中，这样顶点v就多了一个相邻点w</span></span><br><span class="line">        adj[v].enqueue(w);</span><br><span class="line">        <span class="comment">//把v添加到w的链表中，这样顶点w就多了一个相邻点v</span></span><br><span class="line">        adj[w].enqueue(v);</span><br><span class="line">        <span class="comment">//边的数目自增1</span></span><br><span class="line">        E++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取和顶点v相邻的所有顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">adj</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="图的搜索"><a href="#图的搜索" class="headerlink" title="图的搜索"></a>图的搜索</h5><p><strong>深度优先搜索</strong></p>
<p>​		所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找子结点，然后找兄弟结点。</p>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>DepthFirstSearch</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>DepthFirstSearch(Graph G,int s)：构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相通顶点</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private void dfs(Graph G, int v)：使用深度优先搜索找出G图中v顶点的所有相通顶点<br>2.public boolean marked(int w):判断w顶点与s顶点是否相通<br>3.public int count():获取与顶点s相通的所有顶点的总数</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索<br>2.private int count：记录有多少个顶点与s顶点相通</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 深度优先搜索</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepthFirstSearch</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索引代表顶点，值表示当前顶点是否已经被搜索</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录有多少个顶点与s顶点相通</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相通顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DepthFirstSearch(UndirectedGraph G,<span class="type">int</span> s)&#123;</span><br><span class="line">        <span class="comment">//创建一个和图的顶点数一样大小的布尔数组</span></span><br><span class="line">        marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[G.V()];</span><br><span class="line">        <span class="comment">//搜索G图中与顶点s相同的所有顶点</span></span><br><span class="line">        dfs(G,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用深度优先搜索找出G图中v顶点的所有相通顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(UndirectedGraph G, <span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="comment">//把当前顶点标记为已搜索</span></span><br><span class="line">        marked[v]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//遍历v顶点的邻接表，得到每一个顶点w</span></span><br><span class="line">        <span class="keyword">for</span> (Integer w : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked(w))&#123;</span><br><span class="line">                dfs(G,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//相通的顶点数量+1</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断w顶点与s顶点是否相通</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">marked</span><span class="params">(<span class="type">int</span> w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取与顶点s相通的所有顶点的总数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
