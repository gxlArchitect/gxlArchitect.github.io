<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dubbo</title>
    <url>/2023/03/31/Dubbo/</url>
    <content><![CDATA[<h2 id="Dubbo架构体系"><a href="#Dubbo架构体系" class="headerlink" title="Dubbo架构体系"></a>Dubbo架构体系</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。</p>
<p>Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>
<h2 id="Dubbo基本使用"><a href="#Dubbo基本使用" class="headerlink" title="Dubbo基本使用"></a>Dubbo基本使用</h2><h3 id="Dubbo与SpringBoot的整合"><a href="#Dubbo与SpringBoot的整合" class="headerlink" title="Dubbo与SpringBoot的整合"></a>Dubbo与SpringBoot的整合</h3><p>基于Zookeeper实现Dubbo与Spring Boot的集成整合。</p>
<h4 id="顶级工程pom依赖"><a href="#顶级工程pom依赖" class="headerlink" title="顶级工程pom依赖"></a><strong>顶级工程pom依赖</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dubbo-version</span>&gt;</span>2.7.8<span class="tag">&lt;/<span class="name">dubbo-version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>2.3.0.RELEASE<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- Spring Boot --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">&lt;!-- Apache Dubbo  --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-dependencies-bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dubbo-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dubbo-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Dubbo Spring Boot Starter --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dubbo-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Dubbo核心组件 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--Spring Boot 依赖 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Zookeeper客户端框架 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Zookeeper dependencies --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-dependencies-zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dubbo-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="公用RPC接口工程"><a href="#公用RPC接口工程" class="headerlink" title="公用RPC接口工程"></a>公用RPC接口工程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取订单详情</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> orderId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getOrder</span><span class="params">(Long orderId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务端工程"><a href="#服务端工程" class="headerlink" title="服务端工程"></a>服务端工程</h4><p>1、pom依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Dubbo Spring Boot Starter --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dubbo-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Dubbo 核心依赖 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 公用RPC接口依赖 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、RPC服务接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DubboService(version = &quot;$&#123;dubbo.spring.provider.version&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;dubbo.spring.provider.version&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serviceVersion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取订单详情</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> orderId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOrder</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;get order detail ,orderId=&quot;</span>+orderId +<span class="string">&quot;,serverPort=&quot;</span>+serverPort +<span class="string">&quot;,serviceVersion=&quot;</span>+serviceVersion;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过DubboService注解， 声明为RPC服务，version可以标识具体的版本号， 消费端需匹配保持一致。</p>
<p>3、工程配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">18081</span></span><br><span class="line"><span class="comment"># 应用程序名称</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">dubbo-spring-provider</span></span><br><span class="line"><span class="comment"># Dubbo服务扫描路径</span></span><br><span class="line"><span class="attr">dubbo.scan.base-packages</span>=<span class="string">com.itheima</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Dubbo 通讯协议</span></span><br><span class="line"><span class="attr">dubbo.protocol.name</span>=<span class="string">dubbo</span></span><br><span class="line"><span class="comment"># Dubbo服务提供的端口， 配置为-1，代表为随机端口 默认20880</span></span><br><span class="line"><span class="attr">dubbo.protocol.port</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## Dubbo 注册器配置信息</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="attr">dubbo.registry.file</span> = <span class="string">$&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache</span></span><br><span class="line"><span class="attr">dubbo.spring.provider.version</span> = <span class="string">1.0.0</span></span><br></pre></td></tr></table></figure>



<h4 id="消费端工程"><a href="#消费端工程" class="headerlink" title="消费端工程"></a>消费端工程</h4><p>1、pom依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Dubbo Spring Boot Starter --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dubbo-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 公用RPC接口依赖 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、消费端调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单服务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DubboReference(version = &quot;$&#123;dubbo.spring.provider.version&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取订单详情接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> orderId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/getOrder&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOrder</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = orderService.getOrder(orderId);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、工程配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">18084</span></span><br><span class="line"><span class="comment">#服务名称</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">dubbo-spring-consumer</span></span><br><span class="line"><span class="comment">#服务版本号</span></span><br><span class="line"><span class="attr">dubbo.spring.provider.version</span> = <span class="string">1.0.0</span></span><br><span class="line"><span class="comment">#消费端注册器配置信息</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="attr">dubbo.registry.file</span> = <span class="string">$&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache</span></span><br></pre></td></tr></table></figure>

<h3 id="Dubbo高阶配置运用"><a href="#Dubbo高阶配置运用" class="headerlink" title="Dubbo高阶配置运用"></a>Dubbo高阶配置运用</h3><h4 id="不同配置覆盖关系"><a href="#不同配置覆盖关系" class="headerlink" title="不同配置覆盖关系"></a>不同配置覆盖关系</h4><p>配置规则：</p>
<p>方法级优先，接口级次之，全局配置再次之。</p>
<p>如果级别一样，则消费方优先，提供方次之。</p>
<h4 id="属性配置优先级"><a href="#属性配置优先级" class="headerlink" title="属性配置优先级"></a><strong>属性配置优先级</strong></h4><p>优先级从高到低：</p>
<ul>
<li>JVM -D 参数；</li>
<li>XML（application.yml&#x2F;application.properties）配置会重写dubbo.properties 中的，一般配置项目特有的</li>
<li>Properties默认配置（dubbo.properties），仅仅作用于以上两者没有配置时，一般配置全局公共配置</li>
</ul>
<h4 id="重试与容错处理机制"><a href="#重试与容错处理机制" class="headerlink" title="重试与容错处理机制"></a><strong>重试与容错处理机制</strong></h4><p>容错机制：</p>
<ul>
<li><p>Failfast Cluster</p>
<p>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p>
</li>
<li><p>Failsafe Cluster</p>
<p>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p>
</li>
<li><p>Failback Cluster</p>
<p>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p>
</li>
<li><p>Forking Cluster</p>
<p>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks&#x3D;”2” 来设置最大并行数。</p>
</li>
<li><p>Broadcast Cluster</p>
<p>广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>
</li>
</ul>
<h4 id="多版本控制"><a href="#多版本控制" class="headerlink" title="多版本控制"></a><strong>多版本控制</strong></h4><p>根据指定的版本，消费端和服务端必须一致，否则无法远程调用</p>
<h4 id="本地存根调用"><a href="#本地存根调用" class="headerlink" title="本地存根调用"></a>本地存根调用</h4><h4 id="负载均衡机制"><a href="#负载均衡机制" class="headerlink" title="负载均衡机制"></a><strong>负载均衡机制</strong></h4><ol>
<li><p>默认负载策略</p>
<p>Dubbo默认采用的是随机负载策略。</p>
<p>开启三个服务节点，通过消费端访问验证： <a href="http://127.0.0.1:18084/order/getOrder?orderId=123">http://127.0.0.1:18084/order/getOrder?orderId=123</a></p>
<p>通过控制后台日志输出， 可以看到每个服务节点呈现不规则的调用。</p>
</li>
<li><p>Dubbo 支持的负载均衡策略，可用参看源码：<code>AbstractLoadBalance</code></p>
<ul>
<li><p>Random LoadBalance：默认</p>
<blockquote>
<p>随机，按权重设置随机概率。 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p>
</blockquote>
</li>
<li><p>RoundRobin LoadBalance</p>
<blockquote>
<p>加权轮询负载均衡，按公约后的权重设置轮询比率。 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p>
</blockquote>
</li>
<li><p>LeastActive LoadBalance</p>
<blockquote>
<p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。 活跃数其实就是在当前这个服务调用者中当前这个时刻 某个invoker（某个服务提供者的某个接口）某个方法的调用并发数，在调用之前+1 调用之后-1的一个计数器，如果出现多个活跃数相等invoker的时候使用随机算法来选取一个</p>
</blockquote>
</li>
<li><p>ConsistentHash LoadBalance</p>
<blockquote>
<p>一致性 Hash，相同参数的请求总是发到同一提供者。 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<blockquote>
<blockquote>
<p>一致性Hash负载均衡涉及到两个主要的配置参数为<strong>hash.arguments</strong> 与<strong>hash.nodes</strong>。</p>
</blockquote>
<blockquote>
<p><strong>hash.arguments</strong> ： 当进行调用时候根据调用方法的哪几个参数生成key，并根据key来通过一致性hash算法来选择调用结点</p>
</blockquote>
<blockquote>
<p><strong>hash.nodes</strong>： 为结点的副本数</p>
</blockquote>
</blockquote>
<ul>
<li><p>ShortestResponseLoadBalance</p>
<blockquote>
<p>2.7.7 +新增</p>
<p>最短响应时间负载均衡</p>
<p>从多个服务提供者中选择出调用成功的且响应时间最短的服务提供者，由于满足这样条件的服务提供者有可能有多个。所以当选择出多个服务提供者后要根据他们的权重做分析，如果权重一样，则随机</p>
</blockquote>
</li>
</ul>
<h4 id="服务降级运用"><a href="#服务降级运用" class="headerlink" title="服务降级运用"></a>服务降级运用</h4><h2 id="Dubbo源码分析"><a href="#Dubbo源码分析" class="headerlink" title="Dubbo源码分析"></a>Dubbo源码分析</h2><p><img src="1322298-20220522215206659-384650563.png" alt="1322298-20220522215206659-384650563"></p>
<h3 id="服务导出"><a href="#服务导出" class="headerlink" title="服务导出"></a>服务导出</h3><p>如图所示，在ServiceConfig执行export方法，根据接口实现代理对象，对方法进行增强，并封装成invoker对象，在拦截增强执行invoke方法内，通过SPI自适应机制生成对应的Expoter对象，一层一层封装handler对象，最终在最底层Server对象中开启netty监听，并在zookeeper中注册资源信息，最终完成服务端的启动</p>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3>]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql日志与备份</title>
    <url>/2023/07/14/Mysql%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Mysql事务</title>
    <url>/2023/07/14/Mysql%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Nacos</title>
    <url>/2023/03/02/Nacos/</url>
    <content><![CDATA[<h2 id="Nacos安装"><a href="#Nacos安装" class="headerlink" title="Nacos安装"></a>Nacos安装</h2><h2 id="Nacos功能应用"><a href="#Nacos功能应用" class="headerlink" title="Nacos功能应用"></a>Nacos功能应用</h2><h3 id="Nacos服务注册与发现"><a href="#Nacos服务注册与发现" class="headerlink" title="Nacos服务注册与发现"></a>Nacos服务注册与发现</h3><p>​	服务发现是微服务架构体系中最关键的组件之一。Nacos Discovery Starter可以帮助您将服务自动注册到Nacos服务端，并且能够动态感知和刷新某个服务实例的服务列表。初次之外，Nacos Discovery Starter也将服务实例自身的一些元数据信息，例如host，port，健康检查URL，主页等注册到Nacos上</p>
]]></content>
      <categories>
        <category>nacos</category>
        <category>spring alibaba</category>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>nacos</tag>
        <tag>注册中心</tag>
        <tag>配置中心</tag>
      </tags>
  </entry>
  <entry>
    <title>SPI机制</title>
    <url>/2023/03/31/SPI%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="SPI的概述"><a href="#SPI的概述" class="headerlink" title="SPI的概述"></a>SPI的概述</h2><p>SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。</p>
<h2 id="java-SPI-机制"><a href="#java-SPI-机制" class="headerlink" title="java SPI 机制"></a>java SPI 机制</h2><p>在面向的对象的设计里，不同模块之间推崇面向接口编程，不建议在模块中对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。SPI使得程序能在ClassPath路径下的META-INF&#x2F;services文件夹查找接口的实现类，自动加载文件里所定义的实现类</p>
<p>Java SPI 实际上是“<strong>基于接口的编程＋策略模式＋配置文件</strong>”组合实现的动态加载机制。</p>
<h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><p>首先，我们定义一个接口，名称为 Robot。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来定义两个实现类，分别为 OptimusPrime 和 Bumblebee。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bumblebee</span> <span class="keyword">implements</span> <span class="title class_">Robot</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Bumblebee.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptimusPrime</span> <span class="keyword">implements</span> <span class="title class_">Robot</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Optimus Prime.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来 META-INF&#x2F;services 文件夹下创建一个文件，名称为 Robot 的全限定名 com.itheima.java.spi.Robot。文件内容为实现类的全限定的类名，如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">com.gxl.spi.Bumblebee</span></span><br><span class="line"><span class="attr">com.gxl.spi.OptimusPrime</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaSPITest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ServiceLoader&lt;Robot&gt; serviceLoader = ServiceLoader.load(Robot.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;JAVA SPI&quot;</span>);</span><br><span class="line">        serviceLoader.forEach(Robot::sayHello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a><strong>实现原理：</strong></h3><ol>
<li>应用程序调用ServiceLoader.load方法，创建一个新的ServiceLoader，并实例化该类中的成员变量</li>
<li>获取到serviceLoader对象，实现了iterator接口，并实现了hasNext方法，ServiceLoader先判断成员变量providers对象中(LinkedHashMap&lt;String,S&gt;类型)是否有缓存实例对象，如果有缓存，直接返回。 如果没有缓存，执行类的装载 ，在方法内部，去读取META-INF&#x2F;services +className文件的内容，</li>
</ol>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><p>使用 Java SPI 机制的优势是实现解耦，使得接口的定义与具体业务实现分离，而不是耦合在一起。应用进程可以根据实际业务情况启用或替换具体组件。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><ul>
<li>不能按需加载。虽然 ServiceLoader 做了延迟载入，但是基本只能通过遍历全部获取，也就是接口的实现类得全部载入并实例化一遍。如果你并不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。</li>
<li>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。</li>
<li>多个并发多线程使用 ServiceLoader 类的实例是不安全的。</li>
<li>加载不到实现类时抛出并不是真正原因的异常，错误很难定位。</li>
</ul>
<h2 id="Spring-SPI"><a href="#Spring-SPI" class="headerlink" title="Spring SPI"></a>Spring SPI</h2><p>Spring SPI沿用了Java SPI的设计思想，Spring采用的是spring.factories方式实现SPI机制，可以在不修改Spring源码的前提下，提供Spring框架的扩展性。</p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>1、定义一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataBaseService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getConnection</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、定义两个类，并实现接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysqlDataBase</span> <span class="keyword">implements</span> <span class="title class_">DataBaseService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mysql DB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OracleDataBase</span> <span class="keyword">implements</span> <span class="title class_">DataBaseService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Oracle DB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、在项目的META-INF目录下，新增spring.factories文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">com.gxl.spi.spring.DataBaseService</span>=<span class="string">com.gxl.spi.spring.MysqlDataBase,com.gxl.spi.spring.OracleDataBase</span></span><br></pre></td></tr></table></figure>

<p>4、测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringSpiTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;DataBaseService&gt; dataBaseServices = SpringFactoriesLoader.loadFactories(DataBaseService.class, Thread.currentThread().getContextClassLoader());</span><br><span class="line">        <span class="keyword">for</span> (DataBaseService dataBaseService : dataBaseServices) &#123;</span><br><span class="line">            dataBaseService.getConnection();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>loadFactoryNames解析spring.factories文件中指定接口的实现类的全限定名</p>
<p>获取所有jar包中META-INF&#x2F;spring.factories文件路径，以枚举值返回。 遍历spring.factories文件路径，逐个加载解析，整合factoryClass类型的实现类名称，获取到实现类的全类名称添加到Map集合中</p>
<p>通过类的权限定名，获取指定接口的实现类List集合，遍历通过反射实例化所有的实现类</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>Spring factories SPI是一个spring.factories配置文件存放多个接口及对应的实现类，以接口全限定名作为key，实现类作为value来配置，多个实现类用逗号隔开，仅spring.factories一个配置文件。</p>
<h2 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Dubbo 并未使用 Java SPI，而是重新实现了一套功能更强的 SPI 机制。Dubbo SPI 的相关逻辑被封装在了 ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。</p>
<h3 id="入门案例-1"><a href="#入门案例-1" class="headerlink" title="入门案例"></a>入门案例</h3><p>与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。下面来演示 Dubbo SPI 的用法：</p>
<p>1、在使用Dubbo SPI 时，需要在接口上标注 @SPI 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、Dubbo SPI 所需的配置文件需放置在 META-INF&#x2F;dubbo 路径下，与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置（key自己指定，value为实现类的全路径），配置内容如下。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">bumblebee</span>=<span class="string">com.gxl.spi.dubbo.Bumblebee</span></span><br><span class="line"><span class="attr">optimusPrime</span>=<span class="string">com.gxl.spi.dubbo.OptimusPrime</span></span><br></pre></td></tr></table></figure>

<p>3、通过 ExtensionLoader，我们可以加载指定的实现类，下面来演示 Dubbo SPI ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboSPITest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ExtensionLoader&lt;Robot&gt; extensionLoader =</span><br><span class="line">                ExtensionLoader.getExtensionLoader(Robot.class);</span><br><span class="line">        <span class="type">Robot</span> <span class="variable">optimusPrime</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;optimusPrime&quot;</span>);</span><br><span class="line">        optimusPrime.sayHello();</span><br><span class="line">        <span class="type">Robot</span> <span class="variable">bumblebee</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;bumblebee&quot;</span>);</span><br><span class="line">        bumblebee.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">getExtension(String name)  #根据key获取拓展对象</span><br><span class="line"><span class="code">    --&gt;createExtension(String name) #创建拓展实例</span></span><br><span class="line"><span class="code">        --&gt;getExtensionClasses #根据路径获取所有的拓展类</span></span><br><span class="line"><span class="code">            --&gt;loadExtensionClasses #加载拓展类</span></span><br><span class="line"><span class="code">                --&gt;cacheDefaultExtensionName #解析@SPI注解</span></span><br><span class="line"><span class="code">            --&gt;loadDirectory #方法加载指定文件夹配置文件</span></span><br><span class="line"><span class="code">                --&gt;loadResource #加载资源</span></span><br><span class="line"><span class="code">                    --&gt;loadClass #加载类，并通过 loadClass 方法对类进行缓存</span></span><br></pre></td></tr></table></figure>

<p>createExtension 方法的逻辑稍复杂一下，包含了如下的步骤：</p>
<ol>
<li>通过 getExtensionClasses 获取所有的拓展类</li>
<li>通过反射创建拓展对象</li>
<li>向拓展对象中注入依赖</li>
<li>将拓展对象包裹在相应的 Wrapper 对象中</li>
</ol>
<p>以上步骤中，第一个步骤是加载拓展类的关键，第三和第四个步骤是 Dubbo IOC 与 AOP 的具体实现。</p>
<h3 id="SPI中的IOC和AOP"><a href="#SPI中的IOC和AOP" class="headerlink" title="SPI中的IOC和AOP"></a>SPI中的IOC和AOP</h3><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>Dubbo IOC 是通过 setter 方法注入依赖。Dubbo 首先会通过反射获取到实例的所有方法，然后再遍历方法列表，检测方法名是否具有 setter 方法特征。若有，则通过 ObjectFactory 获取依赖对象，最后通过反射调用 setter 方法将依赖设置到目标对象中。整个过程对应的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">injectExtension</span><span class="params">(T instance)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (objectFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历目标类的所有方法</span></span><br><span class="line">            <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">                <span class="comment">// 检测方法是否以 set 开头，且方法仅有一个参数，且方法访问级别为 public</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().startsWith(<span class="string">&quot;set&quot;</span>)</span><br><span class="line">                    &amp;&amp; method.getParameterTypes().length == <span class="number">1</span></span><br><span class="line">                    &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                    <span class="comment">// 获取 setter 方法参数类型</span></span><br><span class="line">                    Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取属性名，比如 setName 方法对应属性名 name</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> getSetterProperty(method);</span><br><span class="line">                        <span class="comment">/* getSetterProperty :</span></span><br><span class="line"><span class="comment">                        method.getName().length() &gt; 3 ? </span></span><br><span class="line"><span class="comment">                            method.getName().substring(3, 4).toLowerCase() + </span></span><br><span class="line"><span class="comment">                                method.getName().substring(4) : &quot;&quot;;</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="comment">// 从 ObjectFactory 中获取依赖对象</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> objectFactory.getExtension(pt, property);</span><br><span class="line">                        <span class="keyword">if</span> (object != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 通过反射调用 setter 方法设置依赖</span></span><br><span class="line">                            method.invoke(instance, object);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(<span class="string">&quot;fail to inject via method...&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		在上面代码中，objectFactory 变量的类型为 AdaptiveExtensionFactory，AdaptiveExtensionFactory 内部维护了一个 ExtensionFactory 列表，用于存储其他类型的 ExtensionFactory。Dubbo 目前提供了两种 ExtensionFactory，分别是 SpiExtensionFactory 和 SpringExtensionFactory。前者用于创建自适应的拓展，后者是用于从 Spring 的 IOC 容器中获取所需的拓展。这两个类的类的代码不是很复杂，这里就不一一分析了。</p>
<p>​	Dubbo IOC 目前仅支持 setter 方式注入，总的来说，逻辑比较简单易懂。</p>
<h4 id="动态增强"><a href="#动态增强" class="headerlink" title="动态增强"></a>动态增强</h4><p>在Dubbo中，有一种特殊的类，被称为Wrapper类。通过<strong>装饰者模式</strong>，使用包装类包装原始的扩展点实例。在原始扩展点实现前后插入其他逻辑，实现AOP功能。</p>
<p><strong>装饰者模式</strong></p>
<p>装饰者模式：在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p>
<p>一般来说装饰者模式有下面几个参与者：</p>
<ul>
<li>Component：装饰者和被装饰者共同的父类，是一个接口或者抽象类，用来定义基本行为</li>
<li>ConcreteComponent：定义具体对象，即被装饰者</li>
<li>Decorator：抽象装饰者，继承自Component，从外类来扩展ConcreteComponent。对于ConcreteComponent来说，不需要知道Decorator的存在，Decorator是一个接口或抽象类</li>
<li>ConcreteDecorator：具体装饰者，用于扩展ConcreteComponent</li>
</ul>
<p>注：装饰者和被装饰者对象有相同的超类型，因为装饰者和被装饰者必须是一样的类型，<strong>这里利用继承是为了达到类型匹配，而不是利用继承获得行为。</strong></p>
<p><strong>dubbo中的AOP</strong></p>
<p>1、定义接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、定义被装饰者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptimusPrime</span> <span class="keyword">implements</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Optimus Prime.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、定义装饰者，为了简单没有定义装饰者接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bumblebee</span> <span class="keyword">implements</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Robot robot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bumblebee</span><span class="params">(Robot robot)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.robot = robot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Bumblebee.&quot;</span>);</span><br><span class="line">        robot.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、添加拓展点配置文件META-INF&#x2F;dubbo&#x2F;com.gxl.spi.dubbo.Robot,内容如下</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">optimusPrime</span>=<span class="string">com.gxl.spi.dubbo.OptimusPrime</span></span><br><span class="line"><span class="attr">wrapper</span>=<span class="string">com.gxl.spi.dubbo.Bumblebee</span></span><br></pre></td></tr></table></figure>

<p>5、测试，方法被增强</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboSPITest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ExtensionLoader&lt;Robot&gt; extensionLoader =</span><br><span class="line">                ExtensionLoader.getExtensionLoader(Robot.class);</span><br><span class="line">        <span class="type">Robot</span> <span class="variable">bumblebee</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;optimusPrime&quot;</span>);</span><br><span class="line">        bumblebee.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h4><h5 id="SPI中的自适应"><a href="#SPI中的自适应" class="headerlink" title="SPI中的自适应"></a>SPI中的自适应</h5><p>我们知道在 Dubbo 中，很多拓展都是通过 SPI 机制 进行加载的，比如 Protocol、Cluster、LoadBalance、ProxyFactory 等。有时，有些拓展并不想在框架启动阶段被加载，而是希望在拓展方法被调用时，根据运行时参数进行加载，即根据参数动态加载实现类。如下所示：</p>
<blockquote>
<p>根据参数动态选择的意思是：</p>
<p>通过ExtensionLoader.getExtensionLoader(XXXClass).getExtension(key)的形式来获取接口的某个实现类。</p>
<p>但这种形式本质上还是通过硬编码的形式在代码中固定的获取了接口的一个实现，诸如Protocol(实现有Dubbo、Redis、Thrift等)，或者Transporter(实现有Netty、Mina等)这些接口，我们是可以在Dubbo服务声明时指定具体实现的</p>
</blockquote>
<p>这种在运行时，根据方法参数才动态决定使用具体的拓展，在dubbo中就叫做扩展点自适应实例。其实是一个扩展点的代理，将扩展的选择从Dubbo启动时，延迟到RPC调用时。Dubbo中每一个扩展点都有一个自适应类，如果没有显式提供，Dubbo会自动为我们创建一个，默认使用Javaassist。</p>
<p><strong>自适应拓展机制的实现逻辑是这样的</strong></p>
<ol>
<li>首先 Dubbo 会为拓展接口生成具有代理功能的代码；</li>
<li>通过 javassist 或 jdk 编译这段代码，得到 Class 类；</li>
<li>通过反射创建代理类；</li>
<li>在代理类中，通过URL对象的参数来确定到底调用哪个实现类；</li>
</ol>
<h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><p><strong>Adaptive注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Adaptive &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可知，Adaptive 可注解在类或方法上。</p>
<ul>
<li>标注在类上：Dubbo 不会为该类生成代理类。Adaptive 注解在类上的情况很少，在 Dubbo 中，仅有两个类被 Adaptive 注解了，分别是 AdaptiveCompiler 和 AdaptiveExtensionFactory。此种情况，表示拓展的加载逻辑由人工编码完成。更多时候，Adaptive 是注解在接口方法上的，表示拓展的加载逻辑需由框架自动生成</li>
<li>标注在方法上：Dubbo 则会为该方法生成代理逻辑，表示当前方法需要根据 参数URL 调用对应的扩展点实现。例如 Protocol的SPI类有 injvm dubbo registry filter listener等等 很多扩展未知类， 它设计了Protocol$Adaptive的类，通过ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(spi类);来提取对象</li>
</ul>
<p><strong>获取自适应拓展类</strong></p>
<p>dubbo中每一个扩展点都有一个自适应类，如果没有显式提供，Dubbo会自动为我们创建一个，默认使用Javaassist。 先来看下创建自适应扩展类的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 精简代码如下</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getAdaptiveExtension</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> cachedAdaptiveInstance.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">                instance = cachedAdaptiveInstance.get();</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                      instance = createAdaptiveExtension();</span><br><span class="line">                      cachedAdaptiveInstance.set(instance); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看createAdaptiveExtension方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">        getExtensionClasses();</span><br><span class="line">        <span class="keyword">if</span> (cachedAdaptiveClass != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">cachedAdaptiveClass</span> <span class="operator">=</span> createAdaptiveExtensionClass();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>续看createAdaptiveExtensionClass方法，绕了一大圈，终于来到了具体的实现了。看这个createAdaptiveExtensionClass方法，它首先会生成自适应类的Java源码，然后再将源码编译成Java的字节码，加载到JVM中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> createAdaptiveExtensionClassCode();</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> findClassLoader();</span><br><span class="line">        org.apache.dubbo.common.compiler.<span class="type">Compiler</span> <span class="variable">compiler</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">        <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Compiler的代码，默认实现是javassist。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;javassist&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Compiler</span> &#123;</span><br><span class="line">    Class&lt;?&gt; compile(String code, ClassLoader classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createAdaptiveExtensionClassCode()方法中使用一个StringBuilder来构建自适应类的Java源码。方法实现比较长，这里就不贴代码了。这种生成字节码的方式也挺有意思的，先生成Java源代码，然后编译，加载到jvm中。通过这种方式，可以更好的控制生成的Java类。而且这样也不用care各个字节码生成框架的api等。因为xxx.java文件是Java通用的，也是我们最熟悉的。只是代码的可读性不强，需要一点一点构建xx.java的内容。</p>
<p>示例：以 Protocol 接口为例，Protocol接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;dubbo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Protocol</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getDefaultPort</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; Exporter&lt;T&gt; <span class="title function_">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> List&lt;ProtocolServer&gt; <span class="title function_">getServers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面给大家展示一下生成的 Protocol$Adaptive 的源码，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.rpc;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Protocol$Adaptive</span> <span class="keyword">implements</span> <span class="title class_">org</span>.apache.dubbo.rpc.Protocol &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.Invoker <span class="title function_">refer</span><span class="params">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg1 == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        org.apache.dubbo.common.<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> arg1;</span><br><span class="line">        <span class="type">String</span> <span class="variable">extName</span> <span class="operator">=</span> ( url.getProtocol() == <span class="literal">null</span> ? <span class="string">&quot;dubbo&quot;</span> : url.getProtocol() );</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url (&quot;</span> + url.toString() + <span class="string">&quot;) use keys([protocol])&quot;</span>);</span><br><span class="line">        org.apache.dubbo.rpc.<span class="type">Protocol</span> <span class="variable">extension</span> <span class="operator">=</span> (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> java.util.List <span class="title function_">getServers</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;The method public default java.util.List org.apache.dubbo.rpc.Protocol.getServers() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.Exporter <span class="title function_">export</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;</span>);</span><br><span class="line">        org.apache.dubbo.common.<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> arg0.getUrl();</span><br><span class="line">        <span class="type">String</span> <span class="variable">extName</span> <span class="operator">=</span> ( url.getProtocol() == <span class="literal">null</span> ? <span class="string">&quot;dubbo&quot;</span> : url.getProtocol() );</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url (&quot;</span> + url.toString() + <span class="string">&quot;) use keys([protocol])&quot;</span>);</span><br><span class="line">        org.apache.dubbo.rpc.<span class="type">Protocol</span> <span class="variable">extension</span> <span class="operator">=</span> (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.export(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;The method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDefaultPort</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;The method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以调用 Protocol 的接口的 refer方法为例，下面给大家看一下自适应拓展的整个过程：</p>
<p>1）、先通过 Protocol REF_PROTOCOL &#x3D; ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension(); 生成了 Protocol$Adaptive 代理类</p>
<p>2）、传参 Url 为：dubbo:&#x2F;&#x2F;192.168.1.247:20887&#x2F;org.apache.dubbo.config.spring.api.DemoService，调用 Protocol 的 refer 方法，此时直接调用是 Protocol$Adaptive 代理类的 refer 方法</p>
<p>3）、在 Protocol$Adaptive 的 refer 方法中先调用 url 中的 getProtocol() 方法获取拓展类名称，赋值给 extName 变量</p>
<p>4）、然后调用 org.apache.dubbo.rpc.Protocol extension &#x3D; (org.apache.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName); 语句获取到具体的实现类的实例</p>
<p>5）、最后执行 extension.refer(arg0, arg1) 语句，调用 4 中获取到的具体实现类的 refer 方法，最终返回结果</p>
]]></content>
      <categories>
        <category>SPI</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql</title>
    <url>/2023/06/16/Mysql%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="MySQL基本原理"><a href="#MySQL基本原理" class="headerlink" title="MySQL基本原理"></a>MySQL基本原理</h2><h3 id="Mysql表类型（存储引擎）的选择"><a href="#Mysql表类型（存储引擎）的选择" class="headerlink" title="Mysql表类型（存储引擎）的选择"></a>Mysql表类型（存储引擎）的选择</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>插件式存储引擎是MySQL数据库最重要的特性之一，用户可以根据应用的需要选择如何存储和索引数据、是否使用事务等。MySQL默认支持多种存储引擎，以适用于不同领域的数据库应用需要，用户可以通过选择使用不同的存储引擎提高应用的效率，提供灵活的存储，用户甚至可以按照自己的定制和使用自己的存储引擎，以实现最大程度的可定制性。</p>
<p>MySQL5.0支持的存储引擎包括MyLSAM、InnoDB、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB和DBD提供了事务安全表，其他引擎都是非事务安全表。</p>
<p>创建表时如果不指定存储引擎，那么系统就会使用默认存储引擎，MySQL5.5之前的默认存储引擎是MyLSAM，5.5之后改为InnoDB。如果要修改默认的存储引擎，可以在参数中设置default-table-type</p>
<h4 id="各个存储引擎的特点"><a href="#各个存储引擎的特点" class="headerlink" title="各个存储引擎的特点"></a>各个存储引擎的特点</h4><p><strong>MyISAM</strong></p>
<p>不支持事务，不支持外键，其优势就是访问速度快，对事务完整性没有要求或者以select、insert为主的应用基本上都可以使用这个引擎来创建表</p>
<p>每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但扩展名分别是：</p>
<ul>
<li>.frm（存储表定义）</li>
<li>.MYD（MYData，存储数据）</li>
<li>.MYI（MYIndex，存储索引）</li>
</ul>
<p>数据文件和索引文件可以放置在不同目录，平均分布IO，获得更快的速度</p>
<p>要指定索引文件和数据文件的路径，需要在创建表的时候通过DATA DIRECTORY和INDEX DIRECTORY语句指定，也就是说不同的MyISAM表的索引文件和数据文件可以放置到不同路径下。文件路径需要是绝对路径，并且具有访问权限。</p>
<p>MyISAM类型的表可能是会损坏，原因可能是多种多样的，损坏后的表可能不能被访问，会提示需要修复或者访问返回错误的结果。MyISAM类型的表提供修复工具，可以用CHECK TABLE语句来检查MyISAM表的健康，并用REPAIR TABLE 语句修复一个损坏的MyISAM表，表损坏可能导致数据库异常重新启动，需要尽快修复并尽可能的确认损坏原因，需要尽快修复并确认损坏的原因。</p>
<p>MyISAM的表还支持3中不同的存储格式，分别是：</p>
<ul>
<li>静态（固定长度）表</li>
<li>动态表</li>
<li>压缩表</li>
</ul>
<p>其中静态表是默认的存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定的长度的，这种存储方式的优点是存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多。静态表在存储数据时会按照列的宽度定义补足空格，但是在应用访问的时候并不会得到这些空格，这些空格在返回给应用之前已经去掉。</p>
<p>但是有些要注意的的问题，如果需要保存的内容后面本来有空格，那么返回结果的时候会别去掉。</p>
<p>动态表包含变长字段，记录不是固定的长度，这样存储的有点是占用的空间相对较少，但是频繁的更新和删除记录会产生碎片，需要定期执行OPTIMIZE TABLE语句或者myisamchk-r命令来改善性能，并且在出现故障时恢复相对比较困难</p>
<p>压缩表有由myisampack工具创建，占据非常小的磁盘空间。因为每个记录是被单独压缩的，所有只有非常小的访问开支</p>
<p><strong>InnoDB</strong></p>
<p>InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。</p>
<p><strong>1、自动增长列</strong></p>
<p>InnoDB，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列。但是MyISAM表，自动增长列可以是组合索引的其他列，这样插入记录后，自动增长列是按照组合索引的前面几列进行排序后递增的。</p>
<p><strong>2、外键约束</strong></p>
<p>当某个表的创建了外键参照，那么该表的对应索引或者主键禁止被删除</p>
<p><strong>3、存储方式</strong></p>
<p>InnoDB存储表和索引有两种方式：</p>
<ul>
<li>使用共享表空间存储，这种方式创建的表的表结构保存在.frm文件中，数据和索引保存在innodb_data_home_dir和innodb_data_file_path定义的表空间中，可以是多个文件。</li>
<li>使用多表空间存储，这种方式创建的表的结构仍然保存在.frm文件中，但是每个表的数据和索引单独保存在.ibd中，如果是多个分区表，则每个分区对应单独的.ibd文件，文件名是表名+分区名，可以创建分区的时候指定每个分区的数据文件的位置，以此来将表的IO均匀分布在磁盘上。</li>
</ul>
<p>要使用多表空间的存储方式，需要设置参数innodb_file_pre_table，并且重新启动服务后才可以生效，对于新建的表按照多表空间的方式创建，已有的表仍然使用共享表空间存储。如果将已有的多表空间方式修改回共享表空间方式，则新建表会在共享表空间中创建，但已有的多表空间的表仍然保存原来的访问方式。所以多表空间的参数生效后，只对新建的表生效。</p>
<p>多表空间文件没有大小限制，不需要设置初始大小，也不需要设置文件的最大限制、扩展大小等参数</p>
<p>对于使用多表空间特性的表，可以比较方便地进行单表备份和恢复操作，但是直接复制.ibd文件是不行的，因为没有共享表空间的数据字典信息，直接复制.ibd文件和.frm文件恢复时是不能被正确识别的，但是可以通过以下命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name discard tablespace</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name import tablespace</span><br></pre></td></tr></table></figure>

<p>将备份恢复到数据库中，但是这样的单表备份，只能恢复表原来所在的数据库中，而不能恢复到其他数据库中。如果要将单表恢复到目标数据库中，则需要通过mysqldump和mysqlimport来实现</p>
<h4 id="如何选择合适的存储引擎"><a href="#如何选择合适的存储引擎" class="headerlink" title="如何选择合适的存储引擎"></a>如何选择合适的存储引擎</h4><p>在选择存储引擎时，应根据应用特点，选择合适的存储引擎，对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合</p>
<p>MyISAM：默认的MySQL插件式存储引擎。如果应用是以读操作或是查操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求 不是很高，那么选择这个存储引擎是合适的。MyISAM是在web、数据仓储和其他仓储和其他应用环境下最常使用的存储引擎之一。</p>
<p>InnoDB：用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包括很多的更新、删除操作，那么InnoDB存储引擎应该是比较合适的选择。InnoDB存储引擎除了有效降低由于删除和更新导致的锁定，还可以确保事务的完整提交和回滚，对于类似计费系统或者财务系统对数据准确性要求比较高的系统，InnoDB是合适的选择。</p>
<h3 id="选择合适的数据类型"><a href="#选择合适的数据类型" class="headerlink" title="选择合适的数据类型"></a>选择合适的数据类型</h3><h4 id="CHAR和VARCHAR"><a href="#CHAR和VARCHAR" class="headerlink" title="CHAR和VARCHAR"></a>CHAR和VARCHAR</h4><p>CHAR和VARCHAR类型类似，都是用来存储字符串的，但他们保存和检索方式不同。CHAR属于固定长度的字符类型，而VARCHAR属于可变长度的字符类型。</p>
<p>由于CHAR是固定长度的，所以他的处理速度比VARCHAR快得多，但是其缺点是浪费存储空间，程序需要对行尾空格进行处理，所以对于那些长度变化不大并且对查询速度有较高要求的数据可以考虑使用CHAR类型来存储。</p>
<p>随着MySQL版本的不断升级，VARCHAR数据类型的性能也在不断改进并提高，所以在许多的应用中，VARCHAR类型被更多地使用</p>
<p>不同存储引擎使用原则：</p>
<p>MyISAM：建议使用固定长度的数据列代替可变长度的数据列</p>
<p>InnoDB：建议使用VARCHAR类型。对于InnoDB数据表，内部的行存储格式没有区分固定长度和可变长度列（所有数据行都使用指向数据列值得头指针），因此在本质上，使用固定长度的CHAR列不一定比使用可变长度VARCHAR列性能要好。因而，主要的性能因素是数据行使用的存储总量。由于CHAR平均占用的空间多于VARCHAR，因此使用VARCHAR来最小化需要处理数据行的存储总量和磁盘I&#x2F;O是比较好。</p>
<h4 id="TEXT与BLOB"><a href="#TEXT与BLOB" class="headerlink" title="TEXT与BLOB"></a>TEXT与BLOB</h4><p>一般保存少量的字符串的时候，我们会选择CHAR或者VARCHAR；而在保存较大文本时，通常会选择使用TEXT和BLOB；两者区别，BLOB存储二进制数据，TEXT只保存字符数据。</p>
<p>（1）BLOB和TEXT值会引起一些性能问题，特别是在执行了大量的删除操作时</p>
<p>删除操作会在数据表中留下很大的“空洞”，以后填入这些“空洞”的记录在插入的性能上会有影响。为了提高性能，建议定期使用OPTIMIZE TABLE 功能对这类表进行碎片整理，避免因为“空洞”导致性能问题。</p>
<p>（2）使用合成的索引来提高大文本字段的查询性能</p>
<p>合成索引就是根据大文本字段的内容建立一个散列值，并把这个值存储在单独的数据列中，接下来就可以通过检索散列值找到数据行了。但只适用于精准查询。可以使用MD5生成散列值。</p>
<p>（3）在不必要的时候避免检索大型的BLOB或TEXT值</p>
<p>（4）把BLOB或TEXT分离到单独的表中</p>
<h4 id="浮点数和定点数"><a href="#浮点数和定点数" class="headerlink" title="浮点数和定点数"></a>浮点数和定点数</h4><p>浮点数一般用于表示含有小数部分的数值。当一个字段被定义为浮点类型后，如果插入数据的精度超过改了定义的实际精度，则插入值会被四舍五入到实际定义的精度值，然后插入，四舍五入过程不会报错。在MySQL中float、double用来表示浮点数。</p>
<p>定点数不同于浮点数，定点数实际上是以字符串形式存放的，所以定点数可以更精确地保存数据。如果实际插入的数值精度大于实际定义的精度，则MySQL会警告（默认的SQLModel下），但是数据按照实际精度四舍五入后插入；如果SQLModel是在TRADITIONAL（传统模式）下，则系统会直接报错，导致数据无法插入。decimal表示定点数。</p>
<p>使用原则：</p>
<ul>
<li>浮点数存在误差</li>
<li>对货币等对精度敏感的数据，应该用定点数表示或存储</li>
<li>在编程中，如果用到浮点数，要特别注意误差问题，并尽量避免使用浮点数比较</li>
<li>要注意浮点数中一些特殊值的处理</li>
</ul>
<h4 id="日期类型选择"><a href="#日期类型选择" class="headerlink" title="日期类型选择"></a>日期类型选择</h4><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><table>
<thead>
<tr>
<th>字符集</th>
<th>是否定长</th>
<th>编码方式</th>
<th>其他说明</th>
</tr>
</thead>
<tbody><tr>
<td>ACSII</td>
<td>是</td>
<td>单字节7位编码</td>
<td>最早的奠基性字符集</td>
</tr>
<tr>
<td>ISO-8859-1&#x2F;latin1</td>
<td>是</td>
<td>单字节8位编码</td>
<td>西欧字符集，经常被一些程序员用来转码</td>
</tr>
<tr>
<td>GB2312-80</td>
<td>是</td>
<td>双字节编码</td>
<td>早起标准，不推荐再使用</td>
</tr>
<tr>
<td>GBK</td>
<td>是</td>
<td>双字节编码</td>
<td>虽然不是国际，但是支持的系统不少</td>
</tr>
<tr>
<td>GB18030</td>
<td>否</td>
<td>2字节或4字节编码</td>
<td>开始有一些支持，但数据库支持的很少见</td>
</tr>
<tr>
<td>UTF-32</td>
<td>是</td>
<td>4字节编码</td>
<td>UCS-4原始编码，现在很少使用</td>
</tr>
<tr>
<td>UCS-2</td>
<td>是</td>
<td>2字节编码</td>
<td>Windows2000内部用UCS-2</td>
</tr>
<tr>
<td>UTF-16</td>
<td>否</td>
<td>2字节或4字节编码</td>
<td>Java和WindowsXP&#x2F;NT等内部使用UTF-16</td>
</tr>
<tr>
<td>UTF-8</td>
<td>否</td>
<td>1~4字节编码</td>
<td>互联网和UNIX&#x2F;Linux广泛支持的Unicode字符集；<br>MySQLServer也使用</td>
</tr>
</tbody></table>
<h4 id="怎样选择合适的字符集"><a href="#怎样选择合适的字符集" class="headerlink" title="怎样选择合适的字符集"></a>怎样选择合适的字符集</h4><ol>
<li>满足应用支持语言需求，如果应用要处理各种各样的文字，或者将发布到使用不同语言的国家或者地区，就应该选择Unicode字符集。对MySQL来说，目前就是UTF-8。</li>
<li>如果应用中涉及已有数据的导入，就要充分考虑数据库字符集对已有数据的兼容性。</li>
<li>如果数据库只需要支持一般中文，数据量很大，性能要求也很高，那应该选择双字节定长编码的中文字符集，比如GBK。因为，相对于UTF-8而言，GBK比较小，每个汉字只占2个字节，而UTF-8汉字编码需要3个字节，这样可以减少磁盘I&#x2F;O、数据库Cache以及网络传输的时间，从而提高性能。相反，如果应用主要处理英文字符，仅有少量汉字数据，那么选择UTF-8更好，因为GBK、UCS-2、UTF-16的西文字符编码都是2字节，会造成很多不必要的开销</li>
<li>如果数据库需要做大量字符运算，如比较、排序等，那么选择定长字符集可能更好，因为定长字符集的处理速度要比变长字符集的处理速度快</li>
<li>如果所有客户端程序都支持相同的字符集，则应该优先选择该字符集作为数据库的字符集。这样可以避免因字符集转换带来的性能开销和数据损失。</li>
</ol>
<h4 id="MySQL支持的字符集简介"><a href="#MySQL支持的字符集简介" class="headerlink" title="MySQL支持的字符集简介"></a>MySQL支持的字符集简介</h4><p>MySQL服务器可以支持多种字符集，在同一台服务器、同一个数据库甚至同一表的不同字段都可以指定不同的字符集，相比Oracle等其他数据库管理系统，在同一个数据库只能使用相同的字符集，MySQL明显存在更大的灵活性。</p>
<h4 id="MySQL字符集的设置"><a href="#MySQL字符集的设置" class="headerlink" title="MySQL字符集的设置"></a>MySQL字符集的设置</h4><p>MySQL的字符集和校对规则有四个级别的默认设置：服务器级、数据库级、表级和字段级。他们分别在不同的地方设置，作用也不相同。</p>
<p>MySQL的字符集包括字符集和校对规则两个概念。其中字符集用来定义MySQL存储字符串的方式，校对规则用来定义比较字符串的方式。字符集和校对规则是一对多关系。</p>
<p>校对规则命名约定：他们以相关的字符集名开始，通常包括一个语言名，并且以 ci（大小写不敏感）、cs（大小写敏感）或bin（二元，即比较是基于字符编码的值而与language无关）结束。</p>
<p><strong>服务器字符集和校对规则</strong></p>
<p>服务器字符集和校对规则，可以再MySQL服务启动的时候确定。</p>
<p><strong>数据库字符集和校对规则</strong></p>
<p>数据库字符集和校对规则在创建数据库的时候指定。如果数据库里已经存在数据，因为修改字符集并不能将已有的数据按照新的字符集进行存放，所以不能通过修改数据库的字符集直接修改数据库的内容。</p>
<p><strong>表字符集和校对规则</strong></p>
<p><strong>连接字符集和校对规则</strong></p>
<p>对于客户端和服务器的交互操作，MySQL提供了3个不同的参数：character_set_client、character_set_connection和character_set_result，分别代表客户端、连接和返回结果的字符集。通常情况下，这3个字符集应该相同的，才可以确保用户写入的数据可以正确的读出。</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>视图是虚拟存在的表，对于使用视图的用户来说基本上是透明的。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p>
<p>视图的优势：</p>
<ul>
<li>简单：使用视图的用户完全不需要关心后面对应的表结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集</li>
<li>安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是可以通过视图就可以简单实现</li>
<li>数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响</li>
</ul>
<h3 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>存储过程和函数是事先经过编译并存储在数据库的一段SQL语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p>
<p>存储过程和函数的区别在于函数必须由返回值，而存储过程没有，存储过程的参数可以使用IN、OUT、INOU类型，而函数的参数只能是IN类型的。如果有函数从其他类型的数据库迁移到MySQL，那么就可能因此需要将函数改造成存储过程。</p>
<h2 id="MySQL高级原理"><a href="#MySQL高级原理" class="headerlink" title="MySQL高级原理"></a>MySQL高级原理</h2><h3 id="Linux下MySQL的安装与使用"><a href="#Linux下MySQL的安装与使用" class="headerlink" title="Linux下MySQL的安装与使用"></a>Linux下MySQL的安装与使用</h3><h3 id="MySQL的数据目录"><a href="#MySQL的数据目录" class="headerlink" title="MySQL的数据目录"></a>MySQL的数据目录</h3><h3 id="用户与权限管理"><a href="#用户与权限管理" class="headerlink" title="用户与权限管理"></a>用户与权限管理</h3><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a><strong>用户管理</strong></h4><p><strong>登录MySQL服务器</strong></p>
<p>启动MySQL服务后，可以通过mysql命令来登录MySQL服务器，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql –h hostname|hostIP –P port –u username –p DatabaseName –e &quot;SQL语句&quot;</span><br></pre></td></tr></table></figure>

<p>下面详细介绍命令中的参数：</p>
<ul>
<li>-h参数 后面接主机名或者主机IP，hostname为主机，hostIP为主机IP。</li>
<li>-P参数 后面接MySQL服务的端口，通过该参数连接到指定的端口。MySQL服务的默认端口是3306，不使用该参数时自动连接到3306端口，port为连接的端口号。</li>
<li>-u参数 后面接用户名，username为用户名。</li>
<li>-p参数 会提示输入密码。</li>
<li>DatabaseName参数 指明登录到哪一个数据库中。如果没有该参数，就会直接登录到MySQL数据库中，然后可以使用USE命令来选择数据库。</li>
<li>-e参数 后面可以直接加SQL语句。登录MySQL服务器以后即可执行这个SQL语句，然后退出MySQL服务器。</li>
</ul>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p -hlocalhost -P3306 mysql -e &quot;select host,user from user&quot;</span><br></pre></td></tr></table></figure>

<p><strong>创建用户</strong></p>
<p>CREATE USER语句的基本语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER 用户名 [IDENTIFIED BY &#x27;密码&#x27;][,用户名 [IDENTIFIED BY &#x27;密码&#x27;]];</span><br></pre></td></tr></table></figure>

<ul>
<li>用户名参数表示新建用户的账户，由 用户（User） 和 主机名（Host） 构成；</li>
<li>“[ ]”表示可选，也就是说，可以指定用户登录时需要密码验证，也可以不指定密码验证，这样用户可以直接登录。不过，不指定密码的方式不安全，不推荐使用。如果指定密码值，这里需要使用IDENTIFIED BY指定明文密码值。</li>
<li>CREATE USER语句可以同时创建多个用户。</li>
</ul>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> zhang3 IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123123&#x27;</span>; # 默认host是 <span class="operator">%</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;li4&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>修改用户</strong></p>
<p>修改用户名：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> mysql.user <span class="keyword">SET</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;li4&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;wang5&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p><strong>删除用户</strong></p>
<p><strong>方式1：使用DROP方式删除（推荐）</strong></p>
<p>使用DROP USER语句来删除用户时，必须用于DROP USER权限。DROP USER语句的基本语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="keyword">user</span>[,<span class="keyword">user</span>]…;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> li4 ; # 默认删除host为<span class="operator">%</span>的用户</span><br></pre></td></tr></table></figure>

<p><strong>设置当前用户密码</strong></p>
<p>使用ALTER USER命令来修改当前用户密码用户可以使用ALTER命令来修改自身密码，如下语句代表修改当前登录用户的密码。基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">USER</span>() IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;new_password&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>修改其它用户密码</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">user</span> [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>]</span><br><span class="line">[,<span class="keyword">user</span>[IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>]]…;</span><br></pre></td></tr></table></figure>

<h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a><strong>权限管理</strong></h4><p><strong>权限列表</strong></p>
<ol>
<li>CREATE和DROP权限 ，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。</li>
<li>SELECT、INSERT、UPDATE和DELETE权限 允许在一个数据库现有的表上实施操作。</li>
<li>SELECT权限只有在它们真正从一个表中检索行时才被用到。</li>
<li>INDEX权限 允许创建或删除索引，INDEX适用于已有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。</li>
<li>ALTER权限可以使用ALTER TABLE来更改表的结构和重新命名表。</li>
<li>CREATE ROUTINE权限 用来创建保存的程序（函数和程序），ALTER ROUTINE权限用来更改和删除保存的程序， EXECUTE权限 用来执行保存的程序。</li>
<li>GRANT权限允许授权给其他用户，可用于数据库、表和保存的程序。</li>
<li>FILE权限 使用户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）。</li>
</ol>
<p>​	<strong>授予权限的原则</strong></p>
<p>权限控制主要是出于安全因素，因此需要遵循以下几个经验原则：</p>
<ol>
<li>只授予能满足需要的最小权限，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。 </li>
<li>创建用户的时候限制用户的登录主机 ，一般是限制成指定IP或者内网IP段。</li>
<li>为每个用户设置满足密码复杂度的密码 。</li>
<li>定期清理不需要的用户，回收权限或者删除用户。</li>
</ol>
<p><strong>授予权限</strong></p>
<p>给用户授权的方式有 2 种，分别是通过把角色赋予用户给用户授权和直接给用户授权 。用户是数据库的使用者，我们可以通过给用户授予访问数据库中资源的权限，来控制使用者对数据库的访问，消除安全隐患。</p>
<p>授权命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限<span class="number">1</span>,权限<span class="number">2</span>,…权限n <span class="keyword">ON</span> 数据库名称.表名称 <span class="keyword">TO</span> 用户名@用户地址 [IDENTIFIED <span class="keyword">BY</span> ‘密码口令’];</span><br></pre></td></tr></table></figure>

<p>该权限如果发现没有该用户，则会直接新建一个用户。</p>
<p>比如：</p>
<ul>
<li>给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">INSERT</span>,<span class="keyword">DELETE</span>,<span class="keyword">UPDATE</span> <span class="keyword">ON</span> atguigudb.<span class="operator">*</span> <span class="keyword">TO</span> li4<span class="variable">@localhost</span> ;</span><br></pre></td></tr></table></figure>

<ul>
<li>授予通过网络方式登录的joe用户 ，对所有库所有表的全部权限，密码设为123。注意这里唯独不包括grant的权限。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> joe@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">我们在开发应用的时候，经常会遇到一种需求，就是要根据用户的不同，对数据进行横向和纵向的分组。</span><br><span class="line"><span class="code">	所谓横向的分组，就是指用户可以接触到的数据的范围，比如可以看到哪些表的数据；</span></span><br><span class="line"><span class="code">	所谓纵向的分组，就是指用户对接触到的数据能访问到什么程度，比如能看、能改，甚至是删除。</span></span><br></pre></td></tr></table></figure>

<p><strong>查看权限</strong></p>
<ul>
<li>查看当前用户权限</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS;</span><br><span class="line"># 或</span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="built_in">CURRENT_USER</span>;</span><br><span class="line"># 或</span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="built_in">CURRENT_USER</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>查看某用户的全局权限</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;user&#x27;</span>@<span class="string">&#x27;主机地址&#x27;</span> ;</span><br></pre></td></tr></table></figure>

<p><strong>收回权限</strong></p>
<p>收回权限就是取消已经赋予用户的某些权限。收回用户不必要的权限可以在一定程度上保证系统的安全性。MySQL中使用 REVOKE语句取消用户的某些权限。使用REVOKE收回权限之后，用户账户的记录将从db、host、tables_priv和columns_priv表中删除，但是用户账户记录仍然在user表中保存（删除user表中的账户记录使用DROP USER语句）。</p>
<p><strong>注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限。</strong></p>
<ul>
<li>收回权限命令</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限<span class="number">1</span>,权限<span class="number">2</span>,…权限n <span class="keyword">ON</span> 数据库名称.表名称 <span class="keyword">FROM</span> 用户名@用户地址;</span><br></pre></td></tr></table></figure>

<p>举例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#收回全库全表的所有权限</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">FROM</span> joe@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">#收回mysql库下的所有表的插删改查权限</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>,<span class="keyword">INSERT</span>,<span class="keyword">UPDATE</span>,<span class="keyword">DELETE</span> <span class="keyword">ON</span> mysql.<span class="operator">*</span> <span class="keyword">FROM</span> joe<span class="variable">@localhost</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意： 须用户重新登录后才能生效</strong></p>
<h4 id="权限表"><a href="#权限表" class="headerlink" title="权限表"></a><strong>权限表</strong></h4><p>user表user表是MySQL中最重要的一个权限表， 记录用户账号和权限信息 ，有49个字段。</p>
<p>这些字段可以分成4类，分别是范围列（或用户列）、权限列、安全列和资源控制列。</p>
<p><strong>范围列（或用户列）</strong></p>
<p>host ： 表示连接类型</p>
<ul>
<li>% 表示所有远程通过 TCP方式的连接</li>
<li>IP 地址 如 (192.168.1.2、127.0.0.1) 通过制定ip地址进行的TCP方式的连接</li>
<li>机器名 通过制定网络中的机器名进行的TCP方式的连接</li>
<li>::1 IPv6的本地ip地址，等同于IPv4的 127.0.0.1</li>
<li>localhost 本地方式通过命令行方式的连接 ，比如mysql -u xxx -p xxx 方式的连接。</li>
</ul>
<p>user ： 表示用户名，同一用户通过不同方式链接的权限是不一样的。</p>
<p>password ： 密码</p>
<ul>
<li>所有密码串通过 password(明文字符串) 生成的密文字符串。MySQL 8.0 在用户管理方面增加了角色管理，默认的密码加密方式也做了调整，由之前的 SHA1 改为了 SHA2 ，不可逆 。同时加上 MySQL 5.7 的禁用用户和用户过期的功能，MySQL 在用户管理方面的功能和安全性都较之前版本大大的增强了。</li>
<li>mysql 5.7 及之后版本的密码保存到 authentication_string 字段中不再使用password 字段。</li>
</ul>
<p><strong>权限列</strong></p>
<ul>
<li>Grant_priv字段：表示是否拥有GRANT权限</li>
<li>Shutdown_priv字段：表示是否拥有停止MySQL服务的权限</li>
<li>Super_priv字段：表示是否拥有超级权限</li>
<li>Execute_priv字段：表示是否拥有EXECUTE权限。拥有EXECUTE权限，可以执行存储过程和函数。</li>
<li>Select_priv , Insert_priv等：为该用户所拥有的权限。</li>
</ul>
<p><strong>安全列</strong> 安全列只有6个字段，其中两个是ssl相关的（ssl_type、ssl_cipher），用于 加密 ；两个是x509相关的（x509_issuer、x509_subject），用于 标识用户 ；另外两个Plugin字段用于 验证用户身份 的插件，该字段不能为空。如果该字段为空，服务器就使用内建授权验证机制验证用户身份。</p>
<p><strong>资源控制列</strong> 资源控制列的字段用来 限制用户使用的资源 ，包含4个字段，分别为：①max_questions，用户每小时允许执行的查询操作次数； ②max_updates，用户每小时允许执行的更新操作次数； ③max_connections，用户每小时允许执行的连接操作次数； ④max_user_connections，用户允许同时建立的连接次数。</p>
<p>查看字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC mysql.user;</span><br></pre></td></tr></table></figure>

<p>查看用户, 以列的方式显示数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mysql.user \G;</span><br></pre></td></tr></table></figure>

<p>查询特定字段：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> host,<span class="keyword">user</span>,authentication_string,select_priv,insert_priv,drop_priv <span class="keyword">FROM</span> mysql.user;</span><br></pre></td></tr></table></figure>

<p><strong>db表</strong></p>
<p>使用DESCRIBE查看db表的基本结构：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> mysql.db;</span><br></pre></td></tr></table></figure>

<p><strong>1.</strong> <strong>用户列</strong> db表用户列有3个字段，分别是Host、User、Db。这3个字段分别表示主机名、用户名和数据库名。表示从某个主机连接某个用户对某个数据库的操作权限，这3个字段的组合构成了db表的主键。</p>
<p><strong>2.</strong> <strong>权限列</strong></p>
<p>Create_routine_priv和Alter_routine_priv这两个字段决定用户是否具有创建和修改存储过程的权限。</p>
<p><strong>tables_priv表和columns_priv表</strong></p>
<p>tables_priv表用来 对表设置操作权限 ，columns_priv表用来对表的 某一列设置权限 。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">desc</span> mysql.tables_priv;</span><br></pre></td></tr></table></figure>

<p>tables_priv表有8个字段，分别是Host、Db、User、Table_name、Grantor、Timestamp、Table_priv和Column_priv，各个字段说明如下：</p>
<ul>
<li>Host 、 Db 、 User 和 Table_name 四个字段分别表示主机名、数据库名、用户名和表名。</li>
<li>Grantor表示修改该记录的用户。</li>
<li>Timestamp表示修改该记录的时间。</li>
<li>Table_priv 表示对象的操作权限。包括Select、Insert、Update、Delete、Create、Drop、Grant、References、Index和Alter。</li>
<li>Column_priv字段表示对表中的列的操作权限，包括Select、Insert、Update和References。</li>
</ul>
<p><strong>procs_priv表</strong></p>
<p>procs_priv表可以对存储过程和存储函数设置操作权限 </p>
<h4 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a><strong>角色管理</strong></h4><p><strong>角色的理解</strong></p>
<p>引入角色的目的是 方便管理拥有相同权限的用户 。恰当的权限设定，可以确保数据的安全性，这是至关重要的</p>
<p><strong>创建角色</strong></p>
<p>创建角色使用 CREATE ROLE 语句，语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ROLE <span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>] [,<span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>]]...</span><br></pre></td></tr></table></figure>

<p>角色名称的命名规则和用户名类似。如果 host_name省略，默认为% ， role_name不可省略 ，不可为空。</p>
<p><strong>给角色赋予权限</strong></p>
<p>创建角色之后，默认这个角色是没有任何权限的，我们需要给角色授权。给角色授权的语法结构是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> privileges <span class="keyword">ON</span> table_name <span class="keyword">TO</span> <span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>上述语句中privileges代表权限的名称，多个权限以逗号隔开。</p>
<p><strong>查看角色的权限</strong></p>
<p>赋予角色权限之后，我们可以通过 SHOW GRANTS 语句，来查看权限是否创建成功了：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;manager&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Grants <span class="keyword">for</span> manager@<span class="operator">%</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> `manager`@`<span class="operator">%</span>` <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> `demo`.`goodsmaster` <span class="keyword">TO</span> `manager`@`<span class="operator">%</span>` <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> `demo`.`invcount` <span class="keyword">TO</span> `manager`@`<span class="operator">%</span>` <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> `demo`.`settlement` <span class="keyword">TO</span> `manager`@`<span class="operator">%</span>` <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>只要你创建了一个角色，系统就会自动给你一个“ USAGE ”权限，意思是 连接登录数据库的权限 。代码的最后三行代表了我们给角色“manager”赋予的权限，也就是对商品信息表、盘点表和应付账款表的只读权限。</p>
<p>结果显示，库管角色拥有商品信息表的只读权限和盘点表的增删改查权限。</p>
<p><strong>回收角色的权限</strong></p>
<p>角色授权后，可以对角色的权限进行维护，对权限进行添加或撤销。添加权限使用GRANT语句，与角色授权相同。撤销角色或角色权限使用REVOKE语句。</p>
<p>修改了角色的权限，会影响拥有该角色的账户的权限。</p>
<p>撤销角色权限的SQL语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> privileges <span class="keyword">ON</span> tablename <span class="keyword">FROM</span> <span class="string">&#x27;rolename&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>删除角色</strong></p>
<p>当我们需要对业务重新整合的时候，可能就需要对之前创建的角色进行清理，删除一些不会再使用的角色。删除角色的操作很简单，你只要掌握语法结构就行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> ROLE role [,role2]...</span><br></pre></td></tr></table></figure>

<p>注意， 如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限 。</p>
<p><strong>给用户赋予角色</strong></p>
<p>角色创建并授权后，要赋给用户并处于 激活状态 才能发挥作用。给用户添加角色可使用GRANT语句，语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> role [,role2,...] <span class="keyword">TO</span> <span class="keyword">user</span> [,user2,...];</span><br></pre></td></tr></table></figure>

<p>在上述语句中，role代表角色，user代表用户。可将多个角色同时赋予多个用户，用逗号隔开即可。</p>
<p><strong>激活角色</strong></p>
<p><strong>方式1：使用set default role命令激活角色</strong></p>
<p><strong>方式2：将activate_all_roles_on_login设置为ON</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> activate_all_roles_on_login<span class="operator">=</span><span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure>

<p>这条 SQL 语句的意思是，对 所有角色永久激活 。运行这条语句之后，用户才真正拥有了赋予角色的所有权限。</p>
<p><strong>撤销用户的角色</strong></p>
<p>撤销用户角色的SQL语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> role <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p><strong>设置强制角色(mandatory role)</strong></p>
<p>方式1：服务启动前设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">mandatory_roles=&#x27;role1,role2@localhost,r3@%.atguigu.com&#x27;</span><br></pre></td></tr></table></figure>

<p>方式2：运行时设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SET PERSIST mandatory_roles = &#x27;role1,role2@localhost,r3@%.example.com&#x27;; #系统重启后仍然有效</span><br><span class="line">SET GLOBAL mandatory_roles = &#x27;role1,role2@localhost,r3@%.example.com&#x27;; #系统重启后失效</span><br></pre></td></tr></table></figure>

<h3 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h3><h4 id="第1层：连接层"><a href="#第1层：连接层" class="headerlink" title="第1层：连接层"></a><strong>第1层：连接层</strong></h4><p>系统（客户端）访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。</p>
<p>经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。</p>
<ul>
<li>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</li>
<li>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</li>
</ul>
<p>TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p>
<h4 id="第2层：服务层"><a href="#第2层：服务层" class="headerlink" title="第2层：服务层"></a><strong>第2层：服务层</strong></h4><ul>
<li><p><strong>SQL Interface: SQL接口</strong></p>
<ul>
<li><p>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQLInterface</p>
</li>
<li><p>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</p>
</li>
</ul>
</li>
<li><p><strong>Parser:</strong> <strong>解析器</strong></p>
<ul>
<li><p>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</p>
</li>
<li><p>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建 语法树 ，并根据数据字典丰富查询语法树，会 验证该客户端是否具有执行该查询的权限 。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。</p>
</li>
</ul>
</li>
<li><p><strong>Optimizer:</strong> <strong>查询优化器</strong></p>
<ul>
<li><p>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划 。</p>
</li>
<li><p>这个执行计划表明应该 使用哪些索引 进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</p>
</li>
<li><p>它使用“ 选取-投影-连接 ”策略进行查询。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这个SELECT查询先根据WHERE语句进行 <strong>选取</strong> ，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性 投影 ，而不是将属性全部取出以后再进行过滤，将这两个查询条件 连接 起来生成最终查询结果。</p>
</li>
</ul>
</li>
<li><p><strong>Caches &amp; Buffers： 查询缓存组件</strong></p>
<ul>
<li><p>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。</p>
</li>
<li><p>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</p>
</li>
<li><p>这个查询缓存可以在 不同客户端之间共享 。</p>
</li>
<li><p>从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除 。</p>
</li>
</ul>
</li>
</ul>
<h4 id="第3层：引擎层"><a href="#第3层：引擎层" class="headerlink" title="第3层：引擎层"></a>第3层：引擎层</h4><p>插件式存储引擎层（ Storage Engines），真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p>
<h4 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h4><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 文件系统 上，以 文件 的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用DAS、NAS、SAN等各种存储系统。</p>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><h4 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a><strong>索引概述</strong></h4><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。</p>
<p><strong>索引的本质：</strong>索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 高级查找算法 。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ol>
<li>类似大学图书馆建书目索引，提高数据检索的效率，降低 数据库的IO成本 ，这也是创建索引最主要的原因。 </li>
<li>通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性 。</li>
<li>在实现数据的参考完整性方面，可以 加速表和表之间的连接 。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。 </li>
<li>在使用分组和排序子句进行数据查询时，可以显著 减少查询中分组和排序的时间 ，降低了CPU的消耗。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ol>
<li>创建索引和维护索引要 耗费时间 ，并且随着数据量的增加，所耗费的时间也会增加。</li>
<li>索引需要占 磁盘空间 ，除了数据表占数据空间之外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。 </li>
<li>虽然索引大大提高了查询速度，同时却会 降低更新表的速度 。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</li>
</ol>
<h3 id="InnoDB数据存储结构"><a href="#InnoDB数据存储结构" class="headerlink" title="InnoDB数据存储结构"></a>InnoDB数据存储结构</h3><h4 id="数据库存储结构：页"><a href="#数据库存储结构：页" class="headerlink" title="数据库存储结构：页"></a>数据库存储结构：页</h4><h5 id="磁盘与内存交互的基本单位：页"><a href="#磁盘与内存交互的基本单位：页" class="headerlink" title="磁盘与内存交互的基本单位：页"></a>磁盘与内存交互的基本单位：页</h5><p>InnoDB将数据划分为若干个页，InnoDB中页的大小默认为16k。</p>
<p>以页作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16k的内容到内存中，一次最少把内存中的16k内容刷新到磁盘中，也就是说，在数据库中，不论读一行，还是读多行，都是将这些所在的页进行加载，也就是说数据库管理存储空间的基本单位是页，数据库I&#x2F;O操作的最小单位是页，一个页中可以存储多个记录</p>
<h5 id="页的概述"><a href="#页的概述" class="headerlink" title="页的概述"></a>页的概述</h5><p>页可以在物理结构上不相连，只要通过双向链表相关联即可，每个数据页中记录会按照主键从小到大组成一个单向链表，每个数据页都会为存储在它里边的记录生成一个页目录，在通过主键查找某记录的时候在页目录中使用二分法快速定位到对应的槽，然后再遍历对应分组中的记录即可快速找到指定的记录。</p>
<h4 id="页的内部结构"><a href="#页的内部结构" class="headerlink" title="页的内部结构"></a>页的内部结构</h4><p><img src="2E798A58-F8E0-4CC7-B442-596383809330.png" alt="2E798A58-F8E0-4CC7-B442-596383809330"></p>
<h5 id="File-Header（文件头部）（38字节）"><a href="#File-Header（文件头部）（38字节）" class="headerlink" title="File Header（文件头部）（38字节）"></a>File Header（文件头部）（38字节）</h5><p><img src="FAB11077-E54A-43AB-82B9-2B0304750D21.png" alt="img"></p>
<ol>
<li><p>FIL_PAGE_OFFSET（4字节）、</p>
<p>每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页。</p>
</li>
<li><p>FIL_PAGE_OFFSET（4字节）</p>
<p><img src="E26C1E0A-9104-472B-9543-9A1C98E97642.png" alt="img"></p>
</li>
<li><p>FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）</p>
</li>
<li><p>FIL_PAGE_SPACE_OR_CHKSUM（4字节）</p>
</li>
<li><p>FIL_PAGE_LSN（8字节）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC框架</title>
    <url>/2023/02/02/RPC%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>RPC 的主要功能目标是让构建分布式计算（应用）更容易，是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议规范，简单的来说就是像调用本地服务一样调用远程服务，对开发者而言是透明的。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1、RPC框架一般使用长链接，不必每次通信都要3次握手，减少网络开销</p>
<p>2、RPC框架一般都有注册中心，有丰富的监控管理</p>
<p>3、发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作</p>
<p>4、协议私密，安全性较高</p>
<p>5、rpc 能做到协议更简单内容更小，效率更高</p>
<p>6、rpc是面向服务的更高级的抽象，支持服务注册发现，负载均衡，超时重试，熔断降级等高级特性</p>
<h2 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h2><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>在高可用的生产环境中，服务一般都以集群方式提供服务，集群里面的IP等重要参数信息可能随时会发生变化，节点也可能会动态扩缩容，客户端需要能够及时感知服务端的变化，获取集群最新服务节点的连接信息，而这些变化要求是要对调用方应用无感知的。</p>
<p>常用的注册中心：<strong>Zookeeper</strong>，<strong>Consul</strong>，<strong>Nacos</strong></p>
<h3 id="代理技术"><a href="#代理技术" class="headerlink" title="代理技术"></a>代理技术</h3><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">在运行期动态的创建代理类，它是通过接口生成代理类的，与静态代理相比更加灵活，但是也有一定的限制，第一是代理对象必须实现一个接口，否则会报异常。第二是有性能问题，因为是通过反射来实现调用的，所以比正常的直接调用来得慢，并且通过生成类文件也会多消耗部分方法区空间，可能引起Full GC。</span><br></pre></td></tr></table></figure>

<p><strong>代码实现：</strong></p>
<p>1、定义一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、编写实现类，并定义一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.jdk;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、编写一个代理方法处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: jdk动态代理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JdkProxy</span><span class="params">(Object object)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> method.invoke(object, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉打豆豆&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、生成代理对象测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dogProxy</span> <span class="operator">=</span> (Animal) Proxy.newProxyInstance(animal.getClass().getClassLoader(), animal.getClass().getInterfaces(), <span class="keyword">new</span> <span class="title class_">JdkProxy</span>(animal));</span><br><span class="line">        dogProxy.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现原理：</strong></p>
<p>JDK动态代理是指：代理类实例在程序运行时，由JVM根据反射机制动态的生成。也就是说代理类不是用户自己定义的，而是由JVM生成的。</p>
<p><strong>1.1 InvocationHandler接口</strong></p>
<p>​		代理实例的调用处理器需要实现InvocationHandler接口，并且每个代理实例都有一个关联的调用处理器。当一个方法在代理实例上被调用时，这个方法调用将被编码并分派到其调用处理器的invoke方法上。</p>
<p>​		也就是说，我们创建的每一个代理实例都要有一个关联的InvocationHandler，并且在调用代理实例的方法时，会被转到InvocationHandler的invoke方法上。</p>
<p>publicObject invoke(Object proxy, Method method, Object[] args) throws Throwable；该invoke方法的作用是：处理代理实例上的方法调用并返回结果。</p>
<p>其有三个参数，分别为：</p>
<ul>
<li><strong>proxy</strong>：是调用该方法的代理实例。</li>
<li><strong>method</strong>：是在代理实例上调用的接口方法对应的Method实例。</li>
<li><strong>args</strong>：一个Object数组，是在代理实例上的方法调用中传递的参数值。如果接口方法为无参，则该值为null。</li>
<li>其返回值为：调用代理实例上的方法的返回值</li>
</ul>
<p><strong>1.2 Proxy类</strong></p>
<p>Proxy类提供了创建动态代理类及其实例的静态方法，该类也是动态代理类的超类。</p>
<p>代理类具有以下属性：</p>
<ul>
<li>代理类的名称以 “$Proxy” 开头，后面跟着一个数字序号。</li>
<li>代理类继承了Proxy类。</li>
<li>代理类实现了创建时指定的接口（JDK动态代理是面向接口的）。</li>
<li>每个代理类都有一个公共构造函数，它接受一个参数，即接口InvocationHandler的实现，用于设置代理实例的调用处理器。</li>
</ul>
<p>Proxy提供了两个静态方法，用于获取代理对象。</p>
<p><strong>1.2.1 getProxyClass</strong></p>
<p>用于获取代理类的Class对象，再通过调用构造函数创建代理实例。</p>
<p>该方法有两个参数：</p>
<ul>
<li><strong>loader</strong>：为类加载器。</li>
<li><strong>intefaces</strong>：为接口的Class对象数组。</li>
</ul>
<p>返回值为动态代理类的Class对象。</p>
<p><strong>1.2.2 newProxyInstance</strong></p>
<p>用于创建一个代理实例。</p>
<p>该方法有三个参数：</p>
<ul>
<li><strong>loader</strong>：为类加载器。</li>
<li><strong>interfaces</strong>：为接口的Class对象数组。</li>
<li><strong>h</strong>：指定的调用处理器。</li>
</ul>
<p>返回值为指定接口的代理类的实例。</p>
<p><strong>生成代理类：</strong></p>
<ul>
<li>代理类继承了Proxy类，其主要目的是为了传递InvocationHandler</li>
<li>代理类实现了被代理的接口，这也是为什么代理类可以直接强转成接口的原因。</li>
<li>有一个公开的构造函数，参数为指定的InvocationHandler，并将参数传递到父类Proxy中。</li>
<li>每一个实现的方法，都会调用InvocationHandler中的invoke方法，并将代理类本身、Method实例、入参三个参数进行传递。这也是为什么调用代理类中的方法时，总会分派到InvocationHandler中的invoke方法的原因。</li>
</ul>
<p><strong>代理生成过程：</strong></p>
<ol>
<li><p>调用<strong>getProxyClass 和 newProxyInstance</strong>方法，底层逻辑都会调用<strong>getProxyClass0</strong>方法</p>
</li>
<li><p>代理接口的最多不能超过65535个，会先从缓存<strong>WeakCache</strong>中获取代理类，则没有再通过<strong>ProxyClassFactory</strong>创建代理类。</p>
</li>
<li><p>ProxyClassFactory是Proxy类的一个静态内部类，该类用于生成代理类。</p>
<p>1）代理类的名称就是在这里定义的，其前缀是$Proxy，后缀是一个数字。</p>
<p>2）调用ProxyGenerator.generateProxyClass生成文件流。</p>
<p>3）defineClass0方法是一个native方法，负责字节码加载的实现，并返回对应的Class对象。</p>
</li>
</ol>
<h4 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">ASM 是一个 Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为（也就是生成的代码可以覆盖原来的类也可以是原始类的子类）。不过ASM在创建class字节码的过程中，操纵的是底层JVM的汇编指令级别，这要求ASM使用者要对class组织结构和JVM汇编指令有一定的了解</span><br></pre></td></tr></table></figure>

<h4 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">CGLIB(Code Generation Library)是一个基于ASM的字节码生成库。其原理是动态生成一个要代理类的子类，子类重写要代理的类的所有不是final的方法，在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用java反射的JDK动态代理要快</span><br></pre></td></tr></table></figure>

<p><strong>代码实现：</strong></p>
<p>1、创建一个测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.cglib;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-28</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、实现MethodInterceptor接口，自定义拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-28</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、通过Enhancer创建代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.cglib;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; clazz)</span>&#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">CglibProxy</span>());</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.cglib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-28</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">proxy</span> <span class="operator">=</span> (Student) CglibProxyFactory.createProxy(Student.class);</span><br><span class="line">        proxy.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现原理：</strong></p>
<p>动态生成一个要代理类的子类，子类重写要代理的类的所有不是 final 的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。</p>
<p>采用ASM字节码生成框架，使用字节码技术生成代理类，比使用 Java 反射效率要高。</p>
<p><strong>代理字节码文件：</strong></p>
<ul>
<li>生成的动态代理类继承了父类 Student，并且实现了接口 Factory</li>
<li>动态代理类持有 MethodInterceptor</li>
<li>动态代理类会重写父类 Student 的非 final、private 方法；也会构建自己的方法（cglib 方法），构建方式：CGLIB”+“$父类方法名$</li>
<li>cglib 方法的方法体：super.方法名，直接调用父类；重写方法：它会调用拦截器中的 intercept() 方法</li>
<li>methodProxy.invokeSuper() 方法会调用动态代理类中的 cglib 方法；methodProxy.invoke() 方法会调用动态代理类中的重写方法</li>
</ul>
<h4 id="bytebuddy"><a href="#bytebuddy" class="headerlink" title="bytebuddy"></a>bytebuddy</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Byte Buddy本身也是基于 ASM API 实现的，是一个较高层级的抽象的字节码操作工具，通过使用 Byte Buddy ，任何熟悉 Java 编程语言的人都有望非常容易地进行字节码操作。</span><br></pre></td></tr></table></figure>

<p>增强案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.bytebuddy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.ByteBuddy;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.implementation.FixedValue;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.matcher.ElementMatcher;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.matcher.ElementMatchers;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 入门案例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteBuddy</span>()</span><br><span class="line">                <span class="comment">//指定父类</span></span><br><span class="line">                .subclass(Object.class)</span><br><span class="line">                <span class="comment">//指定生成的类名</span></span><br><span class="line">                .name(<span class="string">&quot;User&quot;</span>)</span><br><span class="line">                <span class="comment">//按名称拦截类的 toString</span></span><br><span class="line">                .method(ElementMatchers.named(<span class="string">&quot;toString&quot;</span>))</span><br><span class="line">                <span class="comment">//拦截方法调用 返回固定值</span></span><br><span class="line">                .intercept(FixedValue.value(<span class="string">&quot;HelloWorld&quot;</span>))</span><br><span class="line">                <span class="comment">//生成字节码</span></span><br><span class="line">                .make()</span><br><span class="line">                <span class="comment">//classloader 加载字节码到内存</span></span><br><span class="line">                .load(ByteBuddy.class.getClassLoader())</span><br><span class="line">                <span class="comment">//获得Class对象</span></span><br><span class="line">                .getLoaded()</span><br><span class="line">                .newInstance()</span><br><span class="line">                .toString();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>subclass(Object.class)</strong> ：创建一个Object的子类</li>
<li><strong>name(“ExampleClass”) :</strong> 新建的类名叫做“ExampleClass” ,暂时没有用到</li>
<li><strong>method()</strong> ：要拦截“ExampleClass”中的方法</li>
<li><strong>ElementMatchers.named(“toString”)</strong> ：拦截条件，拦截toString()这个方法, 没有条件，表示所有的方法</li>
<li><strong>intercept()</strong> ：指定了拦截到的方法要修改成什么样子，是不是和 Spring AOP有点像了</li>
<li><strong>make()</strong> ：创建上面生成的这个类型</li>
<li><strong>load()</strong> ：加载这个生成的类</li>
<li><strong>newInstance()</strong> ：Java 反射的API，创建实例</li>
</ul>
<p>在Byte buddy中默认提供了一个 dynamicType.saveIn() 方法，可以保存编译后的Class文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.bytebuddy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.ByteBuddy;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.dynamic.DynamicType;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.implementation.FixedValue;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.matcher.ElementMatchers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 保存class文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LookUpClassFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        DynamicType.Unloaded&lt;Object&gt; dynamicType = <span class="keyword">new</span> <span class="title class_">ByteBuddy</span>()</span><br><span class="line">                <span class="comment">// 指定父类</span></span><br><span class="line">                .subclass(Object.class)</span><br><span class="line">                <span class="comment">// 指定生成类的名称</span></span><br><span class="line">                .name(<span class="string">&quot;User&quot;</span>)</span><br><span class="line">                <span class="comment">// 按名称 拦截该类的 toString()</span></span><br><span class="line">                .method(ElementMatchers.named(<span class="string">&quot;toString&quot;</span>))</span><br><span class="line">                <span class="comment">// 拦截方法调用 返回固定值</span></span><br><span class="line">                .intercept(FixedValue.value(<span class="string">&quot;Hello World!!&quot;</span>))</span><br><span class="line">                <span class="comment">// 产生字节码</span></span><br><span class="line">                .make();</span><br><span class="line">        DynamicType.Loaded&lt;Object&gt; loaded = dynamicType.load(ByteBuddy.class.getClassLoader());</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(HelloWorld.class.getResource(<span class="string">&quot;./&quot;</span>).getPath());</span><br><span class="line">        dynamicType.saveIn(file);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> loaded.getLoaded().newInstance().toString();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其他API</strong></p>
<ul>
<li><p>defineMethod(“main”, String.class, Modifier.PUBLIC + Modifier.STATIC)，</p>
<p>定义方法；名称、返回类型、属性<em>public static void</em></p>
<p>Modifier.PUBLIC + Modifier.STATIC，这是一个是二进制相加，每一个类型都在二进制中占有一位。例如 1 2 4 8 … 对应的二进制占位 1111。既可以执行相加运算，并又能保留原有单元的属性。</p>
</li>
<li><p>withParameter(String[].class, “args”)，</p>
<p>定义参数；参数类型、参数名称</p>
</li>
<li><p>intercept(FixedValue.value(“Hello World!”))，</p>
<p>拦截设置返回值，但此时还能满足我们的要求。</p>
</li>
<li><p>defineField() 方法：创建字段。</p>
</li>
<li><p>implement() 方法：实现接口。</p>
</li>
</ul>
<h4 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Javassist 使操作Java字节码变得简单，一个可以用于编辑Java字节码的类库，提供了两种级别的API：源码级别和字节码级别。如果用户使用源码级API，他们可以在不需要过多了解Java字节码规范的前提下使用它提供的基于java语言的API来编辑字节码文件。如果使用字节码级API则允许用户直接编辑字节码文件。Javassist在复杂的字节码级操作上提供了更高级别的抽象层。另外Javassist使用了反射机制，这使得它在运行时比ASM慢。</span><br></pre></td></tr></table></figure>

<p><strong>类</strong></p>
<ul>
<li>ClassPool：javassist的类池，使用ClassPool 类可以跟踪和控制所操作的类，它的工作方式与 JVM 类装载器非常相似</li>
<li>CtClass： CtClass提供了类的操作，如在类中动态添加新字段、方法和构造函数、以及改变类、父类和接口的方法。</li>
<li>CtField：类的属性，通过它可以给类创建新的属性，还可以修改已有的属性的类型，访问修饰符等</li>
<li>CtMethod：类中的方法，通过它可以给类创建新的方法，还可以修改返回类型，访问修饰符等， 甚至还可以修改方法体内容代码</li>
<li>CtConstructor：与CtMethod类</li>
</ul>
<p><strong>API</strong></p>
<p>ClassPool</p>
<ul>
<li>ClassPool pool &#x3D; ClassPool.getDefault(); 类库, jvm中所加载的class</li>
<li>CtClass ctClass &#x3D; pool.get(“com.itheima.Student”); 加载一个已知的类, 注：参数必须为全量类名</li>
<li>CtClass tClass &#x3D; pool.makeClass(“com.itheima.Calculator”); 创建一个新的类, 类名必须为全量类名</li>
</ul>
<p>CtField</p>
<ul>
<li>CtField ctField &#x3D; ctClass.getDeclaredField(“name”); 获取已知类的属性</li>
<li>CtField ctFieldNew &#x3D; new CtField(CtClass.intType,“age”,ctClass); 构建新的类的成员变量</li>
<li>ctFieldNew.setModifiers(Modifier.PUBLIC); 设置类的访问修饰符为public</li>
<li>ctClass.addField(ctFieldNew); 将属性添加到类中</li>
</ul>
<p>CtMethod</p>
<ul>
<li><p>CtMethod ctMethod &#x3D; ctClass.getDeclaredMethod(“sayHello”); 获取已有方法</p>
</li>
<li><p>CtMethod ctMethod &#x3D; new CtMethod(CtClass.intType, “calc”, new CtClass[]{CtClass.intType,CtClass.intType}, tClass);创建新的方法, 参数1:方法的返回类型，参数2：名称，参数3：方法的参数，参数4：方法所属的类</p>
</li>
<li><p>ctMethod.setModifiers(Modifier.PUBLIC); 设置方法的访问修饰</p>
</li>
<li><p>ctClass.addMethod(ctMethod); 将新建的方法添加到类中</p>
</li>
<li><p>ctMethod.setBody(“return $1 + $2;”); 方法体内容代码 $1代表第一个参数，$2代表第二个参数</p>
</li>
<li><p>CtMethod getMethod &#x3D; CtNewMethod.make(“public int getAge() { return this.age;}”, ctClass); </p>
<p>CtMethod setMethod &#x3D; CtNewMethod.make(“public void setAge(int age) { this.age &#x3D; age;}”, ctClass);ctClass.addMethod(getMethod);ctClass.addMethod(setMethod);  直接创建方法</p>
</li>
</ul>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="jdk序列化"><a href="#jdk序列化" class="headerlink" title="jdk序列化"></a>jdk序列化</h4><p>被序列化的对象需要实现java.io.Serializable接口</p>
<h5 id="serialVersionUID的作用"><a href="#serialVersionUID的作用" class="headerlink" title="serialVersionUID的作用"></a>serialVersionUID的作用</h5><p>一句话：其目的是序列化对象版本控制，有关各版本反序列化时是否兼容。如果在新版本中这个值修改了，新版本就不兼容旧版本，反序列化时会抛出InvalidClassException异常。如果修改较小，比如仅仅是增加了一个属性，我们希望向下兼容，老版本的数据都能保留，那就不用修改；如果我们删除了一个属性，或者更改了类的继承关系，必然不兼容旧数据，这时就应该手动更新版本号，即SerialVersionUid。</p>
<p>serialVersionUID有两种显示的生成方式：</p>
<ul>
<li>一是默认的1L，比如：private static final long serialVersionUID &#x3D; 1L;</li>
<li>二是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，</li>
</ul>
<h5 id="静态变量的序列化"><a href="#静态变量的序列化" class="headerlink" title="静态变量的序列化"></a>静态变量的序列化</h5><p>静态变量不会被序列化。因为静态变量在全局区,本来流里面就没有写入静态变量,我打印静态变量当然会去全局区查找</p>
<h5 id="Transient-关键字作用"><a href="#Transient-关键字作用" class="headerlink" title="Transient 关键字作用"></a>Transient 关键字作用</h5><p>Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol>
<li>Java序列化只是针对对象的状态进行保存，至于对象中的方法，序列化不关心</li>
<li>当一个父类实现了序列化，那么子类会自动实现序列化，不需要显示实现序列化接口</li>
<li>当一个对象的实例变量引用了其他对象，序列化这个对象的时候会自动把引用的对象也进行序列化（实现深度克隆）</li>
<li>当某个字段被申明为transient后，默认的序列化机制会忽略这个字段</li>
<li>被申明为transient的字段，如果需要序列化，可以添加两个私有方法：writeObject和readObject</li>
</ol>
<h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><p>XML序列化的好处在于可读性好，方便阅读和调试。但是序列化以后的字节码文件比较大，而且效率不高，适用于对性能不高，而且QPS较低的企业级内部系统之间的数据交换的场景，同时XML又具有语言无关性，所以还可以用于异构系统之间的数据交换和协议。比如我们熟知的Webservice，就是采用XML格式对数据进行序列化的。XML序列化&#x2F;反序列化的实现方式有很多，熟知的方式有XStream和Java自带的XML序列化和反序列化两种。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.serialize.xml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gxl.serialize.jdk.User;</span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.XStream;</span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.io.xml.DomDriver;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLSerializer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;Mic&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        String xml=serialize(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化完成：&quot;</span>+xml);</span><br><span class="line">        User nuser=deserialize(xml);</span><br><span class="line">        System.out.println(nuser);    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">serialize</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XStream</span>(<span class="keyword">new</span> <span class="title class_">DomDriver</span>()).toXML(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User <span class="title function_">deserialize</span><span class="params">(String xml)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (User)<span class="keyword">new</span> <span class="title class_">XStream</span>(<span class="keyword">new</span> <span class="title class_">DomDriver</span>()).fromXML(xml);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，相对于XML来说，JSON的字节流更小，而且可读性也非常好。现在JSON数据格式在企业运用是最普遍的</p>
<p>JSON序列化常用的开源工具有很多</p>
<ol>
<li>Jackson （<a href="javascript:void(0)">https://github.com/FasterXML/jackson）</a></li>
<li>阿里开源的FastJson （<a href="javascript:void(0)">https://github.com/alibaba/fastjon）</a></li>
<li>Google的GSON (<a href="javascript:void(0)">https://github.com/google/gson</a>)</li>
</ol>
<p>这几种json序列化工具中，Jackson与fastjson要比GSON的性能要好，但是Jackson、GSON的稳定性要比Fastjson好。而fastjson的优势在于提供的api非常容易使用	</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.serialize.json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.gxl.serialize.jdk.User;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonSerializer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;Mic&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> serializer(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化完成：&quot;</span> + json);</span><br><span class="line">        <span class="type">User</span> <span class="variable">nuser</span> <span class="operator">=</span> deserializer(json);</span><br><span class="line">        System.out.println(nuser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">serializer</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User <span class="title function_">deserializer</span><span class="params">(String json)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (User) JSON.parseObject(json, User.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a><strong>Hessian</strong></h4><p>Hessian是一个支持跨语言传输的二进制序列化协议，相对于Java默认的序列化机制来说，Hessian具有更好的性能和易用性，而且支持多种不同的语言</p>
<p>实际上Dubbo采用的就是Hessian序列化来实现，只不过Dubbo对Hessian进行了重构，性能更高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.serialize.hessian;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.caucho.hessian.io.HessianInput;</span><br><span class="line"><span class="keyword">import</span> com.caucho.hessian.io.HessianOutput;</span><br><span class="line"><span class="keyword">import</span> com.gxl.serialize.jdk.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HessianSerializer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;Mic&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes = serializer(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化完成&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">nuser</span> <span class="operator">=</span> deserializer(bytes);</span><br><span class="line">        System.out.println(nuser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] serializer(User user) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>(); <span class="comment">//表示输出到内存的实现</span></span><br><span class="line">        <span class="type">HessianOutput</span> <span class="variable">ho</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianOutput</span>(bos);</span><br><span class="line">        ho.writeObject(user);</span><br><span class="line">        <span class="keyword">return</span> bos.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User <span class="title function_">deserializer</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(data);</span><br><span class="line">        <span class="type">HessianInput</span> <span class="variable">hi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianInput</span>(bis);</span><br><span class="line">        <span class="keyword">return</span> (User) hi.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Protobuf序列化"><a href="#Protobuf序列化" class="headerlink" title="Protobuf序列化"></a>Protobuf序列化</h4><p>Protobuf是Google的一种数据交换格式，它独立于语言、独立于平台。Google提供了多种语言来实现，比如Java、C、Go、Python，每一种实现都包含了相应语言的编译器和库文件，Protobuf是一个纯粹的表示层协议，可以和各种传输层协议一起使用。</p>
<p>Protobuf使用比较广泛，主要是空间开销小和性能比较好，非常适合用于公司内部对性能要求高的RPC调用。 另外由于解析性能比较高，序列化以后数据量相对较少，所以也可以应用在对象的持久化场景中</p>
<p>但是要使用Protobuf会相对来说麻烦些，因为他有自己的语法，有自己的编译器，如果需要用到的话必须要去投入成本在这个技术的学习中</p>
<blockquote>
<p>protobuf有个缺点就是要传输的每一个类的结构都要生成对应的proto文件，如果某个类发生修改，还得重新生成该类对应的proto文件</p>
</blockquote>
<p>使用protobuf开发的一般步骤是</p>
<ol>
<li>配置开发环境，安装protocol compiler代码编译器</li>
<li>编写.proto文件，定义序列化对象的数据结构</li>
<li>基于编写的.proto文件，使用protocol compiler编译器生成对应的序列化&#x2F;反序列化工具类</li>
<li>基于自动生成的代码，编写自己的序列化应用</li>
</ol>
<h5 id="安装protobuf编译工具"><a href="#安装protobuf编译工具" class="headerlink" title="安装protobuf编译工具"></a>安装protobuf编译工具</h5><p>下载对应操作系统使用的protobuf包</p>
<p>编写proto文件</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;com.gxl.serialize.protobuf&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;UserProtos&quot;</span>;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span> &#123;  </span><br><span class="line">  <span class="keyword">required</span> <span class="type">int32</span>  age = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据类型说明如下：</p>
<ul>
<li><p>enum 枚举类</p>
</li>
<li><p>string &#x2F; bytes &#x2F; bool &#x2F; int32（4个字节）&#x2F;int64&#x2F;float&#x2F;double</p>
</li>
<li><p>message 自定义类</p>
</li>
<li><p>修饰符</p>
<ul>
<li>required 表示必填字段</li>
<li>optional 表示可选字段</li>
<li>repeated 可重复，表示集合</li>
<li>1，2，3，4需要在当前范围内是唯一的，表示顺序</li>
</ul>
</li>
<li><p>生成实例类，在cmd中运行如下命令</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc.exe --java_out=./ ./User.proto</span><br></pre></td></tr></table></figure>

<p>将生成的java文件拷贝到指定目录中</p>
<p><strong>测试代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.serialize.protobuf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.protobuf.ByteString;</span><br><span class="line"><span class="keyword">import</span> com.google.protobuf.InvalidProtocolBufferException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-31</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtobufSerializer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvalidProtocolBufferException &#123;</span><br><span class="line">        UserProtos.<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> UserProtos.User.newBuilder().setName(<span class="string">&quot;Mic&quot;</span>).setAge(<span class="number">18</span>).build();</span><br><span class="line">        <span class="type">ByteString</span> <span class="variable">bytes</span> <span class="operator">=</span> user.toByteString();</span><br><span class="line">        System.out.println(bytes.toByteArray().length);</span><br><span class="line">        UserProtos.<span class="type">User</span> <span class="variable">nUser</span> <span class="operator">=</span> UserProtos.User.parseFrom(bytes);</span><br><span class="line">        System.out.println(nUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Protobuf序列化原理解析"><a href="#Protobuf序列化原理解析" class="headerlink" title="Protobuf序列化原理解析"></a>Protobuf序列化原理解析</h5><p>正常来说，要达到最小的序列化结果，一定会用到压缩的技术，而protobuf里面用到了两种压缩算法，一种是varint，另一种是zigzag</p>
<p>先说第一种，我们先来看【Mic】是怎么被压缩的“Mic”这个字符，需要根据ASCII对照表转化为数字。M &#x3D;77、i&#x3D;105、c&#x3D;99，所以结果为 77 105 99</p>
<p>varint是对字节码做压缩，但是如果这个数字的二进制只需要一个字节表示的时候，其实最终编码出来的结果是不会变化的。 如果出现需要大于一个字节的方式来表示，则需要进行压缩。</p>
<p>采用T - L - V 的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑</p>
]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Gateway</title>
    <url>/2023/06/11/Spring-Cloud-Gateway/</url>
    <content><![CDATA[<p><strong>微服务网关就是一个系统，通过暴露该微服务网关系统，方便我们进行相关的鉴权，安全控制，日志统一处理，易于监控，限流等相关功能。</strong></p>
<h2 id="Gateway工作原理"><a href="#Gateway工作原理" class="headerlink" title="Gateway工作原理"></a>Gateway工作原理</h2><p><img src="1609152705386.png" alt="1609152705386"></p>
<p>Gateway的执行流程如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1:Gateway的客户端向Spring Cloud Gateway发起请求，请求首先会被HttpWebHandlerAdapter进行提取组装成网关的上下文，然后网关的上下文会传递到DispatcherHandler。</span><br><span class="line"></span><br><span class="line">2:DispatcherHandler是所有请求的分发处理器，DispatcherHandler主要负责分发请求对应的处理器，比如将请求分发到对应RoutePredicateHandlerMapping(路由断言处理器映射器）。</span><br><span class="line"></span><br><span class="line">3:路由断言处理映射器主要用于路由的查找，以及找到路由后返回对应的FilteringWebHandler。</span><br><span class="line"></span><br><span class="line">4:FilteringWebHandler主要负责组装Filter链表并调用Filter执行一系列Filter处理，然后把请求转到后端对应的代理服务处理，处理完毕后，将Response返回到Gateway客户端。</span><br><span class="line">在Filter链中，通过虚线分割Filter的原因是，过滤器可以在转发请求之前处理或者接收到被代理服务的返回结果之后处理。所有的Pre类型的Filter执行完毕之后，才会转发请求到被代理的服务处理。被代理的服务把所有请求完毕之后，才会执行Post类型的过滤器。</span><br></pre></td></tr></table></figure>

<h2 id="Gateway路由"><a href="#Gateway路由" class="headerlink" title="Gateway路由"></a>Gateway路由</h2><p>Gateway路由配置分为<strong>基于配置的静态路由</strong>设置和<strong>基于代码动态路由</strong>配置</p>
<p>静态路由是指在application.yml中把路由信息配置好了，而动态路由则支持在代码中动态加载路由信息，更加灵活，我们接下来把这2种路由操作都实现一次。</p>
<h3 id="基于配置路由设置"><a href="#基于配置路由设置" class="headerlink" title="基于配置路由设置"></a>基于配置路由设置</h3><p>配置参数说明：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">routes:路由配置</span><br><span class="line"><span class="bullet">-</span> id:唯一标识符</span><br><span class="line">uri:路由地址，可以是 lb://IP:端口     也可以是   lb://$&#123;spring.application.name&#125;</span><br><span class="line">predicates:断言，是指路由条件</span><br><span class="line"><span class="bullet">-</span> Path=/driver/<span class="strong">**:路由条件。Predicate 接受一个输入参数，返回一个布尔值结果。这里表示匹配所有以driver开始的请求。</span></span><br><span class="line"><span class="strong">filters:过滤器</span></span><br><span class="line"><span class="strong">- StripPrefix=1:真实路由的时候，去掉第1个路径，路径个数以/分割区分</span></span><br></pre></td></tr></table></figure>

<p>通过在配置文件中配置以上参数实现路由</p>
<h3 id="基于代码路由配置"><a href="#基于代码路由配置" class="headerlink" title="基于代码路由配置"></a>基于代码路由配置</h3><p>我们同样实现上面的功能，但这里基于代码方式实现。所有路由规则我们可以从数据库中读取并加载到程序中。基于代码的路由配置我们只需要创建<code>RouteLocator</code>并添加路由配置即可，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RouteLocator <span class="title function_">routeLocator</span><span class="params">(RouteLocatorBuilder builder)</span>&#123;</span><br><span class="line">       <span class="comment">//构建路由</span></span><br><span class="line">       <span class="keyword">return</span> builder.routes()</span><br><span class="line">               .route(<span class="string">&quot;order-route&quot;</span>,r-&gt; r.path(<span class="string">&quot;/order/**&quot;</span>).uri(<span class="string">&quot;lb://hailtaxi-order&quot;</span>))</span><br><span class="line">               .build();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在真实场景中，基于配置文件的方式更直观、简介，但代码的路由配置是更强大，可以实现很丰富的功能，可以把路由规则存在数据库中，每次直接从数据库中加载规则，这样的好处是可以动态刷新路由规则，通常应用于权限系统动态配置。</p>
<h3 id="Gateway-Predicate"><a href="#Gateway-Predicate" class="headerlink" title="Gateway-Predicate"></a>Gateway-Predicate</h3><p>上面路由匹配规则中我们都用了<code>- Path</code>方式，其实就是路径匹配方式，除了路径匹配方式，Gateway还支持很多丰富的匹配方式，我们对这些方式分别进行讲解。</p>
<p>routes下面的属性含义如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">id：我们自定义的路由 ID，保持唯一</span><br><span class="line"></span><br><span class="line">uri：目标服务地址</span><br><span class="line"></span><br><span class="line">predicates：路由条件，Predicate 接受一个输入参数，返回一个布尔值结果。该属性包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）</span><br></pre></td></tr></table></figure>

<p>Predicate 来源于 Java 8，Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）</p>
<p>在 Spring Cloud Gateway 中 Spring 利用 Predicate 的特性实现了各种路由匹配规则，通过 Header、请求参数等不同的条件来作为条件匹配到对应的路由。</p>
<p><img src="1609172632423.png" alt="1609172632423"></p>
<h4 id="Cookie："><a href="#Cookie：" class="headerlink" title="Cookie："></a><strong>Cookie：</strong></h4><p>Gateway的Cookie匹配接收两个参数：一个是 Cookie name ,一个是正则表达式。路由规则就是通过获取对应的 Cookie name 值和正则表达式去匹配，如果匹配上就会执行路由，如果没有匹配上则不执行。如下配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gateway:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">hailtaxi-driver</span></span><br><span class="line">    <span class="attr">uri:</span> <span class="string">lb://hailtaxi-driver</span></span><br><span class="line">    <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/driver/**</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Cookie=username,test</span></span><br></pre></td></tr></table></figure>

<p>这里表示请求携带了cookie为username的数据，并且值为test，就允许通过。</p>
<h4 id="Header-匹配："><a href="#Header-匹配：" class="headerlink" title="Header 匹配："></a><strong>Header 匹配：</strong></h4><p>Header 匹配 和 Cookie 匹配 一样，也是接收两个参数，一个 header 中属性名称和一个正则表达式，这个属性值和正则表达式匹配则执行。配置如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gateway:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">hailtaxi-driver</span></span><br><span class="line">    <span class="attr">uri:</span> <span class="string">lb://hailtaxi-driver</span></span><br><span class="line">    <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/driver/**</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Header=token,^(?!\d+$)[\da-zA-Z]+$</span></span><br></pre></td></tr></table></figure>

<p>上面的匹配规则，就是请求头要有token属性，并且值必须为数字和字母组合的正则表达式，例如携带token&#x3D;<code>19and30</code>就可以通过访问。</p>
<h4 id="请求方式匹配："><a href="#请求方式匹配：" class="headerlink" title="请求方式匹配："></a><strong>请求方式匹配：</strong></h4><p>通过请求的方式是 POST、GET、PUT、DELETE 等进行路由。配置如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gateway:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">hailtaxi-driver</span></span><br><span class="line">    <span class="attr">uri:</span> <span class="string">lb://hailtaxi-driver</span></span><br><span class="line">    <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/driver/**</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Method=GET,POST</span></span><br></pre></td></tr></table></figure>

<h2 id="Gateway过滤器"><a href="#Gateway过滤器" class="headerlink" title="Gateway过滤器"></a>Gateway过滤器</h2><p>Spring Cloud Gateway根据作用范围划分为<strong>GatewayFilter</strong>和<strong>GlobalFilter</strong>，二者区别如下：</p>
<ul>
<li>GatewayFilter : 需要通过spring.cloud.routes.filters 配置在具体路由下，只作用在当前路由上或通过spring.cloud.default-filters配置在全局，作用在所有路由上；gateway内置了多种过滤器工厂，配套的过滤器可以直接使用，如下图所示：</li>
</ul>
<p><img src="gateway30.png" alt="gateway30"></p>
<p><img src="gatewayfilter.png" alt="gatewayfilter"></p>
<ul>
<li>GlobalFilter : 全局过滤器，不需要在配置文件中配置，作用在所有的路由上，最终通过GatewayFilterAdapter包装成GatewayFilterChain可识别的过滤器，它为请求业务以及路由的URI转换为真实业务服务的请求地址的核心过滤器，不需要配置，系统初始化时加载，并作用在每个路由上。</li>
</ul>
<p><img src="1609180530575.png" alt="1609180530575"></p>
<p>过滤器作为Gateway的重要功能。常用于请求鉴权、服务调用时长统计、修改请求或响应header、限流、去除路径等等。</p>
<h3 id="过滤器分类"><a href="#过滤器分类" class="headerlink" title="过滤器分类"></a>过滤器分类</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">默认过滤器:出厂自带，实现好了拿来就用，不需要实现</span><br><span class="line">  全局默认过滤器</span><br><span class="line">  局部默认过滤器</span><br><span class="line">  </span><br><span class="line">自定义过滤器:根据需求自己实现，实现后需配置，然后才能用哦。</span><br><span class="line">  全局过滤器:作用在所有路由上。</span><br><span class="line">  局部过滤器:配置在具体路由下，只作用在当前路由上。</span><br></pre></td></tr></table></figure>

<p>默认过滤器十好几个，常见如下：</p>
<table>
<thead>
<tr>
<th>过滤器名称</th>
<th>说明</th>
<th>对应的类</th>
<th align="center">父类</th>
</tr>
</thead>
<tbody><tr>
<td>AddRequestHeader</td>
<td>对匹配上的请求加上Header</td>
<td>AddRequestHeaderGatewayFilterFactory</td>
<td align="center">AbstractNameValueGatewayFilterFactory</td>
</tr>
<tr>
<td>AddRequestParameters</td>
<td>对匹配上的请求路由</td>
<td>AddRequestHeaderGatewayFilterFactory</td>
<td align="center">AbstractNameValueGatewayFilterFactory</td>
</tr>
<tr>
<td>AddResponseHeader</td>
<td>对从网关返回的响应添加Header</td>
<td>AddResponseHeaderGatewayFilterFactory</td>
<td align="center">AbstractNameValueGatewayFilterFactory</td>
</tr>
<tr>
<td>StripPrefix</td>
<td>对匹配上的请求路径去除前缀</td>
<td>StripPrefixGatewayFilterFactory</td>
<td align="center">AbstractGatewayFilterFactory</td>
</tr>
</tbody></table>
<h3 id="默认过滤器的使用"><a href="#默认过滤器的使用" class="headerlink" title="默认过滤器的使用"></a>默认过滤器的使用</h3><p>所谓默认过滤器就是系统自带的。有很多，这里简要说明几个：（<strong>通过java配置，注释掉yaml配置</strong>）</p>
<p><strong>1)添加响应头</strong></p>
<p>AddResponseHeaderGatewayFilterFactory  属于  GatewayFilter</p>
<p>对输出响应头设置属性，比如对输出的响应设置其头部属性名称为：X-Response-Default-MyName , 值为test</p>
<p>修改配置文件，配置如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">     <span class="comment"># 配置全局默认过滤器 作用在所有路由上，也可单独为某个路由配置</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">      <span class="comment"># 往响应过滤器中加入信息</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddResponseHeader=X-Response-Default-MyName,test</span></span><br></pre></td></tr></table></figure>

<p><strong>2)前缀处理</strong></p>
<p>在项目中做开发对接接口的时候，我们很多时候需要统一API路径，比如统一以<code>/api</code>开始的请求调用<code>hailtaxi-driver</code>服务，但真实服务接口地址又没有<code>/api</code>路径，我们可以使用Gateway的过滤器处理请求路径。</p>
<p>在gateway中可以通过配置路由的过滤器StripPrefix实现映射路径中的前缀处理，我们来使用一下该过滤器，再进一步做说明。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gateway:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">hailtaxi-driver</span></span><br><span class="line">    <span class="attr">uri:</span> <span class="string">lb://hailtaxi-driver</span></span><br><span class="line">    <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/api/driver/**</span></span><br><span class="line">    <span class="attr">filters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">StripPrefix=1</span></span><br></pre></td></tr></table></figure>

<p>此处<code>- StripPrefix=1</code>表示真实请求地址是当前用户请求以<code>/api</code>开始的uri中去除第1个路径<code>/api</code>.</p>
<h3 id="自定义GatewayFilter"><a href="#自定义GatewayFilter" class="headerlink" title="自定义GatewayFilter"></a>自定义GatewayFilter</h3><h4 id="1、实现GatewayFilter接口"><a href="#1、实现GatewayFilter接口" class="headerlink" title="1、实现GatewayFilter接口"></a>1、实现GatewayFilter接口</h4><p>GatewayFilter 一般作用在某一个路由上，需要实例化创建才能使用，局部过滤器需要实现接口<code>GatewayFilter、Ordered</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-06-12</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DriverFilter</span> <span class="keyword">implements</span> <span class="title class_">GatewayFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;GatewayFilter拦截器执行---pre-----DriverFilter&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange).then(Mono.fromRunnable(() -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;GatewayFilter拦截器执行---post-----DriverFilter&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.filter.DriverFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.route.RouteLocator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 动态路由配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-06-12</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouteConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouteLocator <span class="title function_">routeLocator</span><span class="params">(RouteLocatorBuilder builder)</span>&#123;</span><br><span class="line">        <span class="comment">//构建路由</span></span><br><span class="line">        <span class="keyword">return</span> builder.routes()</span><br><span class="line">                .route(<span class="string">&quot;driver-route&quot;</span>,r-&gt; r.path(<span class="string">&quot;/driver/**&quot;</span>).uri(<span class="string">&quot;lb://hailtaxi-driver&quot;</span>).filter(<span class="keyword">new</span> <span class="title class_">DriverFilter</span>()))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、继承GatewayFilterFactory"><a href="#2、继承GatewayFilterFactory" class="headerlink" title="2、继承GatewayFilterFactory"></a>2、继承GatewayFilterFactory</h4><p>如果定义局部过滤器，想在配置文件中进行配置来使用，可以继承<code>AbstractGatewayFilterFactory&lt;T&gt;</code>抽象类或者<code>AbstractNameValueGatewayFilterFactory</code></p>
<p>整个体系结构为：</p>
<p><img src="gateway31.png" alt="gateway31"></p>
<p>这两个抽象类的区别就是前者接收一个参数（像StripPrefix和我们创建的这种），后者接收两个参数（像AddResponseHeader）</p>
<p>代码的编写可以参考：<code>StripPrefixGatewayFilterFactory</code> 和 <code>AddRequestHeaderGatewayFilterFactory</code></p>
<p><strong>过滤器工厂默认命名规则必须按照”名称”+GatewayFilterFactory&#96;，如上StripPrefixGatewayFilterFactory的过滤器名称为StripPrefix</strong></p>
<p><strong>2.1、继承<code>AbstractGatewayFilterFactory</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-06-13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DriverMethodGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;DriverMethodGatewayFilterFactory.Config&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DriverMethodGatewayFilterFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(Config.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Config config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (exchange, chain) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> config.getMethod();</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> config.getMsg();</span><br><span class="line">            log.info(<span class="string">&quot;DriverMethodGatewayFilterFactory 加载到的配置信息为:&#123;&#125;---&#123;&#125;&quot;</span>,method,msg);</span><br><span class="line">            <span class="comment">//将method添加到请求头中</span></span><br><span class="line">            exchange.getRequest().mutate().header(<span class="string">&quot;method&quot;</span>,method);</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">shortcutFieldOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//指定从yml中提前出来的配置信息填充到配置类中哪个属性,按规则配置</span></span><br><span class="line">        <span class="keyword">return</span>  Arrays.asList(<span class="string">&quot;method&quot;</span>,<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ShortcutType <span class="title function_">shortcutType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//默认规则</span></span><br><span class="line">        <span class="keyword">return</span> ShortcutType.DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String method;</span><br><span class="line">        <span class="keyword">private</span> String msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、配置文件中使用如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filters:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">DriverMethod=driver,test</span></span><br></pre></td></tr></table></figure>

<p><strong>2.2、继承<code>AbstractNameValueGatewayFilterFactory</code></strong></p>
<p>直接查看<code>AddRequestHeaderGatewayFilterFactory</code>源码，分析即可！</p>
<h3 id="自定义GlobalFilter"><a href="#自定义GlobalFilter" class="headerlink" title="自定义GlobalFilter"></a>自定义GlobalFilter</h3><p>定义全局过滤器需要实现GlobalFilter,Ordered接口：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">GlobalFilter:过滤器拦截处理方法</span><br><span class="line">Ordered:过滤器也有多个，这里主要定义过滤器执行顺序，里面有个方法getOrder()会返回过滤器执行顺序，返回值越小，越靠前执行</span><br></pre></td></tr></table></figure>

<p><strong>需求</strong>：</p>
<p>我们创建全局过滤器并完成常见业务用户权限校验，如果请求中有带有一个名字为<code>token</code>的请求参数，则认为请求有效放行，如果没有则拦截提示授权无效。</p>
<p>创建全局过滤器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-06-13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouterFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由拦截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;RouterFilter----------------&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="comment">//如果token为空，表示未登录</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token))&#123;</span><br><span class="line">            <span class="comment">//没登录，状态设置403</span></span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.PAYLOAD_TOO_LARGE);</span><br><span class="line">            <span class="comment">//结束请求</span></span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跨域配置"><a href="#跨域配置" class="headerlink" title="跨域配置"></a>跨域配置</h2><p>出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）。</p>
<p>在Spring Cloud Gateway中配置跨域是非常简单的，如下面<code>application.yml</code>所示：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gateway:</span></span><br><span class="line">  <span class="attr">globalcors:</span></span><br><span class="line">    <span class="attr">corsConfigurations:</span></span><br><span class="line">      <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">        <span class="attr">allowedOrigins:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">        <span class="attr">allowedMethods:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">GET</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">POST</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">PUT</span></span><br></pre></td></tr></table></figure>

<p>另外一种写法就需要创建<code>CorsWebFilter</code>过滤器，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置跨域</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CorsWebFilter <span class="title function_">corsFilter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">    <span class="comment">// cookie跨域</span></span><br><span class="line">    config.setAllowCredentials(Boolean.TRUE);</span><br><span class="line">    config.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    config.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="comment">// 配置前端js允许访问的自定义响应头</span></span><br><span class="line">    config.addExposedHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>(<span class="keyword">new</span> <span class="title class_">PathPatternParser</span>());</span><br><span class="line">    source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsWebFilter</span>(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>网关可以做很多的事情，比如，限流，当我们的系统 被频繁的请求的时候，就有可能 将系统压垮，所以 为了解决这个问题，需要在每一个微服务中做限流操作，但是如果有了网关，那么就可以在网关系统做限流，因为所有的请求都需要先通过网关系统才能路由到微服务中。</p>
<h3 id="令牌桶算法讲解"><a href="#令牌桶算法讲解" class="headerlink" title="令牌桶算法讲解"></a>令牌桶算法讲解</h3><p><img src="1609181986772.png" alt="1609181986772"></p>
<p>令牌桶算法是常见的限流算法之一，我们讲解一下漏桶算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）所有的请求在处理之前都需要拿到一个可用的令牌才会被处理；</span><br><span class="line">2）根据限流大小，设置按照一定的速率往桶里添加令牌；</span><br><span class="line">3）桶设置最大的放置令牌限制，当桶满时、新添加的令牌就被丢弃或者拒绝；</span><br><span class="line">4）请求达到后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑，处理完业务逻辑之后，将令牌直接删除；</span><br><span class="line">5）令牌桶有最低限额，当桶中的令牌达到最低限额的时候，请求处理完之后将不会删除令牌，以此保证足够的限流</span><br></pre></td></tr></table></figure>

<p>令牌桶算法的实现，有很多技术，Guaua是其中之一，redis客户端也有其实现。</p>
<p>spring cloud gateway 默认使用redis的RateLimter限流算法来实现，外面来简要实现一下：</p>
<p>1、引入依赖</p>
<p>首先需要引入redis的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis-reactive<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">redis:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>

<p>2、定义KeyResolver</p>
<p>在Application引导类中添加如下代码，KeyResolver用于计算某一个类型的限流的KEY也就是说，可以通过KeyResolver来指定限流的Key。</p>
<p>我们可以根据IP来限流，比如每个IP每秒钟只能请求一次，在GatewayApplication定义key的获取，获取客户端IP，将IP作为key，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * IP限流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean(name=&quot;ipKeyResolver&quot;)</span></span><br><span class="line"><span class="keyword">public</span> KeyResolver <span class="title function_">userKeyResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyResolver</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">resolve</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line">            <span class="comment">//获取远程客户端IP</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">hostName</span> <span class="operator">=</span> exchange.getRequest().getRemoteAddress().getAddress().getHostAddress();</span><br><span class="line">            System.out.println(<span class="string">&quot;hostName:&quot;</span>+hostName);</span><br><span class="line">            <span class="keyword">return</span> Mono.just(hostName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在路由中配置如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gateway:</span></span><br><span class="line">  <span class="comment">#路由配置</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="comment">#唯一标识符</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">hailtaxi-driver</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">lb://hailtaxi-driver</span></span><br><span class="line">      <span class="comment">#路由断言</span></span><br><span class="line">      <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/driver/**</span></span><br><span class="line">      <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RequestRateLimiter</span> <span class="comment">#请求数限流 名字不能随便写 ，使用默认的facatory</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="attr">key-resolver:</span> <span class="string">&quot;#&#123;@ipKeyResolver&#125;&quot;</span></span><br><span class="line">            <span class="attr">redis-rate-limiter.replenishRate:</span> <span class="number">1</span></span><br><span class="line">            <span class="attr">redis-rate-limiter.burstCapacity:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">redis-rate-limiter.replenishRate是您希望允许用户每秒执行多少请求，而不会丢弃任何请求。这是令牌桶填充的速率</span><br><span class="line">redis-rate-limiter.burstCapacity是指令牌桶的容量，允许在一秒钟内完成的最大请求数,将此值设置为零将阻止所有请求。</span><br><span class="line">key-resolver: “#&#123;@ipKeyResolver&#125;” 用于通过SPEL表达式来指定使用哪一个KeyResolver.</span><br></pre></td></tr></table></figure>

<p>如上配置： 表示 一秒内，允许 一个请求通过，令牌桶的填充速率也是一秒钟添加一个令牌。 最大突发状况 也只允许 一秒内有一次请求，可以根据业务来调整 。</p>
<h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><h3 id="Gateway工作流程源码剖析"><a href="#Gateway工作流程源码剖析" class="headerlink" title="Gateway工作流程源码剖析"></a>Gateway工作流程源码剖析</h3><h4 id="Gateway工作流程分析"><a href="#Gateway工作流程分析" class="headerlink" title="Gateway工作流程分析"></a>Gateway工作流程分析</h4>]]></content>
      <categories>
        <category>gateway</category>
        <category>网关</category>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>gateway</tag>
        <tag>网关</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud Consul</title>
    <url>/2023/03/02/SpringCloud-Consul/</url>
    <content><![CDATA[<h2 id="Consul介绍"><a href="#Consul介绍" class="headerlink" title="Consul介绍"></a>Consul介绍</h2><p>​		Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其它分布式服务注册与发现的方案，Consul 的方案更“一站式”，内置了服务注册与发现框 架、分布一致性协议实现、健康检查、Key&#x2F;Value 存储、多数据中心方案，不再需要依赖其它工具（比如 ZooKeeper 等）。使用起来也较 为简单。Consul 使用 Go 语言编写，因此具有天然可移植性(支持Linux、windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署，与Docker 等轻量级容器可无缝配合。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>服务发现</li>
<li>健康检查</li>
<li>Key&#x2F;Value 存储</li>
<li>多数据中心</li>
<li>社区活跃</li>
</ul>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>使用 Raft 算法来保证一致性, 比复杂的 Paxos 算法更直接. 相比较而言,zookeeper 采用的是 Paxos, 而 etcd 使用的则是 Raft。</li>
<li>支持多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障,而其部署则需要考虑网络延迟,分片等情况等。 zookeeper 和 etcd 均不提供多数据中心功能的支持。</li>
<li>支持健康检查。 etcd 不提供此功能。</li>
<li>支持 http 和 dns 协议接口。 zookeeper 的集成较为复杂, etcd 只支持http 协议</li>
<li>官方提供 web 管理界面, etcd 无此功能。</li>
<li>综合比较, Consul 作为服务注册和配置管理的新星, 比较值得关注和研究</li>
<li>提供了rest api 便于集成：<a href="https://www.consul.io/api-docs/index">https://www.consul.io/api-docs/index</a></li>
</ul>
<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul>
<li>client: 客户端, 无状态, 将 HTTP 和 DNS 接口请求转发给局域网内的服务端集群。</li>
<li>server: 服务端, 保存配置信息, 高可用集群, 在局域网内与本地客户端通讯, 通过广域网与其它数据中心通讯。 每个数据中心的 server 数量推荐为 3 个或是 5 个。</li>
</ul>
<p>Consul 客户端、服务端还支持夸中心的使用，更加提高了它的高可用性。</p>
<h2 id="Consul-基础架构"><a href="#Consul-基础架构" class="headerlink" title="Consul 基础架构"></a>Consul 基础架构</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li><p>agent</p>
<p>​		组成 consul 集群的每个成员上都要运行一个 agent，可以通过 consul agent 命令来启动。agent可以运行在 server 状态或者 client 状态。自然运行在 server 状态的节点被称为 server 节点；运行在 client 状态的节点被称为 client 节点</p>
</li>
<li><p>server 节点</p>
<p>​		负责组成 cluster 的复杂工作（选举server 自行选举一个 leader、状态维护、转发请求到 leader），以及 consul 提供的服务（响应RPC 请求），以及存放和复制数据。考虑到容错和收敛，一般部署 3 ~ 5 个比较合适。</p>
</li>
<li><p>client 节点</p>
<p>​		负责转发所有的 RPC 到 server 节点。本身无状态，且轻量级，因此，可以部署大量的client 节点。</p>
</li>
<li><p>数据中心</p>
<p>​		虽然数据中心的定义似乎很明显，但仍有一些细微的细节必须考虑。我们将一个数据中心定义为一个私有、低延迟和高带宽的网络环境。这不包括通过公共互联网的通信，但是为了我们的目的，单个EC2 区域内的多个可用区域将被视为单个数据中心的一部分。</p>
</li>
</ul>
<p>另外：</p>
<p>​		server 自行选举一个 leader。虽然 Consul 可以运行在一台 server ，但是建议使用 3 到 5 台来避免失败情况下数据的丢失。每个数据中心建议配置一个server 集群。</p>
<p>​		在基础设施中需要发现其他服务的组件可以查询任何一个 Consul 的server 或者agent，Agent 会自动转发请求到 server。</p>
<p>​		每个数据中心运行了一个 Consul server 集群。当一个跨数据中心的服务发现和配置请求创建时，本地 Consul Server 转发请求到远程的数据中心并返回结果。</p>
<h3 id="如何实现服务注册和发现"><a href="#如何实现服务注册和发现" class="headerlink" title="如何实现服务注册和发现"></a><strong>如何实现服务注册和发现</strong></h3><p><img src="1677740195077.jpg" alt="1677740195077"></p>
<p>工作原理：</p>
<ol>
<li>当Producer启动的时候，会向Consul发送一个post请求，并向Consul传输自己的IP和Port。</li>
<li>Consul 接收到Producer的注册后，每隔10s（默认）会向Producer发送一个健康检查的请求，检验Producer是否健康。</li>
<li>当Consumer以Http的方式向Producer发起请求，会先从Consul中拿到一个存储服务IP和Port的临时表，从表中拿到Producer的IP和Port后再发送请求。</li>
<li>该临时表每隔10s会更新，只包含有通过了健康检查的Producer。</li>
</ol>
<h2 id="Consul安装"><a href="#Consul安装" class="headerlink" title="Consul安装"></a>Consul安装</h2><p><strong>下载consul服务</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 从官网下载最新版本的Consul服务</span></span></span><br><span class="line">wget https://releases.hashicorp.com/consul/1.10.3/consul_1.10.3_linux_amd64.zip </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#使用unzip命令解压</span></span></span><br><span class="line">unzip consul_1.10.3_linux_amd64.zip </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#将解压好的consul可执行命令移动到/usr/local/bin目录下</span></span></span><br><span class="line">mv consul /usr/local/bin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#测试一下</span></span></span><br><span class="line">consul --version</span><br></pre></td></tr></table></figure>

<p><strong>启动consul服务</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// ip1</span><br><span class="line">consul agent -server -ui -bootstrap-expect=3 -data-dir=/data/consul -node=agent-1 -client=0.0.0.0 -bind=ip1 -datacenter=dc1</span><br><span class="line"> </span><br><span class="line">// ip2</span><br><span class="line">consul agent -server -ui -bootstrap-expect=3 -data-dir=/data/consul -node=agent-2 -client=0.0.0.0 -bind=ip2 -datacenter=dc1 -join ip1</span><br><span class="line"> </span><br><span class="line">// ip3</span><br><span class="line">consul agent -server -ui -bootstrap-expect=3 -data-dir=/data/consul -node=agent-3 -client=0.0.0.0 -bind=ip3 -datacenter=dc1 -join ip1</span><br></pre></td></tr></table></figure>

<p>​	<strong>参数解释：</strong></p>
<ul>
<li>-bootstrap-expect:集群期望的节点数，只有节点数量达到这个值才会选举leader。</li>
<li>-server： 运行在server模式</li>
<li>-client：consul服务侦听地址，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1所以不对外提供服务，如果你要对外提供服务改成0.0.0.0</li>
<li>-data-dir：指定数据目录，其他的节点对于这个目录必须有读的权限</li>
<li>-node：指定节点的名称</li>
<li>-bind：为该节点绑定一个地址</li>
<li>-config-dir：指定配置文件，定义服务的，默认所有一.json结尾的文件都会读</li>
<li>-enable-script-checks&#x3D;true：设置检查服务为可用</li>
<li>-datacenter: 数据中心名称</li>
</ul>
<p>-join：加入到已有的集群中</p>
<p> <strong>其他命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看集群成员</span></span><br><span class="line">consul members</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看集群状态</span></span><br><span class="line">consul info</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新加载配置文件</span></span><br><span class="line">consul reload</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">帮助</span></span><br><span class="line">consul agent -h</span><br></pre></td></tr></table></figure>

<p><strong>Consul 的 WebUI 控制台</strong></p>
<p><a href="http://ip1:8500/">http://ip1:8500</a></p>
]]></content>
      <categories>
        <category>Consul</category>
      </categories>
      <tags>
        <tag>注册中心</tag>
        <tag>Consul</tag>
      </tags>
  </entry>
  <entry>
    <title>Seata分布式事务</title>
    <url>/2023/06/05/Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h2><h3 id="事务的简介"><a href="#事务的简介" class="headerlink" title="事务的简介"></a>事务的简介</h3><p>​	事务是访问可能可能更新数据库各个数据项的一个程序执行单元。在关系数据库中，一个事务由一组SQL语句组成。事务具有四个属性：原子性、一致性、隔离性、持久性</p>
<p><strong>原子性：</strong>事务是一个不可分割的工作单位，事务中包括的操作要么都做，要么都不做</p>
<p><strong>一致性：</strong>事务必须是使数据库从一个一致性状态到另一个一致性状态，事务中间状态不能被观察到</p>
<p><strong>隔离性：</strong>一个事务的执行不能被其他事务干扰。即一个事务的内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。隔离性又分为四个级别：读未提交，读已提交，可重复读，串行化</p>
<p><strong>持久性：</strong>也称永久性，指一个事务一旦提交，他对数据库中数据改变应该是永久性的。接下来的其他操作或故障不应该对其有任何影响</p>
<h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h4 id="跨库事务"><a href="#跨库事务" class="headerlink" title="跨库事务"></a>跨库事务</h4><p>一个功能需要操作多个库，不同的库中存储不同的业务数据</p>
<h4 id="分库分表事务"><a href="#分库分表事务" class="headerlink" title="分库分表事务"></a>分库分表事务</h4><p>通常一个库数据量比较大或预期未来的数据量比较大，都会进行水平拆分，也就是分库分表</p>
<h4 id="跨应用事务"><a href="#跨应用事务" class="headerlink" title="跨应用事务"></a>跨应用事务</h4><h2 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h2><h3 id="CAP原理"><a href="#CAP原理" class="headerlink" title="CAP原理"></a>CAP原理</h3><p>在一个分布式系统中，当涉及读写操作时，只能保证一致性、可用性、分区容错性三者中的两个，另一个必须被牺牲</p>
<h4 id="C-Consistency-一致性"><a href="#C-Consistency-一致性" class="headerlink" title="C-Consistency 一致性"></a>C-Consistency 一致性</h4><p>对某个指定的客户端来说，读操作保证能够返回最新的写操作结果</p>
<p>这里并不是强调同一时刻拥有相同的数据，对于系统执行事务来说，在事务执行过程中，系统其实处于一个不一致的状态，不同的节点的数据并不完全一致</p>
<p>一致性强调客户端读操作能获取最新的写操作的结果，是因为事务在执行过程中，客户端是无法读取到未提交的数据的，只有等到事务提交后，客户端才能读到事务写入的数据，而如果事务失败则会进行回滚，客户端也不会读取到事务中间写入的数据</p>
<h4 id="A-Availability-可用性"><a href="#A-Availability-可用性" class="headerlink" title="A-Availability 可用性"></a>A-Availability 可用性</h4><p>非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应）。</p>
<p>这里强调的是合理的响应，不能超时，不能出错。注意并没有说“正确”的结果，例如，应该返回 100 但实际上返回了 90，肯定是不正确的结果，但可以是一个合理的结果。</p>
<h4 id="P-Partition-Tolerance-分区容忍性"><a href="#P-Partition-Tolerance-分区容忍性" class="headerlink" title="P-Partition Tolerance 分区容忍性"></a>P-Partition Tolerance 分区容忍性</h4><p>当出现<strong>网络分区</strong>后，系统能够继续“履行职责”。</p>
<p>这里<strong>网络分区</strong>是指： 一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障（节点间网络连接断开、节点宕机），使得有些节点之间不连通了，整个网络就分成了几块区域，数据就散布在了这些不连通的区域中。</p>
<h4 id="CAP-的选择"><a href="#CAP-的选择" class="headerlink" title="CAP 的选择"></a>CAP 的选择</h4><p>虽然 CAP 理论定义是三个要素中只能取两个，但放到分布式环境下来思考，我们会发现必须选择 P（分区容忍）要素，因为网络本身无法做到 100% 可靠，有可能出故障，所以分区是一个必然的现象</p>
<p>为什么必须要选择P:</p>
<p>如果我们选择了 CA（一致性 + 可用性） 而放弃了 P（分区容忍性），那么当发生分区现象时，为了保证 C（一致性），系统需要禁止写入，当有写入请求时，系统返回 error（例如，当前系统不允许写入），这又和 A(可用性) 冲突了，因为 A（可用性）要求返回 no error 和 no timeout。</p>
<p>因此，分布式系统理论上不可能选择 CA （一致性 + 可用性）架构，<strong>只能选择 CP（一致性 + 分区容忍性） 或者 AP （可用性 + 分区容忍性）架构，在一致性和可用性做折中选择</strong>。</p>
<p>针对这两种选择再来看一下：</p>
<p><strong>1、CP - Consistency + Partition Tolerance （一致性 + 分区容忍性）</strong></p>
<p><img src="cap1.png" alt="cap1"></p>
<p>如上图所示，因为Node1节点和Node2节点连接中断导致分区现象，Node1节点的数据已经更新到y，但是Node1 和 Node2 之间的复制通道中断，数据 y 无法同步到 Node2，Node2 节点上的数据还是旧数据x。</p>
<p>这时客户端C 访问 Node2 时，Node2 需要返回 Error，提示客户端 “系统现在发生了错误”，这种处理方式违背了可用性（Availability）的要求，因此 CAP 三者只能满足 CP。</p>
<p><strong>2、AP - Availability + Partition Tolerance （可用性 + 分区容忍性）</strong></p>
<p><img src="cap2.png" alt="cap2"></p>
<p> 同样是Node2 节点上的数据还是旧数据x，这时客户端C 访问 Node2 时，Node2 将当前自己拥有的数据 x 返回给客户端 了，而实际上当前最新的数据已经是 y 了，这就不满足一致性（Consistency）的要求了，因此 CAP 三者只能满足 AP。</p>
<p><strong>注意</strong>：这里 Node2 节点返回 x，虽然不是一个“正确”的结果，但是一个“合理”的结果，因为 x 是旧的数据，并不是一个错乱的值，只是不是最新的数据。</p>
<p><strong>值得补充的是：</strong>CAP理论告诉我们<strong>分布式系统只能选择AP或者CP</strong>，但实际上并不是说整个系统只能选择AP或者CP，在 CAP 理论落地实践时，我们需要将系统内的数据按照不同的应用场景和要求进行分类，每类数据选择不同的策略（CP 还是 AP），而不是直接限定整个系统所有数据都是同一策略。</p>
<p> <strong>另外，只能选择CP或者AP是指系统发生分区现象时无法同时保证C（一致性）和A（可用性），但不是意味着什么都不做，当分区故障解决后，系统还是要保持保证CA。也就是说选了AP不意味着放弃了C，选了CP不意味着放弃了A</strong></p>
<h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p><img src="base.png" alt="base"></p>
<p>BASE 是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency），是基于CAP定理演化而来，是对CAP中一致性和可用性权衡的结果；核心思想是即使无法做到强一致性（CAP 的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性。</p>
<h4 id="BA-Basically-Available基本可用"><a href="#BA-Basically-Available基本可用" class="headerlink" title="BA-Basically Available基本可用"></a>BA-Basically Available基本可用</h4><blockquote>
<p>分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</p>
</blockquote>
<p>这里的关键词是“<strong>部分</strong>”和“<strong>核心</strong>”，实际实践上，哪些是核心需要根据具体业务来权衡。例如登录功能相对注册功能更加核心，注册不了最多影响流失一部分用户，如果用户已经注册但无法登录，那就意味用户无法使用系统，造成的影响范围更大。</p>
<h4 id="S-Soft-State-软状态"><a href="#S-Soft-State-软状态" class="headerlink" title="S-Soft State 软状态"></a>S-Soft State 软状态</h4><p>允许系统存在中间状态，而该中间状态不会影响系统整体可用性。这里的中间状态就是 CAP 理论中的数据不一致。</p>
<h4 id="E-Eventual-Consistency-最终一致性"><a href="#E-Eventual-Consistency-最终一致性" class="headerlink" title="E-Eventual Consistency 最终一致性"></a>E-Eventual Consistency 最终一致性</h4><blockquote>
<p>系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。</p>
</blockquote>
<p>这里的关键词是“一定时间” 和 “最终”，“<strong>一定时间</strong>”和数据的特性是强关联的，不同业务不同数据能够容忍的不一致时间是不同的。例如支付类业务是要求秒级别内达到一致，因为用户时时关注；用户发的最新微博，可以容忍30分钟内达到一致的状态，因为用户短时间看不到明星发的微博是无感知的。而“<strong>最终</strong>”的含义就是不管多长时间，最终还是要达到一致性的状态。</p>
<p><strong>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充：</strong></p>
<ul>
<li><p><strong>CP 理论是忽略延时的，而实际应用中延时是无法避免的。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这一点就意味着完美的 CP 场景是不存在的，即使是几毫秒的数据复制延迟，在这几毫秒时间间隔内，系统是不符合 CP 要求的。因此 CAP 中的 CP 方案，实际上也是实现了最终一致性，只是“一定时间”是指几毫秒而已。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>AP 方案中牺牲一致性只是指发生分区故障期间，而不是永远放弃一致性。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这一点其实就是 BASE 理论延伸的地方，分区期间牺牲一致性，但分区故障恢复后，系统应该达到最终一致性。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="刚柔事务"><a href="#刚柔事务" class="headerlink" title="刚柔事务"></a>刚柔事务</h3><p>何谓刚柔事务？刚性事务它的事务是原子的，要么都成功要么都失败，也就是需要保障ACID理论，而柔性事务只需要保障数据最终一致即可，需要遵循BASE理论。</p>
<ul>
<li>刚性事务满足ACID理论</li>
<li>柔性事务满足BASE理论（基本可用，最终一致）</li>
</ul>
<p>基于BASE理论的设计思想，柔性事务下，在不影响系统整体可用性的情况下(Basically Available 基本可用)，允许系统存在数据不一致的中间状态(Soft State 软状态)，在经过数据同步的延时之后，最终数据能够达到一致。<strong>并不是完全放弃了ACID，而是通过放宽一致性要求，借助本地事务来实现最终分布式事务一致性的同时也保证系统的吞吐</strong>。</p>
<h2 id="常用事务解决方案模型"><a href="#常用事务解决方案模型" class="headerlink" title="常用事务解决方案模型"></a>常用事务解决方案模型</h2><p>分布式事务解决方案几乎都是柔性事务，分布式事务的实现有许多种，其中较经典是由Tuxedo提出的XA分布式事务协议，XA协议包含二阶段提交（2PC）和三阶段提交（3PC）两种实现。</p>
<p>其他还有 TCC、MQ 等最终一致性解决方案，至于工作中用哪种方案，需要根据业务场景选取，<code>2PC/3PC、TCC</code>数据强一致性高，而MQ是最终数据一致。</p>
<h3 id="DTP模型"><a href="#DTP模型" class="headerlink" title="DTP模型"></a>DTP模型</h3><p> X&#x2F;Open DTP(X&#x2F;Open Distributed Transaction Processing Reference Model) 是X&#x2F;Open 这个组织定义的一套分布式事务的标准，也就是了定义了规范和API接口，由厂商进行具体的实现</p>
<p><strong>X&#x2F;Open DTP中的角色</strong></p>
<p><img src="sw.webp" alt="sw"></p>
<p>**AP(Application Program)**：应用程序，主要是定义事务边界以及那些组成事务的特定于应用程序的操作。</p>
<p>**RM(Resouces Manager)**：资源管理器，管理一些共享资源的自治域，如提供对诸如数据库之类的共享资源的访问。譬如：数据库、文件系统等，并且提供了这些资源的访问方式。</p>
<p>**TM(Transaction Manager)**：事务管理器，管理全局事务，协调事务的提交或者回滚，并协调故障恢复。</p>
<p>DTP模型里面定义了XA协议接口，TM 和 RM 通过XA接口进行双向通信</p>
<h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><blockquote>
<p><code>2PC</code>、<code>3PC</code>，都是基于 <code>XA</code> 协议的</p>
</blockquote>
<h4 id="方案简介"><a href="#方案简介" class="headerlink" title="方案简介"></a>方案简介</h4><p>二阶段提交协议（Two-phase Commit，即2PC）是常用的分布式事务解决方案，即将事务的提交过程分为两个阶段来进行处理：<strong>准备阶段和提交阶段。事务的发起者称协调者，事务的执行者称参与者</strong>。</p>
<p>在分布式系统里，每个节点都可以知晓自己操作的成功或者失败，却无法知道其他节点操作的成功或失败。当一个事务跨多个节点时，为了保持事务的原子性与一致性，而引入一个协调者来统一掌控所有参与者的操作结果，并指示它们是否要把操作结果进行真正的提交或者回滚（rollback）。</p>
<p>二阶段提交的算法思路可以概括为：<strong>参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作</strong>。</p>
<p>核心思想就是对每一个事务都采用先尝试后提交的处理方式，处理后所有的读操作都要能获得最新的数据，因此也可以将二阶段提交看作是一个强一致性算法。</p>
<h4 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h4><blockquote>
<p>简单一点理解，可以把协调者节点比喻为带头大哥，参与者理解比喻为跟班小弟，带头大哥统一协调跟班小弟的任务执行。</p>
</blockquote>
<h5 id="阶段1：准备阶段"><a href="#阶段1：准备阶段" class="headerlink" title="阶段1：准备阶段"></a>阶段1：准备阶段</h5><blockquote>
<ul>
<li>1、协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待所有参与者答复。</li>
<li>2、各参与者执行事务操作，将undo和redo信息记入事务日志中（但不提交事务）。</li>
<li>3、如参与者执行成功，给协调者反馈yes，即可以提交；如执行失败，给协调者反馈no，即不可提交。</li>
</ul>
</blockquote>
<h5 id="阶段2：提交阶段"><a href="#阶段2：提交阶段" class="headerlink" title="阶段2：提交阶段"></a>阶段2：提交阶段</h5><p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(rollback)消息；否则，发送提交(commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源) </p>
<p>接下来分两种情况分别讨论提交阶段的过程。</p>
<p><strong>情况1，当所有参与者均反馈yes，提交事务</strong>：</p>
<p><img src="transaction09.png" alt="transaction09"></p>
<ul>
<li>1、协调者向所有参与者发出正式提交事务的请求（即commit请求）。</li>
<li>2、参与者执行commit请求，并释放整个事务期间占用的资源。</li>
<li>3、各参与者向协调者反馈ack(应答)完成的消息。</li>
<li>4、协调者收到所有参与者反馈的ack消息后，即完成事务提交</li>
</ul>
<p><strong>情况2，当任何阶段1一个参与者反馈no，中断事务</strong>：</p>
<p><img src="transaction10.png" alt="transaction10"></p>
<blockquote>
<ul>
<li>1、协调者向所有参与者发出回滚请求（即rollback请求）。</li>
<li>2、参与者使用阶段1中的undo信息执行回滚操作，并释放整个事务期间占用的资源。</li>
<li>3、各参与者向协调者反馈ack完成的消息。</li>
<li>4、协调者收到所有参与者反馈的ack消息后，即完成事务中断。</li>
</ul>
</blockquote>
<h4 id="方案总结"><a href="#方案总结" class="headerlink" title="方案总结"></a>方案总结</h4><p>2PC是一个强一致性的同步阻塞协议，事务执⾏过程中需要将所需资源全部锁定，也就是俗称的 <code>刚性事务</code></p>
<p>2PC方案实现起来简单，实际项目中使用比较少，主要因为以下问题：</p>
<ul>
<li>性能问题 所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。</li>
<li>可靠性问题 如果协调者存在单点故障问题，如果协调者出现故障，参与者将一直处于锁定状态。</li>
<li>数据一致性问题 在阶段2中，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。</li>
</ul>
<h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><h4 id="方案简介-1"><a href="#方案简介-1" class="headerlink" title="方案简介"></a>方案简介</h4><p>三阶段提交协议，是二阶段提交协议的改进版本，与二阶段提交不同的是，引入超时机制。同时在协调者和参与者中都引入超时机制（<code>2PC</code> 中只有协调者有超时机制）。</p>
<p>三阶段提交将二阶段的准备阶段拆分为2个阶段，插入了一个preCommit阶段，使得原先在二阶段提交中，参与者在准备之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。</p>
<h4 id="处理流程-1"><a href="#处理流程-1" class="headerlink" title="处理流程"></a>处理流程</h4><h5 id="阶段1：canCommit"><a href="#阶段1：canCommit" class="headerlink" title="阶段1：canCommit"></a>阶段1：canCommit</h5><p>协调者向参与者发送canCommit请求，参与者如果可以提交就返回yes响应(参与者不执行事务操作)，否则返回no响应：</p>
<blockquote>
<ul>
<li>1、协调者向所有参与者发出包含事务内容的canCommit请求，询问是否可以提交事务，并等待所有参与者答复。</li>
<li>2、参与者收到canCommit请求后，如果认为可以执行事务操作，则反馈yes并进入预备状态，否则反馈no。</li>
</ul>
</blockquote>
<h5 id="阶段2：preCommit"><a href="#阶段2：preCommit" class="headerlink" title="阶段2：preCommit"></a>阶段2：preCommit</h5><p>协调者根据阶段1 canCommit参与者的反应情况来决定是否可以基于事务的preCommit操作。根据响应情况，有以下两种可能。</p>
<p><strong>情况1，阶段1所有参与者均反馈yes，参与者预执行事务：</strong></p>
<p><img src="transaction11.png" alt="transaction11"></p>
<ul>
<li>1、协调者向所有参与者发出preCommit请求，进入准备阶段。</li>
<li>2、参与者收到preCommit请求后，执行事务操作，将undo和redo信息记入事务日志中（但不提交事务）。</li>
<li>3、各参与者向协调者反馈ack响应或no响应，并等待最终指令</li>
</ul>
<p><strong>情况2，阶段1任何一个参与者反馈no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务:</strong></p>
<p><img src="transaction12.png" alt="transaction12"></p>
<ul>
<li>1、协调者向所有参与者发出abort请求。</li>
<li>2、无论收到协调者发出的abort请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。</li>
</ul>
<h5 id="阶段3：do-Commit"><a href="#阶段3：do-Commit" class="headerlink" title="阶段3：do Commit"></a>阶段3：do Commit</h5><blockquote>
<p>该阶段进行真正的事务提交，也可以分为以下两种情况：</p>
</blockquote>
<p><strong>情况1：阶段2所有参与者均反馈ack响应，执行真正的事务提交：</strong></p>
<p><img src="transaction13.png" alt="transaction13"></p>
<ul>
<li>1、如果协调者处于工作状态，则向所有参与者发出do Commit请求。</li>
<li>2、参与者收到do Commit请求后，会正式执行事务提交，并释放整个事务期间占用的资源。</li>
<li>3、各参与者向协调者反馈ack完成的消息。</li>
<li>4、协调者收到所有参与者反馈的ack消息后，即完成事务提交</li>
</ul>
<p><strong>阶段2任何一个参与者反馈no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务：</strong></p>
<p><img src="transaction14.png" alt="transaction14"></p>
<ul>
<li>1、如果协调者处于工作状态，向所有参与者发出abort请求。</li>
<li>2、参与者使用阶段1中的undo信息执行回滚操作，并释放整个事务期间占用的资源。</li>
<li>3、各参与者向协调者反馈ack完成的消息。</li>
<li>4、协调者收到所有参与者反馈的ack消息后，即完成事务中断</li>
</ul>
<p><strong>注意</strong>：进入阶段3后，如果协调者出现问题，或者协调者与参与者网络出现问题，都会导致参与者无法接收到协调者发出的do Commit请求或rollback请求。此时，参与者都会在等待超时之后，继续执行事务提交。</p>
<p>阶段三 只允许成功不允许失败，如果服务器宕机或者停电，因为记录的阶段二的数据，重启服务后在提交事务，所以，到了阶段三，失败了也不进行回滚，<strong>只允许成功</strong>。</p>
<h4 id="方案总结-1"><a href="#方案总结-1" class="headerlink" title="方案总结"></a>方案总结</h4><p>优点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相比二阶段提交，三阶段提交降低了阻塞范围，在等待超时后协调者或参与者会中断事务。避免了协调者单点问题，阶段3中协调者出现问题时，参与者会继续提交事务。</span><br></pre></td></tr></table></figure>

<p>缺点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据不一致问题依然存在，当在参与者收到preCommit请求后等待do commit指令时，此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。</span><br></pre></td></tr></table></figure>

<h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><h4 id="方案简介-2"><a href="#方案简介-2" class="headerlink" title="方案简介"></a>方案简介</h4><p><strong>TCC（Try-Confirm-Cancel）的概念，最早是由Pat Helland于2007年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。</strong></p>
<p><strong>TCC是服务化的二阶段编程模型，其Try、Confirm、Cancel 3个方法均由业务编码实现，基本类似两阶段提交</strong></p>
<ul>
<li>Try操作作为一阶段，负责资源的检查和预留。</li>
<li>Confirm操作作为二阶段提交操作，执行真正的业务。</li>
<li>Cancel是预留资源的取消。</li>
</ul>
<p>TCC事务的Try、Confirm、Cancel可以理解为SQL事务中的Lock、Commit、Rollback。</p>
<p><code>TCC</code> 为在业务层编写代码实现的两阶段提交。<code>TCC</code> 分别指 <code>Try</code>、<code>Confirm</code>、<code>Cancel</code> ，一个业务操作要对应的写这三个方法。</p>
<h4 id="处理流程-2"><a href="#处理流程-2" class="headerlink" title="处理流程"></a>处理流程</h4><h5 id="阶段1：Try-阶段"><a href="#阶段1：Try-阶段" class="headerlink" title="阶段1：Try 阶段"></a>阶段1：Try 阶段</h5><p>从执行阶段来看，与传统事务机制中业务逻辑相同。但从业务角度来看，却不一样。TCC机制中的Try仅是一个初步操作，它和后续的确认一起才能真正构成一个完整的业务逻辑，这个阶段主要完成：</p>
<ul>
<li>完成所有业务检查( 一致性 )</li>
<li>预留必须业务资源( 准隔离性 )</li>
<li>Try 尝试执行业务 TCC事务机制以初步操作（Try）为中心的，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。因此，Try阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其执行结果撤销</li>
</ul>
<p><img src="transaction15.png" alt="transaction15"></p>
<h5 id="阶段2：Confirm-x2F-Cancel-阶段"><a href="#阶段2：Confirm-x2F-Cancel-阶段" class="headerlink" title="阶段2：Confirm &#x2F; Cancel 阶段"></a>阶段2：Confirm &#x2F; Cancel 阶段</h5><blockquote>
<p>根据Try阶段服务是否全部正常执行，继续执行确认操作（Confirm）或取消操作（Cancel）。 Confirm和Cancel操作满足幂等性，如果Confirm或Cancel操作执行失败，将会不断重试直到执行完成。</p>
</blockquote>
<h6 id="Confirm：确认"><a href="#Confirm：确认" class="headerlink" title="Confirm：确认"></a>Confirm：确认</h6><blockquote>
<p><strong>当Try阶段服务全部正常执行， 执行确认业务逻辑操作</strong></p>
</blockquote>
<p><img src="transaction16.png" alt="transaction16"></p>
<blockquote>
<p>这里使用的资源一定是Try阶段预留的业务资源。在TCC事务机制中认为，如果在Try阶段能正常的预留资源，那Confirm一定能完整正确的提交。Confirm阶段也可以看成是对Try阶段的一个补充，Try+Confirm一起组成了一个完整的业务逻辑。</p>
</blockquote>
<h6 id="Cancel：取消"><a href="#Cancel：取消" class="headerlink" title="Cancel：取消"></a>Cancel：取消</h6><blockquote>
<p><strong>当Try阶段存在服务执行失败， 进入Cancel阶段</strong></p>
</blockquote>
<p><img src="transaction17.png" alt="transaction17"></p>
<blockquote>
<p>Cancel取消执行，释放Try阶段预留的业务资源，上面的例子中，Cancel操作会把冻结的库存释放，并更新订单状态为取消。</p>
</blockquote>
<h4 id="方案总结-2"><a href="#方案总结-2" class="headerlink" title="方案总结"></a>方案总结</h4><p>TCC事务机制相对于传统事务机制（X&#x2F;Open XA），TCC事务机制相比于上面介绍的XA事务机制，有以下优点:</p>
<p>-<br>  性能提升 具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。</p>
<ul>
<li>数据最终一致性 基于Confirm和Cancel的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。</li>
<li>可靠性 解决了XA协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。</li>
</ul>
<p>缺点：TCC的Try、Confirm和Cancel操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。</p>
<h3 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h3><h4 id="方案简介-3"><a href="#方案简介-3" class="headerlink" title="方案简介"></a>方案简介</h4><p>本地消息表的方案最初是由ebay提出，核心思路是将分布式事务拆分成本地事务进行处理。</p>
<p> 方案通过在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。</p>
<p> 这样设计可以避免”<strong>业务处理成功 + 事务消息发送失败</strong>“，或”<strong>业务处理失败 + 事务消息发送成功</strong>“的棘手情况出现，保证2个系统事务的数据一致性。</p>
<h4 id="处理流程-3"><a href="#处理流程-3" class="headerlink" title="处理流程"></a>处理流程</h4><p> 下面把分布式事务最先开始处理的事务方成为事务主动方，在事务主动方之后处理的业务内的其他事务成为事务被动方。</p>
<p> 为了方便理解，下面继续以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建2个步骤，库存服务和订单服务分别在不同的服务器节点上，其中库存服务是事务主动方，订单服务是事务被动方。</p>
<p>事务的主动方需要额外新建事务消息表，用于记录分布式事务的消息的发生、处理状态。</p>
<p><strong>整个业务处理流程如下：</strong></p>
<p><img src="transaction18.png" alt="transaction18"></p>
<blockquote>
<p><strong>步骤1 事务主动方处理本地事务。</strong> 事务主动方在本地事务中处理业务更新操作和写消息表操作。 上面例子中库存服务阶段在本地事务中完成扣减库存和写消息表(图中1、2)。</p>
<p><strong>步骤2 事务主动方通过消息中间件，通知事务被动方处理事务通知事务待消息</strong>。 消息中间件可以基于Kafka、RocketMQ消息队列，事务主动方法主动写消息到消息队列，事务消费方消费并处理消息队列中的消息。 上面例子中，库存服务把事务待处理消息写到消息中间件，订单服务消费消息中间件的消息，完成新增订单（图中3 - 5）。</p>
<p><strong>步骤3 事务被动方通过消息中间件，通知事务主动方事务已处理的消息。</strong> 上面例子中，订单服务把事务已处理消息写到消息中间件，库存服务消费中间件的消息，并将事务消息的状态更新为已完成(图中6 - 8)</p>
</blockquote>
<p> 为了数据的一致性，当处理错误需要重试，事务发送方和事务接收方相关业务处理需要支持幂等。具体保存一致性的容错处理如下：</p>
<blockquote>
<p>1、当步骤1处理出错，事务回滚，相当于什么都没发生。</p>
<p>2、当步骤2、步骤3处理出错，由于未处理的事务消息还是保存在事务发送方，事务发送方可以定时轮询为超时消息数据，再次发送的消息中间件进行处理。事务被动方消费事务消息重试处理。</p>
<p>3、如果是业务上的失败，事务被动方可以发消息给事务主动方进行回滚。</p>
<p>4、如果多个事务被动方已经消费消息，事务主动方需要回滚事务时需要通知事务被动方回滚</p>
</blockquote>
<h4 id="方案总结-3"><a href="#方案总结-3" class="headerlink" title="方案总结"></a>方案总结</h4><p>方案的优点如下：</p>
<ul>
<li>从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对MQ中间件特性的依赖。</li>
<li>方案轻量，容易实现。</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>与具体的业务场景绑定，耦合性强，不可共用。</li>
<li>消息数据与业务数据同库，占用业务系统资源。</li>
<li>业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限</li>
</ul>
<h3 id="MQ事务"><a href="#MQ事务" class="headerlink" title="MQ事务"></a>MQ事务</h3><p>MQ事务保证最终一致性。</p>
<h4 id="方案简介-4"><a href="#方案简介-4" class="headerlink" title="方案简介"></a>方案简介</h4><p>基于MQ的分布式事务方案其实是对本地消息表的封装，将本地消息表存于MQ 内部，其他方面的协议基本与本地消息表一致。</p>
<h4 id="处理流程-4"><a href="#处理流程-4" class="headerlink" title="处理流程"></a>处理流程</h4><p>下面主要基于RocketMQ4.3之后的版本介绍MQ的分布式事务方案。</p>
<p>在本地消息表方案中，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务，RocketMQ的事务消息相对于普通MQ，相对于提供了2PC的提交接口，方案如下：</p>
<h5 id="正常情况——事务主动方发消息"><a href="#正常情况——事务主动方发消息" class="headerlink" title="正常情况——事务主动方发消息"></a>正常情况——事务主动方发消息</h5><p>这种情况下，事务主动方服务正常，没有发生故障，发消息流程如下：</p>
<p><img src="transaction19.png" alt="transaction19"></p>
<p>1、发送方向 MQ服务端(MQ Server)发送half消息。</p>
<p>2、MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功。</p>
<p>3、发送方开始执行本地事务逻辑。</p>
<p>4、发送方根据本地事务执行结果向 MQ Server 提交二次确认（commit 或是 rollback）。</p>
<p>5、MQ Server 收到 commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 rollback 状态则删除半消息，订阅方将不会接受该消息。</p>
<h5 id="异常情况——事务主动方消息恢复"><a href="#异常情况——事务主动方消息恢复" class="headerlink" title="异常情况——事务主动方消息恢复"></a>异常情况——事务主动方消息恢复</h5><p>在断网或者应用重启等异常情况下，图中第4步提交的二次确认超时未到达 MQ Server，此时处理逻辑如下：</p>
<p><img src="transaction20.png" alt="transaction20"></p>
<p>5、MQ Server 对该消息发起消息回查。</p>
<p>6、发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</p>
<p>7、发送方根据检查得到的本地事务的最终状态再次提交二次确认</p>
<p>8、MQ Server基于commit &#x2F; rollback 对消息进行投递或者删除</p>
<p>介绍完RocketMQ的事务消息方案后，由于前面已经介绍过本地消息表方案，这里就简单介绍RocketMQ分布式事务：</p>
<p><img src="transaction21.png" alt="transaction21"></p>
<p>事务主动方基于MQ通信通知事务被动方处理事务，事务被动方基于MQ返回处理结果。 如果事务被动方消费消息异常，需要不断重试，业务处理逻辑需要保证幂等。 如果是事务被动方业务上的处理失败，可以通过MQ通知事务主动方进行补偿或者事务回滚。</p>
<h4 id="方案总结-4"><a href="#方案总结-4" class="headerlink" title="方案总结"></a>方案总结</h4><p>相比本地消息表方案，MQ事务方案优点是：</p>
<ul>
<li>消息数据独立存储 ，降低业务系统与消息系统之间的耦合。</li>
<li>吞吐量优于使用本地消息表方案。</li>
</ul>
<p>缺点是：</p>
<ul>
<li>一次消息发送需要两次网络请求(half消息 + commit&#x2F;rollback消息)</li>
<li>业务处理服务需要实现消息状态回查接口</li>
</ul>
<h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><p>Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。在 Seata 开源之前，Seata 对应的内部版本在阿里经济体内部一直扮演着分布式一致性中间件的角色，帮助经济体平稳的度过历年的双11，对各BU业务进行了有力的支撑。经过多年沉淀与积累，商业化产品先后在阿里云、金融云进行售卖。2019.1 为了打造更加完善的技术生态和普惠技术成果，Seata 正式宣布对外开源，开放以来，广受欢迎，不到一年已经成为最受欢迎的分布式事务解决方案。</p>
<h3 id="Seata术语"><a href="#Seata术语" class="headerlink" title="Seata术语"></a>Seata术语</h3><p><strong>TC (Transaction Coordinator) - 事务协调者</strong></p>
<p>维护全局和分支事务的状态，驱动全局事务提交或回滚。</p>
<p><strong>TM (Transaction Manager) - 事务管理器</strong></p>
<p>定义全局事务的范围：开始全局事务、提交或回滚全局事务。</p>
<p><strong>RM (Resource Manager) - 资源管理器</strong></p>
<p>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>
<p><img src="seta1.png" alt="seta1"></p>
<p>Seata  致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p>
<h3 id="Seata-AT模式"><a href="#Seata-AT模式" class="headerlink" title="Seata AT模式"></a>Seata AT模式</h3><p>AT模式最受欢迎，使用也非常简单，但它内在的原理不简单。</p>
<p>AT模式的相关资料请参考官方文档说明：<a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p>
<p>下图是AT模式的执行流程：</p>
<p><img src="1614217488699.png" alt="1614217488699"></p>
]]></content>
      <categories>
        <category>分布式事务</category>
      </categories>
      <tags>
        <tag>seata</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper进阶篇</title>
    <url>/2023/03/02/Zookeeper%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>netty</title>
    <url>/2023/03/09/netty/</url>
    <content><![CDATA[<h2 id="JAVA-IO-模型"><a href="#JAVA-IO-模型" class="headerlink" title="JAVA IO 模型"></a>JAVA IO 模型</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>阻塞&#x2F;非阻塞：没有数据传过来时，读会阻塞直到有数据；缓冲区满时，写操作也会阻塞。非阻塞遇到这种情况直接返回</li>
<li>同步IO&#x2F;异步IO：数据就绪后需要自己去读是同步；数据就绪后系统直接读好回调给程序是异步</li>
</ul>
<h3 id="JAVA-BIO"><a href="#JAVA-BIO" class="headerlink" title="JAVA BIO"></a>JAVA BIO</h3><ol>
<li>BIO是blocking I&#x2F;O的简称，它是同步阻塞型IO，其相关的类和接口在java.io下</li>
<li>BIO模型简单来讲，就是服务端为每一个请求都分配一个线程进行处理，I&#x2F;O操作都是基于流Stream的操作</li>
</ol>
<h4 id="弊端："><a href="#弊端：" class="headerlink" title="弊端："></a>弊端：</h4><ul>
<li><strong>线程开销：</strong>客户端的的并发数和后端的并发数成1:1比例，线程的创建、销毁是非常消耗系统资源的，随着并发量增大，服务端性能显著下降，甚至会出现线程堆栈溢出等错误</li>
<li><strong>线程阻塞：</strong>当连接创建后如果该线程没有操作时，会进行阻塞操作，这样极大的浪费了服务器资源</li>
</ul>
<h3 id="JAVA-NIO-模型"><a href="#JAVA-NIO-模型" class="headerlink" title="JAVA NIO 模型"></a>JAVA NIO 模型</h3><ul>
<li>NIO，称之为New IO 或是 non-block IO （非阻塞IO），这两种说法都可以，其实称之为非阻塞IO更恰当一些</li>
<li>NIO的三大核心组件：<strong>Buffer（缓冲区）、Channel（通道）、Selector（选择器&#x2F;多路复用器）</strong></li>
</ul>
<h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p><strong>Buffer（缓冲区）：</strong></p>
<ul>
<li>Buffer是一个对象，包含一些要写入或者读出的数据，体现了与原I&#x2F;O的一个重要区别。在面向流的I&#x2F;O中，数据的读写是直接进入到stream中；在NIO中，所有数据都是用缓冲区处理的，读数据直接从缓冲区读，写数据直接写入到缓冲区。</li>
<li>缓冲区的本质是一个数组，通常是一个字节数组（ByteBuffer），也可以使用其他类型，但缓冲区又不仅仅是一个数组，它还提供了对数据结构化访问以及维护读写位置等操作。</li>
</ul>
<p><strong>Channel（通道）：</strong></p>
<ul>
<li>Channel 是一个通道，管道，网络数据通过Channel读取和写入，Channel和流Stream的不同之处在于Channel是双向的，流只在一个方向上移动（InputStream&#x2F;OutputStream），而Channel可以用于读写同时进行，即Channel是全双工的。</li>
</ul>
<p><strong>Selector（选择器&#x2F;多路复用器）：</strong></p>
<ul>
<li>Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，即该Channel处于就绪状态，它就会被Selector轮询出来，然后通过selectedKeys可以获取就绪Channel的集合，进行后续的I&#x2F;O操作。</li>
</ul>
<h3 id="JAVA-AIO模型"><a href="#JAVA-AIO模型" class="headerlink" title="JAVA AIO模型"></a>JAVA AIO模型</h3><p>AIO是asynchronous I&#x2F;O的简称，是异步IO，该异步IO是需要依赖于操作系统底层的异步IO实现。</p>
<p><strong>AIO的基本流程</strong>：用户线程通过系统调用，告知kernel内核启动某个IO操作，用户线程返回。kernel内核在整个IO操作（包括数据准备、数据复制）完成后，通知用户程序，用户执行后续的业务操作。</p>
<h2 id="Reactor-线程模型"><a href="#Reactor-线程模型" class="headerlink" title="Reactor 线程模型"></a>Reactor 线程模型</h2><p>Reactor线程模型不是Java专属，也不是Netty专属，它其实是一种并发编程模型，是一种思想，具有指导意义</p>
<p>Reactor模型中定义了三种角色：</p>
<ul>
<li><strong>Reactor</strong>：负责监听和分配事件，将I&#x2F;O事件分派给对应的Handler。新的事件包含连接建立就绪、读就绪、写就绪等。</li>
<li><strong>Acceptor</strong>：处理客户端新连接，并分派请求到处理器链中。</li>
<li><strong>Handler</strong>：将自身与事件绑定，执行非阻塞读&#x2F;写任务，完成channel的读入，完成处理业务逻辑后，负责</li>
<li>将结果写出channel</li>
</ul>
<h3 id="单Reactor-单线程"><a href="#单Reactor-单线程" class="headerlink" title="单Reactor-单线程"></a><strong>单Reactor-单线程</strong></h3><p>所有的接收连接，处理数据的相关操作都在一个线程中来完成，性能上有瓶颈</p>
<h3 id="单Reactor-多线程"><a href="#单Reactor-多线程" class="headerlink" title="单Reactor-多线程"></a><strong>单Reactor-多线程</strong></h3><p>把比较耗时的数据的编解码运算操作放入线程池中来执行，提升了性能但还不是最好的方式</p>
<h3 id="主从Reactor-多线程"><a href="#主从Reactor-多线程" class="headerlink" title="主从Reactor-多线程"></a><strong>主从Reactor-多线程</strong></h3><p>主从多线程，对于服务器来说，接收客户端的连接是比较重要的，因此将这部分操作单独用线程去操作</p>
<h4 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h4><ol>
<li>Reactor 主线程 MainReactor 对象通过 select 监听客户端连接事件，收到事件后，通过 Acceptor 处理客户端连接事件。</li>
<li>当 Acceptor 处理完客户端连接事件之后（与客户端建立好 Socket 连接），MainReactor 将连接分配给SubReactor。（即：MainReactor 只负责监听客户端连接请求，和客户端建立连接之后将连接交由SubReactor 监听后面的 IO 事件。）</li>
<li>SubReactor 将连接加入到自己的连接队列进行监听，并创建 Handler 对各种事件进行处理。</li>
<li>当连接上有新事件发生的时候，SubReactor 就会调用对应的 Handler 处理。</li>
<li>Handler 通过 read 从连接上读取请求数据，将请求数据分发给 Worker 线程池进行业务处理。</li>
<li>Worker 线程池会分配独立线程来完成真正的业务处理，并将处理结果返回给 Handler。Handler 通过send 向客户端发送响应数据</li>
<li>一个 MainReactor 可以对应多个 SubReactor，即一个 MainReactor 线程可以对应多个 SubReactor 线程</li>
</ol>
<h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><ul>
<li>MainReactor 线程与 SubReactor 线程的数据交互简单职责明确，MainReactor 线程只需要接收新连接，SubReactor 线程完成后续的业务处理。</li>
<li>MainReactor 线程与 SubReactor 线程的数据交互简单， MainReactor 线程只需要把新连接传给SubReactor 线程，SubReactor 线程无需返回数据。</li>
<li>多个 SubReactor 线程能够应对更高的并发请求。</li>
<li>这种模式的缺点是编程复杂度较高。但是由于其优点明显，在许多项目中被广泛使用，包括 Nginx、Memcached、Netty 等。</li>
<li>这种模式也被叫做服务器的 1+M+N 线程模式，即使用该模式开发的服务器包含一个（或多个，1 只是表示相对较少）连接建立线程+M 个 IO 线程+N 个业务处理线程。这是业界成熟的服务器程序设计模式。</li>
</ul>
<h2 id="Netty概述"><a href="#Netty概述" class="headerlink" title="Netty概述"></a>Netty概述</h2><ul>
<li>Netty是由JBOSS提供的一个java开源框架，现为 Github上的独立项目。Netty提供非阻塞的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。</li>
</ul>
<h3 id="Netty中的Reactor实现"><a href="#Netty中的Reactor实现" class="headerlink" title="Netty中的Reactor实现"></a>Netty中的Reactor实现</h3><p>Netty线程模型是基于Reactor模型实现的，对Reactor三种模式都有非常好的支持，并做了一定的改进，也非常的灵活，一般情况，在服务端会采用主从架构模型。</p>
<p><strong>工作流程：</strong></p>
<ol>
<li><p>Netty 抽象出两组线程池：BossGroup 和 WorkerGroup，每个线程池中都有EventLoop 线程（可以OIO,NIO,AIO）。BossGroup中的线程专门负责和客户端建立连接，WorkerGroup 中的线程专门负责处理连接上的读写, EventLoopGroup 相当于一个事件循环组，这个组中含有多个事件循环。</p>
</li>
<li><p>EventLoop 表示一个不断循环的执行事件处理的线程，每个EventLoop 都包含一个 Selector，用于监听注册在其上的 Socket 网络连接（Channel）。</p>
</li>
<li><p>每个 BossEventLoop 中循环执行以下三个步骤：</p>
<p>1）select：轮训注册在其上的 ServerSocketChannel 的 accept 事件（OP_ACCEPT 事件）</p>
<p>2）processSelectedKeys：处理 accept 事件，与客户端建立连接，生成一个SocketChannel，并将其注册到某个 WorkerEventLoop 上的 Selector 上</p>
<p>3）runAllTasks：再去以此循环处理任务队列中的其他任务</p>
</li>
<li><p>每个 Worker EventLoop 中循环执行以下三个步骤：</p>
<p>1）select：轮训注册在其上的SocketChannel 的 read&#x2F;write 事件（OP_READ&#x2F;OP_WRITE 事件）</p>
<p>2）processSelectedKeys：在对应的SocketChannel 上处理 read&#x2F;write 事件</p>
<p>3）runAllTasks：再去以此循环处理任务队列中的其他任务</p>
</li>
<li><p>在以上两个processSelectedKeys步骤中，会使用 Pipeline（管道），Pipeline 中引用了 Channel，即通过Pipeline 可以获取到对应的 Channel，Pipeline 中维护了很多的处理器（拦截处理器、过滤处理器、自定义处理器等）。</p>
</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li>Netty 的线程模型基于主从多Reactor模型。通常由一个线程负责处理OP_ACCEPT事件，拥有 CPU 核数的两倍的IO线程处理读写事件</li>
<li>一个通道的IO操作会绑定在一个IO线程中，而一个IO线程可以注册多个通道</li>
<li>在一个网络通信中通常会包含网络数据读写，编码、解码、业务处理。默认情况下网络数据读写，编码、解码等操作会在IO线程中运行，但也可以指定其他线程池。</li>
<li>通常业务处理会单独开启业务线程池（看业务类型），但也可以进一步细化，例如心跳包可以直接在IO线程中处理，而需要再转发给业务线程池，避免线程切换</li>
<li>在一个IO线程中所有通道的事件是串行处理的。</li>
<li>通常业务操作会专门开辟一个线程池，那业务处理完成之后，如何将响应结果通过 IO 线程写入到网卡中呢？业务线程调用 Channel对象的 write 方法并不会立即写入网络，只是将数据放入一个待写入缓存区，然后IO线程每次执行事件选择后，会从待写入缓存区中获取写入任务，将数据真正写入到网络中</li>
</ul>
<h2 id="Pipeline-和-Handler"><a href="#Pipeline-和-Handler" class="headerlink" title="Pipeline 和 Handler"></a>Pipeline 和 Handler</h2><h3 id="ChannelPipeline-amp-ChannelHandler"><a href="#ChannelPipeline-amp-ChannelHandler" class="headerlink" title="ChannelPipeline &amp; ChannelHandler"></a>ChannelPipeline &amp; ChannelHandler</h3><ul>
<li>ChannelPipeline 提供了 ChannelHandler 链的容器。以服务端程序为例，客户端发送过来的数据要接收，读取处理，我们称数据是入站的，需要经过一系列Handler处理后；如果服务器想向客户端写回数据，也需要经过一系列Handler处理，我们称数据是出站的。</li>
</ul>
<h3 id="ChannelHandler-分类"><a href="#ChannelHandler-分类" class="headerlink" title="ChannelHandler 分类"></a>ChannelHandler 分类</h3><p>对于数据的出站和入站，有着不同的ChannelHandler类型与之对应：</p>
<ol>
<li>ChannelInboundHandler 入站事件处理器</li>
<li>ChannelOutBoundHandler 出站事件处理器</li>
<li>ChannelHandlerAdapter提供了一些方法的默认实现，可减少用户对于ChannelHandler的编写</li>
<li>ChannelDuplexHandler：混合型，既能处理入站事件又能处理出站事件</li>
</ol>
<h3 id="ChannelHandler-体系结构"><a href="#ChannelHandler-体系结构" class="headerlink" title="ChannelHandler 体系结构"></a>ChannelHandler 体系结构</h3><ol>
<li>inbound入站事件处理顺序（方向）是由链表的头到链表尾，outbound事件的处理顺序是由链表尾到链表头。</li>
<li>inbound入站事件由netty内部触发，最终由netty外部的代码消费。</li>
<li>outbound事件由netty外部的代码触发，最终由netty内部消费。</li>
</ol>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><ul>
<li>InboundHandler是按照Pipleline的加载顺序(addLast)，<strong>顺序</strong>执行</li>
<li>OutboundHandler是按照Pipeline的加载顺序(addLast)，<strong>逆序</strong>执行</li>
</ul>
<h3 id="回写数据事件流转规则"><a href="#回写数据事件流转规则" class="headerlink" title="回写数据事件流转规则"></a>回写数据事件流转规则</h3><ul>
<li>如果是通过Channel对象进行数据回写，事件会从pipeline尾部流向头部</li>
<li>如果是通过ChannelHandlerContext对象进行数据回写，事件会从当前handler流向头部</li>
<li>问题：OutboundHandler和InboundHandler的先后顺序是否有要求？才能保证所有outboundHandler能被执行</li>
</ul>
<h2 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h2><ul>
<li><p>Bootstrap是引导的意思，它的作用是配置整个Netty程序，将各个组件都串起来，最后绑定端口、启动Netty服务</p>
</li>
<li><p>Netty中提供了2种类型的引导类，一种用于客户端(Bootstrap)，而另一种(ServerBootstrap)用于服务器，区别在于：</p>
<p>1、ServerBootstrap 将绑定到一个端口，因为服务器必须要监听连接，而 Bootstrap 则是由想要连接到远程	  节点的客户端应用程序所使用的</p>
<p>2、引导一个客户端只需要一个EventLoopGroup，但是一个ServerBootstrap则需要两个</p>
</li>
</ul>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul>
<li>Netty中的Channel是与网络套接字相关的，可以理解为是socket连接，在客户端与服务端连接的时候就会建立一个Channel，它负责基本的IO操作，比如：bind()、connect()，read()，write() 等</li>
</ul>
<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ol>
<li>通过Channel可获得当前网络连接的通道状态。</li>
<li>通过Channel可获得网络连接的配置参数（缓冲区大小等）。</li>
<li>Channel提供异步的网络I&#x2F;O操作，比如连接的建立、数据的读写、端口的绑定等。</li>
</ol>
<p>不同协议、不同的I&#x2F;O类型的连接都有不同的 Channel 类型与之对应</p>
<h2 id="EventLoopGroup-amp-EventLoop"><a href="#EventLoopGroup-amp-EventLoop" class="headerlink" title="EventLoopGroup&amp;EventLoop"></a>EventLoopGroup&amp;EventLoop</h2><ul>
<li>Netty是基于事件驱动的，比如：连接注册，连接激活；数据读取；异常事件等等，有了事件，就需要一个组件去监控事件的产生和事件的协调处理，这个组件就是EventLoop（事件循环&#x2F;EventExecutor），在Netty 中每个Channel 都会被分配到一个 EventLoop。一个 EventLoop 可以服务于多个 Channel。每个EventLoop 会占用一个 Thread，同时这个 Thread 会处理 EventLoop 上面发生的所有 IO 操作和事件。</li>
<li>EventLoopGroup 是用来生成 EventLoop 的，包含了一组EventLoop（可以初步理解成Netty线程池）</li>
</ul>
<h2 id="ChannelHandler-amp-amp-ChannelHandlerContext-amp-amp-ChannelPipeline"><a href="#ChannelHandler-amp-amp-ChannelHandlerContext-amp-amp-ChannelPipeline" class="headerlink" title="ChannelHandler&amp;&amp;ChannelHandlerContext&amp;&amp;ChannelPipeline"></a>ChannelHandler&amp;&amp;ChannelHandlerContext&amp;&amp;ChannelPipeline</h2><ul>
<li><strong>@Sharable</strong> 可以被复用，至于线程安全问题需要开发者自行保证</li>
<li>继承SimpleChannelInboundHandler需要重写channelRead0方法，且可以通过泛型指定msg类型</li>
<li>SimpleChannelInboundHandler在接收到数据后会自动release掉数据占用的Bytebuffer资源</li>
<li>注意事项：服务端异步处理数据，服务端想把客户端发送来的数据再写回等等场景下最好不要继承SimpleChannelInboundHandler</li>
<li>客户端推荐使用SimpleChannelInboundHandler，服务端看场景</li>
</ul>
<h2 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h2><h3 id="概念和作用"><a href="#概念和作用" class="headerlink" title="概念和作用"></a>概念和作用</h3><ul>
<li>Java NIO 提供了ByteBuffer 作为它的字节容器，但是这个类使用起来过于复杂，而且也有些繁琐。Netty使用ByteBuf来替代ByteBuffer，它是一个强大的实现，既解决了JDK API 的局限性， 又为网络应用程序的开发者提供了更好的API</li>
<li>从结构上来说，ByteBuf 由一串字节数组构成。数组中每个字节用来存放信息，ByteBuf提供了两个索引，一个用于读取数据（readerIndex ），一个用于写入数据（writerIndex）。这两个索引通过在字节数组中移动，来定位需要读或者写信息的位置。而JDK的ByteBuffer只有一个索引，因此需要使用flip方法进行读写切换</li>
</ul>
<h3 id="ByteBuf的三个指针"><a href="#ByteBuf的三个指针" class="headerlink" title="ByteBuf的三个指针"></a>ByteBuf的三个指针</h3><ul>
<li>readerIndex：指示读取的起始位置， 每读取一个字节， readerIndex自增累加1。 如果readerIndex 与writerIndex 相等，ByteBuf 不可读。</li>
<li>writerIndex：指示写入的起始位置， 每写入一个字节， writeIndex自增累加1。如果增加到 writerIndex 与capacity（） 容量相等，表示 ByteBuf 已经不可写，但是这个时候，并不代表不能往 ByteBuf 中写数据了， 如果发现往ByteBuf 中写数据写不进去的话，Netty 会自动扩容 ByteBuf，直到扩容到底层的内存大小为 maxCapacity</li>
<li>maxCapacity：指示ByteBuf 可以扩容的最大容量， 如果向ByteBuf写入数据时， 容量不足， 可以进行扩容的最大容量</li>
</ul>
<h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><ul>
<li><p>capacity()：表示 ByteBuf 底层占用了多少字节的内存（包括丢弃的字节、可读字节、可写字节），不同的底层实现机制有不同的计算方式。</p>
</li>
<li><p>maxCapacity()： ByteBuf 底层最大能够占用多少字节的内存，当向 ByteBuf 中写数据的时候，如果发现容量不足，则进行扩容，直到扩容到 maxCapacity，超过这个数，就抛异常。</p>
</li>
<li><p>readableBytes() 与 isReadable()：readableBytes() 表示 ByteBuf 当前可读的字节数，它的值等于writerIndex-readerIndex，如果两者相等，则不可读，isReadable() 方法返回 false</p>
</li>
<li><p>writableBytes()、 isWritable() 、maxWritableBytes()：writableBytes() 表示 ByteBuf 当前可写的字节数，它的值等于 capacity()-writerIndex，如果两者相等，则表示不可写，isWritable() 返回 false，但是这个时候，并不代表不能往 ByteBuf 中写数据了， 如果发现往ByteBuf 中写数据写不进去的话，Netty 会自动扩容 ByteBuf，直到扩容到底层的内存大小为 maxCapacity，而 maxWritableBytes() 就表示可写的最大字节数，它的值等于maxCapacity-writerIndex。</p>
</li>
<li><p>readerIndex() 与 readerIndex(int readerIndex)：前者表示返回当前的读指针 readerIndex, 后者表示设置读指针</p>
</li>
<li><p>writeIndex() 与 writeIndex(int writerIndex)：前者表示返回当前的写指针 writerIndex, 后者表示设置写指针</p>
</li>
<li><p>markReaderIndex() 与markWriterIndex()：表示把当前的读指针&#x2F;写指针保存起来，操作形式为：markedReaderIndex &#x3D; readerIndex &#x2F; markedWriterIndex &#x3D; writerIndex;</p>
</li>
<li><p>writeBytes(byte[] src)： 表示把字节数组 src 里面的数据全部写到 ByteBuf，src字节数组大小的长度通常小于等于writableBytes()</p>
</li>
<li><p>readBytes(byte[] dst)：把 ByteBuf 里面的数据全部读取到 dst，dst 字节数组的大小通常等于 readableBytes()</p>
</li>
<li><p>writeByte(int value)、readByte()：writeByte() 表示往 ByteBuf 中写一个字节，而 readByte() 表示从 ByteBuf 中读取一个字节，类似的 API 还有 writeBoolean()、writeChar()、writeShort()、writeInt()、writeLong()、writeFloat()、writeDouble() 与 readBoolean()、readChar()、readShort()、readInt()、readLong()、readFloat()、readDouble() 等等</p>
</li>
<li><p>discardReadBytes()： 丢弃已读取的字节空间，可写空间变多</p>
</li>
<li><p>clear()：重置readerIndex 、 writerIndex 为0，需要注意的是，重置并没有删除真正的内容</p>
</li>
<li><p>release()：真正去释放bytebuf中的数据，</p>
</li>
<li><p>ReferenceCountUtil.release(buf)：工具方法，内部还是调用release()</p>
</li>
</ul>
<h3 id="ByteBuf三类使用模式"><a href="#ByteBuf三类使用模式" class="headerlink" title="ByteBuf三类使用模式"></a>ByteBuf三类使用模式</h3><ul>
<li>堆缓冲区（HeapByteBuf）：内存分配在jvm堆，分配和回收速度比较快，可以被JVM自动回收，缺点是，如果进行socket的IO读写，需要额外做一次内存复制，将堆内存对应的缓冲区复制到内核Channel中，性能会有一定程度的下降。由于在堆上被 JVM 管理，在不被使用时可以快速释放。可以通过 ByteBuf.array() 来获取 byte[] 数据。</li>
<li>直接缓冲区（DirectByteBuf）：内存分配的是堆外内存（系统内存），相比堆内存，它的分配和回收速度会慢一些，但是将它写入或从Socket Channel中读取时，由于减少了一次内存拷贝，速度比堆内存块。</li>
<li>复合缓冲区（CompositeByteBuf）：顾名思义就是将两个不同的缓冲区从逻辑上合并，让使用更加方便。</li>
<li>Netty默认使用的是DirectByteBuf，如果需要使用HeapByteBuf模式，则需要进行系统参数的设置</li>
</ul>
<h3 id="ByteBuf-的分配器"><a href="#ByteBuf-的分配器" class="headerlink" title="ByteBuf 的分配器"></a>ByteBuf 的分配器</h3><p><strong>BufAllocator：</strong></p>
<p>Netty 提供了两种 ByteBufAllocator 的实现，分别是：</p>
<ul>
<li><p>PooledByteBufAllocator：实现了 ByteBuf 的对象的池化，提高性能减少并最大限度地减少内存碎片，池化思想通过预先申请一块专用内存地址作为<strong>内存池</strong>进行管理，从而不需要每次都进行分配和释放</p>
</li>
<li><p>UnpooledByteBufAllocator：没有实现对象的池化，每次会生成新的对象实例</p>
</li>
<li><p>对于Pooled类型的ByteBuf，不管是PooledDirectByteBuf还是PooledHeapByteBuf都只能由Netty内部自己使用（构造是私有和受保护的），开发者可以使用Unpooled类型的ByteBuf。</p>
</li>
<li><p>Netty提供Unpooled工具类创建的ByteBuf都是unpooled类型，默认采用的Allocator是direct类型；当然用户可以自己选择创建UnpooledDirectByteBuf和UnpooledHeapByteBuf</p>
</li>
</ul>
<h3 id="ByteBuf-的释放"><a href="#ByteBuf-的释放" class="headerlink" title="ByteBuf 的释放"></a>ByteBuf 的释放</h3><ul>
<li><p>ByteBuf如果采用的是堆缓冲区模式的话，可以由GC回收，但是如果采用的是直接缓冲区，就不受GC的管理，就得手动释放，否则会发生内存泄露，Netty自身引入了引用计数，提供了ReferenceCounted接口，当对象的引用计数&gt;0时要保证对象不被释放，当为0时需要被释放</p>
</li>
<li><p>手动释放，就是在使用完成后，调用ReferenceCountUtil.release(byteBuf); 进行释放，这种方式的弊端就是一旦忘记释放就可能会造成内存泄露</p>
</li>
<li><p>自动释放有三种方式，分别是：</p>
<p>1）入站的TailHandler（TailContext）、继SimpleChannelInboundHandler、HeadHandler（HeadContext）的出站释放</p>
<p>2）TailContext：Inbound流水线的末端，如果前面的handler都把消息向后传递最终由TailContext释放该消息，需要注意的是，如果没有进行向下传递，是不会进行释放操作的</p>
<p>3）SimpleChannelInboundHandler：自定义的InboundHandler继承自SimpleChannelInboundHandler，在SimpleChannelInboundHandler中自动释放</p>
<p>4）HeadContext：outbound流水线的末端，出站消息一般是由应用所申请，到达最后一站时，经过一轮复杂的调用，在flush完成后终将被release掉</p>
</li>
</ul>
<p><strong>对于入站消息：</strong></p>
<ul>
<li>对原消息不做处理，依次调用 ctx.fireChannelRead(msg)把原消息往下传，如果能到TailContext，那不用做什么释放，它会自动释放</li>
<li>将原消息转化为新的消息并调用 ctx.fireChannelRead(newMsg)往下传，那需要将原消息release掉</li>
<li>如果已经不再调用ctx.fireChannelRead(msg)传递任何消息，需要把原消息release掉。</li>
</ul>
<p><strong>对于出站消息</strong>：则无需用户关心，消息最终都会走到HeadContext，flush之后会自动释放。</p>
<h2 id="Future-amp-Promise"><a href="#Future-amp-Promise" class="headerlink" title="Future &amp; Promise"></a>Future &amp; Promise</h2><p><strong>Netty的异步编程模型</strong></p>
<ul>
<li>future和promise，目的是将值（future）与其计算方式（promise）分离，从而允许更灵活地进行计算，特别是通过并行化。Future 表示目标计算的返回值，Promise 表示计算的方式，这个模型将返回结果和计算逻辑分离，目的是为了让计算逻辑不影响返回结果，从而抽象出一套异步编程模型。而计算逻辑与结果关联的纽带就是 callback。</li>
<li>Netty中有非常多的异步调用，譬如：client&#x2F;server的启动，连接，数据的读写等操作都是支持异步的。</li>
</ul>
<h3 id="Netty-ChannelFuture"><a href="#Netty-ChannelFuture" class="headerlink" title="Netty ChannelFuture"></a>Netty ChannelFuture</h3><p>ChannelFuture：跟Channel的操作有关，Netty中的Handler处理都是异步IO，通过ChannelFuture添加事件监听，可获取Channel异步IO操作的结果；当然也可等待获取，但最好不要在handler中通过future的sync或await来获取异步操作的结果。</p>
<h3 id="Netty-ChannelPromise"><a href="#Netty-ChannelPromise" class="headerlink" title="Netty ChannelPromise"></a>Netty ChannelPromise</h3><p>1、Promise机制</p>
<ul>
<li>Netty的Future，只是增加了监听器。整个异步的状态，是不能进行设置和修改的，于是Netty的 Promise接口扩展了Netty的Future接口，可以设置异步执行的结果。在IO操作过程，如果顺利完成、或者发生异常，都可以设置Promise的结果，并且通知Promise的Listener们。</li>
</ul>
<p>2、ChannelPromise接口，则继承扩展了Promise和ChannelFuture。所以，ChannelPromise既绑定了  Channel，又具备了设置监听回调的功能，还可以设置IO操作的结果，是Netty实际编程使用的最多的接口。</p>
<h2 id="Netty-消息编解码器"><a href="#Netty-消息编解码器" class="headerlink" title="Netty 消息编解码器"></a>Netty 消息编解码器</h2><h3 id="一次编解码"><a href="#一次编解码" class="headerlink" title="一次编解码"></a>一次编解码</h3><p>主要解决TCP粘包，半包问题</p>
<p>主要分为三种：</p>
<ol>
<li>固定长度（FixedLengthFrameDecoder）</li>
<li>分隔符（DelimiterBasedFrameDecoder）</li>
<li>固定长度字段存消息长度 （LengthFieldBasedFrameDecoder）（推荐使用）</li>
</ol>
<h3 id="二次编解码"><a href="#二次编解码" class="headerlink" title="二次编解码"></a>二次编解码</h3><ul>
<li>我们把解决半包粘包问题的常用三种解码器叫一次解码器，其作用是将原始数据流(可能会出现粘包和半包的数据流)转换为用户数据(ByteBuf中存储)，但仍然是字节数据，所以我们需要二次解码器将字节数组转换为java对象，或者将将一种格式转化为另一种格式，方便上层应用程序使用。</li>
<li>一次解码器继承自：ByteToMessageDecoder；二次解码器继承自：MessageToMessageDecoder；但他们的本质都是继承ChannelInboundHandlerAdapter</li>
</ul>
<h4 id="二次编解码方式"><a href="#二次编解码方式" class="headerlink" title="二次编解码方式"></a><strong>二次编解码方式</strong></h4><p>用户数据(ByteBuf )和 Java Object之间的转换，或者将将一种格式转化为另一种格式（譬如将应用数据转化成某种协议数据）。</p>
<ul>
<li>Java 序列化：不推荐使用，占用空间大，也只有java语言能用</li>
<li>Marshaling：比java序列化稍好</li>
<li>XML ：可读性好，但是占用空间大</li>
<li>JSON ：可读性也好，空间较小</li>
<li>MessagePack ：占用空间比JSON小，可读性不如JSON，但也还行</li>
<li>Protobuf ：性能高，体积小，但是可读性差</li>
<li>hessian ：跨语言、高效的二进制序列化协议，整体性能和protobuf差不多。</li>
<li>其他</li>
</ul>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper入门篇</title>
    <url>/2023/02/02/Zookeeper%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>Zookeeper 是 Apache Hadoop 项目下的一个子项目，是一个树形目录服务。</li>
<li>Zookeeper 翻译过来就是 动物园管理员，他是用来管 Hadoop（大象）、Hive(蜜蜂)、Pig(小 猪)的管理员。简称zk。</li>
<li>Zookeeper 是一个分布式的、开源的分布式应用程序的协调服务。</li>
<li>Zookeeper 提供的主要功能包括：配置管理、分布式锁、集群管理</li>
</ul>
<h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>ZooKeeper服务器是用Java创建的，它运行在JVM之上。需要安装JDK 7或更高版本。</p>
<h4 id="上传安装包"><a href="#上传安装包" class="headerlink" title="上传安装包"></a>上传安装包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打开 opt目录</span></span><br><span class="line">cd /opt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建zooKeeper目录</span></span><br><span class="line">mkdir  zooKeeper</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将zookeeper安装包上传到当前目录</span></span><br></pre></td></tr></table></figure>

<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><p>将tar包解压到&#x2F;opt&#x2F;zookeeper目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-ZooKeeper-3.5.6-bin.tar.gz </span><br></pre></td></tr></table></figure>

<h3 id="配置启动"><a href="#配置启动" class="headerlink" title="配置启动"></a>配置启动</h3><h4 id="配置zoo-cfg"><a href="#配置zoo-cfg" class="headerlink" title="配置zoo.cfg"></a>配置zoo.cfg</h4><p>进入到conf目录拷贝一个zoo_sample.cfg并完成配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入到conf目录</span></span><br><span class="line">cd /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/conf/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拷贝</span></span><br><span class="line">cp  zoo_sample.cfg  zoo.cfg</span><br></pre></td></tr></table></figure>

<p>修改zoo.cfg</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打开目录</span></span><br><span class="line">cd /opt/zooKeeper/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建zooKeeper存储目录</span></span><br><span class="line">mkdir  zkdata</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改zoo.cfg</span></span><br><span class="line">vim /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/conf/zoo.cfg</span><br></pre></td></tr></table></figure>

<p><img src="/./images/1577548250377.png" alt="1577548250377"></p>
<p>修改存储目录：dataDir&#x3D;&#x2F;opt&#x2F;zookeeper&#x2F;zkdata</p>
<h4 id="启动ZooKeeper"><a href="#启动ZooKeeper" class="headerlink" title="启动ZooKeeper"></a>启动ZooKeeper</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/bin/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动</span></span><br><span class="line">./zkServer.sh  start</span><br></pre></td></tr></table></figure>

<p><img src="1577548052037.png" alt="1577548052037"></p>
<p>看到上图表示ZooKeeper成功启动</p>
<h2 id="ZooKeeper-命令操作"><a href="#ZooKeeper-命令操作" class="headerlink" title="ZooKeeper 命令操作"></a>ZooKeeper 命令操作</h2><h3 id="Zookeeper命令操作数据模型"><a href="#Zookeeper命令操作数据模型" class="headerlink" title="Zookeeper命令操作数据模型"></a>Zookeeper命令操作数据模型</h3><ul>
<li><p>ZooKeeper 是一个树形目录服务,其数据模型和Unix的文件系统目录树很类似，拥有一个层次化结构。</p>
</li>
<li><p>这里面的每一个节点都被称为： ZNode，每个节点上都会保存自己的数据和节点信息。 </p>
</li>
<li><p>节点可以拥有子节点，同时也允许少量（1MB）数据存储在该节点之下。</p>
</li>
<li><p>节点可以分为四大类：</p>
<ol>
<li><p>PERSISTENT 持久化节点 </p>
</li>
<li><p>EPHEMERAL 临时节点 ：-e</p>
</li>
<li><p>PERSISTENT_SEQUENTIAL 持久化顺序节点 ：-s</p>
</li>
<li><p>EPHEMERAL_SEQUENTIAL 临时顺序节点  ：-es</p>
</li>
</ol>
</li>
</ul>
<p><img src="/../images/1592054828485.png" alt="1592054828485"></p>
<p><img src="/../images/1592054844023.png" alt="1592054844023"></p>
<h3 id="Zookeeper命令操作服务端命令"><a href="#Zookeeper命令操作服务端命令" class="headerlink" title="Zookeeper命令操作服务端命令"></a>Zookeeper命令操作服务端命令</h3><ul>
<li><p>启动 ZooKeeper 服务: .&#x2F;zkServer.sh start</p>
</li>
<li><p>查看 ZooKeeper 服务状态: .&#x2F;zkServer.sh status</p>
</li>
<li><p>停止 ZooKeeper 服务: .&#x2F;zkServer.sh stop </p>
</li>
<li><p>重启 ZooKeeper 服务: .&#x2F;zkServer.sh restart</p>
</li>
</ul>
<h3 id="Zookeeper客户端常用命令"><a href="#Zookeeper客户端常用命令" class="headerlink" title="Zookeeper客户端常用命令"></a>Zookeeper客户端常用命令</h3><ul>
<li>连接ZooKeeper服务端</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./zkCli.sh –server ip:port</span><br></pre></td></tr></table></figure>

<ul>
<li>断开连接</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure>

<ul>
<li>查看命令帮助</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">help</span><br></pre></td></tr></table></figure>

<ul>
<li>显示指定目录下节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls 目录</span><br></pre></td></tr></table></figure>

<ul>
<li>创建节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create /节点path value</span><br></pre></td></tr></table></figure>

<ul>
<li>获取节点值</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">get /节点path</span><br></pre></td></tr></table></figure>

<ul>
<li>设置节点值</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set /节点path value</span><br></pre></td></tr></table></figure>

<ul>
<li>删除单个节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">delete /节点path</span><br></pre></td></tr></table></figure>

<ul>
<li>删除带有子节点的节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deleteall /节点path</span><br></pre></td></tr></table></figure>

<h3 id="客户端命令-创建临时有序节点"><a href="#客户端命令-创建临时有序节点" class="headerlink" title="客户端命令-创建临时有序节点"></a>客户端命令-创建临时有序节点</h3><ul>
<li>创建临时节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create -e /节点path value</span><br></pre></td></tr></table></figure>

<ul>
<li>创建顺序节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create -s /节点path value</span><br></pre></td></tr></table></figure>

<ul>
<li>查询节点详细信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls –s /节点path </span><br></pre></td></tr></table></figure>

<ol>
<li><p>czxid：节点被创建的事务ID </p>
</li>
<li><p>ctime: 创建时间 </p>
</li>
<li><p>mzxid: 最后一次被更新的事务ID </p>
</li>
<li><p>mtime: 修改时间 </p>
</li>
<li><p>pzxid：子节点列表最后一次被更新的事务ID</p>
</li>
<li><p>cversion：子节点的版本号 </p>
</li>
<li><p>dataversion：数据版本号 </p>
</li>
<li><p>aclversion：权限版本号 </p>
</li>
<li><p>ephemeralOwner：用于临时节点，代表临时节点的事务ID，如果为持久节点则为0 </p>
</li>
<li><p>dataLength：节点存储的数据的长度 </p>
</li>
<li><p>numChildren：当前节点的子节点个数</p>
</li>
</ol>
<h2 id="ZooKeeper-JavaAPI-操作"><a href="#ZooKeeper-JavaAPI-操作" class="headerlink" title="ZooKeeper JavaAPI 操作"></a>ZooKeeper JavaAPI 操作</h2><h3 id="urator介绍"><a href="#urator介绍" class="headerlink" title="urator介绍"></a>urator介绍</h3><p>•Curator 是 Apache ZooKeeper 的Java客户端库。</p>
<p>•常见的ZooKeeper Java API ：</p>
<p>•原生Java API</p>
<p>•ZkClient</p>
<p>•Curator</p>
<p>•Curator 项目的目标是简化 ZooKeeper 客户端的使用。</p>
<p>•Curator 最初是 Netfix 研发的,后来捐献了 Apache 基金会,目前是 Apache 的顶级项目。</p>
<p>•官网：<a href="http://curator.apache.org/">http://curator.apache.org/</a></p>
<h3 id="JavaAPI操作建立连接"><a href="#JavaAPI操作建立连接" class="headerlink" title="JavaAPI操作建立连接"></a>JavaAPI操作建立连接</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnect</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//重试策略</span></span><br><span class="line">    <span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">3000</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//2.第二种方式</span></span><br><span class="line">    <span class="comment">//CuratorFrameworkFactory.builder();</span></span><br><span class="line">    client = CuratorFrameworkFactory.builder()</span><br><span class="line">        .connectString(<span class="string">&quot;192.168.200.130:2181&quot;</span>)</span><br><span class="line">        .sessionTimeoutMs(<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">        .connectionTimeoutMs(<span class="number">15</span> * <span class="number">1000</span>)</span><br><span class="line">        .retryPolicy(retryPolicy)</span><br><span class="line">        .namespace(<span class="string">&quot;itheima&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">//开启连接</span></span><br><span class="line">    client.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper-JavaAPI操作-创建节点"><a href="#Zookeeper-JavaAPI操作-创建节点" class="headerlink" title="Zookeeper JavaAPI操作-创建节点"></a>Zookeeper JavaAPI操作-创建节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建节点：create 持久 临时 顺序 数据</span></span><br><span class="line"><span class="comment">* 1. 基本创建 ：create().forPath(&quot;&quot;)</span></span><br><span class="line"><span class="comment">* 2. 创建节点 带有数据:create().forPath(&quot;&quot;,data)</span></span><br><span class="line"><span class="comment">* 3. 设置节点的类型：create().withMode().forPath(&quot;&quot;,data)</span></span><br><span class="line"><span class="comment">* 4. 创建多级节点  /app1/p1 ：create().creatingParentsIfNeeded().forPath(&quot;&quot;,data)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreate</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//2. 创建节点 带有数据</span></span><br><span class="line">    <span class="comment">//如果创建节点，没有指定数据，则默认将当前客户端的ip作为数据存储</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> client.create().forPath(<span class="string">&quot;/app2&quot;</span>, <span class="string">&quot;hehe&quot;</span>.getBytes());</span><br><span class="line">    System.out.println(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreate2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1. 基本创建</span></span><br><span class="line">    <span class="comment">//如果创建节点，没有指定数据，则默认将当前客户端的ip作为数据存储</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> client.create().forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">    System.out.println(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreate3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//3. 设置节点的类型</span></span><br><span class="line">    <span class="comment">//默认类型：持久化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> client.create().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">&quot;/app3&quot;</span>);</span><br><span class="line">    System.out.println(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreate4</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//4. 创建多级节点  /app1/p1</span></span><br><span class="line">    <span class="comment">//creatingParentsIfNeeded():如果父节点不存在，则创建父节点</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> client.create().creatingParentsIfNeeded().forPath(<span class="string">&quot;/app4/p1&quot;</span>);</span><br><span class="line">    System.out.println(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZookeeperJavaAPI操作-查询节点"><a href="#ZookeeperJavaAPI操作-查询节点" class="headerlink" title="ZookeeperJavaAPI操作-查询节点"></a>ZookeeperJavaAPI操作-查询节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查询节点：</span></span><br><span class="line"><span class="comment">* 1. 查询数据：get: getData().forPath()</span></span><br><span class="line"><span class="comment">* 2. 查询子节点： ls: getChildren().forPath()</span></span><br><span class="line"><span class="comment">* 3. 查询节点状态信息：ls -s:getData().storingStatIn(状态对象).forPath()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGet1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1. 查询数据：get</span></span><br><span class="line">    <span class="type">byte</span>[] data = client.getData().forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGet2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 2. 查询子节点： ls</span></span><br><span class="line">    List&lt;String&gt; path = client.getChildren().forPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    System.out.println(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGet3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Stat</span> <span class="variable">status</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line">    System.out.println(status);</span><br><span class="line">    <span class="comment">//3. 查询节点状态信息：ls -s</span></span><br><span class="line">    client.getData().storingStatIn(status).forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">    System.out.println(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper-JavaAPI操作-修改节点"><a href="#Zookeeper-JavaAPI操作-修改节点" class="headerlink" title="Zookeeper JavaAPI操作-修改节点"></a>Zookeeper JavaAPI操作-修改节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 修改数据</span></span><br><span class="line"><span class="comment">* 1. 基本修改数据：setData().forPath()</span></span><br><span class="line"><span class="comment">* 2. 根据版本修改: setData().withVersion().forPath()</span></span><br><span class="line"><span class="comment">* * version 是通过查询出来的。目的就是为了让其他客户端或者线程不干扰我。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	client.setData().forPath(<span class="string">&quot;/app1&quot;</span>, <span class="string">&quot;itcast&quot;</span>.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSetForVersion</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Stat</span> <span class="variable">status</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line">    <span class="comment">//3. 查询节点状态信息：ls -s</span></span><br><span class="line">    client.getData().storingStatIn(status).forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">version</span> <span class="operator">=</span> status.getVersion();<span class="comment">//查询出来的 3</span></span><br><span class="line">    System.out.println(version);</span><br><span class="line">    client.setData().withVersion(version).forPath(<span class="string">&quot;/app1&quot;</span>, <span class="string">&quot;hehe&quot;</span>.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper-JavaAPI操作-删除节点"><a href="#Zookeeper-JavaAPI操作-删除节点" class="headerlink" title="Zookeeper JavaAPI操作-删除节点"></a>Zookeeper JavaAPI操作-删除节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除节点： delete deleteall</span></span><br><span class="line"><span class="comment">* 1. 删除单个节点:delete().forPath(&quot;/app1&quot;);</span></span><br><span class="line"><span class="comment">* 2. 删除带有子节点的节点:delete().deletingChildrenIfNeeded().forPath(&quot;/app1&quot;);</span></span><br><span class="line"><span class="comment">* 3. 必须成功的删除:为了防止网络抖动。本质就是重试。  client.delete().guaranteed().forPath(&quot;/app2&quot;);</span></span><br><span class="line"><span class="comment">* 4. 回调：inBackground</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 删除单个节点</span></span><br><span class="line">    client.delete().forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//2. 删除带有子节点的节点</span></span><br><span class="line">    client.delete().deletingChildrenIfNeeded().forPath(<span class="string">&quot;/app4&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//3. 必须成功的删除</span></span><br><span class="line">    client.delete().guaranteed().forPath(<span class="string">&quot;/app2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete4</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//4. 回调</span></span><br><span class="line">    client.delete().guaranteed().inBackground(<span class="keyword">new</span> <span class="title class_">BackgroundCallback</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processResult</span><span class="params">(CuratorFramework client, CuratorEvent event)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我被删除了~&quot;</span>);</span><br><span class="line">            System.out.println(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper-JavaAPI操作-Watch监听概述"><a href="#Zookeeper-JavaAPI操作-Watch监听概述" class="headerlink" title="Zookeeper JavaAPI操作-Watch监听概述"></a>Zookeeper JavaAPI操作-Watch监听概述</h3><ol>
<li>ZooKeeper 允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</li>
<li>ZooKeeper 中引入了Watcher机制来实现了发布&#x2F;订阅功能能，能够让多个订阅者同时监听某一个对象，当一个对象自身状态变化时，会通知所有订阅者。</li>
<li>ZooKeeper 原生支持通过注册Watcher来进行事件监听，但是其使用并不是特别方便需要开发人员自己反复注册Watcher，比较繁琐。</li>
<li>Curator引入了 Cache 来实现对 ZooKeeper 服务端事件的监听。</li>
<li>ZooKeeper提供了三种Watcher：</li>
</ol>
<ul>
<li>NodeCache : 只是监听某一个特定的节点</li>
<li>PathChildrenCache : 监控一个ZNode的子节点</li>
<li>TreeCache : 可以监控整个树上的所有节点，类似于PathChildrenCache和NodeCache的组合</li>
</ul>
<h3 id="Zookeeper-JavaAPI操作-Watch监听-NodeCache"><a href="#Zookeeper-JavaAPI操作-Watch监听-NodeCache" class="headerlink" title="Zookeeper JavaAPI操作-Watch监听-NodeCache"></a>Zookeeper JavaAPI操作-Watch监听-NodeCache</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 演示 NodeCache：给指定一个节点注册监听器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testNodeCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1. 创建NodeCache对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">NodeCache</span> <span class="variable">nodeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeCache</span>(client,<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">    <span class="comment">//2. 注册监听</span></span><br><span class="line">   	nodeCache.getListenable().addListener(<span class="keyword">new</span> <span class="title class_">NodeCacheListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;节点变化了~&quot;</span>);</span><br><span class="line">            <span class="comment">//获取修改节点后的数据</span></span><br><span class="line">            <span class="type">byte</span>[] data = nodeCache.getCurrentData().getData();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    	<span class="comment">//3. 开启监听.如果设置为true，则开启监听是，加载缓冲数据</span></span><br><span class="line">    	nodeCache.start(<span class="literal">true</span>);</span><br><span class="line">    	<span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper-JavaAPI操作-Watch监听-PathChildrenCache"><a href="#Zookeeper-JavaAPI操作-Watch监听-PathChildrenCache" class="headerlink" title="Zookeeper JavaAPI操作-Watch监听-PathChildrenCache"></a>Zookeeper JavaAPI操作-Watch监听-PathChildrenCache</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPathChildrenCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1.创建监听对象</span></span><br><span class="line">    <span class="type">PathChildrenCache</span> <span class="variable">pathChildrenCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathChildrenCache</span>(client,<span class="string">&quot;/app2&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//2. 绑定监听器</span></span><br><span class="line">    pathChildrenCache.getListenable().addListener(<span class="keyword">new</span> <span class="title class_">PathChildrenCacheListener</span>() &#123;    			<span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子节点变化了~&quot;</span>);</span><br><span class="line">            System.out.println(event);</span><br><span class="line">            <span class="comment">//监听子节点的数据变更，并且拿到变更后的数据</span></span><br><span class="line">            <span class="comment">//1.获取类型</span></span><br><span class="line">            PathChildrenCacheEvent.<span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> event.getType();</span><br><span class="line">            <span class="comment">//2.判断类型是否是update</span></span><br><span class="line">            <span class="keyword">if</span>(type.equals(PathChildrenCacheEvent.Type.CHILD_UPDATED))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数据变了！！！&quot;</span>);</span><br><span class="line">                <span class="type">byte</span>[] data = event.getData().getData();</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//3. 开启</span></span><br><span class="line">    pathChildrenCache.start();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper-JavaAPI操作-Watch监听-TreeCache"><a href="#Zookeeper-JavaAPI操作-Watch监听-TreeCache" class="headerlink" title="Zookeeper JavaAPI操作-Watch监听-TreeCache"></a>Zookeeper JavaAPI操作-Watch监听-TreeCache</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 演示 TreeCache：监听某个节点自己和所有子节点们</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTreeCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1. 创建监听器</span></span><br><span class="line">    <span class="type">TreeCache</span> <span class="variable">treeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeCache</span>(client,<span class="string">&quot;/app2&quot;</span>);</span><br><span class="line">    <span class="comment">//2. 注册监听</span></span><br><span class="line">    treeCache.getListenable().addListener(<span class="keyword">new</span> <span class="title class_">TreeCacheListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">childEvent</span><span class="params">(CuratorFramework client, TreeCacheEvent event)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;节点变化了&quot;</span>);</span><br><span class="line">            System.out.println(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//3. 开启</span></span><br><span class="line">    treeCache.start();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper分布式锁-概念"><a href="#Zookeeper分布式锁-概念" class="headerlink" title="Zookeeper分布式锁-概念"></a>Zookeeper分布式锁-概念</h3><ul>
<li>在我们进行单机应用开发，涉及并发同步的时候，我们往往采用synchronized或者Lock的方式来解决多线程间的代码同步问题，这时多线程的运行都是在同一个JVM之下，没有任何问题。</li>
<li>但当我们的应用是分布式集群工作的情况下，属于多JVM下的工作环境，跨JVM之间已经无法通过多线程的锁解决同步问题。</li>
<li>那么就需要一种更加高级的锁机制，来处理种跨机器的进程之间的数据同步问题——这就是分布式锁。</li>
</ul>
<h3 id="Zookeeper分布式锁-zookeeper分布式锁原理"><a href="#Zookeeper分布式锁-zookeeper分布式锁原理" class="headerlink" title="Zookeeper分布式锁-zookeeper分布式锁原理"></a>Zookeeper分布式锁-zookeeper分布式锁原理</h3><p>核心思想：当客户端要获取锁，则创建节点，使用完锁，则删除该节点</p>
<p>客户端获取锁时，在lock节点下创建临时顺序节点。</p>
<p>然后获取lock下面的所有子节点，客户端获取到所有的子节点之后，如果发现自己创建的子节点序号最小，那么就认为该客户端获取到了锁。使用完锁后，将该节点删除。</p>
<p>如果发现自己创建的节点并非lock所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，同时对其注册事件监听器，监听删除事件。</p>
<h3 id="Zookeeper-分布式锁-Curator实现分布式锁API"><a href="#Zookeeper-分布式锁-Curator实现分布式锁API" class="headerlink" title="Zookeeper 分布式锁-Curator实现分布式锁API"></a>Zookeeper 分布式锁-Curator实现分布式锁API</h3><p>在Curator中有五种锁方案：</p>
<ul>
<li>InterProcessSemaphoreMutex：分布式排它锁（非可重入锁）</li>
<li>InterProcessMutex：分布式可重入排它锁</li>
<li>InterProcessReadWriteLock：分布式读写锁</li>
<li>InterProcessMultiLock：将多个锁作为单个实体管理的容器</li>
<li>InterProcessSemaphoreV2：共享信号量</li>
</ul>
<h2 id="ZooKeeper-集群搭建"><a href="#ZooKeeper-集群搭建" class="headerlink" title="ZooKeeper 集群搭建"></a>ZooKeeper 集群搭建</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li><p>三台服务器</p>
</li>
<li><p>安装JDK</p>
</li>
<li><p>上传zookeeper安装包至三台服务器</p>
</li>
<li><p>将Zookeeper解压 ，建立&#x2F;usr&#x2F;local&#x2F;zookeeper-cluster目录，将解压后的Zookeeper复制该目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /usr/local/zookeeper</span><br><span class="line">tar -zxvf apache-zookeeper-3.5.6-bin.tar.gz</span><br><span class="line">mv apache-zookeeper-3.5.6-bin /usr/local/zookeeper</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建data目录 ，并且将 conf下zoo_sample.cfg 文件改名为 zoo.cfg</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /usr/local/zookeeper/data</span><br><span class="line">mv  /usr/local/zookeeper/conf/zoo_sample.cfg  /usr/local/zookeeper/conf/zoo.cfg</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置dataDir 为创建的data目录和 指定的clientPort </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/zookeeper/conf/zoo.cfg</span><br><span class="line"></span><br><span class="line">clientPort=2181</span><br><span class="line">dataDir=/usr/local/zookeeper/data</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果定义集群，使用结点名访问，配置hostname</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname zookeeper1</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h3><ol>
<li><p>在zookeeper的 data 目录下创建一个 myid 文件，内容分别是1、2、3 。这个文件就是记录每个服务器的ID</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1 &gt;/usr/local/zookeeper/data/myid</span><br></pre></td></tr></table></figure>
</li>
<li><p>在每一个zookeeper 的 zoo.cfg配置客户端访问端口（clientPort）和集群服务器IP列表。集群服务器IP列表如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/zookeeper/conf/zoo.cfg</span><br><span class="line"></span><br><span class="line">server.1=ip:2881:3881</span><br><span class="line">server.2=ip:2882:3882</span><br><span class="line">server.3=ip:2883:3883</span><br></pre></td></tr></table></figure>

<p>解释：server.服务器ID&#x3D;服务器IP地址：服务器之间通信端口：服务器之间投票选举端口</p>
</li>
</ol>
<h3 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h3><p>分别在三台服务器上启动zookeeper</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/zookeeper/bin/zkServer.sh start</span><br></pre></td></tr></table></figure>

<p>启动后我们查询一下每个实例的运行状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/zookeeper/bin/zkServer.sh status</span><br></pre></td></tr></table></figure>

<p>如果存在一个leader和两个follower，说明集群启动成功</p>
<h4 id="Zookeepe集群角色"><a href="#Zookeepe集群角色" class="headerlink" title="Zookeepe集群角色"></a>Zookeepe集群角色</h4><p>在ZooKeeper集群服中务中有三个角色：</p>
<ul>
<li><p>Leader 领导者 ：</p>
<p>处理事务请求</p>
<p>集群内部各服务器的调度者</p>
</li>
<li><p>Follower 跟随者 ：</p>
<p>处理客户端非事务请求，转发事务请求给Leader服务器</p>
<p>参与Leader选举投票</p>
</li>
<li><p>Observer 观察者：</p>
<p>处理客户端非事务请求，转发事务请求给Leader服务器</p>
</li>
</ul>
<p><img src="/./images/1592058451822.png"></p>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql索引及调优</title>
    <url>/2023/07/14/Mysql%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h2 id="为什么使用索引"><a href="#为什么使用索引" class="headerlink" title="为什么使用索引"></a>为什么使用索引</h2><p>索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则<code>通过索引查找</code>相关数据，如果不符合则需要<code>全表扫描</code>，即需要一条一条地查找记录，直到找到与条件符合的记录。</p>
<p><img src="index.png" alt="image-20230714142202471"></p>
<p>如上图所示，数据库没有索引的情况下，数据<code>分布在硬盘不同的位置上面</code>，读取数据时，摆臂需要前后摆动查询数据，这样操作非常消耗时间。如果<code>数据顺序摆放</code>，那么也需要从1到6行按顺序读取，这样就相当于进行了6次IO操作，<code>依旧非常耗时</code>。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找 Col 2 &#x3D; 89 这条记录，就要逐行去查找、去比较。从Col 2 &#x3D; 34 开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有<code>上千万条数据</code>，就意味着要做<code>很多很多次硬盘I/0</code>才能找到。现在要查找 Col 2 &#x3D; 89 这条记录。CPU必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间就是磁盘I&#x2F;O（涉及到磁盘的旋转时间（速度较快），磁头的寻道时间(速度慢、费时)）</p>
<p>假如给数据使用 <code>二叉树</code> 这样的数据结构进行存储，如下图所示</p>
<p><img src="image-20230714142455822.png" alt="image-20230714142455822">对字段 Col 2 添加了索引，就相当于在硬盘上为 Col 2 维护了一个索引的数据结构，即这个 <code>二叉搜索树</code>。二叉搜索树的每个结点存储的是 <code>(K, V) 结构</code>，key 是 Col 2，value 是该 key 所在行的文件指针（地址）。比如：该二叉搜索树的根节点就是：<code>(34, 0x07)</code>。现在对 Col 2 添加了索引，这时再去查找 Col 2 &#x3D; 89 这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找)。读 34 到内存，89 &gt; 34; 继续右侧数据，读 89 到内存，89&#x3D;&#x3D;89；找到数据返回。找到之后就根据当前结点的 value 快速定位到要查找的记录对应的地址。我们可以发现，只需要 <code>查找两次</code> 就可以定位到记录的地址，查询速度就提高了。</p>
<p>这就是我们为什么要建索引，目的就是为了 <code>减少磁盘I/O的次数</code>，加快查询速率。</p>
<h2 id="索引及其优缺点"><a href="#索引及其优缺点" class="headerlink" title="索引及其优缺点"></a>索引及其优缺点</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。</p>
<p><strong>索引的本质</strong>：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 <code>高级查找算法</code> 。</p>
<p><code>索引是在存储引擎中实现的</code>，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的 <code>最大索引数</code>和 <code>最大索引长度</code>。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>类似大学图书馆建书目索引，提高数据检索的效率，降低 <strong>数据库的IO成本</strong> ，这也是创建索引最主 要的原因。</li>
<li>通过创建唯一索引，可以保证数据库表中每一行 <strong>数据的唯一性</strong> 。</li>
<li>在实现数据的 参考完整性方面，可以 <strong>加速表和表之间的连接</strong> 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。</li>
<li>在使用分组和排序子句进行数据查询时，可以显著 <strong>减少查询中分组和排序的时间</strong> ，降低了CPU的消耗。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>增加索引也有许多不利的方面，主要表现在如下几个方面：</p>
<ol>
<li>创建索引和维护索引要 <strong>耗费时间</strong> ，并 且随着数据量的增加，所耗费的时间也会增加。</li>
<li>索引需要占 <strong>磁盘空间</strong> ，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文 件更快达到最大文件尺寸。</li>
<li>虽然索引大大提高了查询速度，同时却会 <strong>降低更新表的速度</strong> 。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 因此，选择使用索引时，需要综合考虑索引的优点和缺点。</li>
</ol>
<p>因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p>
<blockquote>
<p>提示：</p>
<p>索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p>
</blockquote>
<h2 id="InnoDB中索引的推演"><a href="#InnoDB中索引的推演" class="headerlink" title="InnoDB中索引的推演"></a>InnoDB中索引的推演</h2><h3 id="索引之前的查找"><a href="#索引之前的查找" class="headerlink" title="索引之前的查找"></a>索引之前的查找</h3><p>先来看一个精确匹配的例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [列名列表] <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="operator">=</span> xxx;</span><br></pre></td></tr></table></figure>

<h4 id="在一个页中的查找"><a href="#在一个页中的查找" class="headerlink" title="在一个页中的查找"></a>在一个页中的查找</h4><p>假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p>
<ul>
<li><p>以主键为搜索条件</p>
<p>可以在页目录中使用 <code>二分法</code> 快速定位到对应的槽，然后再遍历该槽对用分组中的记录即可快速找到指定记录。</p>
</li>
<li><p>以其他列作为搜索条件</p>
<p>因为在数据页中并没有对非主键列简历所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从 <code>最小记录</code> 开始 <code>依次遍历单链表中的每条记录</code>， 然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</p>
</li>
</ul>
<h4 id="在很多页中查找"><a href="#在很多页中查找" class="headerlink" title="在很多页中查找"></a>在很多页中查找</h4><p>在很多页中查找记录的活动可以分为两个步骤：</p>
<ol>
<li>定位到记录所在的页。</li>
<li>从所在的页内中查找相应的记录。</li>
</ol>
<p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能 从第一个页沿着双向链表 一直往下找，在每一个页中根据我们上面的查找方式去查 找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 超级耗时 的。如果一个表有一亿条记录呢？此时 索引 应运而生。</p>
<h3 id="设计索引"><a href="#设计索引" class="headerlink" title="设计索引"></a>设计索引</h3><p>建一个表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo(</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> c1 <span class="type">INT</span>,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> c2 <span class="type">INT</span>,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> c3 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">PRIMARY</span> KEY(c1)</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> ) ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure>

<p>这个新建的 <strong>index_demo</strong> 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键， 这个表使用 <strong>Compact</strong> 行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：</p>
<p><img src="image-20230714143358038.png" alt="image-20230714143358038"></p>
<p>我们只在示意图里展示记录的这几个部分：</p>
<ul>
<li>record_type ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记 录、 3 表示最大记录、 1 暂时还没用过，下面讲。</li>
<li>mysql&gt; CREATE TABLE index_demo( -&gt; c1 INT, -&gt; c2 INT, -&gt; c3 CHAR(1), -&gt; PRIMARY KEY(c1) -&gt; ) ROW_FORMAT &#x3D; Compact; next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用 箭头来表明下一条记录是谁。</li>
<li>各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。</li>
<li>其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li>
</ul>
<p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p>
<p><img src="image-20230714143826132.png" alt="image-20230714143826132"></p>
<p>把一些记录放到页里的示意图就是：</p>
<p><img src="image-20230714143859703.png" alt="image-20230714143859703"></p>
<h4 id="一个简单的索引设计方案"><a href="#一个简单的索引设计方案" class="headerlink" title="一个简单的索引设计方案"></a>一个简单的索引设计方案</h4><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们 <strong>想快速的定位到需要查找的记录在哪些数据页</strong> 中该咋办？我们可以为快速定位记录所在的数据页而建立一个目录 ，建这个目录必须完成下边这些事：</p>
<ul>
<li><p><strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</strong></p>
<p>假设：每个数据结构最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> index_demo <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="string">&#x27;u&#x27;</span>), (<span class="number">3</span>, <span class="number">9</span>, <span class="string">&#x27;d&#x27;</span>), (<span class="number">5</span>, <span class="number">3</span>, <span class="string">&#x27;y&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p> 那么这些记录以及按照主键值的大小串联成一个单向链表了，如图所示：</p>
<p><img src="image-20230714144032027.png" alt="image-20230714144032027"></p>
<p>从图中可以看出来， index_demo 表中的3条记录都被插入到了编号为10的数据页中了。此时我们再来插入一条记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> index_demo <span class="keyword">VALUES</span>(<span class="number">4</span>, <span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>因为 <strong>页10</strong> 最多只能放3条记录，所以我们不得不再分配一个新页：</p>
<p><img src="image-20230714144140221.png" alt="image-20230714144140221"></p>
<p>注意：新分配的 <strong>数据页编号可能并不是连续的</strong>。它们只是通过维护者上一个页和下一个页的编号而建立了 <strong>链表</strong> 关系。另外，<strong>页10</strong>中用户记录最大的主键值是5，而<strong>页28</strong>中有一条记录的主键值是4，因为5&gt;4，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为4的记录的时候需要伴随着一次 <strong>记录移动</strong>，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下：</p>
<p><img src="image-20230714144223889.png" alt="image-20230714144223889"></p>
<p>这个过程表明了在对页中的记录进行增删改查操作的过程中，我们必须通过一些诸如 <strong>记录移动</strong> 的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程称为 <strong>页分裂</strong>。</p>
<ul>
<li><strong>给所有的页建立一个目录项。</strong></li>
</ul>
<p>由于数据页的 <strong>编号可能是不连续</strong> 的，所以在向 index_demo 表中插入许多条记录后，可能是这样的效果：</p>
<p><img src="image-20230714144331137.png" alt="image-20230714144331137"></p>
<p>我们需要给它们做个 <strong>目录</strong>，每个页对应一个目录项，每个目录项包括下边两个部分：</p>
<p>1）页的用户记录中最小的主键值，我们用 <strong>key</strong> 来表示。</p>
<p>2）页号，我们用 <strong>page_on</strong> 表示。</p>
<p><img src="image-20230714154813715.png" alt="image-20230714154813715"></p>
<p>以 页28 为例，它对应 目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主 键值 5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键 值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：</p>
<ol>
<li>先从目录项中根据 二分法 快速确定出主键值为 20 的记录在 目录项3 中（因为 12 &lt; 20 &lt; 209 ），它对应的页是 页9 。</li>
<li>再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。</li>
</ol>
<p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 <strong>索引</strong> 。</p>
<h4 id="InnoDB中的索引方案"><a href="#InnoDB中的索引方案" class="headerlink" title="InnoDB中的索引方案"></a>InnoDB中的索引方案</h4><h5 id="迭代1次：目录项纪录的页"><a href="#迭代1次：目录项纪录的页" class="headerlink" title="迭代1次：目录项纪录的页"></a>迭代1次：目录项纪录的页</h5><p>InnoDB怎么区分一条记录是普通的 <strong>用户记录</strong> 还是 <strong>目录项记录</strong> 呢？使用记录头信息里的 <strong>record_type</strong> 属性，它的各自取值代表的意思如下：</p>
<ul>
<li>0：普通的用户记录</li>
<li>1：目录项记录</li>
<li>2：最小记录</li>
<li>3：最大记录</li>
</ul>
<p>我们把前边使用到的目录项放到数据页中的样子就是这样：</p>
<p><img src="image-20230714155726688.png" alt="image-20230714155726688"></p>
<p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 <strong>目录项记录</strong> 和普通的 <strong>用户记录</strong> 的不同点：</p>
<ul>
<li><strong>目录项记录</strong> 的 record_type 值是1，而 <strong>普通用户记录</strong> 的 record_type 值是0。</li>
<li>目录项记录只有 <strong>主键值和页的编号</strong> 两个列，而普通的用户记录的列是用户自己定义的，可能包含 <strong>很多列</strong> ，另外还有InnoDB自己添加的隐藏列。</li>
<li>了解：记录头信息里还有一个叫 <strong>min_rec_mask</strong> 的属性，只有在存储 <strong>目录项记录</strong> 的页中的主键值最小的 <strong>目录项记录</strong> 的 <strong>min_rec_mask</strong> 值为 <strong>1</strong> ，其他别的记录的 <strong>min_rec_mask</strong> 值都是 <strong>0</strong> 。</li>
</ul>
<p><strong>相同点</strong>：两者用的是一样的数据页，都会为主键值生成 <strong>Page Directory （页目录）</strong>，从而在按照主键值进行查找时可以使用 <strong>二分法</strong> 来加快查询速度。</p>
<p>现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p>
<ol>
<li>先到存储 目录项记录 的页，也就是页30中通过 二分法 快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9。</li>
<li>再到存储用户记录的页9中根据 二分法 快速定位到主键值为 20 的用户记录。</li>
</ol>
<h5 id="迭代2次：多个目录项纪录的页"><a href="#迭代2次：多个目录项纪录的页" class="headerlink" title="迭代2次：多个目录项纪录的页"></a>迭代2次：多个目录项纪录的页</h5><p><img src="image-20230714155915297.png" alt="image-20230714155915297"></p>
<p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：</p>
<ul>
<li>为存储该用户记录而新生成了 页31 。</li>
<li>因为原先存储目录项记录的 页30的容量已满 （我们前边假设只能存储4条目录项记录），所以不得 不需要一个新的 页32 来存放 页31 对应的目录项。</li>
</ul>
<p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为 20 的记录为例：</p>
<ol>
<li>确定 目录项记录页 我们现在的存储目录项记录的页有两个，即 页30 和 页32 ，又因为页30表示的目录项的主键值的 范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目 录项记录在 页30 中。</li>
<li>通过目录项记录页 确定用户记录真实所在的页 。 在一个存储 目录项记录 的页中通过主键值定位一条目录项记录的方式说过了。</li>
<li>在真实存储用户记录的页中定位到具体的记录。</li>
</ol>
<h5 id="迭代3次：目录项记录页的目录页"><a href="#迭代3次：目录项记录页的目录页" class="headerlink" title="迭代3次：目录项记录页的目录页"></a>迭代3次：目录项记录页的目录页</h5><p>如果我们表中的数据非常多则会<code>产生很多存储目录项记录的页</code>，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个<code>更高级的目录</code>，就像是一个多级目录一样，<code>大目录里嵌套小目录</code>，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p>
<p><img src="image-20230714160026724.png" alt="image-20230714160026724"></p>
<p>如图，我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用 户记录的主键值在 [1, 320) 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的 话，就到页32中查找更详细的目录项记录。</p>
<p>我们可以用下边这个图来描述它：</p>
<p><img src="image-20230714160111944.png" alt="image-20230714160111944"></p>
<p>这个数据结构，它的名称是 B+树 。</p>
<h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h5><p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存 放 1000条目录项记录 ，那么：</p>
<ul>
<li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。</li>
<li>如果B+树有2层，最多能存放 1000×100&#x3D;10,0000 条记录。</li>
<li>如果B+树有3层，最多能存放 1000×1000×100&#x3D;1,0000,0000 条记录。</li>
<li>如果B+树有4层，最多能存放 1000×1000×1000×100&#x3D;1000,0000,0000 条记录。相当多的记录！</li>
</ul>
<p>你的表里能存放 <strong>100000000000</strong> 条记录吗？所以一般情况下，我们用到的 <strong>B+树都不会超过4层</strong> ，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的 <strong>Page Directory</strong> （页目录），所以在页面内也可以通过 <strong>二分法</strong> 实现快速 定位记录。</p>
<h3 id="常见索引概念"><a href="#常见索引概念" class="headerlink" title="常见索引概念"></a>常见索引概念</h3><p>索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集 索引称为二级索引或者辅助索引。</p>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引并不是一种单独的索引类型，而是<strong>一种数据存储方式</strong>（所有的用户记录都存储在了叶子结点），也就是所谓的 <code>索引即数据，数据即索引</code>。</p>
<blockquote>
<p>术语”聚簇”表示当前数据行和相邻的键值聚簇的存储在一起</p>
</blockquote>
<p><strong>特点：</strong></p>
<ul>
<li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p>
<ul>
<li><code>页内</code> 的记录是按照主键的大小顺序排成一个 <code>单向链表</code> 。</li>
<li>各个存放 <code>用户记录的页</code> 也是根据页中用户记录的主键大小顺序排成一个 <code>双向链表</code> 。</li>
<li>存放 <code>目录项记录的页</code> 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 <code>双向链表</code> 。</li>
</ul>
</li>
<li><p>B+树的 叶子节点 存储的是完整的用户记录。</p>
<p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p>
</li>
</ul>
<p>我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX 语句去创建， <code>InnDB</code> 存储引擎会 <code>自动</code> 的为我们创建聚簇索引。</p>
<p><strong>优点：</strong></p>
<ul>
<li><code>数据访问更快</code> ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li>
<li>聚簇索引对于主键的 <code>排序查找</code> 和 <code>范围查找</code> 速度非常快</li>
<li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 <code>节省了大量的io操作</code> 。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><code>插入速度严重依赖于插入顺序</code> ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<code>自增的ID列为主键</code></li>
<li><code>更新主键的代价很高</code> ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li>
<li><code>二级索引访问需要两次索引查找</code> ，第一次找到主键值，第二次根据主键值找到行数据</li>
</ul>
<h4 id="二级索引（辅助索引、非聚簇索引）"><a href="#二级索引（辅助索引、非聚簇索引）" class="headerlink" title="二级索引（辅助索引、非聚簇索引）"></a>二级索引（辅助索引、非聚簇索引）</h4><p>如果我们想以别的列作为搜索条件该怎么办？肯定不能是从头到尾沿着链表依次遍历记录一遍。</p>
<p>答案：我们可以<code>多建几颗B+树</code>，不同的B+树中的数据采用不同的排列规则。比方说我们用<code>c2</code>列的大小作为数据页、页中记录的排序规则，再建一课B+树，效果如下图所示：</p>
<p><img src="image-20230714160245062.png" alt="image-20230714160245062"></p>
<p>这个B+树与上边介绍的聚簇索引有几处不同：</p>
<p><img src="image-20230714160311029.png" alt="image-20230714160311029"></p>
<p><strong>概念：回表</strong></p>
<p>我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根 据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就 是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！</p>
<p><strong>问题</strong>：为什么我们还需要一次 回表 操作呢？直接把完整的用户记录放到叶子节点不OK吗？</p>
<p><strong>回答</strong>：</p>
<p>如果把完整的用户记录放到叶子结点是可以不用回表。但是<code>太占地方</code>了，相当于每建立一课B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。</p>
<p>因为这种按照<code>非主键列</code>建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为<code>二级索引</code>，或者辅助索引。由于使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树为c2列简历的索引。</p>
<p>非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。</p>
<p><img src="image-20230714160414093.png" alt="image-20230714160414093"></p>
<p>小结：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：</p>
<ol>
<li>聚簇索引的<code>叶子节点</code>存储的就是我们的<code>数据记录</code>, 非聚簇索引的叶子节点存储的是<code>数据位置</code>。非聚簇索引不会影响数据表的物理存储顺序。</li>
<li>一个表<code>只能有一个聚簇索引</code>，因为只能有一种排序存储的方式，但可以有<code>多个非聚簇索引</code>，也就是多个索引目录提供数据检索。</li>
<li>使用聚簇索引的时候，数据的<code>查询效率高</code>，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。</li>
</ol>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按 照 c2和c3列 的大小进行排序，这个包含两层含义：</p>
<ul>
<li>先把各个记录和页按照c2列进行排序。</li>
<li>在记录的c2列相同的情况下，采用c3列进行排序</li>
</ul>
<p>为c2和c3建立的索引的示意图如下：</p>
<p><img src="image-20230714160448075.png" alt="image-20230714160448075"></p>
<p>如图所示，我们需要注意以下几点：</p>
<ul>
<li>每条目录项都有c2、c3、页号这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序</li>
<li>B+树叶子节点处的用户记录由c2、c3和主键c1列组成</li>
</ul>
<p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意 思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p>
<ul>
<li>建立 联合索引 只会建立如上图一样的1棵B+树。</li>
<li>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</li>
</ul>
<h3 id="InnoDB的B-树索引的注意事项"><a href="#InnoDB的B-树索引的注意事项" class="headerlink" title="InnoDB的B+树索引的注意事项"></a>InnoDB的B+树索引的注意事项</h3><h4 id="根页面位置万年不动"><a href="#根页面位置万年不动" class="headerlink" title="根页面位置万年不动"></a>根页面位置万年不动</h4><p>实际上B+树的形成过程是这样的：</p>
<ul>
<li>每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个 <code>根结点</code> 页面。最开始表中没有数据的时候，每个B+树索引对应的 <code>根结点</code> 中即没有用户记录，也没有目录项记录。</li>
<li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code> 中。</li>
<li>当根节点中的可用 <code>空间用完时</code> 继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如 <code>页a</code> 中，然后对这个新页进行 <code>页分裂</code> 的操作，得到另一个新页，比如<code>页b</code> 。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到 <code>页a</code> 或者 <code>页b</code> 中，而 <code>根节点</code> 便升级为存储目录项记录的页。</li>
</ul>
<p>这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表创建一个索引，那么它的根节点的页号便会被记录到某个地方。然后凡是 <code>InnoDB</code> 存储引擎需要用到这个索引的时候，都会从哪个固定的地方取出根节点的页号，从而来访问这个索引。</p>
<h4 id="内节点中目录项记录的唯一性"><a href="#内节点中目录项记录的唯一性" class="headerlink" title="内节点中目录项记录的唯一性"></a>内节点中目录项记录的唯一性</h4><p>我们知道B+树索引的内节点中目录项记录的内容是 <code>索引列 + 页号</code> 的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿 index_demo 表为例，假设这个表中的数据是这样的：</p>
<p><img src="image-20230714160708662.png" alt="image-20230714160708662"></p>
<p>如果二级索引中目录项记录的内容只是 <code>索引列 + 页号</code> 的搭配的话，那么为 <code>c2</code> 列简历索引后的B+树应该长这样：</p>
<p><img src="image-20230714160730495.png" alt="image-20230714160730495"></p>
<p>如果我们想新插入一行记录，其中 <code>c1</code> 、<code>c2</code> 、<code>c3</code> 的值分别是: <code>9</code>、<code>1</code>、<code>c</code>, 那么在修改这个为 c2 列建立的二级索引对应的 B+ 树时便碰到了个大问题：由于 <code>页3</code> 中存储的目录项记录是由 <code>c2列 + 页号</code> 的值构成的，<code>页3</code> 中的两条目录项记录对应的 c2 列的值都是1，而我们 <code>新插入的这条记录</code> 的 c2 列的值也是 <code>1</code>，那我们这条新插入的记录到底应该放在 <code>页4</code> 中，还是应该放在 <code>页5</code> 中？答案：对不起，懵了</p>
<p>为了让新插入记录找到自己在那个页面，我们需要<strong>保证在B+树的同一层页节点的目录项记录除页号这个字段以外是唯一的</strong>。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p>
<ul>
<li>索引列的值</li>
<li>主键值</li>
<li>页号</li>
</ul>
<p>也就是我们把<code>主键值</code>也添加到二级索引内节点中的目录项记录，这样就能保住 B+ 树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2建立二级索引后的示意图实际上应该是这样子的：</p>
<p><img src="image-20230714160813585.png" alt="image-20230714160813585"></p>
<p>这样我们再插入记录<code>(9, 1, &#39;c&#39;)</code> 时，由于 <code>页3</code> 中存储的目录项记录是由 <code>c2列 + 主键 + 页号</code> 的值构成的，可以先把新纪录的 <code>c2</code> 列的值和 <code>页3</code> 中各目录项记录的 <code>c2</code> 列的值作比较，如果 <code>c2</code> 列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的 <code>c2列 + 主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新纪录应该被插入到 <code>页5</code> 中。</p>
<h4 id="一个页面最少存储-2-条记录"><a href="#一个页面最少存储-2-条记录" class="headerlink" title="一个页面最少存储 2 条记录"></a>一个页面最少存储 2 条记录</h4><p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常多，而且最后的那个存放真实数据的目录中只存放一条数据。所以 <strong>InnoDB 的一个数据页至少可以存放两条记录</strong>。</p>
<h2 id="MyISAM中的索引方案"><a href="#MyISAM中的索引方案" class="headerlink" title="MyISAM中的索引方案"></a>MyISAM中的索引方案</h2><p>B树索引使用存储引擎如表所示：</p>
<table>
<thead>
<tr>
<th>索引 &#x2F; 存储引擎</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>B-Tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索 引是Btree索引；而Memory默认的索引是Hash索引。</p>
<p>MyISAM引擎使用 B+Tree 作为索引结构，叶子节点的data域存放的是 数据记录的地址 。</p>
<h3 id="MyISAM索引的原理"><a href="#MyISAM索引的原理" class="headerlink" title="MyISAM索引的原理"></a>MyISAM索引的原理</h3><p><img src="image-20230714160937717.png" alt="image-20230714160937717"></p>
<p><img src="image-20230714160952453.png" alt="image-20230714160952453"></p>
<p><img src="image-20230714161009301.png" alt="image-20230714161009301"></p>
<p><img src="image-20230714161024390.png" alt="image-20230714161024390"></p>
<p><img src="image-20230714161042650.png" alt="image-20230714161042650"></p>
<h3 id="MyISAM-与-InnoDB对比"><a href="#MyISAM-与-InnoDB对比" class="headerlink" title="MyISAM 与 InnoDB对比"></a>MyISAM 与 InnoDB对比</h3><p><strong>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区别：</strong></p>
<p>① 在InnoDB存储引擎中，我们只需要根据主键值对 聚簇索引 进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次 回表 操作，意味着MyISAM中建立的索引相当于全部都是 二级索引 。</p>
<p>② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是 分离的 ，索引文件仅保存数 据记录的地址。</p>
<p>③ InnoDB的非聚簇索引data域存储相应记录 主键的值 ，而MyISAM索引记录的是 地址 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域。</p>
<p>④ MyISAM的回表操作是十分 快速 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通 过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p>
<p>⑤ InnoDB要求表 必须有主键 （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐 含字段作为主键，这个字段长度为6个字节，类型为长整型。</p>
<p><strong>小结：</strong></p>
<p><img src="image-20230714161133219.png" alt="image-20230714161133219"></p>
<p><img src="image-20230714161149350.png" alt="image-20230714161149350"></p>
<h2 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h2><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p>
<ul>
<li><p>空间上的代价</p>
<p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p>
</li>
<li><p>时间上的代价</p>
<p>每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每 层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还 是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序 而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需 要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p>
</li>
</ul>
<blockquote>
<p>一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们得学学这些索引在哪些条件下起作用的。</p>
</blockquote>
<h2 id="MySQL数据结构选择的合理性"><a href="#MySQL数据结构选择的合理性" class="headerlink" title="MySQL数据结构选择的合理性"></a>MySQL数据结构选择的合理性</h2><p><img src="image-20230714161542610.png" alt="image-20230714161542610"></p>
<h3 id="全表查询"><a href="#全表查询" class="headerlink" title="全表查询"></a>全表查询</h3><h3 id="Hash查询"><a href="#Hash查询" class="headerlink" title="Hash查询"></a>Hash查询</h3><p><img src="image-20230714161720301.png" alt="image-20230714161720301"></p>
<p><strong>加快查找速度的数据结构，常见的有两类：</strong></p>
<p>(1) 树，例如平衡二叉搜索树，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是 <code>O(log2N)</code>;</p>
<p>(2)哈希，例如HashMap，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是 <code>O(1)</code>; (key, value)</p>
<p><img src="image-20230714161800540.png" alt="image-20230714161800540"></p>
<p><img src="image-20230714161820538.png" alt="image-20230714161820538"></p>
<p><img src="image-20230714161838622.png" alt="image-20230714161838622"></p>
<p>上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做 碰撞 ，在数据库中一般采用 链 接法 来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：</p>
<p><img src="image-20230714161928952.png" alt="image-20230714161928952"></p>
<p><strong>Hash结构效率高，那为什么索引结构要设计成树型呢？</strong></p>
<p><img src="image-20230714161957648.png" alt="image-20230714161957648"></p>
<p><strong>Hash索引适用存储引擎如表所示：</strong></p>
<table>
<thead>
<tr>
<th>索引 &#x2F; 存储引擎</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>HASH索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p><strong>Hash索引的适用性：</strong></p>
<p><img src="image-20230714162023308.png" alt="image-20230714162023308"></p>
<p><img src="image-20230714162039666.png" alt="image-20230714162039666"></p>
<p>采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时 候，通过自适应 Hash 索引可以明显提高数据的检索效率。</p>
<p>我们可以通过 innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%adaptive_hash_index&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p>
<p><strong>二叉搜索树的特点</strong></p>
<ul>
<li>一个节点只能有两个子节点，也就是一个节点度不能超过2</li>
<li>左子节点 &lt; 本节点; 右子节点 &gt;&#x3D; 本节点，比我大的向右，比我小的向左</li>
</ul>
<p><strong>查找规则</strong></p>
<p><img src="image-20230714162216120.png" alt="image-20230714162216120"></p>
<p><img src="image-20230714162235278.png" alt="image-20230714162235278"></p>
<p>但是特殊情况，就是有时候二叉树的深度非常大，比如：</p>
<p><img src="image-20230714162258227.png" alt="image-20230714162258227"></p>
<p>为了提高查询效率，就需要 减少磁盘IO数 。为了减少磁盘IO的次数，就需要尽量 降低树的高度 ，需要把 原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。</p>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p><img src="image-20230714162320731.png" alt="image-20230714162320731"></p>
<p><img src="image-20230714162335531.png" alt="image-20230714162335531"></p>
<p>每访问一次节点就需要进行一次磁盘 I&#x2F;O 操作，对于上面的树来说，我们需要进行 5次 I&#x2F;O 操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘 I&#x2F;O 操作次数多，会影响整体数据查询的效率。</p>
<p>针对同样的数据，如果我们把二叉树改成 M 叉树 （M&gt;2）呢？当 M&#x3D;3 时，同样的 31 个节点可以由下面 的三叉树来进行存储：</p>
<p><img src="image-20230714162418300.png" alt="image-20230714162418300"></p>
<p>你能看到此时树的高度降低了，当数据量 N 大的时候，以及树的分叉树 M 大的时候，M叉树的高度会远小于二叉树的高度 (M &gt; 2)。所以，我们需要把 &#96;树从“瘦高” 变 “矮胖”。</p>
<h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>B 树的英文是 Balance Tree，也就是 <code>多路平衡查找树</code>。简写为 B-Tree。它的高度远小于平衡二叉树的高度。</p>
<p>B 树的结构如下图所示：</p>
<p><img src="image-20230714162458716.png" alt="image-20230714162458716"></p>
<p><img src="image-20230714162510428.png" alt="image-20230714162510428"></p>
<p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p>
<ol>
<li>根节点的儿子数的范围是 [2,M]。</li>
<li>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 &#x3D; 关键字的数量 +1，k 的取值范围为 [ceil(M&#x2F;2), M]。</li>
<li>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M&#x2F;2), M]。</li>
<li>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]&lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树。</li>
<li>所有叶子节点位于同一层。</li>
</ol>
<p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它 有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15) 大于 12，刚好符合刚才我们给出的特征。</p>
<p>然后我们来看下如何用 B 树进行查找。假设我们想要 查找的关键字是 9 ，那么步骤可以分为以下几步：</p>
<ol>
<li>我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1；</li>
<li>按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2；</li>
<li>按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。</li>
</ol>
<p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比 较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I&#x2F;O 操作，消耗的时间比在内存中进行 比较所需要的时间要多，是数据查找用时的重要因素。 B 树相比于平衡二叉树来说磁盘 I&#x2F;O 操作要少 ， 在数据查询中比平衡二叉树效率要高。所以 只要树的高度足够低，IO次数足够少，就可以提高查询性能 。</p>
<p><img src="image-20230714162541238.png" alt="image-20230714162541238"></p>
<p><img src="image-20230714162559287.png" alt="image-20230714162559287"></p>
<h3 id="B-Tree-2"><a href="#B-Tree-2" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>B+Tree是一种多路搜索树，基于B树做出了改进，主流的DBMS都支持B+Tree的索引方式，相比于B-Tree，B+Tree更适合文件索引系统</p>
<p><strong>B+ 树和 B 树的差异在于以下几点：</strong></p>
<ol>
<li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字数 +1。</li>
<li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最 小）。</li>
<li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， 非 叶子节点既保存索引，也保存数据记录 。</li>
<li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大 小从小到大顺序链接。</li>
</ol>
<p><img src="image-20230714162812288.png" alt="image-20230714162812288"></p>
<p><img src="image-20230714162827963.png" alt="image-20230714162827963"></p>
<p><img src="image-20230714162844889.png" alt="image-20230714162844889"></p>
<p><img src="image-20230714162901691.png" alt="image-20230714162901691"></p>
<blockquote>
<p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。 但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</p>
</blockquote>
<p><strong>思考题：为了减少IO，索引树会一次性加载吗？</strong></p>
<p><img src="image-20230714162958135.png" alt="image-20230714162958135"></p>
<p><strong>思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p>
<p><img src="image-20230714163021807.png" alt="image-20230714163021807"></p>
<p><strong>思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p>
<p><img src="image-20230714163038655.png" alt="image-20230714163038655"></p>
<p><strong>思考题：Hash 索引与 B+ 树索引的区别</strong></p>
<p><img src="image-20230714163108708.png" alt="image-20230714163108708"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="image-20230714163142974.png" alt="image-20230714163142974"></p>
<h3 id="附录：算法的时间复杂度"><a href="#附录：算法的时间复杂度" class="headerlink" title="附录：算法的时间复杂度"></a>附录：算法的时间复杂度</h3><p>同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在 于选择合适算法和改进算法。</p>
<p><img src="image-20230714163203219.png" alt="image-20230714163203219"></p>
<h2 id="InnoDB数据存储结构"><a href="#InnoDB数据存储结构" class="headerlink" title="InnoDB数据存储结构"></a>InnoDB数据存储结构</h2><h3 id="数据库的存储结构：页"><a href="#数据库的存储结构：页" class="headerlink" title="数据库的存储结构：页"></a>数据库的存储结构：页</h3><p>索引结构给我们提供了高效的索引方式，不过索引信息和数据记录都是保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的存储引擎负责对表中数据的读写工作。不同的存储引擎的存放的格式一般是不同的，甚至有的存储引擎不用磁盘来存储数据（Memory）</p>
<h4 id="磁盘与内存交互基本单位：页"><a href="#磁盘与内存交互基本单位：页" class="headerlink" title="磁盘与内存交互基本单位：页"></a>磁盘与内存交互基本单位：页</h4><p>InnoDB将数据划分为若干个也，InnoDB中页的大小默认是16KB。</p>
<p>以页作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，数据库中，不论是读一行还是读多行，都是将这些行所在的页进行加载，也就是说，数据库管理存储空间的基本单位是页，数据库I&#x2F;O操作的最小单位是页，一个页中可以存储多个行记录。</p>
<p><img src="image-20230717090642194.png" alt="image-20230717090642194"></p>
<h4 id="页结构的概述"><a href="#页结构的概述" class="headerlink" title="页结构的概述"></a>页结构的概述</h4><p>这些页可以不在物理结构上相连，只要通过双向链表相关联即可，每个数据页中的记录会按照主键值从小到大顺序组成一个单向链表，每个数据页都会为存储在它里面的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历槽对应分组中的记录即可快速找到指定的目录。</p>
<h4 id="页的大小"><a href="#页的大小" class="headerlink" title="页的大小"></a>页的大小</h4><p>不同的数据库管理系统（简称DBMS）的页大小不同。比如在 MySQL 的 InnoDB 存储引擎中，默认页的大小是 <code>16KB</code>，我们可以通过下面的命令来进行查看：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_page_size%&#x27;</span></span><br></pre></td></tr></table></figure>

<p>SQL Server 中页的大小为 <code>8KB</code>，而在 Oracle 中我们用术语 “<code>块</code>“ （Block）来表示 “页”，Oracle 支持的快大小为2KB, 4KB, 8KB, 16KB, 32KB 和 64KB。</p>
<h4 id="页的上层结构"><a href="#页的上层结构" class="headerlink" title="页的上层结构"></a>页的上层结构</h4><p>另外在数据库中，还存在着区（Extent）、段（Segment）和表空间（Tablespace）的概念。行、页、区、段、表空间的关系如下图所示：</p>
<p><img src="image-20230717180015966.png" alt="image-20230717180015966"></p>
<p><img src="image-20230717180123529.png" alt="image-20230717180123529"></p>
<h3 id="页的内部结构"><a href="#页的内部结构" class="headerlink" title="页的内部结构"></a>页的内部结构</h3><p>页如果按类型划分的话，常见的有 <code>数据页（保存B+树节点）、系统表、Undo 页 和 事务数据页</code> 等。数据页是我们最常使用的页。</p>
<p>数据页的 <code>16KB</code> 大小的存储空间被划分为七个部分，分别是文件头（File Header）、页头（Page Header）、最大最小记录（Infimum + supremum）、用户记录（User Records）、空闲空间（Free Space）、页目录（Page Directory）和文件尾（File Tailer）。</p>
<p>页结构的示意图如下所示：</p>
<p><img src="image-20230717180300109.png" alt="image-20230717180300109"></p>
<p>如下表所示：</p>
<p><img src="image-20230717180327464.png" alt="image-20230717180327464"></p>
<p>我们可以把这7个结构分为3个部分。</p>
<h4 id="第一部分：File-Header-文件头部-和-File-Trailer-文件尾部"><a href="#第一部分：File-Header-文件头部-和-File-Trailer-文件尾部" class="headerlink" title="第一部分：File Header (文件头部) 和 File Trailer (文件尾部)"></a>第一部分：File Header (文件头部) 和 File Trailer (文件尾部)</h4><h4 id="第二部分：User-Records-用户记录-、最大最小记录、Free-Space-空闲空间"><a href="#第二部分：User-Records-用户记录-、最大最小记录、Free-Space-空闲空间" class="headerlink" title="第二部分：User Records (用户记录)、最大最小记录、Free Space (空闲空间)"></a>第二部分：User Records (用户记录)、最大最小记录、Free Space (空闲空间)</h4><h4 id="第三部分：Page-Directory-页目录-和-Page-Header-页面头部"><a href="#第三部分：Page-Directory-页目录-和-Page-Header-页面头部" class="headerlink" title="第三部分：Page Directory (页目录) 和 Page Header (页面头部)"></a>第三部分：Page Directory (页目录) 和 Page Header (页面头部)</h4><h4 id="从数据库页的角度看B-树如何查询"><a href="#从数据库页的角度看B-树如何查询" class="headerlink" title="从数据库页的角度看B+树如何查询"></a>从数据库页的角度看B+树如何查询</h4><p>一颗B+树按照字节类型可以分为两部分：</p>
<ol>
<li>叶子节点，B+ 树最底层的节点，节点的高度为0，存储行记录。</li>
<li>非叶子节点，节点的高度大于0，存储索引键和页面指针，并不存储行记录本身。</li>
</ol>
<p><img src="image-20230717180458188.png" alt="image-20230717180458188"></p>
<p>当我们从页结构来理解 B+ 树的结构的时候，可以帮我们理解一些通过索引进行检索的原理：</p>
<p><strong>B+树是如何进行记录检索的</strong></p>
<p>如果通过B+树的索引查询行记录，首先是从B+树的根开始，逐层检索，直到找到叶子结点，也就是找到对应的数据页为止，将数据页加载到内存中，页目录中的槽采用二分查找的方式，先找到一个祖略的记录分组，然后再在分组中通过链表遍历的方式查找记录</p>
<p><strong>普通索引和唯一索引在查询效率上有什么不同</strong></p>
<p>唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，找到了关键字就停止检索。而普通索引，可能存在用户记录中的关键字相同的情况，根据页结构的原理，当我们读取一条记录的时候，不是将这条记录从索引中读取出来，而是将这个记录所在的页加载到内存中进行读取，InnoDB存储引擎的页大小为16kb，在一个页中可能存着上千个记录，因此在普通索引的字段上进行查找也就是在内存中多几次判断下一条记录的操作。对于CPU来说，这些操作所消耗的时间可以忽略。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本没有差别。</p>
<h3 id="InnoDB行格式-或记录格式"><a href="#InnoDB行格式-或记录格式" class="headerlink" title="InnoDB行格式 (或记录格式)"></a>InnoDB行格式 (或记录格式)</h3><h3 id="区、段与碎片区"><a href="#区、段与碎片区" class="headerlink" title="区、段与碎片区"></a>区、段与碎片区</h3><h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p><img src="image-20230719092120684.png" alt="image-20230719092120684"></p>
<h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p><img src="image-20230719092203365.png" alt="image-20230719092203365"></p>
<h4 id="碎片区"><a href="#碎片区" class="headerlink" title="碎片区"></a>碎片区</h4><p><img src="image-20230719092241880.png" alt="image-20230719092241880"></p>
<h4 id="区的分类"><a href="#区的分类" class="headerlink" title="区的分类"></a>区的分类</h4><p>区大体上可以分为4种类型：</p>
<ul>
<li>空闲的区 (FREE) : 现在还没有用到这个区中的任何页面。</li>
<li>有剩余空间的碎片区 (FREE_FRAG)：表示碎片区中还有可用的页面。</li>
<li>没有剩余空间的碎片区 (FULL_FRAG)：表示碎片区中的所有页面都被使用，没有空闲页面。</li>
<li>附属于某个段的区 (FSEG)：每一个索引都可以分为叶子节点段和非叶子节点段。</li>
</ul>
<p>处于FREE、FREE_FRAG 以及 FULL_FRAG 这三种状态的区都是独立的，直属于表空间。而处于 FSEG 状态的区是附属于某个段的。</p>
<blockquote>
<p>如果把表空间比作是一个集团军，段就相当于师，区就相当于团。一般的团都是隶属于某个师的，就像是处于 FSEG 的区全部隶属于某个段，而处于 FREE、FREE_FRAG 以及 FULL_FRAG 这三种状态的区却直接隶属于表空间，就像独立团直接听命于军部一样。</p>
</blockquote>
<h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p><img src="image-20230719132316627.png" alt="image-20230719132316627"></p>
<h4 id="独立表空间"><a href="#独立表空间" class="headerlink" title="独立表空间"></a>独立表空间</h4><p>独立表空间，即每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间 (即：单表) 可以在不同的数据库之间进行 <code>迁移</code>。</p>
<p>空间可以回收 (DROP TABLE 操作可自动回收表空间；其他情况，表空间不能自己回收) 。如果对于统计分析或是日志表，删除大量数据后可以通过：alter table TableName engine&#x3D;innodb; 回收不用的空间。对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。</p>
<p><strong>独立表空间结构</strong></p>
<p>独立表空间由段、区、页组成。</p>
<p><strong>真实表空间对应的文件大小</strong></p>
<p>我们到数据目录里看，会发现一个新建的表对应的 .ibd 文件只占用了 96K，才6个页面大小 (MySQL5.7中)，这是因为一开始表空间占用的空间很小，因为表里边都没有数据。不过别忘了这些 .ibd 文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。</p>
<p><strong>查看 InnoDB 的表空间类型：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_file_per_table&#x27;</span></span><br></pre></td></tr></table></figure>

<p>你能看到 innodb_file_per_table&#x3D;ON, 这就意味着每张表都会单词保存一个 .ibd 文件。</p>
<h4 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h4><p>系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。</p>
<p><strong>InnoDB数据字典</strong></p>
<p><img src="image-20230719132724247.png" alt="image-20230719132724247"></p>
<p>删除这些数据并不是我们使用 INSERT 语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得以引入的一些额外数据，这些数据页称为 元数据。InnoDB 存储引擎特意定义了一些列的 内部系统表 (internal system table) 来记录这些元数据：</p>
<p><img src="image-20230719132804601.png" alt="image-20230719132804601"></p>
<p>这些系统表也称为 <code>数据字典</code>，它们都是以 B+ 树的形式保存在系统表空间的某个页面中。其中 <code>SYS_TABLES、SYS_COLUMNS、SYS_INDEXES、SYS_FIELDS</code> 这四个表尤其重要，称之为基本系统表 (basic system tables) ，我们先看看这4个表的结构：</p>
<p><img src="image-20230719132835123.png" alt="image-20230719132835123"></p>
<p><img src="image-20230719132907074.png" alt="image-20230719132907074"></p>
<p><img src="image-20230719132925143.png" alt="image-20230719132925143"></p>
<p><img src="image-20230719132943082.png" alt="image-20230719132943082"></p>
<p>注意：用户不能直接访问 InnoDB 的这些内部系统表，除非你直接去解析系统表空间对应文件系统上的文件。不过考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库 <code>information_schema</code> 中提供了一些以 <code>innodb_sys</code> 开头的表:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE information_schema;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_sys%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在 <code>information_scheme</code> 数据库中的这些以 <code>INNODB_SYS</code> 开头的表并不是真正的内部系统表 (内部系统表就是我们上边以 <code>SYS</code> 开头的那些表)，而是在存储引擎启动时读取这些以 <code>SYS</code> 开头的系统表，然后填充到这些以 <code>INNODB_SYS</code> 开头的表中。以 <code>INNODB_SYS</code> 开头的表和以 <code>SYS</code> 开头的表中的字段并不完全一样，但仅供大家参考已经足矣。</p>
<h3 id="数据页加载的三种方式"><a href="#数据页加载的三种方式" class="headerlink" title="数据页加载的三种方式"></a>数据页加载的三种方式</h3><p>InnoDB从磁盘中读取数据 <code>最小单位</code> 是数据页。而你想得到的 id &#x3D; xxx 的数据，就是这个数据页众多行中的一行。</p>
<p>对于MySQL存放的数据，逻辑概念上我们称之为表，在磁盘等物理层面而言是按 <code>数据页</code> 形式进行存放的，当其加载到 MySQL 中我们称之为 <code>缓存页</code>。</p>
<p>如果缓冲池没有该页数据，那么缓冲池有以下三种读取数据的方式，每种方式的读取速率是不同的：</p>
<p><strong>1. 内存读取</strong></p>
<p>如果该数据存在于内存中，基本上执行时间在 1ms 左右，效率还是很高的。</p>
<p><img src="image-20230719133137328.png" alt="image-20230719133137328"></p>
<p><strong>2. 随机读取</strong></p>
<p><img src="image-20230719133223246.png" alt="image-20230719133223246"></p>
<p><img src="image-20230719133239870.png" alt="image-20230719133239870"></p>
<p><strong>3. 顺序读取</strong></p>
<p><img src="image-20230719133309436.png" alt="image-20230719133309436"></p>
<h2 id="性能分析工具的使用"><a href="#性能分析工具的使用" class="headerlink" title="性能分析工具的使用"></a>性能分析工具的使用</h2><p>在数据库调优中，我们的目标是 <code>响应时间更快, 吞吐量更大</code> 。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式。</p>
<h3 id="数据库服务器的优化步骤"><a href="#数据库服务器的优化步骤" class="headerlink" title="数据库服务器的优化步骤"></a>数据库服务器的优化步骤</h3><p>当我们遇到数据库调优问题的时候，该如何思考呢？这里把思考的流程整理成下面这张图。</p>
<p>整个流程划分成了 <code>观察（Show status）</code> 和 <code>行动（Action）</code> 两个部分。字母 S 的部分代表观察（会使 用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。</p>
<p><img src="image-20230719133808779.png" alt="image-20230719133808779"></p>
<p><img src="image-20230719133830949.png" alt="image-20230719133830949"></p>
<p>我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解执行慢的SQL都有哪些，查看具体的SQL执行计划，甚至是SQL执行中的每一步的成本代价，这样才能定位问题所在，找到了问题，再采取相应的行动。</p>
<p><strong>详细解释一下这张图：</strong></p>
<p><img src="image-20230719133904974.png" alt="image-20230719133904974"></p>
<p><img src="image-20230719133923243.png" alt="image-20230719133923243"></p>
<h3 id="查看系统性能参数"><a href="#查看系统性能参数" class="headerlink" title="查看系统性能参数"></a>查看系统性能参数</h3><p>在MySQL中，可以使用 <code>SHOW STATUS</code> 语句查询一些MySQL数据库服务器的<code>性能参数、执行频率</code>。</p>
<p>SHOW STATUS语句语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;参数&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>一些常用的性能参数如下：</p>
<ul>
<li>Connections：连接MySQL服务器的次数。</li>
<li>Uptime：MySQL服务器的上线时间。</li>
<li>Slow_queries：慢查询的次数。</li>
<li>Innodb_rows_read：Select查询返回的行数</li>
<li>Innodb_rows_inserted：执行INSERT操作插入的行数</li>
<li>Innodb_rows_updated：执行UPDATE操作更新的 行数</li>
<li>Innodb_rows_deleted：执行DELETE操作删除的行数</li>
<li>Com_select：查询操作的次数。</li>
<li>Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。</li>
<li>Com_update：更新操作 的次数。</li>
<li>Com_delete：删除操作的次数。</li>
</ul>
<p>若查询MySQL服务器的连接次数，则可以执行如下语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Connections&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>若查询服务器工作时间，则可以执行如下语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Uptime&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>若查询MySQL服务器的慢查询次数，则可以执行如下语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Slow_queries&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>慢查询次数参数可以结合慢查询日志找出慢查询语句，然后针对慢查询语句进行<code>表结构优化</code>或者<code>查询语句优化</code>。</p>
<p>再比如，如下的指令可以查看相关的指令情况：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Innodb_rows_%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="统计SQL的查询成本-last-query-cost"><a href="#统计SQL的查询成本-last-query-cost" class="headerlink" title="统计SQL的查询成本: last_query_cost"></a>统计SQL的查询成本: last_query_cost</h3><p>一条SQL查询语句在执行前需要查询执行计划，如果存在多种执行计划的话，MySQL会计算每个执行计划所需要的成本，从中选择<code>成本最小</code>的一个作为最终执行的执行计划。</p>
<p>如果我们想要查看某条SQL语句的查询成本，可以在执行完这条SQL语句之后，通过查看当前会话中的<code>last_query_cost</code>变量值来得到当前查询的成本。它通常也是我们<code>评价一个查询的执行效率</code>的一个常用指标。这个查询成本对应的是<code>SQL 语句所需要读取的读页的数量</code>。</p>
<p>我们依然使用第8章的 student_info 表为例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student_info` (</span><br><span class="line">    `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `student_id` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">    `name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `course_id` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">    `class_id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `create_time` DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>如果我们想要查询 id&#x3D;900001 的记录，然后看下查询成本，我们可以直接在聚簇索引上进行查找：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time <span class="keyword">FROM</span> student_info <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">900001</span>;</span><br></pre></td></tr></table></figure>

<p>运行结果（1 条记录，运行时间为 0.042s ）</p>
<p>然后再看下查询优化器的成本，实际上我们只需要检索一个页即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SHOW STATUS LIKE <span class="string">&#x27;last_query_cost&#x27;</span>;</span></span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Variable_name   |   Value  |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Last_query_cost | 1.000000 |</span><br><span class="line">+-----------------+----------+</span><br></pre></td></tr></table></figure>

<p>如果我们想要查询 id 在 900001 到 9000100 之间的学生记录呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time <span class="keyword">FROM</span> student_info <span class="keyword">WHERE</span> id <span class="keyword">BETWEEN</span> <span class="number">900001</span> <span class="keyword">AND</span> <span class="number">900100</span>;</span><br></pre></td></tr></table></figure>

<p>运行结果（100 条记录，运行时间为 0.046s ）：</p>
<p>然后再看下查询优化器的成本，这时我们大概需要进行 20 个页的查询。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SHOW STATUS LIKE <span class="string">&#x27;last_query_cost&#x27;</span>;</span></span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   |   Value   |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Last_query_cost | 21.134453 |</span><br><span class="line">+-----------------+-----------+</span><br></pre></td></tr></table></figure>

<p>你能看到页的数量是刚才的 20 倍，但是查询的效率并没有明显的变化，实际上这两个 SQL 查询的时间 基本上一样，就是因为采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然 页 数量（last_query_cost）增加了不少 ，但是通过缓冲池的机制，并 没有增加多少查询时间 。</p>
<p><strong>使用场景：</strong>它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p>
<blockquote>
<p>SQL查询时一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：</p>
<ol>
<li><code>位置决定效率</code>。如果页就在数据库 <code>缓冲池</code> 中，那么效率是最高的，否则还需要从 <code>内存</code> 或者 <code>磁盘</code> 中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li>
<li><code>批量决定效率</code>。如果我们从磁盘中对单一页进行随机读，那么效率是很低的(差不多10ms)，而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li>
</ol>
<p>所以说，遇到I&#x2F;O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是进程使用的数据就要尽量放到<code>缓冲池</code>中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p>
</blockquote>
<h3 id="定位执行慢的-SQL：慢查询日志"><a href="#定位执行慢的-SQL：慢查询日志" class="headerlink" title="定位执行慢的 SQL：慢查询日志"></a>定位执行慢的 SQL：慢查询日志</h3><p><img src="image-20230719134247691.png" alt="image-20230719134247691"></p>
<h4 id="开启慢查询日志参数"><a href="#开启慢查询日志参数" class="headerlink" title="开启慢查询日志参数"></a>开启慢查询日志参数</h4><p><strong>1. 开启 slow_query_log</strong></p>
<p>在使用前，我们需要先查下慢查询是否已经开启，使用下面这条命令即可：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719134330093.png" alt="image-20230719134330093"></p>
<p>我们可以看到 <code>slow_query_log=OFF</code>，我们可以把慢查询日志打开，注意设置变量值的时候需要使用 global，否则会报错：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;ON&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>然后我们再来查看下慢查询日志是否开启，以及慢查询日志文件的位置：</p>
<p><img src="image-20230719134355223.png" alt="image-20230719134355223"></p>
<p>你能看到这时慢查询分析已经开启，同时文件保存在 <code>/var/lib/mysql/atguigu02-slow.log</code> 文件 中。</p>
<p><strong>2. 修改 long_query_time 阈值</strong></p>
<p>接下来我们来看下慢查询的时间阈值设置，使用如下命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719134443576.png" alt="image-20230719134443576"></p>
<p>这里如果我们想把时间缩短，比如设置为 1 秒，可以这样设置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#测试发现：设置<span class="keyword">global</span>的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并</span><br><span class="line">执行下述语句</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> long_query_time <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> long_query_time<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719134514085.png" alt="image-20230719134514085"></p>
<p><strong>补充：配置文件中一并设置参数</strong></p>
<p>如下的方式相较于前面的命令行方式，可以看做是永久设置的方式。</p>
<p>修改 <code>my.cnf</code> 文件，[mysqld] 下增加或修改参数 <code>long_query_time、slow_query_log</code> 和 <code>slow_query_log_file</code> 后，然后重启 MySQL 服务器。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log<span class="operator">=</span><span class="keyword">ON</span>  # 开启慢查询日志开关</span><br><span class="line">slow_query_log_file<span class="operator">=</span><span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu<span class="operator">-</span>low.log  # 慢查询日志的目录和文件名信息</span><br><span class="line">long_query_time<span class="operator">=</span><span class="number">3</span>  # 设置慢查询的阈值为<span class="number">3</span>秒，超出此设定值的<span class="keyword">SQL</span>即被记录到慢查询日志</span><br><span class="line">log_output<span class="operator">=</span>FILE</span><br></pre></td></tr></table></figure>

<p>如果不指定存储路径，慢查询日志默认存储到MySQL数据库的数据文件夹下。如果不指定文件名，默认文件名为hostname_slow.log。</p>
<h4 id="查看慢查询数目"><a href="#查看慢查询数目" class="headerlink" title="查看慢查询数目"></a>查看慢查询数目</h4><p>查询当前系统中有多少条慢查询记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%Slow_queries%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h4><p><strong>步骤1. 建表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">    `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `stuno` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">    `name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `age` <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `classId` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p><strong>步骤2：设置参数 log_bin_trust_function_creators</strong></p>
<p>创建函数，假如报错：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">This <span class="keyword">function</span> has <span class="keyword">none</span> <span class="keyword">of</span> DETERMINISTIC......</span><br></pre></td></tr></table></figure>

<ul>
<li>命令开启：允许创建函数设置：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>; # 不加<span class="keyword">global</span>只是当前窗口有效。</span><br></pre></td></tr></table></figure>

<p><strong>步骤3：创建函数</strong></p>
<p>随机产生字符串：（同上一章）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>)</span><br><span class="line">	<span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>) #该函数会返回一个字符串</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span></span><br><span class="line"><span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line">    	<span class="keyword">SET</span> return_str <span class="operator">=</span>CONCAT(return_str,<span class="built_in">SUBSTRING</span>(chars_str,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line">    	<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line">    <span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line"><span class="keyword">SELECT</span> rand_string(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>产生随机数值：（同上一章）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num (from_num <span class="type">INT</span> ,to_num <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span>RAND()<span class="operator">*</span>(to_num <span class="operator">-</span> from_num<span class="operator">+</span><span class="number">1</span>)) ;</span><br><span class="line">    <span class="keyword">RETURN</span> i;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#测试：</span><br><span class="line"><span class="keyword">SELECT</span> rand_num(<span class="number">10</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><strong>步骤4：创建存储过程</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_stu1( <span class="keyword">START</span> <span class="type">INT</span> , max_num <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>; #设置手动提交事务</span><br><span class="line">    REPEAT #循环</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>; #赋值</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (stuno, NAME ,age ,classId ) <span class="keyword">VALUES</span></span><br><span class="line">    ((<span class="keyword">START</span><span class="operator">+</span>i),rand_string(<span class="number">6</span>),rand_num(<span class="number">10</span>,<span class="number">100</span>),rand_num(<span class="number">10</span>,<span class="number">1000</span>));</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">    <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>; #提交事务</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p><strong>步骤5：调用存储过程</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#调用刚刚写好的函数, <span class="number">4000000</span>条记录,从<span class="number">100001</span>号开始</span><br><span class="line"><span class="keyword">CALL</span> insert_stu1(<span class="number">100001</span>,<span class="number">4000000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="测试及分析"><a href="#测试及分析" class="headerlink" title="测试及分析"></a>测试及分析</h4><p><strong>1. 测试</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SELECT * FROM student WHERE stuno = 3455655;</span></span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">|   id    |  stuno  |  name  | age  | classId |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| 3523633 | 3455655 | oQmLUr |  19  |    39   |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">1 row in set (2.09 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SELECT * FROM student WHERE name = <span class="string">&#x27;oQmLUr&#x27;</span>;</span></span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">|   id    |  stuno  |  name  |  age | classId |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| 1154002 | 1243200 | OQMlUR | 266  |   28    |</span><br><span class="line">| 1405708 | 1437740 | OQMlUR | 245  |   439   |</span><br><span class="line">| 1748070 | 1680092 | OQMlUR | 240  |   414   |</span><br><span class="line">| 2119892 | 2051914 | oQmLUr | 17   |   32    |</span><br><span class="line">| 2893154 | 2825176 | OQMlUR | 245  |   435   |</span><br><span class="line">| 3523633 | 3455655 | oQmLUr | 19   |   39    |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">6 rows in set (2.39 sec)</span><br></pre></td></tr></table></figure>

<p>从上面的结果可以看出来，查询学生编号为“3455655”的学生信息花费时间为2.09秒。查询学生姓名为 “oQmLUr”的学生信息花费时间为2.39秒。已经达到了秒的数量级，说明目前查询效率是比较低的，下面 的小节我们分析一下原因。</p>
<p><strong>2. 分析</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;slow_queries&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719134805361.png" alt="image-20230719134805361"></p>
<h4 id="慢查询日志分析工具：mysqldumpslow"><a href="#慢查询日志分析工具：mysqldumpslow" class="headerlink" title="慢查询日志分析工具：mysqldumpslow"></a>慢查询日志分析工具：mysqldumpslow</h4><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具 <code>mysqldumpslow</code> 。</p>
<p>查看mysqldumpslow的帮助信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldumpslow --help</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719134851652.png" alt="image-20230719134851652"></p>
<p>mysqldumpslow 命令的具体参数如下：</p>
<ul>
<li>-a: 不将数字抽象成N，字符串抽象成S</li>
<li>-s: 是表示按照何种方式排序：<ul>
<li>c: 访问次数</li>
<li>l: 锁定时间</li>
<li>r: 返回记录</li>
<li>t: 查询时间</li>
<li>al:平均锁定时间</li>
<li>ar:平均返回记录数</li>
<li>at:平均查询时间 （默认方式）</li>
<li>ac:平均查询次数</li>
</ul>
</li>
<li>-t: 即为返回前面多少条的数据；</li>
<li>-g: 后边搭配一个正则匹配模式，大小写不敏感的；</li>
</ul>
<p>举例：我们想要按照查询时间排序，查看前五条 SQL 语句，这样写即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s t -t 5 /var/lib/mysql/atguigu01-slow.log</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@bogon ~]# mysqldumpslow -s t -t 5 /var/lib/mysql/atguigu01-slow.log</span><br><span class="line"></span><br><span class="line">Reading mysql slow query log from /var/lib/mysql/atguigu01-slow.log</span><br><span class="line">Count: 1 Time=2.39s (2s) Lock=0.00s (0s) Rows=13.0 (13), root[root]@localhost</span><br><span class="line">SELECT * FROM student WHERE name = &#x27;S&#x27;</span><br><span class="line"></span><br><span class="line">Count: 1 Time=2.09s (2s) Lock=0.00s (0s) Rows=2.0 (2), root[root]@localhost</span><br><span class="line">SELECT * FROM student WHERE stuno = N</span><br><span class="line"></span><br><span class="line">Died at /usr/bin/mysqldumpslow line 162, &lt;&gt; chunk 2.</span><br></pre></td></tr></table></figure>

<p><strong>工作常用参考：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">得到返回记录集最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">得到访问次数最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">得到按照时间排序的前10条里面含有左连接的查询语句</span></span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more</span><br></pre></td></tr></table></figure>

<h4 id="关闭慢查询日志"><a href="#关闭慢查询日志" class="headerlink" title="关闭慢查询日志"></a>关闭慢查询日志</h4><p>MySQL服务器停止慢查询日志功能有两种方法：</p>
<p><strong>方式1：永久性方式</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log<span class="operator">=</span>OFF</span><br></pre></td></tr></table></figure>

<p>或者，把slow_query_log一项注释掉 或 删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#slow_query_log <span class="operator">=</span>OFF</span><br></pre></td></tr></table></figure>

<p>重启MySQL服务，执行如下语句查询慢日志功能。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow%&#x27;</span>; #查询慢查询日志所在目录</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%long_query_time%&#x27;</span>; #查询超时时长</span><br></pre></td></tr></table></figure>

<p><strong>方式2：临时性方式</strong></p>
<p>使用SET语句来设置。</p>
<p>（1）停止MySQL慢查询日志功能，具体SQL语句如下。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log<span class="operator">=</span>off;</span><br></pre></td></tr></table></figure>

<p>（2）<strong>重启MySQL服务</strong>，使用SHOW语句查询慢查询日志功能信息，具体SQL语句如下。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow%&#x27;</span>;</span><br><span class="line">#以及</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="删除慢查询日志"><a href="#删除慢查询日志" class="headerlink" title="删除慢查询日志"></a>删除慢查询日志</h4><p>使用SHOW语句显示慢查询日志信息，具体SQL语句如下。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> `slow_query_log<span class="operator">%</span>`;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719135056374.png" alt="image-20230719135056374"></p>
<p>从执行结果可以看出，慢查询日志的目录默认为MySQL的数据目录，在该目录下 <code>手动删除慢查询日志文件</code> 即可。</p>
<p>使用命令 <code>mysqladmin flush-logs</code> 来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqladmin -uroot -p flush-logs slow</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示</p>
<p>慢查询日志都是使用mysqladmin flush-logs命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。</p>
</blockquote>
<h4 id="查看-SQL-执行成本：SHOW-PROFILE"><a href="#查看-SQL-执行成本：SHOW-PROFILE" class="headerlink" title="查看 SQL 执行成本：SHOW PROFILE"></a>查看 SQL 执行成本：SHOW PROFILE</h4><p>show profile 在《逻辑架构》章节中讲过，这里作为复习。</p>
<p>show profile 是 MySQL 提供的可以用来分析当前会话中 SQL 都做了什么、执行的资源消耗工具的情况，可用于 sql 调优的测量。<code>默认情况下处于关闭状态</code>，并保存最近15次的运行结果。</p>
<p>我们可以在会话级别开启这个功能。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;profiling&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719135757901.png" alt="image-20230719135757901"></p>
<p>通过设置 profiling&#x3D;’ON’ 来开启 show profile:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> profiling <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719135827047.png" alt="image-20230719135827047"></p>
<p>然后执行相关的查询语句。接着看下当前会话都有哪些 profiles，使用下面这条命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> profiles;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719135859294.png" alt="image-20230719135859294"></p>
<p>你能看到当前会话一共有 2 个查询。如果我们想要查看最近一次查询的开销，可以使用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> profile;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719135924156.png" alt="image-20230719135924156"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profile cpu,block io <span class="keyword">for</span> query <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><img src="image-20230719135959180.png" alt="image-20230719135959180"></p>
<p><strong>show profile的常用查询参数：</strong></p>
<p>① ALL：显示所有的开销信息。</p>
<p>② BLOCK IO：显示块IO开销。</p>
<p>③ CONTEXT SWITCHES：上下文切换开销。</p>
<p>④ CPU：显示CPU开销信息。</p>
<p>⑤ IPC：显示发送和接收开销信息。</p>
<p>⑥ MEMORY：显示内存开销信 息。</p>
<p>⑦ PAGE FAULTS：显示页面错误开销信息。</p>
<p>⑧ SOURCE：显示和Source_function，Source_file， Source_line相关的开销信息。</p>
<p>⑨ SWAPS：显示交换次数开销信息。</p>
<p><strong>日常开发需注意的结论：</strong></p>
<p>① <code>converting HEAP to MyISAM</code>: 查询结果太大，内存不够，数据往磁盘上搬了。</p>
<p>② <code>Creating tmp table</code>：创建临时表。先拷贝数据到临时表，用完后再删除临时表。</p>
<p>③ <code>Copying to tmp table on disk</code>：把内存中临时表复制到磁盘上，警惕！</p>
<p>④ <code>locked</code>。</p>
<p>如果在show profile诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化。</p>
<p><strong>注意：</strong></p>
<p>不过SHOW PROFILE命令将被启用，我们可以从 information_schema 中的 profiling 数据表进行查看。</p>
<h3 id="分析查询语句：EXPLAIN"><a href="#分析查询语句：EXPLAIN" class="headerlink" title="分析查询语句：EXPLAIN"></a>分析查询语句：EXPLAIN</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><img src="image-20230719140206300.png" alt="image-20230719140206300"></p>
<p><strong>能做什么？</strong></p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>EXPLAIN 或 DESCRIBE语句的语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> select_options</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">SELECT</span> select_options</span><br></pre></td></tr></table></figure>

<p>如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个 EXPLAIN ，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719140324387.png" alt="image-20230719140324387"></p>
<p><img src="image-20230719140345673.png" alt="image-20230719140345673"></p>
<p>EXPLAIN 语句输出的各个列的作用如下：</p>
<p><img src="image-20230719140409198.png" alt="image-20230719140409198"></p>
<h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><p><strong>1. 建表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s1 (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key2 <span class="type">INT</span>,</span><br><span class="line">    key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    INDEX idx_key1 (key1),</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX idx_key2 (key2),</span><br><span class="line">    INDEX idx_key3 (key3),</span><br><span class="line">    INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s2 (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key2 <span class="type">INT</span>,</span><br><span class="line">    key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    INDEX idx_key1 (key1),</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX idx_key2 (key2),</span><br><span class="line">    INDEX idx_key3 (key3),</span><br><span class="line">    INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p><strong>2. 设置参数 log_bin_trust_function_creators</strong></p>
<p>创建函数，假如报错，需开启如下命令：允许创建函数设置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>; # 不加<span class="keyword">global</span>只是当前窗口有效。</span><br></pre></td></tr></table></figure>

<p><strong>3. 创建函数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string1(n <span class="type">INT</span>)</span><br><span class="line">	<span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>) #该函数会返回一个字符串</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span></span><br><span class="line"><span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line">        <span class="keyword">SET</span> return_str <span class="operator">=</span>CONCAT(return_str,<span class="built_in">SUBSTRING</span>(chars_str,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line">    <span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p><strong>4. 创建存储过程</strong></p>
<p>创建往s1表中插入数据的存储过程：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_s1 (<span class="keyword">IN</span> min_num <span class="type">INT</span> (<span class="number">10</span>),<span class="keyword">IN</span> max_num <span class="type">INT</span> (<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    REPEAT</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> s1 <span class="keyword">VALUES</span>(</span><br><span class="line">        (min_num <span class="operator">+</span> i),</span><br><span class="line">        rand_string1(<span class="number">6</span>),</span><br><span class="line">        (min_num <span class="operator">+</span> <span class="number">30</span> <span class="operator">*</span> i <span class="operator">+</span> <span class="number">5</span>),</span><br><span class="line">        rand_string1(<span class="number">6</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>),</span><br><span class="line">        rand_string1(<span class="number">5</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>));</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">    <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>创建往s2表中插入数据的存储过程：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_s2 (<span class="keyword">IN</span> min_num <span class="type">INT</span> (<span class="number">10</span>),<span class="keyword">IN</span> max_num <span class="type">INT</span> (<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    REPEAT</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> s2 <span class="keyword">VALUES</span>(</span><br><span class="line">        (min_num <span class="operator">+</span> i),</span><br><span class="line">        rand_string1(<span class="number">6</span>),</span><br><span class="line">        (min_num <span class="operator">+</span> <span class="number">30</span> <span class="operator">*</span> i <span class="operator">+</span> <span class="number">5</span>),</span><br><span class="line">        rand_string1(<span class="number">6</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>),</span><br><span class="line">        rand_string1(<span class="number">5</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>));</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">    <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p><strong>5. 调用存储过程</strong></p>
<p>s1表数据的添加：加入1万条记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> insert_s1(<span class="number">10001</span>,<span class="number">10000</span>);</span><br></pre></td></tr></table></figure>

<p>s2表数据的添加：加入1万条记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> insert_s2(<span class="number">10001</span>,<span class="number">10000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="EXPLAIN各列作用"><a href="#EXPLAIN各列作用" class="headerlink" title="EXPLAIN各列作用"></a>EXPLAIN各列作用</h4><p>为了让大家有比较好的体验，我们调整了下 <code>EXPLAIN</code> 输出列的顺序。</p>
<h5 id="1-table"><a href="#1-table" class="headerlink" title="1. table"></a>1. table</h5><p>不论我们的查询语句有多复杂，里边儿 包含了多少个表 ，到最后也是需要对每个表进行 单表访问 的，所 以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该 表的表名（有时不是真实的表名字，可能是简称）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719140905469.png" alt="image-20230719140905469"></p>
<p>这个查询语句只涉及对s1表的单表查询，所以 <code>EXPLAIN</code> 输出中只有一条记录，其中的table列的值为s1，表明这条记录是用来说明对s1表的单表访问方法的。</p>
<p>下边我们看一个连接查询的执行计划</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719140932181.png" alt="image-20230719140932181"></p>
<p>可以看出这个连接查询的执行计划中有两条记录，这两条记录的table列分别是s1和s2，这两条记录用来分别说明对s1表和s2表的访问方法是什么。</p>
<h5 id="2-id"><a href="#2-id" class="headerlink" title="2. id"></a>2. id</h5><p>我们写的查询语句一般都以 SELECT 关键字开头，比较简单的查询语句里只有一个 SELECT 关键字，比 如下边这个查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>稍微复杂一点的连接查询中也只有一个 SELECT 关键字，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2</span><br><span class="line"><span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1</span><br><span class="line"><span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>但是下边两种情况下在一条查询语句中会出现多个SELECT关键字：</p>
<p><img src="image-20230719141019804.png" alt="image-20230719141019804"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719141040463.png" alt="image-20230719141040463"></p>
<p>对于连接查询来说，一个SELECT关键字后边的FROM字句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719141105908.png" alt="image-20230719141105908"></p>
<p>可以看到，上述连接查询中参与连接的s1和s2表分别对应一条记录，但是这两条记录对应的<code>id</code>都是1。这里需要大家记住的是，<strong>在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的</strong>，出现在前边的表表示<code>驱动表</code>，出现在后面的表表示<code>被驱动表</code>。所以从上边的EXPLAIN输出中我们可以看到，查询优化器准备让s1表作为驱动表，让s2表作为被驱动表来执行查询。</p>
<p>对于包含子查询的查询语句来说，就可能涉及多个<code>SELECT</code>关键字，所以在**包含子查询的查询语句的执行计划中，每个<code>SELECT</code>关键字都会对应一个唯一的id值，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719141132286.png" alt="image-20230719141132286"></p>
<p><img src="image-20230719141149010.png" alt="image-20230719141149010"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询优化器可能对涉及子查询的查询语句进行重写，转变为多表查询的操作。  </span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key2 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719141332637.png" alt="image-20230719141332637"></p>
<p>可以看到，虽然我们的查询语句是一个子查询，但是执行计划中s1和s2表对应的记录的<code>id</code>值全部是1，这就表明<code>查询优化器将子查询转换为了连接查询</code>。</p>
<p>对于包含<code>UNION</code>子句的查询语句来说，每个<code>SELECT</code>关键字对应一个<code>id</code>值也是没错的，不过还是有点儿特别的东西，比方说下边的查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">Union</span>去重</span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719141356302.png" alt="image-20230719141356302"></p>
<p><img src="image-20230719141411657.png" alt="image-20230719141411657"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719141437507.png" alt="image-20230719141437507"></p>
<p><strong>小结:</strong></p>
<ul>
<li>id如果相同，可以认为是一组，从上往下顺序执行</li>
<li>在所有组中，id值越大，优先级越高，越先执行</li>
<li>关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</li>
</ul>
<h5 id="3-select-type"><a href="#3-select-type" class="headerlink" title="3. select_type"></a>3. select_type</h5><p><img src="image-20230719141516660.png" alt="image-20230719141516660"></p>
<p><img src="image-20230719141531340.png" alt="image-20230719141531340"></p>
<p>具体分析如下：</p>
<ul>
<li><p>SIMPLE</p>
<p>查询语句中不包含<code>UNION</code>或者子查询的查询都算作是<code>SIMPLE</code>类型，比方说下边这个单表查询<code>select_type</code>的值就是<code>SIMPLE</code>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719141602503.png" alt="image-20230719141602503"></p>
<p>当然，连接查询也算是 SIMPLE 类型，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719141623804.png" alt="image-20230719141623804"></p>
</li>
<li><p>PRIMARY</p>
<p>对于包含<code>UNION、UNION ALL</code>或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的<code>select_type</code>的值就是<code>PRIMARY</code>,比方说：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719141743749.png" alt="image-20230719141743749"></p>
<p>从结果中可以看到，最左边的小查询<code>SELECT * FROM s1</code>对应的是执行计划中的第一条记录，它<code>select_type</code>的值就是<code>PRIMARY</code>。</p>
</li>
<li><p>UNION</p>
<p>对于包含<code>UNION</code>或者<code>UNION ALL</code>的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询意外，其余的小查询的<code>select_type</code>值就是UNION，可以对比上一个例子的效果。</p>
</li>
<li><p>UNION RESULT</p>
<p>MySQL 选择使用临时表来完成<code>UNION</code>查询的去重工作，针对该临时表的查询的<code>select_type</code>就是<code>UNION RESULT</code>, 例子上边有。</p>
</li>
<li><p>SUBQUERY</p>
<p>如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>SUBQUERY</code>，比如下边这个查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719142049894.png" alt="image-20230719142049894"></p>
</li>
<li><p>DEPENDENT SUBQUERY</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> s1.key2 <span class="operator">=</span> s2.key2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719142129243.png" alt="image-20230719142129243"></p>
</li>
<li><p>DEPENDENT UNION</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719142414418.png" alt="image-20230719142414418"></p>
</li>
<li><p>DERIVED</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> key1, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> key1) <span class="keyword">AS</span> derived_s1 <span class="keyword">where</span> c <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719142441084.png" alt="image-20230719142441084"></p>
<p>从执行计划中可以看出，id为2的记录就代表子查询的执行方式，它的select_type是DERIVED, 说明该子查询是以物化的方式执行的。id为1的记录代表外层查询，大家注意看它的table列显示的是derived2，表示该查询时针对将派生表物化之后的表进行查询的。</p>
</li>
<li><p>MATERIALIZED</p>
<p>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后的外层查询进行连接查询时，该子查询对应的<code>select_type</code>属性就是DERIVED，比如下边这个查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2);</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719142530325.png" alt="image-20230719142530325"></p>
</li>
<li><p>UNCACHEABLE SUBQUERY</p>
<p>不常用，就不多说了。</p>
</li>
<li><p>UNCACHEABLE UNION</p>
<p>不常用，就不多说了。</p>
</li>
</ul>
<h5 id="4-partitions-可略"><a href="#4-partitions-可略" class="headerlink" title="4. partitions (可略)"></a>4. partitions (可略)</h5><h5 id="5-type"><a href="#5-type" class="headerlink" title="5. type"></a>5. type</h5><p>执行计划的一条记录就代表着MySQL对某个表的 <code>执行查询时的访问方法</code> , 又称“访问类型”，其中的 <code>type</code> 列就表明了这个访问方法是啥，是较为重要的一个指标。比如，看到<code>type</code>列的值是<code>ref</code>，表明<code>MySQL</code>即将使用<code>ref</code>访问方法来执行对<code>s1</code>表的查询。</p>
<p>完整的访问方法如下： <code>system ， const ， eq_ref ， ref ， fulltext ， ref_or_null ， index_merge ， unique_subquery ， index_subquery ， range ， index ， ALL</code> 。</p>
<p>我们详细解释一下：</p>
<ul>
<li><p><code>system</code></p>
<p>当表中<code>只有一条记录</code>并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是<code>system</code>。比方说我们新建一个<code>MyISAM</code>表，并为其插入一条记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t(i <span class="type">int</span>) Engine<span class="operator">=</span>MyISAM;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.05</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>然后我们看一下查询这个表的执行计划：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719144519679.png" alt="image-20230719144519679"></p>
<p>可以看到<code>type</code>列的值就是<code>system</code>了，</p>
<blockquote>
<p>测试，可以把表改成使用InnoDB存储引擎，试试看执行计划的<code>type</code>列是什么。ALL</p>
</blockquote>
</li>
<li><p>const</p>
<p>当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是<code>const</code>, 比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719144557169.png" alt="image-20230719144557169"></p>
</li>
<li><p>eq_ref</p>
<p>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较）。则对该被驱动表的访问方法就是<code>eq_ref</code>，比方说：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.id <span class="operator">=</span> s2.id;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719145624167.png" alt="image-20230719145624167"></p>
<p>从执行计划的结果中可以看出，MySQL打算将s2作为驱动表，s1作为被驱动表，重点关注s1的访问 方法是 <code>eq_ref</code> ，表明在访问s1表的时候可以 <code>通过主键的等值匹配</code> 来进行访问。</p>
</li>
<li><p>ref</p>
<p>当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是<code>ref</code>，比方说下边这个查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719145716821.png" alt="image-20230719145716821"></p>
</li>
<li><p>fulltext</p>
<p>全文检索</p>
</li>
<li><p>ref_or_null</p>
<p>当对普通二级索引进行等值匹配查询，该索引列的值也可以是<code>NULL</code>值时，那么对该表的访问方法就可能是<code>ref_or_null</code>，比如说：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key1 <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719145801914.png" alt="image-20230719145801914"></p>
</li>
<li><p>index_merge</p>
<p>一般情况下对于某个表的查询只能使用到一个索引，但单表访问方法时在某些场景下可以使用<code>Interseation、union、Sort-Union</code>这三种索引合并的方式来执行查询。我们看一下执行计划中是怎么体现MySQL使用索引合并的方式来对某个表执行查询的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719145828438.png" alt="image-20230719145828438"></p>
<p>从执行计划的 <code>type</code> 列的值是 <code>index_merge</code> 就可以看出，MySQL 打算使用索引合并的方式来执行 对 s1 表的查询。</p>
</li>
<li><p>unique_subquery</p>
<p>类似于两表连接中被驱动表的<code>eq_ref</code>访问方法，<code>unique_subquery</code>是针对在一些包含<code>IN</code>子查询的查询语句中，如果查询优化器决定将<code>IN</code>子查询转换为<code>EXISTS</code>子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的<code>type</code>列的值就是<code>unique_subquery</code>，比如下边的这个查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key2 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s2 <span class="keyword">where</span> s1.key1 <span class="operator">=</span> s2.key1) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719145919670.png" alt="image-20230719145919670"></p>
</li>
<li><p>index_subquery</p>
<p><code>index_subquery</code> 与 <code>unique_subquery</code> 类似，只不过访问子查询中的表时使用的是普通的索引，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> common_field <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key3 <span class="keyword">FROM</span> s2 <span class="keyword">where</span> s1.key1 <span class="operator">=</span> s2.key1) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719145949481.png" alt="image-20230719145949481"></p>
</li>
<li><p>range</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150012486.png" alt="image-20230719150012486"></p>
<p>或者：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> key1 <span class="operator">&lt;</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150040886.png" alt="image-20230719150040886"></p>
</li>
<li><p>index</p>
<p>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是<code>index</code>，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> key_part2 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150106325.png" alt="image-20230719150106325"></p>
<p>上述查询中的所有列表中只有key_part2 一个列，而且搜索条件中也只有 key_part3 一个列，这两个列又恰好包含在idx_key_part这个索引中，可是搜索条件key_part3不能直接使用该索引进行<code>ref</code>和<code>range</code>方式的访问，只能扫描整个<code>idx_key_part</code>索引的记录，所以查询计划的<code>type</code>列的值就是<code>index</code>。</p>
<blockquote>
<p>再一次强调，对于使用InnoDB存储引擎的表来说，二级索引的记录只包含索引列和主键列的值，而聚簇索引中包含用户定义的全部列以及一些隐藏列，所以扫描二级索引的代价比直接全表扫描，也就是扫描聚簇索引的代价更低一些。</p>
</blockquote>
</li>
<li><p>ALL</p>
<p>全表扫描</p>
</li>
</ul>
<p><strong>小结：</strong></p>
<p><strong>结果值从最好到最坏依次是：</strong></p>
<p><strong>system &gt; const &gt; eq_ref &gt; ref</strong> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
<p><strong>其中比较重要的几个提取出来（见上图中的粗体）。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 consts级别。（阿里巴巴 开发手册要求）</strong></p>
<h5 id="6-possible-keys和key"><a href="#6-possible-keys和key" class="headerlink" title="6. possible_keys和key"></a>6. possible_keys和key</h5><p>在EXPLAIN语句输出的执行计划中，<code>possible_keys</code>列表示在某个查询语句中，对某个列执行<code>单表查询时可能用到的索引</code>有哪些。一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。<code>key</code>列表示<code>实际用到的索引</code>有哪些，如果为NULL，则没有使用索引。比方说下面这个查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150326576.png" alt="image-20230719150326576"></p>
<p>上述执行计划的<code>possible_keys</code>列的值是<code>idx_key1, idx_key3</code>，表示该查询可能使用到<code>idx_key1, idx_key3</code>两个索引，然后<code>key</code>列的值是<code>idx_key3</code>，表示经过查询优化器计算使用不同索引的成本后，最后决定采用<code>idx_key3</code>。</p>
<h5 id="7-key-len"><a href="#7-key-len" class="headerlink" title="7. key_len"></a>7. key_len</h5><p>实际使用到的索引长度 (即：字节数)</p>
<p>帮你检查<code>是否充分的利用了索引</code>，<code>值越大越好</code>，主要针对于联合索引，有一定的参考意义。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150401618.png" alt="image-20230719150401618"></p>
<blockquote>
<p>int 占用 4 个字节</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key2 <span class="operator">=</span> <span class="number">10126</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150425383.png" alt="image-20230719150425383"></p>
<blockquote>
<p>key2上有一个唯一性约束，是否为NULL占用一个字节，那么就是5个字节</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150446322.png" alt="image-20230719150446322"></p>
<blockquote>
<p>key1 VARCHAR(100) 一个字符占3个字节，100*3，是否为NULL占用一个字节，varchar的长度信息占两个字节。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150508012.png" alt="image-20230719150508012"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> key_part2 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150530155.png" alt="image-20230719150530155"></p>
<blockquote>
<p>联合索引中可以比较，key_len&#x3D;606的好于key_len&#x3D;303</p>
</blockquote>
<p>key_len的长度计算公式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">varchar</span>(<span class="number">10</span>)变长字段且允许<span class="keyword">NULL</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> ( <span class="type">character</span> <span class="keyword">set</span>：utf8<span class="operator">=</span><span class="number">3</span>,gbk<span class="operator">=</span><span class="number">2</span>,latin1<span class="operator">=</span><span class="number">1</span>)<span class="operator">+</span><span class="number">1</span>(<span class="keyword">NULL</span>)<span class="operator">+</span><span class="number">2</span>(变长字段)</span><br><span class="line"></span><br><span class="line"><span class="type">varchar</span>(<span class="number">10</span>)变长字段且不允许<span class="keyword">NULL</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> ( <span class="type">character</span> <span class="keyword">set</span>：utf8<span class="operator">=</span><span class="number">3</span>,gbk<span class="operator">=</span><span class="number">2</span>,latin1<span class="operator">=</span><span class="number">1</span>)<span class="operator">+</span><span class="number">2</span>(变长字段)</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>(<span class="number">10</span>)固定字段且允许<span class="keyword">NULL</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> ( <span class="type">character</span> <span class="keyword">set</span>：utf8<span class="operator">=</span><span class="number">3</span>,gbk<span class="operator">=</span><span class="number">2</span>,latin1<span class="operator">=</span><span class="number">1</span>)<span class="operator">+</span><span class="number">1</span>(<span class="keyword">NULL</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>(<span class="number">10</span>)固定字段且不允许<span class="keyword">NULL</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> ( <span class="type">character</span> <span class="keyword">set</span>：utf8<span class="operator">=</span><span class="number">3</span>,gbk<span class="operator">=</span><span class="number">2</span>,latin1<span class="operator">=</span><span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h5 id="8-ref"><a href="#8-ref" class="headerlink" title="8. ref"></a>8. ref</h5><p><img src="image-20230719150619229.png" alt="image-20230719150619229"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150638537.png" alt="image-20230719150638537"></p>
<p>可以看到<code>ref</code>列的值是<code>const</code>，表明在使用<code>idx_key1</code>索引执行查询时，与<code>key1</code>列作等值匹配的对象是一个常数，当然有时候更复杂一点:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.id <span class="operator">=</span> s2.id;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150704459.png" alt="image-20230719150704459"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s2.key1 <span class="operator">=</span> <span class="built_in">UPPER</span>(s1.key1);</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150724181.png" alt="image-20230719150724181"></p>
<h5 id="9-rows"><a href="#9-rows" class="headerlink" title="9. rows"></a>9. rows</h5><p>预估的需要读取的记录条数，<code>值越小越好</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150756951.png" alt="image-20230719150756951"></p>
<h5 id="10-filtered"><a href="#10-filtered" class="headerlink" title="10. filtered"></a>10. filtered</h5><p>某个表经过搜索条件过滤后剩余记录条数的百分比</p>
<p>如果使用的是索引执行的单表扫描，那么计算时需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150827687.png" alt="image-20230719150827687"></p>
<p>对于单表查询来说，这个filtered的值没有什么意义，我们<code>更关注在连接查询中驱动表对应的执行计划记录的filtered值</code>，它决定了被驱动表要执行的次数 (即: rows * filtered)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719150851270.png" alt="image-20230719150851270"></p>
<p>从执行计划中可以看出来，查询优化器打算把<code>s1</code>作为驱动表，<code>s2</code>当做被驱动表。我们可以看到驱动表<code>s1</code>表的执行计划的<code>rows</code>列为<code>9688</code>，filtered列为<code>10.00</code>，这意味着驱动表<code>s1</code>的扇出值就是<code>9688 x 10.00% = 968.8</code>，这说明还要对被驱动表执行大约<code>968</code>次查询。</p>
<h5 id="11-Extra"><a href="#11-Extra" class="headerlink" title="11. Extra"></a>11. Extra</h5><p>顾名思义，<code>Extra</code>列是用来说明一些额外信息的，包含不适合在其他列中显示但十分重要的额外信息。我们可以通过这些额外信息来<code>更准确的理解MySQL到底将如何执行给定的查询语句</code>。MySQL提供的额外信息有好几十个，我们就不一个一个介绍了，所以我们只挑选比较重要的额外信息介绍给大家。</p>
<ul>
<li><p>No tables used</p>
<p>当查询语句没有<code>FROM</code>子句时将会提示该额外信息，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151153955.png" alt="image-20230719151153955"></p>
</li>
<li><p>Impossible WHERE</p>
<p>当查询语句的<code>WHERE</code>子句永远为<code>FALSE</code>时将会提示该额外信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> <span class="number">1</span> <span class="operator">!=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151216044.png" alt="image-20230719151216044"></p>
</li>
<li><p>Using where</p>
<p><img src="image-20230719151232918.png" alt="image-20230719151232918"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151255817.png" alt="image-20230719151255817"></p>
<p><img src="image-20230719151442487.png" alt="image-20230719151442487"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151505275.png" alt="image-20230719151505275"></p>
</li>
<li><p>No matching min&#x2F;max row</p>
<p>当查询列表处有<code>MIN</code>或者<code>MAX</code>聚合函数，但是并没有符合<code>WHERE</code>子句中的搜索条件的记录时。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(key1) <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;abcdefg&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151526828.png" alt="image-20230719151526828"></p>
</li>
<li><p>Using index</p>
<p>当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用覆盖索引的情况下，在<code>Extra</code>列将会提示该额外信息。比方说下边这个查询中只需要用到<code>idx_key1</code>而不需要回表操作:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151554259.png" alt="image-20230719151554259"></p>
</li>
<li><p>Using index condition</p>
<p>有些搜索条件中虽然出现了索引列，但却不能使用到索引，比如下边这个查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key1 <span class="keyword">LIKE</span> <span class="string">&#x27;%a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151620769.png" alt="image-20230719151620769"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key1 <span class="keyword">LIKE</span> <span class="string">&#x27;%b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151641903.png" alt="image-20230719151641903"></p>
</li>
<li><p>Using join buffer (Block Nested Loop)</p>
<p>在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为其分配一块名叫<code>join buffer</code>的内存块来加快查询速度，也就是我们所讲的<code>基于块的嵌套循环算法</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.common_field <span class="operator">=</span> s2.common_field;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151705722.png" alt="image-20230719151705722"></p>
</li>
<li><p>Not exists</p>
<p>当我们使用左(外)连接时，如果<code>WHERE</code>子句中包含要求被驱动表的某个列等于<code>NULL</code>值的搜索条件，而且那个列是不允许存储<code>NULL</code>值的，那么在该表的执行计划的Extra列就会提示这个信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151727762.png" alt="image-20230719151727762"></p>
</li>
<li><p>Using intersect(…) 、 Using union(…) 和 Using sort_union(…)</p>
<p>如果执行计划的<code>Extra</code>列出现了<code>Using intersect(...)</code>提示，说明准备使用<code>Intersect</code>索引合并的方式执行查询，括号中的<code>...</code>表示需要进行索引合并的索引名称；</p>
<p>如果出现<code>Using union(...)</code>提示，说明准备使用<code>Union</code>索引合并的方式执行查询;</p>
<p>如果出现<code>Using sort_union(...)</code>提示，说明准备使用<code>Sort-Union</code>索引合并的方式执行查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151754158.png" alt="image-20230719151754158"></p>
</li>
<li><p>Zero limit</p>
<p>当我们的<code>LIMIT</code>子句的参数为<code>0</code>时，表示压根儿不打算从表中读取任何记录，将会提示该额外信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 LIMIT <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151820994.png" alt="image-20230719151820994"></p>
</li>
<li><p>Using filesort</p>
<p>有一些情况下对结果集中的记录进行排序是可以使用到索引的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> key1 LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151914985.png" alt="image-20230719151914985"></p>
<p><img src="image-20230719151931537.png" alt="image-20230719151931537"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> common_field LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719151949693.png" alt="image-20230719151949693"></p>
<p>需要注意的是，如果查询中需要使用<code>filesort</code>的方式进行排序的记录非常多，那么这个过程是很耗费性能的，我们最好想办法<code>将使用文件排序的执行方式改为索引进行排序</code>。</p>
</li>
<li><p>Using temporary</p>
<p><img src="image-20230719152012778.png" alt="image-20230719152012778"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> common_field <span class="keyword">FROM</span> s1;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719152029183.png" alt="image-20230719152029183"></p>
<p>再比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> common_field, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> amount <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> common_field;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719152052680.png" alt="image-20230719152052680"></p>
<p>执行计划中出现<code>Using temporary</code>并不是一个好的征兆，因为建立与维护临时表要付出很大的成本的，所以我们<code>最好能使用索引来替代掉使用临时表</code>，比方说下边这个包含<code>GROUP BY</code>子句的查询就不需要使用临时表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> key1, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> amount <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> key1;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719152118103.png" alt="image-20230719152118103"></p>
<p>从 <code>Extra</code> 的 <code>Using index</code> 的提示里我们可以看出，上述查询只需要扫描 <code>idx_key1</code> 索引就可以搞 定了，不再需要临时表了。</p>
</li>
</ul>
<h5 id="12-小结"><a href="#12-小结" class="headerlink" title="12. 小结"></a>12. 小结</h5><ul>
<li>EXPLAIN不考虑各种Cache</li>
<li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li>
<li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li>
<li>部分统计信息是估算的，并非精确值</li>
</ul>
<h3 id="EXPLAIN的进一步使用"><a href="#EXPLAIN的进一步使用" class="headerlink" title="EXPLAIN的进一步使用"></a>EXPLAIN的进一步使用</h3><h4 id="EXPLAIN四种输出格式"><a href="#EXPLAIN四种输出格式" class="headerlink" title="EXPLAIN四种输出格式"></a>EXPLAIN四种输出格式</h4><p>这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式： <code>传统格式</code> ，<code>JSON格式</code> ， <code>TREE格式</code> 以及 <code>可视化输出</code> 。用户可以根据需要选择适用于自己的格式。</p>
<h5 id="1-传统格式"><a href="#1-传统格式" class="headerlink" title="1. 传统格式"></a>1. 传统格式</h5><p>传统格式简单明了，输出是一个表格形式，概要说明查询计划。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> s1.key1, s2.key1 <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.common_field <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719152337180.png" alt="image-20230719152337180"></p>
<h5 id="2-JSON格式"><a href="#2-JSON格式" class="headerlink" title="2. JSON格式"></a>2. JSON格式</h5><p>第1种格式中介绍的<code>EXPLAIN</code>语句输出中缺少了一个衡量执行好坏的重要属性 —— <code>成本</code>。而JSON格式是四种格式里面输出<code>信息最详尽</code>的格式，里面包含了执行的成本信息。</p>
<ul>
<li>JSON格式：在EXPLAIN单词和真正的查询语句中间加上 FORMAT&#x3D;JSON 。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN FORMAT<span class="operator">=</span>JSON <span class="keyword">SELECT</span> ....</span><br></pre></td></tr></table></figure>

<ul>
<li>EXPLAIN的Column与JSON的对应关系：(来源于MySQL 5.7文档)</li>
</ul>
<p><img src="image-20230719152429144.png" alt="image-20230719152429144"></p>
<p>这样我们就可以得到一个json格式的执行计划，里面包含该计划花费的成本。比如这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN FORMAT<span class="operator">=</span>JSON <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key2 <span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>\G</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719152449438.png" alt="image-20230719152449438"></p>
<p><img src="image-20230719152501556.png" alt="image-20230719152501556"></p>
<p><img src="image-20230719152520199.png" alt="image-20230719152520199"></p>
<p><img src="image-20230719152534137.png" alt="image-20230719152534137"></p>
<p><img src="image-20230719152549524.png" alt="image-20230719152549524"></p>
<p>我们使用 # 后边跟随注释的形式为大家解释了 <code>EXPLAIN FORMAT=JSON</code> 语句的输出内容，但是大家可能 有疑问 “<code>cost_info</code>“ 里边的成本看着怪怪的，它们是怎么计算出来的？先看 s1 表的 “<code>cost_info</code>“ 部 分：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;read_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1840.84&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eval_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;193.76&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;prefix_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2034.60&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data_read_per_join&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1M&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>read_cost</code> 是由下边这两部分组成的：</p>
<ul>
<li>IO 成本</li>
<li>检测 rows × (1 - filter) 条记录的 CPU 成本</li>
</ul>
<blockquote>
<p>小贴士： rows和filter都是我们前边介绍执行计划的输出列，在JSON格式的执行计划中，rows 相当于rows_examined_per_scan，filtered名称不变。</p>
</blockquote>
</li>
<li><p><code>eval_cost</code> 是这样计算的：</p>
<p>检测 rows × filter 条记录的成本。</p>
</li>
<li><p><code>prefix_cost</code> 就是单独查询 s1 表的成本，也就是：</p>
<p><code>read_cost + eval_cost</code></p>
</li>
<li><p><code>data_read_per_join</code> 表示在此次查询中需要读取的数据量。</p>
</li>
</ul>
<p>对于 <code>s2</code> 表的 “<code>cost_info</code>“ 部分是这样的：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;read_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;968.80&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eval_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;193.76&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;prefix_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3197.16&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data_read_per_join&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1M&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>由于 <code>s2</code> 表是被驱动表，所以可能被读取多次，这里的<code>read_cost</code> 和 <code>eval_cost</code> 是访问多次 <code>s2</code> 表后累加起来的值，大家主要关注里边儿的 <code>prefix_cost</code> 的值代表的是整个连接查询预计的成本，也就是单次查询 <code>s1</code> 表和多次查询 <code>s2</code> 表后的成本的和，也就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">968.80 + 193.76 + 2034.60 = 3197.16</span><br></pre></td></tr></table></figure>

<h5 id="3-TREE格式"><a href="#3-TREE格式" class="headerlink" title="3. TREE格式"></a>3. TREE格式</h5><p>TREE格式是8.0.16版本之后引入的新格式，主要根据查询的 <code>各个部分之间的关系</code> 和 <code>各部分的执行顺序</code> 来描述如何查询。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">EXPLAIN FORMAT=tree SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE</span></span><br><span class="line">s1.common_field = &#x27;a&#x27;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">EXPLAIN: -&gt; Nested loop inner join (cost=1360.08 rows=990)</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Filter: ((s1.common_field = &#x27;a&#x27;) and (s1.key1 is not null)) (cost=1013.75</span></span><br><span class="line">rows=990)</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Table scan on s1 (cost=1013.75 rows=9895)</span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Single-row index lookup on s2 using idx_key2 (key2=s1.key1), with index</span></span><br><span class="line">condition: (cast(s1.key1 as double) = cast(s2.key2 as double)) (cost=0.25 rows=1)</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<h5 id="4-可视化输出"><a href="#4-可视化输出" class="headerlink" title="4. 可视化输出"></a>4. 可视化输出</h5><p>可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。通过点击Workbench的放大镜图标，即可生成可视化的查询计划。</p>
<p><img src="image-20230719152804302.png" alt="image-20230719152804302"></p>
<p>上图按从左到右的连接顺序显示表。红色框表示 <code>全表扫描</code> ，而绿色框表示使用 <code>索引查找</code> 。对于每个表， 显示使用的索引。还要注意的是，每个表格的框上方是每个表访问所发现的行数的估计值以及访问该表的成本。</p>
<h4 id="SHOW-WARNINGS的使用"><a href="#SHOW-WARNINGS的使用" class="headerlink" title="SHOW WARNINGS的使用"></a>SHOW WARNINGS的使用</h4><p>在我们使用<code>EXPLAIN</code>语句查看了某个查询的执行计划后，紧接着还可以使用<code>SHOW WARNINGS</code>语句查看与这个查询的执行计划有关的一些扩展信息，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> s1.key1, s2.key1 <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.common_field <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719153017477.png" alt="image-20230719153017477"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SHOW WARNINGS\G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    Level: Note</span><br><span class="line">     Code: 1003</span><br><span class="line">Message: /* select#1 */ select `atguigu`.`s1`.`key1` AS `key1`,`atguigu`.`s2`.`key1`</span><br><span class="line">AS `key1` from `atguigu`.`s1` join `atguigu`.`s2` where ((`atguigu`.`s1`.`key1` =</span><br><span class="line">`atguigu`.`s2`.`key1`) and (`atguigu`.`s2`.`common_field` is not null))</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>大家可以看到<code>SHOW WARNINGS</code>展示出来的信息有三个字段，分别是<code>Level、Code、Message</code>。我们最常见的就是Code为1003的信息，当Code值为1003时，<code>Message</code>字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。比如我们上边的查询本来是一个左(外)连接查询，但是有一个s2.common_field IS NOT NULL的条件，这就会导致查询优化器把左(外)连接查询优化为内连接查询，从<code>SHOW WARNINGS</code>的<code>Message</code>字段也可以看出来，原本的LEFE JOIN已经变成了JOIN。</p>
<p>但是大家一定要注意，我们说<code>Message</code>字段展示的信息类似于查询优化器将我们的查询语句<code>重写后的语句</code>，并不是等价于，也就是说<code>Message</code>字段展示的信息并不是标准的查询语句，在很多情况下并不能直接拿到黑框框中运行，它只能作为帮助我们理解MySQL将如何执行查询语句的一个参考依据而已。</p>
<h3 id="分析优化器执行计划：trace"><a href="#分析优化器执行计划：trace" class="headerlink" title="分析优化器执行计划：trace"></a>分析优化器执行计划：trace</h3><p><img src="image-20230719153227898.png" alt="image-20230719153227898"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="operator">=</span><span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">set</span> optimizer_trace_max_mem_size<span class="operator">=</span><span class="number">1000000</span>;</span><br></pre></td></tr></table></figure>

<p>开启后，可分析如下语句：</p>
<ul>
<li>SELECT</li>
<li>INSERT</li>
<li>REPLACE</li>
<li>UPDATE</li>
<li>DELETE</li>
<li>EXPLAIN</li>
<li>SET</li>
<li>DECLARE</li>
<li>CASE</li>
<li>IF</li>
<li>RETURN</li>
<li>CALL</li>
</ul>
<p>测试：执行如下SQL语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>最后， 查询 information_schema.optimizer_trace 就可以知道MySQL是如何执行SQL的 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">*************************** <span class="number">1.</span> row ***************************</span><br><span class="line"><span class="comment">//第1部分：查询语句</span></span><br><span class="line">QUERY<span class="punctuation">:</span> select * from student where id &lt; <span class="number">10</span></span><br><span class="line"><span class="comment">//第2部分：QUERY字段对应语句的跟踪信息</span></span><br><span class="line">TRACE<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;join_preparation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//预备工作</span></span><br><span class="line">        <span class="attr">&quot;select#&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;expanded_query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/* select#1 */ select `student`.`id` AS</span></span><br><span class="line"><span class="string">            `id`,`student`.`stuno` AS `stuno`,`student`.`name` AS `name`,`student`.`age` AS</span></span><br><span class="line"><span class="string">            `age`,`student`.`classId` AS `classId` from `student` where (`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line">    <span class="punctuation">&#125;</span> <span class="comment">/* join_preparation */</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;join_optimization&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//进行优化</span></span><br><span class="line">    <span class="attr">&quot;select#&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;condition_processing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//条件处理</span></span><br><span class="line">        <span class="attr">&quot;condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WHERE&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;original_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;transformation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;equality_propagation&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;resulting_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;transformation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;constant_propagation&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;resulting_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;transformation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;trivial_condition_removal&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;resulting_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line">    <span class="punctuation">&#125;</span> <span class="comment">/* condition_processing */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;substitute_generated_columns&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//替换生成的列</span></span><br><span class="line">        <span class="punctuation">&#125;</span> <span class="comment">/* substitute_generated_columns */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table_dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//表的依赖关系</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;row_may_be_null&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;map_bit&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;depends_on_map_bits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">]</span> <span class="comment">/* depends_on_map_bits */</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* table_dependencies */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ref_optimizer_key_uses&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//使用键</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* ref_optimizer_key_uses */</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;rows_estimation&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//行判断</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;range_analysis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;table_scan&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">3973767</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;cost&quot;</span><span class="punctuation">:</span> <span class="number">408558</span></span><br><span class="line">            <span class="punctuation">&#125;</span> <span class="comment">/* table_scan */</span><span class="punctuation">,</span> <span class="comment">//扫描表</span></span><br><span class="line">            <span class="attr">&quot;potential_range_indexes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//潜在的范围索引</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;usable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;key_parts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;id&quot;</span></span><br><span class="line">                    <span class="punctuation">]</span> <span class="comment">/* key_parts */</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span> <span class="comment">/* potential_range_indexes */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;setup_range_conditions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//设置范围条件</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* setup_range_conditions */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;group_index_range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cause&quot;</span><span class="punctuation">:</span> <span class="string">&quot;not_group_by_or_distinct&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span> <span class="comment">/* group_index_range */</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;skip_scan_range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;potential_skip_scan_indexes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;usable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;cause&quot;</span><span class="punctuation">:</span> <span class="string">&quot;query_references_nonkey_column&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span> <span class="comment">/* potential_skip_scan_indexes */</span></span><br><span class="line">            <span class="punctuation">&#125;</span> <span class="comment">/* skip_scan_range */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzing_range_alternatives&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//分析范围选项</span></span><br><span class="line">            <span class="attr">&quot;range_scan_alternatives&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ranges&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;id &lt; 10&quot;</span></span><br><span class="line">                    <span class="punctuation">]</span> <span class="comment">/* ranges */</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index_dives_for_eq_ranges&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;rowid_ordered&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;using_mrr&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index_only&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cost&quot;</span><span class="punctuation">:</span> <span class="number">1.91986</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span> <span class="comment">/* range_scan_alternatives */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzing_roworder_intersect&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;usable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cause&quot;</span><span class="punctuation">:</span> <span class="string">&quot;too_few_roworder_scans&quot;</span></span><br><span class="line">        	<span class="punctuation">&#125;</span> <span class="comment">/* analyzing_roworder_intersect */</span></span><br><span class="line">        <span class="punctuation">&#125;</span> <span class="comment">/* analyzing_range_alternatives */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;chosen_range_access_summary&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//选择范围访问摘要</span></span><br><span class="line">            <span class="attr">&quot;range_access_plan&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;range_scan&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ranges&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;id &lt; 10&quot;</span></span><br><span class="line">                <span class="punctuation">]</span> <span class="comment">/* ranges */</span></span><br><span class="line">                <span class="punctuation">&#125;</span> <span class="comment">/* range_access_plan */</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;rows_for_plan&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cost_for_plan&quot;</span><span class="punctuation">:</span> <span class="number">1.91986</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span> <span class="comment">/* chosen_range_access_summary */</span></span><br><span class="line">                <span class="punctuation">&#125;</span> <span class="comment">/* range_analysis */</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* rows_estimation */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;considered_execution_plans&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//考虑执行计划</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;plan_prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* plan_prefix */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;best_access_path&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//最佳访问路径</span></span><br><span class="line">        <span class="attr">&quot;considered_access_paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;rows_to_scan&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;access_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;range&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;range_details&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;used_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span> <span class="comment">/* range_details */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;resulting_rows&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cost&quot;</span><span class="punctuation">:</span> <span class="number">2.81986</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* considered_access_paths */</span></span><br><span class="line">    <span class="punctuation">&#125;</span> <span class="comment">/* best_access_path */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;condition_filtering_pct&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span> <span class="comment">//行过滤百分比</span></span><br><span class="line">        <span class="attr">&quot;rows_for_plan&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cost_for_plan&quot;</span><span class="punctuation">:</span> <span class="number">2.81986</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* considered_execution_plans */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;attaching_conditions_to_tables&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//将条件附加到表上</span></span><br><span class="line">        <span class="attr">&quot;original_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;attached_conditions_computation&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* attached_conditions_computation */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;attached_conditions_summary&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//附加条件概要</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;attached&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* attached_conditions_summary */</span></span><br><span class="line">    <span class="punctuation">&#125;</span> <span class="comment">/* attaching_conditions_to_tables */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;finalizing_table_conditions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;original_table_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;final_table_condition &quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* finalizing_table_conditions */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;refine_plan&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//精简计划</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    	<span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* refine_plan */</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line">    <span class="punctuation">&#125;</span> <span class="comment">/* join_optimization */</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;join_execution&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//执行</span></span><br><span class="line">            <span class="attr">&quot;select#&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line">        	<span class="punctuation">&#125;</span> <span class="comment">/* join_execution */</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">//第3部分：跟踪信息过长时，被截断的跟踪信息的字节数。</span></span><br><span class="line">MISSING_BYTES_BEYOND_MAX_MEM_SIZE<span class="punctuation">:</span> <span class="number">0</span> <span class="comment">//丢失的超出最大容量的字节</span></span><br><span class="line"><span class="comment">//第4部分：执行跟踪语句的用户是否有查看对象的权限。当不具有权限时，该列信息为1且TRACE字段为空，一般在</span></span><br><span class="line">调用带有SQL SECURITY DEFINER的视图或者是存储过程的情况下，会出现此问题。</span><br><span class="line">INSUFFICIENT_PRIVILEGES<span class="punctuation">:</span> <span class="number">0</span> <span class="comment">//缺失权限</span></span><br><span class="line"><span class="number">1</span> row in set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="MySQL监控分析视图-sys-schema"><a href="#MySQL监控分析视图-sys-schema" class="headerlink" title="MySQL监控分析视图-sys schema"></a>MySQL监控分析视图-sys schema</h3><p><img src="image-20230719153402605.png" alt="image-20230719153402605"></p>
<h4 id="Sys-schema视图摘要"><a href="#Sys-schema视图摘要" class="headerlink" title="Sys schema视图摘要"></a>Sys schema视图摘要</h4><ol>
<li><strong>主机相关</strong>：以host_summary开头，主要汇总了IO延迟的信息。</li>
<li><strong>Innodb相关</strong>：以innodb开头，汇总了innodb buffer信息和事务等待innodb锁的信息。</li>
<li><strong>I&#x2F;o相关</strong>：以io开头，汇总了等待I&#x2F;O、I&#x2F;O使用量情况。</li>
<li><strong>内存使用情况</strong>：以memory开头，从主机、线程、事件等角度展示内存的使用情况</li>
<li><strong>连接与会话信息</strong>：processlist和session相关视图，总结了会话相关信息。</li>
<li><strong>表相关</strong>：以schema_table开头的视图，展示了表的统计信息。</li>
<li><strong>索引信息</strong>：统计了索引的使用情况，包含冗余索引和未使用的索引情况。</li>
<li><strong>语句相关</strong>：以statement开头，包含执行全表扫描、使用临时表、排序等的语句信息。</li>
<li><strong>用户相关</strong>：以user开头的视图，统计了用户使用的文件I&#x2F;O、执行语句统计信息。</li>
<li><strong>等待事件相关信息</strong>：以wait开头，展示等待事件的延迟情况。</li>
</ol>
<h4 id="Sys-schema视图使用场景"><a href="#Sys-schema视图使用场景" class="headerlink" title="Sys schema视图使用场景"></a>Sys schema视图使用场景</h4><p>索引情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span> 查询冗余索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.schema_redundant_indexes;</span><br><span class="line">#<span class="number">2.</span> 查询未使用过的索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.schema_unused_indexes;</span><br><span class="line">#<span class="number">3.</span> 查询索引的使用情况</span><br><span class="line"><span class="keyword">select</span> index_name,rows_selected,rows_inserted,rows_updated,rows_deleted</span><br><span class="line"><span class="keyword">from</span> sys.schema_index_statistics <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>表相关</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">1.</span> 查询表的访问量</span><br><span class="line"><span class="keyword">select</span> table_schema,table_name,<span class="built_in">sum</span>(io_read_requests<span class="operator">+</span>io_write_requests) <span class="keyword">as</span> io <span class="keyword">from</span></span><br><span class="line">sys.schema_table_statistics <span class="keyword">group</span> <span class="keyword">by</span> table_schema,table_name <span class="keyword">order</span> <span class="keyword">by</span> io <span class="keyword">desc</span>;</span><br><span class="line"># <span class="number">2.</span> 查询占用bufferpool较多的表</span><br><span class="line"><span class="keyword">select</span> object_schema,object_name,allocated,data</span><br><span class="line"><span class="keyword">from</span> sys.innodb_buffer_stats_by_table <span class="keyword">order</span> <span class="keyword">by</span> allocated limit <span class="number">10</span>;</span><br><span class="line"># <span class="number">3.</span> 查看表的全表扫描情况</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.statements_with_full_table_scans <span class="keyword">where</span> db<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>语句相关</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span> 监控<span class="keyword">SQL</span>执行的频率</span><br><span class="line"><span class="keyword">select</span> db,exec_count,query <span class="keyword">from</span> sys.statement_analysis</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> exec_count <span class="keyword">desc</span>;</span><br><span class="line">#<span class="number">2.</span> 监控使用了排序的<span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">select</span> db,exec_count,first_seen,last_seen,query</span><br><span class="line"><span class="keyword">from</span> sys.statements_with_sorting limit <span class="number">1</span>;</span><br><span class="line">#<span class="number">3.</span> 监控使用了临时表或者磁盘临时表的<span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">select</span> db,exec_count,tmp_tables,tmp_disk_tables,query</span><br><span class="line"><span class="keyword">from</span> sys.statement_analysis <span class="keyword">where</span> tmp_tables<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">or</span> tmp_disk_tables <span class="operator">&gt;</span><span class="number">0</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> (tmp_tables<span class="operator">+</span>tmp_disk_tables) <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p>IO相关</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span> 查看消耗磁盘IO的文件</span><br><span class="line"><span class="keyword">select</span> file,avg_read,avg_write,avg_read<span class="operator">+</span>avg_write <span class="keyword">as</span> avg_io</span><br><span class="line"><span class="keyword">from</span> sys.io_global_by_file_by_bytes <span class="keyword">order</span> <span class="keyword">by</span> avg_read limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>Innodb 相关</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span> 行锁阻塞情况</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure>

<p><img src="image-20220704192020603.png" alt="image-20220704192020603"></p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>查询是数据库中最频繁的操作，提高查询速度可以有效地提高MySQL数据库的性能。通过对查询语句的分析可以了解查询语句的执行情况，找出查询语句执行的瓶颈，从而优化查询语句。</p>
<h2 id="索引优化与查询优化"><a href="#索引优化与查询优化" class="headerlink" title="索引优化与查询优化"></a>索引优化与查询优化</h2><p>都有哪些维度可以进行数据库调优？简言之：</p>
<ul>
<li>索引失效、没有充分利用到索引——建立索引</li>
<li>关联查询太多JOIN（设计缺陷或不得已的需求）——SQL优化</li>
<li>服务器调优及各个参数设置（缓冲、线程数等）——调整my.cnf</li>
<li>数据过多——分库分表</li>
</ul>
<p>关于数据库调优的知识非常分散。不同的DBMS，不同的公司，不同的职位，不同的项目遇到的问题都不尽相同。这里我们分为三个章节进行细致讲解。</p>
<p>虽然SQL查询优化的技术有很多，但是大方向上完全可以分成<code>物理查询优化</code>和<code>逻辑查询优化</code>两大块。</p>
<ul>
<li>物理查询优化是通过<code>索引</code>和<code>表连接方式</code>等技术来进行优化，这里重点需要掌握索引的使用。</li>
<li>逻辑查询优化就是通过SQL<code>等价变换</code>提升查询效率，直白一点就是说，换一种查询写法效率可能更高。</li>
</ul>
<h3 id="索引失效案例"><a href="#索引失效案例" class="headerlink" title="索引失效案例"></a>索引失效案例</h3><p><img src="image-20230719154911290.png" alt="image-20230719154911290"></p>
<h4 id="全值匹配我最爱"><a href="#全值匹配我最爱" class="headerlink" title="全值匹配我最爱"></a>全值匹配我最爱</h4><h4 id="最佳左前缀法则"><a href="#最佳左前缀法则" class="headerlink" title="最佳左前缀法则"></a>最佳左前缀法则</h4><p>在MySQL建立联合索引时会遵守最佳左前缀原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<p>举例1：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>举例2：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.classId<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>举例3：索引<code>idx_age_classid_name</code>还能否正常使用？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.classId<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719155156549.png" alt="image-20230719155156549"></p>
<p>虽然可以正常使用，但是只有部分被使用到了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.classId<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719155214651.png" alt="image-20230719155214651"></p>
<p>完全没有使用上索引。</p>
<p>结论：MySQL可以为多个字段创建索引，一个索引可以包含16个字段。对于多列索引，<strong>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用</strong>。如果查询条件中没有用这些字段中第一个字段时，多列（或联合）索引不会被使用。</p>
<blockquote>
<p>拓展：Alibaba《Java开发手册》</p>
<p>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
</blockquote>
<h4 id="主键插入顺序"><a href="#主键插入顺序" class="headerlink" title="主键插入顺序"></a>主键插入顺序</h4><p><img src="image-20230719155646906.png" alt="image-20230719155646906"></p>
<p>如果此时再插入一条主键值为 9 的记录，那它插入的位置就如下图：</p>
<p><img src="image-20230719160211534.png" alt="image-20230719160211534"></p>
<p>可这个数据页已经满了，再插进来咋办呢？我们需要把当前 <code>页面分裂</code> 成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着： <code>性能损耗</code> ！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的 <code>主键值依次递增</code> ，这样就不会发生这样的性能损耗了。 所以我们建议：让主键具有 <code>AUTO_INCREMENT</code> ，让存储引擎自己为表生成主键，而不是我们手动插入 ， 比如： <code>person_info</code> 表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_info(</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    birthday <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    phone_number <span class="type">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    country <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    KEY idx_name_birthday_phone_number (name(<span class="number">10</span>), birthday, phone_number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>我们自定义的主键列 <code>id</code> 拥有 <code>AUTO_INCREMENT</code> 属性，在插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。</p>
<h4 id="计算、函数、类型转换-自动或手动-导致索引失效"><a href="#计算、函数、类型转换-自动或手动-导致索引失效" class="headerlink" title="计算、函数、类型转换(自动或手动)导致索引失效"></a>计算、函数、类型转换(自动或手动)导致索引失效</h4><ol>
<li><p>这两条sql哪种写法更好</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.name <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(student.name,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> student(NAME);</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一种：索引优化生效</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.name <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE <span class="string">&#x27;abc%&#x27;</span>;</span></span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| id | stuno | name | age | classId |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| 5301379 | 1233401 | AbCHEa | 164 | 259 |</span><br><span class="line">| 7170042 | 3102064 | ABcHeB | 199 | 161 |</span><br><span class="line">| 1901614 | 1833636 | ABcHeC | 226 | 275 |</span><br><span class="line">| 5195021 | 1127043 | abchEC | 486 | 72 |</span><br><span class="line">| 4047089 | 3810031 | AbCHFd | 268 | 210 |</span><br><span class="line">| 4917074 | 849096 | ABcHfD | 264 | 442 |</span><br><span class="line">| 1540859 | 141979 | abchFF | 119 | 140 |</span><br><span class="line">| 5121801 | 1053823 | AbCHFg | 412 | 327 |</span><br><span class="line">| 2441254 | 2373276 | abchFJ | 170 | 362 |</span><br><span class="line">| 7039146 | 2971168 | ABcHgI | 502 | 465 |</span><br><span class="line">| 1636826 | 1580286 | ABcHgK | 71 | 262 |</span><br><span class="line">| 374344 | 474345 | abchHL | 367 | 212 |</span><br><span class="line">| 1596534 | 169191 | AbCHHl | 102 | 146 |</span><br><span class="line">...</span><br><span class="line">| 5266837 | 1198859 | abclXe | 292 | 298 |</span><br><span class="line">| 8126968 | 4058990 | aBClxE | 316 | 150 |</span><br><span class="line">| 4298305 | 399962 | AbCLXF | 72 | 423 |</span><br><span class="line">| 5813628 | 1745650 | aBClxF | 356 | 323 |</span><br><span class="line">| 6980448 | 2912470 | AbCLXF | 107 | 78 |</span><br><span class="line">| 7881979 | 3814001 | AbCLXF | 89 | 497 |</span><br><span class="line">| 4955576 | 887598 | ABcLxg | 121 | 385 |</span><br><span class="line">| 3653460 | 3585482 | AbCLXJ | 130 | 174 |</span><br><span class="line">| 1231990 | 1283439 | AbCLYH | 189 | 429 |</span><br><span class="line">| 6110615 | 2042637 | ABcLyh | 157 | 40 |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">401 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种：索引优化失效</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(student.name,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719160930744.png" alt="image-20230719160930744"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = <span class="string">&#x27;abc&#x27;</span>;</span></span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| id | stuno | name | age | classId |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| 5301379 | 1233401 | AbCHEa | 164 | 259 |</span><br><span class="line">| 7170042 | 3102064 | ABcHeB | 199 | 161 |</span><br><span class="line">| 1901614 | 1833636 | ABcHeC | 226 | 275 |</span><br><span class="line">| 5195021 | 1127043 | abchEC | 486 | 72 |</span><br><span class="line">| 4047089 | 3810031 | AbCHFd | 268 | 210 |</span><br><span class="line">| 4917074 | 849096 | ABcHfD | 264 | 442 |</span><br><span class="line">| 1540859 | 141979 | abchFF | 119 | 140 |</span><br><span class="line">| 5121801 | 1053823 | AbCHFg | 412 | 327 |</span><br><span class="line">| 2441254 | 2373276 | abchFJ | 170 | 362 |</span><br><span class="line">| 7039146 | 2971168 | ABcHgI | 502 | 465 |</span><br><span class="line">| 1636826 | 1580286 | ABcHgK | 71 | 262 |</span><br><span class="line">| 374344 | 474345 | abchHL | 367 | 212 |</span><br><span class="line">| 1596534 | 169191 | AbCHHl | 102 | 146 |</span><br><span class="line">...</span><br><span class="line">| 5266837 | 1198859 | abclXe | 292 | 298 |</span><br><span class="line">| 8126968 | 4058990 | aBClxE | 316 | 150 |</span><br><span class="line">| 4298305 | 399962 | AbCLXF | 72 | 423 |</span><br><span class="line">| 5813628 | 1745650 | aBClxF | 356 | 323 |</span><br><span class="line">| 6980448 | 2912470 | AbCLXF | 107 | 78 |</span><br><span class="line">| 7881979 | 3814001 | AbCLXF | 89 | 497 |</span><br><span class="line">| 4955576 | 887598 | ABcLxg | 121 | 385 |</span><br><span class="line">| 3653460 | 3585482 | AbCLXJ | 130 | 174 |</span><br><span class="line">| 1231990 | 1283439 | AbCLYH | 189 | 429 |</span><br><span class="line">| 6110615 | 2042637 | ABcLyh | 157 | 40 |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">401 rows in set, 1 warning (3.62 sec)</span><br></pre></td></tr></table></figure>

<p>type为“ALL”，表示没有使用到索引，查询时间为 3.62 秒，查询效率较之前低很多。</p>
</li>
</ol>
<p><strong>再举例：</strong></p>
<ul>
<li><p>student表的字段stuno上设置有索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_sno <span class="keyword">ON</span> student(stuno);</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引优化失效：（假设：student表的字段stuno上设置有索引）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE id, stuno, NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stuno<span class="operator">+</span><span class="number">1</span> <span class="operator">=</span> <span class="number">900001</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>运行结果：</p>
<p>​	<img src="image-20230719161144949.png" alt="image-20230719161144949"></p>
<ul>
<li><p>索引优化生效：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE id, stuno, NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stuno <span class="operator">=</span> <span class="number">900000</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>再举例：</strong></p>
<ul>
<li><p>student表的字段name上设置有索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> student(NAME);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> id, stuno, name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="built_in">SUBSTRING</span>(name, <span class="number">1</span>,<span class="number">3</span>)<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719161241581.png" alt="image-20230719161241581"></p>
</li>
<li><p>索引优化生效</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> id, stuno, NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="image-20230719161302374.png" alt="image-20230719161302374"></p>
<h4 id="类型转换导致索引失效"><a href="#类型转换导致索引失效" class="headerlink" title="类型转换导致索引失效"></a>类型转换导致索引失效</h4><p>下列哪个sql语句可以用到索引。（假设name字段上设置有索引）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719161419430.png" alt="image-20230719161419430"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719161431240.png" alt="image-20230719161431240"></p>
<p>name&#x3D;123发生类型转换，索引失效。</p>
<h4 id="范围条件右边的列索引失效"><a href="#范围条件右边的列索引失效" class="headerlink" title="范围条件右边的列索引失效"></a>范围条件右边的列索引失效</h4><ol>
<li>系统经常出现的sql如下：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> INDEX idx_name;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> INDEX idx_age;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> INDEX idx_age_classid;</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.classId<span class="operator">&gt;</span><span class="number">20</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span> ;</span><br></pre></td></tr></table></figure>

<p><img src="image-20230719161522661.png" alt="image-20230719161522661"></p>
<ol start="2">
<li>那么索引 idx_age_classId_name 这个索引还能正常使用么？</li>
</ol>
<ul>
<li>不能，范围右边的列不能使用。比如：(&lt;) (&lt;&#x3D;) (&gt;) (&gt;&#x3D;) 和 between 等</li>
<li>如果这种sql出现较多，应该建立：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index idx_age_name_classId on student(age,name,classId);</span><br></pre></td></tr></table></figure>

<ul>
<li>将范围查询条件放置语句最后：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name = &#x27;abc&#x27; AND student.classId&gt;20;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（创建的联合索引中，务必把范围涉及到的字段写在最后）</p>
</blockquote>
<ol start="3">
<li><p>效果</p>
<p><img src="blog\architect\source_posts\Mysql索引及调优\image-20230724114031282.png" alt="image-20230724114031282"></p>
</li>
</ol>
<h4 id="不等于-x3D-或者-lt-gt-索引失效"><a href="#不等于-x3D-或者-lt-gt-索引失效" class="headerlink" title="不等于(!&#x3D; 或者&lt;&gt;)索引失效"></a>不等于(!&#x3D; 或者&lt;&gt;)索引失效</h4><ul>
<li>为name字段创建索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> student(NAME);</span><br></pre></td></tr></table></figure>

<ul>
<li>查看索引是否失效</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.name <span class="operator">&lt;&gt;</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="blog\architect\source_posts\Mysql索引及调优\image-20230724114337762.png" alt="image-20230724114337762"></p>
<h4 id="is-null可以使用索引，is-not-null无法使用索引"><a href="#is-null可以使用索引，is-not-null无法使用索引" class="headerlink" title="is null可以使用索引，is not null无法使用索引"></a>is null可以使用索引，is not null无法使用索引</h4><ul>
<li>IS NULL: 可以触发索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>IS NOT NULL: 无法触发索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>结论：最好在设计数据库的时候就将<code>字段设置为 NOT NULL 约束</code>，比如你可以将 INT 类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(‘’)。</p>
<p>扩展：同理，在查询中使用<code>not like</code>也无法使用索引，导致全表扫描。</p>
<h4 id="like以通配符-开头索引失效"><a href="#like以通配符-开头索引失效" class="headerlink" title="like以通配符%开头索引失效"></a>like以通配符%开头索引失效</h4><p>在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为’%’，索引就不会起作用。只有’%’不在第一个位置，索引才会起作用。</p>
<ul>
<li>使用到索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;ab%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>未使用到索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%ab%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="OR-前后存在非索引的列，索引失效"><a href="#OR-前后存在非索引的列，索引失效" class="headerlink" title="OR 前后存在非索引的列，索引失效"></a>OR 前后存在非索引的列，索引失效</h4><p>在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，<strong>OR前后的两个条件中的列都是索引时，查询中才使用索引。</strong></p>
<p>因为OR的含义就是两个只要满足一个即可，因此<code>只有一个条件列进行了索引是没有意义的</code>，只要有条件列没有进行索引，就会进行<code>全表扫描</code>，因此所以的条件列也会失效。</p>
<p>查询语句使用OR关键字的情况：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">10</span> <span class="keyword">OR</span> classid <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>因为classId字段上没有索引，所以上述查询语句没有使用索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">10</span> <span class="keyword">OR</span> name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>因为age字段和name字段上都有索引，所以查询中使用了索引。你能看到这里使用到了<code>index_merge</code>，简单来说index_merge就是对age和name分别进行了扫描，然后将这两个结果集进行了合并。这样做的好处就是<code>避免了全表扫描</code>。</p>
<h4 id="数据库和表的字符集统一使用utf8mb4"><a href="#数据库和表的字符集统一使用utf8mb4" class="headerlink" title="数据库和表的字符集统一使用utf8mb4"></a>数据库和表的字符集统一使用utf8mb4</h4><p>统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不 同的 <code>字符集</code> 进行比较前需要进行 <code>转换</code> 会造成索引失效。</p>
<h3 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h3><h4 id="join语句原理"><a href="#join语句原理" class="headerlink" title="join语句原理"></a>join语句原理</h4><p>join方式连接多个表，本质就是各个表之间数据的循环匹配。MySQL5.5版本之前，MySQL只支持一种表间关联方式，就是嵌套循环(Nested Loop Join)。如果关联表的数据量很大，则join关联的执行时间会很长。在MySQL5.5以后的版本中，MySQL通过引入BNLJ算法来优化嵌套执行。</p>
<h5 id="1-驱动表和被驱动表"><a href="#1-驱动表和被驱动表" class="headerlink" title="1. 驱动表和被驱动表"></a>1. 驱动表和被驱动表</h5><p>驱动表就是主表，被驱动表就是从表、非驱动表。</p>
<ul>
<li>对于内连接来说：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">JOIN</span> B <span class="keyword">ON</span> ...</span><br></pre></td></tr></table></figure>

<p>A一定是驱动表吗？不一定，优化器会根据你查询语句做优化，决定先查哪张表。先查询的那张表就是驱动表，反之就是被驱动表。通过explain关键字可以查看。</p>
<ul>
<li>对于外连接来说：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> ...</span><br><span class="line"># 或</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> B <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> A <span class="keyword">ON</span> ... </span><br></pre></td></tr></table></figure>

<p>通常，大家会认为A就是驱动表，B就是被驱动表。但也未必。</p>
<h5 id="2-Simple-Nested-Loop-Join-简单嵌套循环连接"><a href="#2-Simple-Nested-Loop-Join-简单嵌套循环连接" class="headerlink" title="2. Simple Nested-Loop Join (简单嵌套循环连接)"></a>2. Simple Nested-Loop Join (简单嵌套循环连接)</h5><p>算法相当简单，从表A中取出一条数据1，遍历表B，将匹配到的数据放到result.. 以此类推，驱动表A中的每一条记录与被驱动表B的记录进行判断：</p>
<p><img src="image-20230724143530242.png" alt="image-20230724143530242"></p>
<p>可以看到这种方式效率是非常低的，以上述表A数据100条，表B数据1000条计算，则A*B&#x3D;10万次。开销统计如下:<img src="image-20230724143647333.png" alt="image-20230724143647333"></p>
<p>当然mysql肯定不会这么粗暴的去进行表的连接，所以就出现了后面的两种对Nested-Loop Join优化算法。</p>
<h5 id="3-Index-Nested-Loop-Join-（索引嵌套循环连接）"><a href="#3-Index-Nested-Loop-Join-（索引嵌套循环连接）" class="headerlink" title="3. Index Nested-Loop Join （索引嵌套循环连接）"></a>3. Index Nested-Loop Join （索引嵌套循环连接）</h5><p>Index Nested-Loop Join其优化的思路主要是为了<code>减少内存表数据的匹配次数</code>，所以要求被驱动表上必须<code>有索引</code>才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内存表的每条记录去进行比较，这样极大的减少了对内存表的匹配次数。</p>
<p><img src="image-20230724143814272.png" alt="image-20230724143814272"></p>
<p>驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故mysql优化器都倾向于使用记录数少的表作为驱动表（外表）。</p>
<p><img src="image-20230724143926587.png" alt="image-20230724143926587"></p>
<p>如果被驱动表加索引，效率是非常高的，但如果索引不是主键索引，所以还得进行一次回表查询。相比，被驱动表的索引是主键索引，效率会更高。</p>
<h5 id="4-Block-Nested-Loop-Join（块嵌套循环连接）"><a href="#4-Block-Nested-Loop-Join（块嵌套循环连接）" class="headerlink" title="4. Block Nested-Loop Join（块嵌套循环连接）"></a>4. Block Nested-Loop Join（块嵌套循环连接）</h5><p><img src="image-20230724144010126-1690180811819-4.png" alt="image-20230724144010126"></p>
<blockquote>
<p>注意：</p>
<p>这里缓存的不只是关联表的列，select后面的列也会缓存起来。</p>
<p>在一个有N个join关联的sql中会分配N-1个join buffer。所以查询的时候尽量减少不必要的字段，可以让join buffer中可以存放更多的列。</p>
</blockquote>
<p><img src="image-20230724144138332.png" alt="image-20230724144138332"></p>
<p><img src="image-20230724144147508.png" alt="image-20230724144147508"></p>
<p>参数设置：</p>
<ul>
<li>block_nested_loop</li>
</ul>
<p>通过<code>show variables like &#39;%optimizer_switch%</code> 查看 <code>block_nested_loop</code>状态。默认是开启的。</p>
<ul>
<li>join_buffer_size</li>
</ul>
<p>驱动表能不能一次加载完，要看join buffer能不能存储所有的数据，默认情况下<code>join_buffer_size=256k</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%join_buffer%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>join_buffer_size的最大值在32位操作系统可以申请4G，而在64位操作系统下可以申请大于4G的Join Buffer空间（64位Windows除外，其大值会被截断为4GB并发出警告）。</p>
<h5 id="5-Join小结"><a href="#5-Join小结" class="headerlink" title="5. Join小结"></a>5. Join小结</h5><p>1、<strong>整体效率比较：INLJ &gt; BNLJ &gt; SNLJ</strong></p>
<p>2、永远用小结果集驱动大结果集（其本质就是减少外层循环的数据数量）（小的度量单位指的是表行数 * 每行大小）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.b,t2.<span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.b<span class="operator">=</span>t2.b) <span class="keyword">where</span> t2.id<span class="operator">&lt;=</span><span class="number">100</span>; # 推荐</span><br><span class="line"><span class="keyword">select</span> t1.b,t2.<span class="operator">*</span> <span class="keyword">from</span> t2 straight_join t1 <span class="keyword">on</span> (t1.b<span class="operator">=</span>t2.b) <span class="keyword">where</span> t2.id<span class="operator">&lt;=</span><span class="number">100</span>; # 不推荐</span><br></pre></td></tr></table></figure>

<p>3、为被驱动表匹配的条件增加索引(减少内存表的循环匹配次数)</p>
<p>4、增大join buffer size的大小（一次索引的数据越多，那么内层包的扫描次数就越少）</p>
<p>5、减少驱动表不必要的字段查询（字段越少，join buffer所缓存的数据就越多）</p>
<h5 id="6-Hash-Join"><a href="#6-Hash-Join" class="headerlink" title="6. Hash Join"></a>6. Hash Join</h5><p><strong>从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join</strong></p>
<ul>
<li><p>Nested Loop:</p>
<p>对于被连接的数据子集较小的情况，Nested Loop是个较好的选择。</p>
</li>
<li><p>Hash Join是做<code>大数据集连接</code>时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立<code>散列表</code>，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。</p>
<ul>
<li>这种方式适合于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。</li>
<li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成<code>若干不同的分区</code>，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I&#x2F;O的性能。</li>
<li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是Join的重型升降机。Hash Join只能应用于等值连接（如WHERE A.COL1 &#x3D; B.COL2），这是由Hash的特点决定的。</li>
</ul>
<p><img src="image-20230724144436345.png" alt="image-20230724144436345"></p>
</li>
</ul>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul>
<li>保证被驱动表的JOIN字段已经创建了索引</li>
<li>需要JOIN 的字段，数据类型保持绝对一致。</li>
<li>LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。</li>
<li>INNER JOIN 时，MySQL会自动将 小结果集的表选为驱动表 。选择相信MySQL优化策略。</li>
<li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)</li>
<li>不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询。</li>
<li>衍生表建不了索引</li>
</ul>
<h3 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h3><p>MySQL从4.1版本开始支持子查询，使用子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结 果作为另一个SELECT语句的条件。 <code>子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作</code> 。</p>
<p>子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，子查询的执行效率不高。原因：</p>
<p>① 执行子查询时，MySQL需要为内层查询语句的查询结果 建立一个临时表 ，然后外层查询语句从临时表 中查询记录。查询完毕后，再撤销这些临时表 。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</p>
<p>② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都 不会存在索引 ，所以查询性能会 受到一定的影响。</p>
<p>③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p>
<p><strong>在MySQL中，可以使用连接（JOIN）查询来替代子查询。</strong>连接查询 <code>不需要建立临时表</code> ，其 <code>速度比子查询</code> 要快 ，如果查询中使用索引的话，性能就会更好。</p>
<blockquote>
<p>结论：尽量不要使用NOT IN或者NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</p>
</blockquote>
<h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><p>在MySQL中，支持两种排序方式，分别是 <code>FileSort</code> 和 <code>Index</code> 排序。</p>
<ul>
<li>Index 排序中，索引可以保证数据的有序性，不需要再进行排序，<code>效率更高</code>。</li>
<li>FileSort 排序则一般在 <code>内存中</code> 进行排序，占用<code>CPU较多</code>。如果待排结果较大，会产生临时文件 I&#x2F;O 到磁盘进行排序的情况，效率较低。</li>
</ul>
<p><strong>优化建议：</strong></p>
<ol>
<li>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 <code>避免全表扫描</code> ，在 ORDER BY 子句 <code>避免使用 FileSort 排序</code> 。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</li>
<li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列； 如果不同就使用联合索引。</li>
<li>无法使用 Index 时，需要对 FileSort 方式进行调优。</li>
</ol>
<p><strong>order by 时不limit,索引失效</strong></p>
<p><strong>order by 时顺序错误，索引失效</strong></p>
<p><strong>order by 时规则不一致，索引失效（顺序错，不索引；方向反，不索引）</strong></p>
<p><strong>无过滤，不索引</strong></p>
<p><strong>小结</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INDEX a_b_c(a,b,c)</span><br><span class="line">order by 能使用索引最左前缀</span><br><span class="line">- ORDER BY a</span><br><span class="line">- ORDER BY a,b</span><br><span class="line">- ORDER BY a,b,c</span><br><span class="line">- ORDER BY a DESC,b DESC,c DESC</span><br><span class="line">如果WHERE使用索引的最左前缀定义为常量，则order by 能使用索引</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b = const ORDER BY c</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b &gt; const ORDER BY b,c</span><br><span class="line">不能使用索引进行排序</span><br><span class="line">- ORDER BY a ASC,b DESC,c DESC /* 排序不一致 */</span><br><span class="line">- WHERE g = const ORDER BY b,c /*丢失a索引*/</span><br><span class="line">- WHERE a = const ORDER BY c /*丢失b索引*/</span><br><span class="line">- WHERE a = const ORDER BY a,d /*d不是索引的一部分*/</span><br><span class="line">- WHERE a in (...) ORDER BY b,c /*对于排序来说，多个相等条件也是范围查询*/</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ol>
<li>两个索引同时存在，mysql自动选择最优的方案。但是， <code>随着数据量的变化，选择的索引也会随之变化的 </code>。</li>
<li><strong>当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过 滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</strong></li>
</ol>
<h4 id="filesort算法：双路排序和单路排序"><a href="#filesort算法：双路排序和单路排序" class="headerlink" title="filesort算法：双路排序和单路排序"></a>filesort算法：双路排序和单路排序</h4><p>排序的字段若不在索引列上，则filesort会有两种算法：双路排序和单路排序</p>
<p><strong>双路排序 （慢）</strong></p>
<ul>
<li>MySQL 4.1之前是使用双路排序 ，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和 order by列 ，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li>
<li>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段 。</li>
</ul>
<p>取一批数据，要对磁盘进行两次扫描，众所周知，IO是很耗时的，所以在mysql4.1之后，出现了第二种 改进的算法，就是单路排序。</p>
<p><strong>单路排序 （快）</strong></p>
<p>从磁盘读取查询需要的 所有列 ，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。</p>
<p><strong>结论及引申出的问题</strong></p>
<ul>
<li>由于单路是后出的，总体而言好过双路</li>
<li>但是用单路有问题<ul>
<li>在sort_buffer中，单路要比多路多占用很多空间，因为单路是把所有字段都取出，所以有可能取出的数据的总大小超出了<code>sort_buffer</code>的容量，导致每次只能取<code>sort_buffer</code>容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取sort_buffer容量大小，再排…从而多次I&#x2F;O。</li>
<li>单路本来想省一次I&#x2F;O操作，反而导致了大量的I&#x2F;O操作，反而得不偿失。</li>
</ul>
</li>
</ul>
<p><strong>优化策略</strong></p>
<p><strong>1. 尝试提高 sort_buffer_size</strong></p>
<p><img src="image-20230725150209948.png" alt="image-20230725150209948"></p>
<p><strong>2. 尝试提高 max_length_for_sort_data</strong></p>
<p><img src="image-20230725150234449.png" alt="image-20230725150234449"></p>
<p><strong>3. Order by 时select * 是一个大忌。最好只Query需要的字段。</strong></p>
<p><img src="image-20230725150317521.png" alt="image-20230725150317521"></p>
<h3 id="GROUP-BY优化"><a href="#GROUP-BY优化" class="headerlink" title="GROUP BY优化"></a>GROUP BY优化</h3><ul>
<li>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。</li>
<li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li>
<li>当无法使用索引列，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置</li>
<li>where效率高于having，能写在where限定的条件就不要写在having中了</li>
<li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li>
<li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行 以内，否则SQL会很慢。</li>
</ul>
<h3 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询"></a>优化分页查询</h3><p><img src="image-20230725151145228.png" alt="image-20230725151145228"></p>
<p><strong>优化思路一</strong></p>
<p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p>
<p><strong>优化思路二</strong></p>
<p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。</p>
<h3 id="优先考虑覆盖索引"><a href="#优先考虑覆盖索引" class="headerlink" title="优先考虑覆盖索引"></a>优先考虑覆盖索引</h3><h4 id="什么是覆盖索引？"><a href="#什么是覆盖索引？" class="headerlink" title="什么是覆盖索引？"></a>什么是覆盖索引？</h4><p><strong>理解方式一</strong>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。<strong>一个索引包含了满足查询结果的数据就叫做覆盖索引</strong>。</p>
<p><strong>理解方式二</strong>：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列 （即建索引的字段正好是覆盖查询条件中所涉及的字段）。</p>
<p>简单说就是， <code>索引列+主键</code> 包含 <code>SELECT 到 FROM之间查询的列</code> 。</p>
<h4 id="覆盖索引的利弊"><a href="#覆盖索引的利弊" class="headerlink" title="覆盖索引的利弊"></a>覆盖索引的利弊</h4><p><img src="image-20230725151549435.png" alt="image-20230725151549435"></p>
<h3 id="如何给字符串添加索引"><a href="#如何给字符串添加索引" class="headerlink" title="如何给字符串添加索引"></a>如何给字符串添加索引</h3><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>MySQL是支持前缀索引的。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字 符串。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> teacher <span class="keyword">add</span> index index1(email);</span><br><span class="line">#或</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> teacher <span class="keyword">add</span> index index2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<p>这两种不同的定义在数据结构和存储上有什么区别呢？下图就是这两个索引的示意图。</p>
<p><img src="image-20230725151659989.png" alt="image-20230725151659989"></p>
<p>以及</p>
<p><img src="image-20230725151722370.png" alt="image-20230725151722370"></p>
<p><strong>如果使用的是index1</strong>（即email整个字符串的索引结构），执行顺序是这样的：</p>
<ol>
<li>从index1索引树找到满足索引值是’ <a href="mailto:zhangssxyz@xxx.com">zhangssxyz@xxx.com</a>’的这条记录，取得ID2的值；</li>
<li>到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；</li>
<li>取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email&#x3D;’ <a href="mailto:zhangssxyz@xxx.com">zhangssxyz@xxx.com</a> ’的 条件了，循环结束。</li>
</ol>
<p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p>
<p><strong>如果使用的是index2</strong>（即email(6)索引结构），执行顺序是这样的：</p>
<ol>
<li>从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1；</li>
<li>到主键上查到主键值是ID1的行，判断出email的值不是’ <a href="mailto:zhangssxyz@xxx.com">zhangssxyz@xxx.com</a> ’，这行记录丢弃；</li>
<li>取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然 后判断，这次值对了，将这行记录加入结果集；</li>
<li>重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。</li>
</ol>
<p>也就是说<strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong>前面 已经讲过区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。</p>
<h4 id="前缀索引对覆盖索引的影响"><a href="#前缀索引对覆盖索引的影响" class="headerlink" title="前缀索引对覆盖索引的影响"></a>前缀索引对覆盖索引的影响</h4><blockquote>
<p>结论： 使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。</p>
</blockquote>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><h4 id="使用前后对比"><a href="#使用前后对比" class="headerlink" title="使用前后对比"></a>使用前后对比</h4><p>Index Condition Pushdown(ICP)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式。</p>
<p><img src="image-20230725151906852.png" alt="image-20230725151906852"></p>
<h4 id="ICP的开启-x2F-关闭"><a href="#ICP的开启-x2F-关闭" class="headerlink" title="ICP的开启&#x2F;关闭"></a>ICP的开启&#x2F;关闭</h4><ul>
<li>默认情况下启动索引条件下推。可以通过设置系统变量<code>optimizer_switch</code>控制：<code>index_condition_pushdown</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 打开索引下推</span><br><span class="line"><span class="keyword">SET</span> optimizer_switch <span class="operator">=</span> <span class="string">&#x27;index_condition_pushdown=on&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 关闭索引下推</span><br><span class="line"><span class="keyword">SET</span> optimizer_switch <span class="operator">=</span> <span class="string">&#x27;index_condition_pushdown=off&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>当使用索引条件下推是，<code>EXPLAIN</code>语句输出结果中<code>Extra</code>列内容显示为<code>Using index condition</code>。</li>
</ul>
<h4 id="ICP的使用条件"><a href="#ICP的使用条件" class="headerlink" title="ICP的使用条件"></a>ICP的使用条件</h4><ol>
<li>如果表的访问类型为 range 、 ref 、 eq_ref 或者 ref_or_null 可以使用ICP。</li>
<li>ICP可以使用<code>InnDB</code>和<code>MyISAM</code>表，包括分区表<code>InnoDB</code>和<code>MyISAM</code>表</li>
<li>对于<code>InnoDB</code>表，ICP仅用于<code>二级索引</code>。ICP的目标是减少全行读取次数，从而减少I&#x2F;O操作。</li>
<li>当SQL使用覆盖索引时，不支持ICP优化方法。因为这种情况下使用ICP不会减少I&#x2F;O。</li>
<li>相关子查询的条件不能使用ICP</li>
</ol>
<h3 id="普通索引-vs-唯一索引"><a href="#普通索引-vs-唯一索引" class="headerlink" title="普通索引 vs 唯一索引"></a>普通索引 vs 唯一索引</h3><h4 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h4><p>假设，执行查询的语句是 select id from test where k&#x3D;5。</p>
<ul>
<li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一 个不满足k&#x3D;5条件的记录。</li>
<li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检 索。</li>
</ul>
<p>那么，这个不同带来的性能差距会有多少呢？答案是， 微乎其微 。</p>
<h4 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h4><p>为了说明普通索引和唯一索引对更新语句性能的影响这个问题，介绍一下change buffer。</p>
<p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话， 在不影响数据一致性的前提下， <code>InooDB会将这些更新操作缓存在change buffer中</code> ，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p>
<p>将change buffer中的操作应用到原数据页，得到最新结果的过程称为 merge 。除了 <code>访问这个数据页</code> 会触 发merge外，系统有 <code>后台线程会定期</code> merge。在 <code>数据库正常关闭（shutdown）</code> 的过程中，也会执行merge 操作。</p>
<p>如果能够将更新操作先记录在change buffer， <code>减少读磁盘</code> ，语句的执行速度会得到明显的提升。而且， 数据读入内存是需要占用 buffer pool 的，所以这种方式还能够 <code>避免占用内存 </code>，提高内存利用率。</p>
<p><code>唯一索引的更新就不能使用change buffer</code> ，实际上也只有普通索引可以使用。</p>
<h4 id="change-buffer的使用场景"><a href="#change-buffer的使用场景" class="headerlink" title="change buffer的使用场景"></a>change buffer的使用场景</h4><ol>
<li>普通索引和唯一索引应该怎么选择？其实，这两类索引在查询能力上是没差别的，主要考虑的是 对 更新性能 的影响。所以，建议你 尽量选择普通索引 。</li>
<li>在实际使用中会发现， 普通索引 和 change buffer 的配合使用，对于 数据量大 的表的更新优化 还是很明显的。</li>
<li>如果所有的更新后面，都马上 伴随着对这个记录的查询 ，那么你应该 关闭change buffer 。而在 其他情况下，change buffer都能提升更新性能。</li>
<li>由于唯一索引用不上change buffer的优化机制，因此如果 业务可以接受 ，从性能角度出发建议优 先考虑非唯一索引。但是如果”业务可能无法确保”的情况下，怎么处理呢？<ul>
<li>首先， 业务正确性优先 。我们的前提是“业务代码已经保证不会写入重复数据”的情况下，讨论性能 问题。如果业务不能保证，或者业务就是要求数据库来做约束，那么没得选，必须创建唯一索引。 这种情况下，本节的意义在于，如果碰上了大量插入数据慢、内存命中率低的时候，给你多提供一 个排查思路。</li>
<li>然后，在一些“ 归档库 ”的场景，你是可以考虑使用唯一索引的。比如，线上数据只需要保留半年， 然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。要提高归档效率， 可以考虑把表里面的唯一索引改成普通索引。</li>
</ul>
</li>
</ol>
<h3 id="其它查询优化策略"><a href="#其它查询优化策略" class="headerlink" title="其它查询优化策略"></a>其它查询优化策略</h3><h4 id="EXISTS-和-IN-的区分"><a href="#EXISTS-和-IN-的区分" class="headerlink" title="EXISTS 和 IN 的区分"></a>EXISTS 和 IN 的区分</h4><p><img src="image-20230726145628244.png" alt="image-20230726145628244"></p>
<h4 id="COUNT-与COUNT-具体字段-效率"><a href="#COUNT-与COUNT-具体字段-效率" class="headerlink" title="COUNT(*)与COUNT(具体字段)效率"></a>COUNT(*)与COUNT(具体字段)效率</h4><p><img src="image-20230726174542607.png" alt="image-20230726174542607"></p>
<h4 id="关于SELECT"><a href="#关于SELECT" class="headerlink" title="关于SELECT(*)"></a>关于SELECT(*)</h4><p>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT &lt;字段列表&gt; 查询。原因：</p>
<p>① MySQL 在解析的过程中，会通过查询数据字典 将”*”按序转换成所有列名，这会大大的耗费资源和时间。</p>
<p>② 无法使用 覆盖索</p>
<h4 id="LIMIT-1-对优化的影响"><a href="#LIMIT-1-对优化的影响" class="headerlink" title="LIMIT 1 对优化的影响"></a>LIMIT 1 对优化的影响</h4><p>针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上 LIMIT 1 的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p>
<p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上 LIMIT 1 了。</p>
<h4 id="多使用COMMIT"><a href="#多使用COMMIT" class="headerlink" title="多使用COMMIT"></a>多使用COMMIT</h4><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放 的资源而减少。</p>
<p>COMMIT 所释放的资源：</p>
<ul>
<li>回滚段上用于恢复数据的信息</li>
<li>被程序语句获得的锁</li>
<li>redo &#x2F; undo log buffer 中的空间</li>
<li>管理上述 3 种资源中的内部花费</li>
</ul>
<h3 id="淘宝数据库，主键如何设计的？"><a href="#淘宝数据库，主键如何设计的？" class="headerlink" title="淘宝数据库，主键如何设计的？"></a>淘宝数据库，主键如何设计的？</h3><h4 id="自增ID的问题"><a href="#自增ID的问题" class="headerlink" title="自增ID的问题"></a>自增ID的问题</h4><p>自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除 了简单，其他都是缺点，总体来看存在以下几方面的问题：</p>
<ol>
<li><p><strong>可靠性不高</strong></p>
<p>存在自增ID回溯的问题，这个问题直到最新版本的MySQL 8.0才修复。</p>
</li>
<li><p>**安全性不高 **</p>
<p>对外暴露的接口可以非常容易猜测对应的信息。比如：&#x2F;User&#x2F;1&#x2F;这样的接口，可以非常容易猜测用户ID的 值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。</p>
</li>
<li><p><strong>性能差</strong></p>
<p>自增ID的性能较差，需要在数据库服务器端生成。</p>
</li>
<li><p><strong>交互多</strong></p>
<p>业务还需要额外执行一次类似 last_insert_id() 的函数才能知道刚才插入的自增值，这需要多一次的 网络交互。在海量并发的系统中，多1条SQL，就多一次性能上的开销。</p>
</li>
<li><p>**局部唯一性 **</p>
<p>最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都 是唯一的。对于目前分布式系统来说，这简直就是噩梦。</p>
</li>
</ol>
<h4 id="业务字段做主键"><a href="#业务字段做主键" class="headerlink" title="业务字段做主键"></a>业务字段做主键</h4><p>为了能够唯一地标识一个会员的信息，需要为 会员信息表 设置一个主键。那么，怎么为这个表设置主 键，才能达到我们理想的目标呢？ 这里我们考虑业务字段做主键。</p>
<p>表数据如下：</p>
<p><img src="image-20230728142608606.png" alt="image-20230728142608606"></p>
<p>在这个表里，哪个字段比较合适呢？</p>
<ul>
<li><strong>选择卡号（cardno）</strong></li>
</ul>
<p>会员卡号（cardno）看起来比较合适，因为会员卡号不能为空，而且有唯一性，可以用来 标识一条会员 记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo.membermaster</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> (</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> cardno <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">PRIMARY</span> KEY, <span class="comment">-- 会员卡号为主键</span></span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> membername TEXT,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> memberphone TEXT,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> memberpid TEXT,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> memberaddress TEXT,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> sex TEXT,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> birthday DATETIME</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> );</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.06</span> sec)</span><br></pre></td></tr></table></figure>

<p>不同的会员卡号对应不同的会员，字段“cardno”唯一地标识某一个会员。如果都是这样，会员卡号与会 员一一对应，系统是可以正常运行的。</p>
<p>但实际情况是， 会员卡号可能存在重复使用 的情况。比如，张三因为工作变动搬离了原来的地址，不再 到商家的门店消费了 （退还了会员卡），于是张三就不再是这个商家门店的会员了。但是，商家不想让 这个会 员卡空着，就把卡号是“10000001”的会员卡发给了王五。</p>
<p>从系统设计的角度看，这个变化只是修改了会员信息表中的卡号是“10000001”这个会员 信息，并不会影 响到数据一致性。也就是说，修改会员卡号是“10000001”的会员信息， 系统的各个模块，都会获取到修 改后的会员信息，不会出现“有的模块获取到修改之前的会员信息，有的模块获取到修改后的会员信息， 而导致系统内部数据不一致”的情况。因此，从 信息系统层面 上看是没问题的。</p>
<p>但是从使用 系统的业务层面 来看，就有很大的问题 了，会对商家造成影响。</p>
<p>比如，我们有一个销售流水表（trans），记录了所有的销售流水明细。2020 年 12 月 01 日，张三在门店 购买了一本书，消费了 89 元。那么，系统中就有了张三买书的流水记录，如下所示：</p>
<p><img src="image-20230728142712172.png" alt="image-20230728142712172"></p>
<p>接着，我们查询一下 2020 年 12 月 01 日的会员销售记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> b.membername,c.goodsname,a.quantity,a.salesvalue,a.transdate</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> demo.trans <span class="keyword">AS</span> a</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">JOIN</span> demo.membermaster <span class="keyword">AS</span> b</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">JOIN</span> demo.goodsmaster <span class="keyword">AS</span> c</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> (a.cardno <span class="operator">=</span> b.cardno <span class="keyword">AND</span> a.itemnumber<span class="operator">=</span>c.itemnumber);</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> membername <span class="operator">|</span> goodsname <span class="operator">|</span> quantity <span class="operator">|</span> salesvalue <span class="operator">|</span> transdate <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span>     张三   <span class="operator">|</span> 书         <span class="operator">|</span> <span class="number">1.000</span>    <span class="operator">|</span> <span class="number">89.00</span>      <span class="operator">|</span> <span class="number">2020</span><span class="number">-12</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>如果会员卡“10000001”又发给了王五，我们会更改会员信息表。导致查询时：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> b.membername,c.goodsname,a.quantity,a.salesvalue,a.transdate</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> demo.trans <span class="keyword">AS</span> a</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">JOIN</span> demo.membermaster <span class="keyword">AS</span> b</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">JOIN</span> demo.goodsmaster <span class="keyword">AS</span> c</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> (a.cardno <span class="operator">=</span> b.cardno <span class="keyword">AND</span> a.itemnumber<span class="operator">=</span>c.itemnumber);</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> membername <span class="operator">|</span> goodsname <span class="operator">|</span> quantity <span class="operator">|</span> salesvalue <span class="operator">|</span> transdate <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> 王五        <span class="operator">|</span> 书        <span class="operator">|</span> <span class="number">1.000</span>    <span class="operator">|</span> <span class="number">89.00</span>      <span class="operator">|</span> <span class="number">2020</span><span class="number">-12</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>这次得到的结果是：王五在 2020 年 12 月 01 日，买了一本书，消费 89 元。显然是错误的！结论：千万 不能把会员卡号当做主键。</p>
<ul>
<li><strong>选择会员电话 或 身份证号</strong></li>
</ul>
<p>会员电话可以做主键吗？不行的。在实际操作中，手机号也存在 被运营商收回 ，重新发给别人用的情况。</p>
<p>那身份证号行不行呢？好像可以。因为身份证决不会重复，身份证号与一个人存在一一对 应的关系。可 问题是，身份证号属于 个人隐私 ，顾客不一定愿意给你。要是强制要求会员必须登记身份证号，会把很 多客人赶跑的。其实，客户电话也有这个问题，这也是我们在设计会员信息表的时候，允许身份证号和 电话都为空的原因。</p>
<p><strong>所以，建议尽量不要用跟业务有关的字段做主键。毕竟，作为项目设计的技术人员，我们谁也无法预测 在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现。</strong></p>
<blockquote>
<p>经验： 刚开始使用 MySQL 时，很多人都很容易犯的错误是喜欢用业务字段做主键，想当然地认为了解业 务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高。</p>
</blockquote>
<h4 id="推荐的主键设计"><a href="#推荐的主键设计" class="headerlink" title="推荐的主键设计"></a>推荐的主键设计</h4><p><strong>非核心业务</strong> ：对应表的主键自增ID，如告警、日志、监控等信息。</p>
<p><strong>核心业务</strong> ：<code>主键设计至少应该是全局唯一且是单调递增</code>。全局唯一保证在各系统之间都是唯一的，单调 递增是希望插入时不影响数据库性能。</p>
<p>这里推荐最简单的一种主键设计：UUID。</p>
<p><strong>UUID的特点：</strong></p>
<p>全局唯一，占用36字节，数据无序，插入性能差。</p>
<p><strong>认识UUID：</strong></p>
<ul>
<li>为什么UUID是全局唯一的？</li>
<li>为什么UUID占用36个字节？</li>
<li>为什么UUID是无序的？</li>
</ul>
<p>MySQL数据库的UUID组成如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UUID = 时间+UUID版本（16字节）- 时钟序列（4字节） - MAC地址（12字节）</span><br></pre></td></tr></table></figure>

<p>我们以UUID值e0ea12d4-6473-11eb-943c-00155dbaa39d举例：</p>
<p><img src="image-20230728142908005.png" alt="image-20230728142908005"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为什么UUID是全局唯一的？</span><br></pre></td></tr></table></figure>

<p>在UUID中时间部分占用60位，存储的类似TIMESTAMP的时间戳，但表示的是从1582-10-15 00：00：00.00 到现在的100ns的计数。可以看到UUID存储的时间精度比TIMESTAMPE更高，时间维度发生重复的概率降 低到1&#x2F;100ns。</p>
<p>时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC地址用于全局唯一。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为什么UUID占用36个字节？</span><br></pre></td></tr></table></figure>

<p>UUID根据字符串进行存储，设计时还带有无用”-“字符串，因此总共需要36个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为什么UUID是随机无序的呢？</span><br></pre></td></tr></table></figure>

<p>因为UUID的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。</p>
<p><strong>改造UUID</strong></p>
<p>若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MySQL 8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。</p>
<p>MySQL 8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的”-“字符串，并且将字符串用二进制类型保存，这样存储空间降低为了16字节。</p>
<p>可以通过MySQL8.0提供的uuid_to_bin函数实现上述功能，同样的，MySQL也提供了bin_to_uuid函数进行转化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @uuid = UUID();</span><br><span class="line">SELECT @uuid,uuid_to_bin(@uuid),uuid_to_bin(@uuid,TRUE);</span><br></pre></td></tr></table></figure>

<p><img src="image-20230728142943472.png" alt="image-20230728142943472"></p>
<p><strong>通过函数uuid_to_bin(@uuid,true)将UUID转化为有序UUID了</strong>。全局唯一 + 单调递增，这不就是我们想要的主键！</p>
<p><strong>有序UUID性能测试</strong></p>
<p>16字节的有序UUID，相比之前8字节的自增ID，性能和存储空间对比究竟如何呢？</p>
<p>我们来做一个测试，插入1亿条数据，每条数据占用500字节，含有3个二级索引，最终的结果如下所示：</p>
<p><img src="image-20230728143001825.png" alt="image-20230728143001825"></p>
<p>从上图可以看到插入1亿条数据有序UUID是最快的，而且在实际业务使用中有序UUID在 <code>业务端就可以生成</code> 。还可以进一步减少SQL的交互次数。</p>
<p>另外，虽然有序UUID相比自增ID多了8个字节，但实际只增大了3G的存储空间，还可以接受。</p>
<blockquote>
<p>在当今的互联网环境中，非常不推荐自增ID作为主键的数据库设计。更推荐类似有序UUID的全局 唯一的实现。</p>
<p>另外在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。这样 的主键设计就更为考验架构师的水平了。</p>
</blockquote>
<p><strong>如果不是MySQL8.0 肿么办？</strong></p>
<p>手动赋值字段做主键！</p>
<p>比如，设计各个分店的会员表的主键，因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题。</p>
<p>可以在总部 MySQL 数据库中，有一个管理信息表，在这个表中添加一个字段，专门用来记录当前会员编号的最大值。</p>
<p>门店在添加会员的时候，先到总部 MySQL 数据库中获取这个最大值，在这个基础上加 1，然后用这个值 作为新会员的“id”，同时，更新总部 MySQL 数据库管理信息表中的当前会员编号的最大值。</p>
<p>这样一来，各个门店添加会员的时候，都对同一个总部 MySQL 数据库中的数据表字段进行操作，就解 决了各门店添加会员时会员编号冲突的问题。</p>
<h2 id="数据库的设计规范"><a href="#数据库的设计规范" class="headerlink" title="数据库的设计规范"></a>数据库的设计规范</h2><h3 id="为什么需要数据库设计"><a href="#为什么需要数据库设计" class="headerlink" title="为什么需要数据库设计"></a>为什么需要数据库设计</h3><p><img src="image-20230728143132063.png" alt="image-20230728143132063"></p>
<h3 id="范-式"><a href="#范-式" class="headerlink" title="范 式"></a>范 式</h3><h4 id="范式简介"><a href="#范式简介" class="headerlink" title="范式简介"></a>范式简介</h4><p>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。可以理解为，一张数据表的设计结 构需要满足的某种设计标准的 级别 。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p>
<h4 id="范式都包括哪些"><a href="#范式都包括哪些" class="headerlink" title="范式都包括哪些"></a>范式都包括哪些</h4><p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式 （2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</p>
<p>数据库的范式设计越高阶，夯余度就越低，同时高阶的范式一定符合低阶范式的要求，满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范的要求称为第二范式（2NF），其余范式以此类推。</p>
<p>一般来说，在关系型数据库设计中，最高也就遵循到<code>BCNF</code>, 普遍还是<code>3NF</code>。但也不绝对，有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是<code>反规范化</code>。</p>
<p><img src="image-20230728143252520.png" alt="image-20230728143252520"></p>
<h4 id="键和相关属性的概念"><a href="#键和相关属性的概念" class="headerlink" title="键和相关属性的概念"></a>键和相关属性的概念</h4><p><img src="image-20230728143330716-1690526011905-1.png" alt="image-20230728143330716"></p>
<p><strong>举例:</strong></p>
<p>这里有两个表：</p>
<p><code>球员表(player)</code> ：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号</p>
<p><code>球队表(team) </code>：球队编号 | 主教练 | 球队所在地</p>
<ul>
<li>超键 ：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号） （球员编号，姓名）（身份证号，年龄）等。</li>
<li>候选键 ：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。</li>
<li>主键 ：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。</li>
<li>外键 ：球员表中的球队编号。</li>
<li>主属性 、 非主属性 ：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名） （年龄）（球队编号）都是非主属性。</li>
</ul>
<h4 id="第一范式-1st-NF"><a href="#第一范式-1st-NF" class="headerlink" title="第一范式(1st NF)"></a>第一范式(1st NF)</h4><p>第一范式主要确保数据库中每个字段的值必须具有<code>原子性</code>，也就是说数据表中每个字段的值为<code>不可再次拆分</code>的最小数据单元。</p>
<p>我们在设计某个字段的时候，对于字段X来说，不能把字段X拆分成字段X-1和字段X-2。事实上，任何的DBMS都会满足第一范式的要求，不会将字段进行拆分。</p>
<h4 id="第二范式-2nd-NF"><a href="#第二范式-2nd-NF" class="headerlink" title="第二范式(2nd NF)"></a>第二范式(2nd NF)</h4><p>第二范式要求，在满足第一范式的基础上，还要<strong>满足数据库里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分</strong>。如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。（要求中的主键，其实可以扩展替换为候选键）。</p>
<h4 id="第三范式-3rd-NF"><a href="#第三范式-3rd-NF" class="headerlink" title="第三范式(3rd NF)"></a>第三范式(3rd NF)</h4><p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，<strong>要求数据表中的所有非主键字段不能依赖于其他非主键字段</strong>。（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在“A-&gt;B-&gt;C”的决定关系）通俗地讲，该规则的意思是所有<code>非主键属性</code>之间不能由依赖关系，必须<code>相互独立</code>。</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p><img src="image-20230728153559784.png" alt="image-20230728153559784"></p>
<h3 id="反范式化"><a href="#反范式化" class="headerlink" title="反范式化"></a>反范式化</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><img src="image-20230728153651374.png" alt="image-20230728153651374"></p>
<p><strong>规范化 vs 性能</strong></p>
<blockquote>
<ol>
<li>为满足某种商业目标 , 数据库性能比规范化数据库更重要</li>
<li>在数据规范化的同时 , 要综合考虑数据库的性能</li>
<li>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间</li>
<li>通过在给定的表中插入计算列，以方便查询</li>
</ol>
</blockquote>
<h4 id="反范式的新问题"><a href="#反范式的新问题" class="headerlink" title="反范式的新问题"></a>反范式的新问题</h4><ul>
<li>存储 空间变大了</li>
<li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则 数据不一致</li>
<li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常 消耗系统资源</li>
<li>在 数据量小 的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加复杂</li>
</ul>
<h4 id="反范式的适用场景"><a href="#反范式的适用场景" class="headerlink" title="反范式的适用场景"></a>反范式的适用场景</h4><p>当冗余信息有价值或者能 <code>大幅度提高查询效率</code> 的时候，我们才会采取反范式的优化。</p>
<h5 id="1-增加冗余字段的建议"><a href="#1-增加冗余字段的建议" class="headerlink" title="1. 增加冗余字段的建议"></a>1. 增加冗余字段的建议</h5><p>增加冗余字段一定要符合如下两个条件。只要满足这两个条件，才可以考虑增加夯余字段。</p>
<p>1）这个冗余字段<code>不需要经常进行修改</code>。</p>
<p>2）这个冗余字段<code>查询的时候不可或缺</code>。</p>
<h5 id="2-历史快照、历史数据的需要"><a href="#2-历史快照、历史数据的需要" class="headerlink" title="2. 历史快照、历史数据的需要"></a>2. 历史快照、历史数据的需要</h5><p>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每 次发生的 <code>订单收货信息</code> 都属于 <code>历史快照</code> ，需要进行保存，但用户可以随时修改自己的信息，这时保存这 些冗余信息是非常有必要的。</p>
<p>反范式优化也常用在 <code>数据仓库</code> 的设计中，因为数据仓库通常<code>存储历史数据</code> ，对增删改的实时性要求不 强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p>
<p>我简单总结下数据仓库和数据库在使用上的区别：</p>
<ol>
<li>数据库设计的目的在于<code>捕捉数据</code>，而数据仓库设计的目的在于<code>分析数据</code>。</li>
<li>数据库对数据的<code>增删改实时性</code>要求强，需要存储在线的用户数据，而数据仓库存储的一般是<code>历史数据</code>。</li>
<li>数据库设计需要<code>尽量避免冗余</code>，但为了提高查询效率也允许一定的<code>冗余度</code>，而数据仓库在设计上更偏向采用反范式设计，</li>
</ol>
<h3 id="BCNF-巴斯范式"><a href="#BCNF-巴斯范式" class="headerlink" title="BCNF(巴斯范式)"></a>BCNF(巴斯范式)</h3><p>人们在3NF的基础上进行了改进，提出了巴斯范式（BCNF），页脚巴斯 - 科德范式（Boyce - Codd Normal Form）。BCNF被认为没有新的设计规范加入，只是对第三范式中设计规范要求更强，使得数据库冗余度更小。所以，称为是<code>修正的第三范式</code>，或<code>扩充的第三范式</code>，BCNF不被称为第四范式。</p>
<h3 id="第四范式"><a href="#第四范式" class="headerlink" title="第四范式"></a>第四范式</h3><p>多值依赖的概念：</p>
<ul>
<li><code>多值依赖</code>即属性之间的一对多关系，记为K—&gt;—&gt;A。</li>
<li><code>函数依赖</code>事实上是单值依赖，所以不能表达属性值之间的一对多关系。</li>
<li><code>平凡的多值依赖</code>：全集U&#x3D;K+A，一个K可以对应于多个A，即K—&gt;—&gt;A。此时整个表就是一组一对多关系。</li>
<li><code>非平凡的多值依赖</code>：全集U&#x3D;K+A+B，一个K可以对应于多个A，也可以对应于多个B，A与B相互独立，即K—&gt;—&gt;A，K—&gt;—&gt;B。整个表有多组一对多关系，且有：”一”部分是相同的属性集合，“多”部分是相互独立的属性集合。</li>
</ul>
<p>第四范式即在满足巴斯 - 科德范式（BCNF）的基础上，消除非平凡且非函数依赖的多值依赖（即把同一表的多对多关系删除）。</p>
<h3 id="第五范式、域键范式"><a href="#第五范式、域键范式" class="headerlink" title="第五范式、域键范式"></a>第五范式、域键范式</h3><p>除了第四范式外，我们还有更高级的第五范式（又称完美范式）和域键范式（DKNF）。</p>
<p>在满足第四范式（4NF）的基础上，消除不是由候选键所蕴含的连接依赖。<strong>如果关系模式R中的每一个连 接依赖均由R的候选键所隐含</strong>，则称此关系模式符合第五范式。</p>
<p>函数依赖是多值依赖的一种特殊的情况，而多值依赖实际上是连接依赖的一种特殊情况。但连接依赖不 像函数依赖和多值依赖可以由 <code>语义直接导出</code> ，而是在 <code>关系连接运算</code> 时才反映出来。存在连接依赖的关系 模式仍可能遇到数据冗余及插入、修改、删除异常等问题。</p>
<p>第五范式处理的是 <code>无损连接问题</code> ，这个范式基本 <code>没有实际意义</code> ，因为无损连接很少出现，而且难以察觉。而域键范式试图定义一个 <code>终极范式</code> ，该范式考虑所有的依赖和约束类型，但是实用价值也是最小的，只存在理论研究中。</p>
<h3 id="ER模型"><a href="#ER模型" class="headerlink" title="ER模型"></a>ER模型</h3><p><img src="image-20230728164420172.png" alt="image-20230728164420172"></p>
<h4 id="ER模型包括哪些要素？"><a href="#ER模型包括哪些要素？" class="headerlink" title="ER模型包括哪些要素？"></a>ER模型包括哪些要素？</h4><p><strong>ER 模型中有三个要素，分别是实体、属性和关系。</strong></p>
<p><code>实体</code> ，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用 矩形 来表 示。实体分为两类，分别是 强实体 和 弱实体 。强实体是指不依赖于其他实体的实体；弱实体是指对另 一个实体有很强的依赖关系的实体。</p>
<p><code>属性</code> ，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用 椭圆形 来表示。</p>
<p><code>关系</code> ，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模 型中用 菱形 来表示。</p>
<p>注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，<strong>可以独立存在的是实体，不可再分的是属性</strong>。也就是说，属性不能包含其他属性。</p>
<h4 id="关系的类型"><a href="#关系的类型" class="headerlink" title="关系的类型"></a>关系的类型</h4><p>在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是 一对一、一对多、多对多。</p>
<p><code>一对一</code> ：指实体之间的关系是一一对应的，比如个人与身份证信息之间的关系就是一对一的关系。一个人只能有一个身份证信息，一个身份证信息也只属于一个人。</p>
<p><code>一对多</code> ：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体。比如说，我们新建一个班级表，而每个班级都有多个学生，每个学 生则对应一个班级，班级对学生就是一对多的关系。</p>
<p><code>多对多</code> ：指关系两边的实体都可以通过关系对应多个对方的实体。比如在进货模块中，供货商与超市之 间的关系就是多对多的关系，一个供货商可以给多个超市供货，一个超市也可以从多个供货商那里采购 商品。再比如一个选课表，有许多科目，每个科目有很多学生选，而每个学生又可以选择多个科目，这 就是多对多的关系。</p>
<h4 id="建模分析"><a href="#建模分析" class="headerlink" title="建模分析"></a>建模分析</h4><p>ER 模型看起来比较麻烦，但是对我们把控项目整体非常重要。如果你只是开发一个小应用，或许简单设 计几个表够用了，一旦要设计有一定规模的应用，在项目的初始阶段，建立完整的 ER 模型就非常关键 了。开发应用项目的实质，其实就是 建模 。</p>
<h3 id="数据表的设计原则"><a href="#数据表的设计原则" class="headerlink" title="数据表的设计原则"></a>数据表的设计原则</h3><p>综合以上内容，总结出数据表设计的一般原则：”三少一多”</p>
<p><strong>1. 数据表的个数越少越好</strong></p>
<p><img src="image-20230731133244497.png" alt="image-20230731133244497"></p>
<p><strong>2. 数据表中的字段个数越少越好</strong></p>
<p><img src="image-20230731133303415.png" alt="image-20230731133303415"></p>
<p><strong>3. 数据表中联合主键的字段个数越少越好</strong></p>
<p><img src="image-20230731133319904.png" alt="image-20230731133319904"></p>
<p><strong>4. 使用主键和外键越多越好</strong></p>
<p><img src="image-20230731133336238.png" alt="image-20230731133336238"></p>
<h3 id="数据库对象编写建议"><a href="#数据库对象编写建议" class="headerlink" title="数据库对象编写建议"></a>数据库对象编写建议</h3><h4 id="关于库"><a href="#关于库" class="headerlink" title="关于库"></a>关于库</h4><ol>
<li>【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字 母开头。</li>
<li>【强制】库名中英文 一律小写 ，不同单词采用 下划线 分割。须见名知意。</li>
<li>【强制】库的名称格式：业务系统名称_子系统名。</li>
<li>【强制】库名禁止使用关键字（如type,order等）。</li>
<li>【强制】创建数据库时必须 显式指定字符集 ，并且字符集只能是utf8或者utf8mb4。 创建数据库SQL举例：CREATE DATABASE crm_fund DEFAULT CHARACTER SET ‘utf8’ ;</li>
<li>【建议】对于程序连接数据库账号，遵循 权限最小原则 使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号 原则上不准有drop权限 。</li>
<li>【建议】临时库以 tmp_ 为前缀，并以日期为后缀； 备份库以 bak_ 为前缀，并以日期为后缀。</li>
</ol>
<h4 id="关于表、列"><a href="#关于表、列" class="headerlink" title="关于表、列"></a>关于表、列</h4><ol>
<li><p>【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议 以 英文字母开头 。</p>
</li>
<li><p>【强制】 表名、列名一律小写 ，不同单词采用下划线分割。须见名知意。</p>
</li>
<li><p>【强制】表名要求有模块名强相关，同一模块的表名尽量使用 统一前缀 。比如：crm_fund_item</p>
</li>
<li><p>【强制】创建表时必须 显式指定字符集 为utf8或utf8mb4。</p>
</li>
<li><p>【强制】表名、列名禁止使用关键字（如type,order等）。</p>
</li>
<li><p>【强制】创建表时必须 显式指定表存储引擎 类型。如无特殊需求，一律为InnoDB。</p>
</li>
<li><p>【强制】建表必须有comment。</p>
</li>
<li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或 缩写 。如：公司 ID，不要使用 corporation_id, 而用corp_id 即可。</p>
</li>
<li><p>【强制】布尔值类型的字段命名为 is_描述 。如member表上表示是否为enabled的会员的字段命 名为 is_enabled。</p>
</li>
<li><p>【强制】禁止在数据库中存储图片、文件等大的二进制数据 通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随 机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。</p>
</li>
<li><p>【建议】建表时关于主键： 表必须有主键</p>
<p>(1)强制要求主键为id，类型为int或bigint，且为 auto_increment 建议使用unsigned无符号型。</p>
<p>(2)标识表里每一行主体的字段不要设为主键，建议 设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机 插入，则会导致innodb内部页分裂和大量随机I&#x2F;O，性能下降。</p>
</li>
<li><p>【建议】核心表（如用户表）必须有行数据的 创建时间字段 （create_time）和 最后更新时间字段 （update_time），便于查问题。</p>
</li>
<li><p>【建议】表中所有字段尽量都是 NOT NULL 属性，业务可以根据需要定义 DEFAULT值 。 因为使用 NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问 题。</p>
</li>
<li><p>【建议】所有存储相同数据的 列名和列类型必须一致 （一般作为关联列，如果查询时关联列类型 不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。</p>
</li>
<li><p>【建议】中间表（或临时表）用于保留中间结果集，名称以 tmp_ 开头。 备份表用于备份或抓取源表快照，名称以 bak_ 开头。中间表和备份表定期清理。 </p>
</li>
<li><p>【示范】一个较为规范的建表语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE user_info (</span><br><span class="line">`id` int unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增主键&#x27;,</span><br><span class="line">`user_id` bigint(11) NOT NULL COMMENT &#x27;用户id&#x27;,</span><br><span class="line">`username` varchar(45) NOT NULL COMMENT &#x27;真实姓名&#x27;,</span><br><span class="line">`email` varchar(30) NOT NULL COMMENT &#x27;用户邮箱&#x27;,</span><br><span class="line">`nickname` varchar(45) NOT NULL COMMENT &#x27;昵称&#x27;,</span><br><span class="line">`birthday` date NOT NULL COMMENT &#x27;生日&#x27;,</span><br><span class="line">`sex` tinyint(4) DEFAULT &#x27;0&#x27; COMMENT &#x27;性别&#x27;,</span><br><span class="line">`short_introduce` varchar(150) DEFAULT NULL COMMENT &#x27;一句话介绍自己，最多50个汉字&#x27;,</span><br><span class="line">`user_resume` varchar(300) NOT NULL COMMENT &#x27;用户提交的简历存放地址&#x27;,</span><br><span class="line">`user_register_ip` int NOT NULL COMMENT &#x27;用户注册时的源ip&#x27;,</span><br><span class="line">`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE</span><br><span class="line">CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">`user_review_status` tinyint NOT NULL COMMENT &#x27;用户资料审核状态，1为通过，2为审核中，3为未</span><br><span class="line">通过，4为还未提交审核&#x27;,</span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">UNIQUE KEY `uniq_user_id` (`user_id`),</span><br><span class="line">KEY `idx_username`(`username`),</span><br><span class="line">KEY `idx_create_time_status`(`create_time`,`user_review_status`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;网站用户基本信息</span><br></pre></td></tr></table></figure>
</li>
<li><p>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。</p>
<p>实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。</p>
<p>可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。</p>
</li>
</ol>
<h4 id="关于索引"><a href="#关于索引" class="headerlink" title="关于索引"></a>关于索引</h4><ol>
<li>【强制】InnoDB表必须主键为id int&#x2F;bigint auto_increment，且主键值 禁止被更新 。</li>
<li>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为 BTREE 。</li>
<li>【建议】主键的名称以 pk_ 开头，唯一键以 uni_ 或 uk_ 开头，普通索引以 idx_ 开头，一律使用小写格式，以字段的名称或缩写作为后缀。</li>
<li>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如: sample 表 member_id 上的索引：idx_sample_mid。</li>
<li>【建议】单个表上的索引个数 不能超过6个 。</li>
<li>【建议】在建立索引时，多考虑建立 联合索引 ，并把区分度最高的字段放在最前面。</li>
<li>【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。</li>
<li>【建议】建表或加索引时，保证表里互相不存在 冗余索引 。 比如：如果表里已经存在key(a,b)， 则key(a)为冗余索引，需要删除。</li>
</ol>
<h4 id="SQL编写"><a href="#SQL编写" class="headerlink" title="SQL编写"></a>SQL编写</h4><ol>
<li>【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。</li>
<li>【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。</li>
<li>【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。</li>
<li>【建议】INSERT INTO…VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很 快，但会引起主从同步延迟。</li>
<li>【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以 内。</li>
<li>【建议】线上环境，多表 JOIN 不要超过5个表。</li>
<li>【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li>
<li>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果 集请保持在1000行以内，否则SQL会很慢。</li>
<li>【建议】对单表的多次alter操作必须合并为一次 对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整 合在一起。 因为alter table会产生 表锁 ，期间阻塞对于该表的所有写入，对于业务可能会产生极 大影响。</li>
<li>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。</li>
<li>【建议】事务里包含SQL不超过5个。 因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</li>
<li>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id&#x3D;XX; 否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</li>
</ol>
<h3 id="PowerDesigner的使用"><a href="#PowerDesigner的使用" class="headerlink" title="PowerDesigner的使用"></a>PowerDesigner的使用</h3><h2 id="数据库其它调优策略"><a href="#数据库其它调优策略" class="headerlink" title="数据库其它调优策略"></a>数据库其它调优策略</h2><h3 id="数据库调优的措施"><a href="#数据库调优的措施" class="headerlink" title="数据库调优的措施"></a>数据库调优的措施</h3><h4 id="调优的目标"><a href="#调优的目标" class="headerlink" title="调优的目标"></a>调优的目标</h4><ul>
<li>尽可能节省系统资源 ，以便系统可以提供更大负荷的服务。（吞吐量更大）</li>
<li>合理的结构设计和参数调整，以提高用户操作响应的速度 。（响应速度更快）</li>
<li>减少系统的瓶颈，提高MySQL数据库整体的性能。</li>
</ul>
<h4 id="如何定位调优问题"><a href="#如何定位调优问题" class="headerlink" title="如何定位调优问题"></a>如何定位调优问题</h4><p><img src="image-20230731134556472.png" alt="image-20230731134556472"></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>调优</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2022/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">线性结构分为两种数据存储方式，一种是顺序存储，一种链式存储</span><br></pre></td></tr></table></figure>

<h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><p><strong>API设计</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>SequenceList</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>SequenceList(int capacity)：创建容量为capacity的SequenceList对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public void clear()：空置对象<br>2.public boolean isEmpty()：判断线性表是否为空，是返回true，否返回false<br>3.public int length():获取线性表中元素的个数<br>4.public T get(int i):读取并返回线性表中的第i个元素的值<br>5.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。<br>6.public void insert(T t):向线性表中添加一个元素t<br>7.public T remove(int i):删除并返回线性表中第i个数据元素。<br>8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回1</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] eles：存储元素的数组<br>2.private int N:当前线性表的长度</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 顺序数据结果实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-12-18</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequenceList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> T[] eles;</span><br><span class="line">    <span class="comment">//当前线性表长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SequenceList</span><span class="params">(<span class="type">int</span> capcity)</span>&#123;</span><br><span class="line">        eles = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capcity];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空置对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断线性表是否为空，是返回true，否返回false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取线性表中元素的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取并返回线性表中的第i个元素的值</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;当前元素不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eles[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在线性表的第i个元素之前插入一个值为t的数据元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> i,T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;插入位置不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(N== eles.length)&#123;</span><br><span class="line">            resize(<span class="number">2</span>*N);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把i位置空出来，i位置及其后面元素一次后移一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N;index&gt;i;index--)&#123;</span><br><span class="line">            eles[index] = eles[index-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把i位置赋值</span></span><br><span class="line">        eles[i] = t;</span><br><span class="line">        <span class="comment">//数量加1</span></span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向线性表中添加一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N== eles.length)&#123;</span><br><span class="line">            resize(<span class="number">2</span>*N);</span><br><span class="line">        &#125;</span><br><span class="line">        eles[N++] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除并返回线性表中第i个数据元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">remove</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;插入位置不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录i位置元素</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> eles[i];</span><br><span class="line">        <span class="comment">//i位置后面的元素都向前一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> index=i;index&lt;N-<span class="number">1</span>;index++)&#123;</span><br><span class="line">            eles[index] = eles[index+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前元素数量-1</span></span><br><span class="line">        N--;</span><br><span class="line">        <span class="comment">//当元素已经不足数组大小的1/4,则重置数组的大小</span></span><br><span class="line">        <span class="keyword">if</span> (N&gt;<span class="number">0</span>&amp;&amp;N&lt; eles.length/<span class="number">4</span>)&#123;</span><br><span class="line">            resize(eles.length/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;查找元素不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eles[i].equals(t))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> cur;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SIterator</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.cur=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cur&lt;N;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> eles[cur++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现扩容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newSize)</span>&#123;</span><br><span class="line">        T[] temp = eles;</span><br><span class="line">        eles = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[newSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            eles[i]=temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取数组长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> eles.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h5 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h5><p>单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据，</p>
<p>指针域用来指向其后继结点。链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。</p>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>LinkList</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>LinkList()：创建LinkList对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public void clear()：空置链表 <br>2.public boolean isEmpty()：判断线性表是否为空，是返回true，否返回false<br>3.public int length():获取线性表中元素的个数<br>4.public T get(int i):读取并返回线性表中的第i个元素的值<br>5.public void insert(T t)：往线性表中添加一个元素；<br>6.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。<br>7.public T remove(int i):删除并返回线性表中第i个数据元素。<br>8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1</td>
</tr>
<tr>
<td>成员内部类</td>
<td>private class Node:结点类</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node head:记录首结点<br>2.private int N:记录链表的长度</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.dc.pr.PRError;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 单向链表API实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-12-29</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkList</span><span class="params">()</span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空置链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">        head.next=<span class="literal">null</span>;</span><br><span class="line">        head.item=<span class="literal">null</span>;</span><br><span class="line">        N=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断线性表是否为空，是返回true，否返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N==<span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取线性表中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;位置不合法！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往线性表中添加一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//找到最后一个结点</span></span><br><span class="line">        <span class="keyword">while</span> (n.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建新结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t,<span class="literal">null</span>);</span><br><span class="line">        n.next = newNode;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在线性表的第i个元素之前插入一个值为t的数据元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> i,T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;位置不合法！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到i结点的上一个结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">//创建新结点并把next结点赋值为i结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t,temp);</span><br><span class="line">        <span class="comment">//将上个结点的next指向新结点</span></span><br><span class="line">        node.next = newNode;</span><br><span class="line">        <span class="comment">//数量加1</span></span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除并返回线性表中第i个数据元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">remove</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;位置不合法！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到i结点的上一个结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> node.next;</span><br><span class="line">        node.next=cur.next;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> cur.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; node.next!=<span class="literal">null</span>; i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="keyword">if</span> (t.equals(cur.item))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Node node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LIterator</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.node=head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node.next!=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            <span class="keyword">return</span> node.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结点类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T item;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T item, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = item;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><p>双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用</p>
<p>来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存</p>
<p>储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。</p>
<p><strong>结点API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Node</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(T t,Node pre,Node next)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>T item:存储数据<br>Node next：指向下一个结点<br>Node pre:指向上一个结点</td>
</tr>
</tbody></table>
<p><strong>双向链表API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>TwoWayLinkList</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>TwoWayLinkList()：创建TwoWayLinkList对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public void clear()：空置链表 <br>2.public boolean isEmpty()：判断线性表是否为空，是返回true，否返回false<br>3.public int length():获取线性表中元素的个数<br>4.public T get(int i):读取并返回线性表中的第i个元素的值<br>5.public void insert(T t)：往线性表中添加一个元素；<br>6.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。<br>7.public T remove(int i):删除并返回线性表中第i个数据元素。<br>8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1<br>9.public T getFirst():获取第一个元素<br>10.public T getLast():获取最后一个元素</td>
</tr>
<tr>
<td>成员内部类</td>
<td>private class Node:结点类</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node head:记录首结点<br>2.private Node last:记录尾结点<br>3.private int N:记录链表的长度</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 双向链表API实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-12-30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoWayLinkList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录首结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录尾结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录链表的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TwoWayLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空置链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">        head.next = last;</span><br><span class="line">        head.pre = <span class="literal">null</span>;</span><br><span class="line">        head.item = <span class="literal">null</span>;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断线性表是否为空，是返回true，否返回false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取线性表中元素的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取并返回线性表中的第i个元素的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;查找位置不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往线性表中添加一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (last==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果当前链表为空</span></span><br><span class="line">            <span class="comment">//直接将尾结点赋值，并将head和last连接</span></span><br><span class="line">            last = <span class="keyword">new</span> <span class="title class_">Node</span>(t,head,<span class="literal">null</span>);</span><br><span class="line">            head.next = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果链表尾结点存在值，创建新的结点连接到原尾结点，并将新结点赋值给尾结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">oldLastNode</span> <span class="operator">=</span> last;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t,oldLastNode,<span class="literal">null</span>);</span><br><span class="line">            oldLastNode.next = node;</span><br><span class="line">            last = node;</span><br><span class="line">        &#125;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在线性表的第i个元素之前插入一个值为t的数据元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> i,T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;查找位置不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先找到i结点前置结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到i结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="comment">//创建新结点，前置结点为原前置结点，后置结点为原i位置结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t,pre,cur);</span><br><span class="line">        <span class="comment">//原前置结点next指向新结点</span></span><br><span class="line">        pre.next = n;</span><br><span class="line">        <span class="comment">//原i结点前置指向n</span></span><br><span class="line">        cur.pre = n;</span><br><span class="line">        <span class="comment">//数量加1</span></span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除并返回线性表中第i个数据元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">remove</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;查找位置不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先找到i结点前置结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到i结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="comment">//找到i结点的后置结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        <span class="comment">//将前置结点和后置结点连接</span></span><br><span class="line">        pre.next = next;</span><br><span class="line">        next.pre = pre;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> cur.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; node.next!=<span class="literal">null</span> ; i++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            <span class="keyword">if</span> (node.item.equals(t))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取第一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取最后一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n.next!=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">            <span class="keyword">return</span> n.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 存储数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> T item;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 指向下一个结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Node pre;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 指向上一个结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T t,Node pre,Node next)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.item = t;</span><br><span class="line">            <span class="built_in">this</span>.pre = pre;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h5><p>使用递归方式实现链表的反转</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (N==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="comment">//当前列表为空，不需要反转</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       reverse(head.next);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Node <span class="title function_">reverse</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node.next==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="comment">//说明已经到最后一个结点，将头结点指向当前结点</span></span><br><span class="line">           head.next = node;</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//递归调用2反转方法</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> reverse(node.next);</span><br><span class="line">       <span class="comment">//将返回结点后置结点指向当前结点</span></span><br><span class="line">       pre.next = node;</span><br><span class="line">       <span class="comment">//当前结点后置结点置为null</span></span><br><span class="line">       node.next = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h5><p>快慢指针指的是定义两个指针，这两个指针的移动速度一块一慢，以此来制造出自己想要的差值，这个差值可以然</p>
<p>我们找到链表上相应的结点。一般情况下，快指针的移动步长为慢指针的两倍</p>
<p><strong>中间值问题</strong></p>
<p>定义一个链表，想获取中间值</p>
<p>使用快慢指针解决，定义两个指针，一个指针的步长为另一个指针的步长的二倍，当快指针到达尾部，慢指针停在的位置即为中间位置</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getMid</span><span class="params">(Node&lt;String&gt; first)</span>&#123;</span><br><span class="line">       Node&lt;String&gt; slow = first;</span><br><span class="line">       Node&lt;String&gt; fast = first;</span><br><span class="line">       <span class="keyword">while</span> (slow.next!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">           fast = fast.next.next;</span><br><span class="line">           slow = slow.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> slow.item;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>单向链表是否有环问题</strong></p>
<p>使用快慢指针，如果一个环状链表，两个速度有差异的指针一定会相遇</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCircle</span><span class="params">(Node&lt;String&gt; first)</span>&#123;</span><br><span class="line">    Node&lt;String&gt; slow = first;</span><br><span class="line">    Node&lt;String&gt; fast = first;</span><br><span class="line">    <span class="keyword">while</span> (slow.next!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        fast = first.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast.equals(slow))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>有环链表入口问题</strong></p>
<p>当快慢指针相遇时，我们可以判断到链表中有环，这时重新设定一个新指针指向链表的起点，且步长与慢指针一样</p>
<p>为1，则慢指针与“新”指针相遇的地方就是环的入口</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Node&lt;String&gt; <span class="title function_">getEntrance</span><span class="params">(Node&lt;String&gt; first)</span> &#123;</span><br><span class="line">    Node&lt;String&gt; slow = first;</span><br><span class="line">    Node&lt;String&gt; fast = first;</span><br><span class="line">    Node&lt;String&gt; temp = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">null</span> &amp;&amp; fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast.equals(slow))&#123;</span><br><span class="line">            temp = first;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp!=<span class="literal">null</span>)&#123;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">            <span class="keyword">if</span> (temp.equals(slow))&#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h5><p>循环链表，顾名思义，链表整体要形成一个圆环状。在单向链表中，最后一个节点的指针为null，不指向任何结</p>
<p>点，因为没有下一个元素了。要实现循环链表，我们只需要让单向链表的最后一个节点的指针指向头结点即可。</p>
<h5 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h5><p><strong>问题描述：</strong></p>
<p>传说有这样一个故事，在罗马人占领乔塔帕特后，39 个犹太人与约瑟夫及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，第一个人从1开始报数，依次后，如果有人报数到3，那么这个人就必须自杀，然后再由他的下一个人重新从1开始报数，直到所有人都自杀身亡为止。然而约瑟夫和他的朋友并不想遵从。于是，约瑟夫要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，从而逃过了这场死亡游戏 。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 约瑟夫经典问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-02</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Joseph</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//构建循环链表</span></span><br><span class="line">        Node&lt;Integer&gt; first = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//记录前一个结点</span></span><br><span class="line">        Node&lt;Integer&gt; pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">41</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//第一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">1</span>)&#123;</span><br><span class="line">                first = <span class="keyword">new</span> <span class="title class_">Node</span>(i,<span class="literal">null</span>);</span><br><span class="line">                pre = first;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Node&lt;Integer&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(i,<span class="literal">null</span>);</span><br><span class="line">            pre.next = node;</span><br><span class="line">            pre = node;</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">41</span>)&#123;</span><br><span class="line">                <span class="comment">//让最后一个结点指向第一个结点</span></span><br><span class="line">                pre.next = first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用count记录当前的报数值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历链表，没循环一次count++</span></span><br><span class="line">        Node&lt;Integer&gt; n = first;</span><br><span class="line">        Node&lt;Integer&gt; before = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (n!=n.next)&#123;</span><br><span class="line">            <span class="comment">//判断count的值，如果是3，则从链表中删除这个结点并打印，把count重置为0</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="comment">//删除当前结点</span></span><br><span class="line">                before.next = n.next;</span><br><span class="line">                System.out.println(n.item);</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                n = n.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                before = n;</span><br><span class="line">                n = n.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(n.item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈是一种基于先进后出(FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出</p>
<p>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一</p>
<p>个数据被第一个读出来）。</p>
<p><strong>链表实现栈API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>StackLink</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>StackLink()：创建StackLink对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false<br>2.public int size():获取栈中元素的个数<br>3.public T pop():弹出栈顶元素<br>4.public void push(T t)：向栈中压入元素t</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node head:记录首结点<br>2.private int N:记录链表的长度</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 栈API实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackLink</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录首结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前栈的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StackLink</span><span class="params">()</span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断栈是否为空，是返回true，否返回false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取栈中元素的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出栈顶元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">oldNode</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">if</span> (oldNode==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = head.next.next;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> oldNode.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向栈中压入元素t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">oldNode</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t,oldNode);</span><br><span class="line">        head.next = node;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StackIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">StackIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n.next!=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> n.next;</span><br><span class="line">            n = n.next;</span><br><span class="line">            <span class="keyword">return</span> node.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> T item;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T item, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = item;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组实现栈API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>StackArray</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>StackArray()：创建StackArray对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false<br>2.public int size():获取栈中元素的个数<br>3.public T pop():弹出栈顶元素<br>4.public void push(T t)：向栈中压入元素t</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] data:存储数据的顺序表<br>2.private int N:记录链表的长度</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 栈结构API数组实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackArray</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T[] data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StackArray</span><span class="params">(<span class="type">int</span> capcity)</span>&#123;</span><br><span class="line">        data = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capcity];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N&gt;=data.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈已满&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[N++] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> data[N-<span class="number">1</span>];</span><br><span class="line">        data[N-<span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StackIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> cur;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cur&lt;N;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data[cur++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两栈共享</strong></p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p><strong>括号匹配问题</strong></p>
<p><strong>问题描述：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">给定一个字符串，里边可能包含&quot;()&quot;小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。</span><br><span class="line">例如：</span><br><span class="line"><span class="code">    &quot;(上海)(长安)&quot;：正确匹配</span></span><br><span class="line"><span class="code">    &quot;上海((长安))&quot;：正确匹配</span></span><br><span class="line"><span class="code">    &quot;上海(长安(北京)(深圳)南京)&quot;:正确匹配</span></span><br><span class="line"><span class="code">    &quot;上海(长安))&quot;：错误匹配</span></span><br><span class="line"><span class="code">    &quot;((上海)长安&quot;：错误匹配</span></span><br></pre></td></tr></table></figure>

<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断str中的括号是否匹配</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> str 括号组成的字符串</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 如果匹配，返回true，如果不匹配，返回false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String str)</span>&#123;</span><br><span class="line">      StackLink&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">StackLink</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> String.valueOf(str.charAt(i));</span><br><span class="line">          <span class="keyword">if</span> (<span class="string">&quot;(&quot;</span>.equals(c))&#123;</span><br><span class="line">              stack.push(c);</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;)&quot;</span>.equals(c))&#123;</span><br><span class="line">              <span class="type">String</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">              <span class="keyword">if</span> (pop==<span class="literal">null</span>||<span class="string">&quot;&quot;</span>.equals(pop))&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (stack.size()==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>逆波兰表达式求值问题</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> notaion 逆波兰表达式的数组表示方式</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 逆波兰表达式的计算结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">caculate</span><span class="params">(String[] notaion)</span>&#123;</span><br><span class="line">       StackLink&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">StackLink</span>&lt;&gt;();</span><br><span class="line">       Integer o1;</span><br><span class="line">       Integer o2;</span><br><span class="line">       Integer result;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; notaion.length; i++) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">curr</span> <span class="operator">=</span> notaion[i];</span><br><span class="line">           <span class="keyword">switch</span> (curr)&#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                   o1 = stack.pop();</span><br><span class="line">                   o2 = stack.pop();</span><br><span class="line">                   result = o1 + o2;</span><br><span class="line">                   stack.push(result);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                   o1 = stack.pop();</span><br><span class="line">                   o2 = stack.pop();</span><br><span class="line">                   result = o2 - o1;</span><br><span class="line">                   stack.push(result);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                   o1 = stack.pop();</span><br><span class="line">                   o2 = stack.pop();</span><br><span class="line">                   result = o1 * o2;</span><br><span class="line">                   stack.push(result);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                   o1 = stack.pop();</span><br><span class="line">                   o2 = stack.pop();</span><br><span class="line">                   result = o2 / o1;</span><br><span class="line">                   stack.push(result);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   stack.push(Integer.valueOf(curr));</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       result = stack.pop();</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列是一种基于先进先出(FIFO)的数据结构，是一种只能在一端进行插入,在另一端进行删除操作的特殊线性表，它</p>
<p>按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。</p>
<h5 id="数组实现队列"><a href="#数组实现队列" class="headerlink" title="数组实现队列"></a>数组实现队列</h5><p>1、入队列，在队列增加元素；出队列，在队头弹出数据，同时数据整体向队头移动，保证队头有数据</p>
<p>2、由于每次移动数据，增加时间复杂度。于是增加队头队尾指针，通过移动指针来操作队列数据，但是不能重复利用数组空间</p>
<p>3、为了能重复利用，引出循环队列概念，当队尾指针最大后，再移动到队头开始，当front和rear相等，有可能是队列为空也有可能是队列满了</p>
<p>4、进而将rear指针定义为队尾的下一位置，从而得出结论front&#x3D;rear说明队列为空，(front+1)%quenenSize&#x3D;front，说明队列已满；并得出队列长度公式：(rear-front+quenenSize)%quenenSize</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用数组实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-05</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuenenArray</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] data;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队头指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队尾下一个结点指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuenenArray</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        data = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpety</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//头指针和尾指针相等</span></span><br><span class="line">        <span class="keyword">return</span> front==rear;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear-front+capacity)%capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向队列添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((rear+<span class="number">1</span>)%capacity==front)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列已满&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[rear] = t;</span><br><span class="line">        rear = (rear+<span class="number">1</span>)%capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rear==front)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> data[front];</span><br><span class="line">        front = (front+<span class="number">1</span>)%capacity;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showDatas</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T t : data) &#123;</span><br><span class="line">            System.out.print(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a>链表实现队列</h5><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 链表实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuenenLink</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//记录首结点</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">//记录最后一个结点</span></span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="comment">//记录队列中元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuenenLink</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回队列中元素的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向队列中插入元素t</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>) &#123;</span><br><span class="line">            last = <span class="keyword">new</span> <span class="title class_">Node</span>(t, <span class="literal">null</span>);</span><br><span class="line">            head.next = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">oldLast</span> <span class="operator">=</span> last;</span><br><span class="line">            last = <span class="keyword">new</span> <span class="title class_">Node</span>(t, <span class="literal">null</span>);</span><br><span class="line">            oldLast.next = last;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//个数+1</span></span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中拿出一个元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">oldFirst</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = oldFirst.next;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            last = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldFirst.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">QIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">QIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n.next != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> n.next;</span><br><span class="line">            n = n.next;</span><br><span class="line">            <span class="keyword">return</span> node.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> T item;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T item, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = item;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h3><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><p>树是由n（n&gt;&#x3D;1）个有限结点组成一个具有层次关系的集合。</p>
<p>树具有以下特点：</p>
<p> 1.每个结点有零个或多个子结点；</p>
<p> 2.没有父结点的结点为根结点；</p>
<p> 3.每一个非根结点只有一个父结点；</p>
<p> 4.每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树；</p>
<h4 id="树的相关概念"><a href="#树的相关概念" class="headerlink" title="树的相关概念"></a>树的相关概念</h4><p><strong>结点的度：</strong></p>
<p>一个结点含有的子树的个数称为该结点的度；</p>
<p><strong>叶结点：</strong></p>
<p>度为0的结点称为叶结点，也可以叫做终端结点</p>
<p><strong>分支结点：</strong></p>
<p>度不为0的结点称为分支结点，也可以叫做非终端结点</p>
<p><strong>结点的层次：</strong></p>
<p>从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推</p>
<p><strong>结点的层序编号：</strong></p>
<p>将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。</p>
<p><strong>树的度：</strong></p>
<p>树中所有结点的度的最大值</p>
<p><strong>树的高度(深度)：</strong></p>
<p>树中结点的最大层次</p>
<p><strong>森林：</strong></p>
<p> m（m&gt;&#x3D;0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根</p>
<p>结点，森林就变成一棵</p>
<p><strong>孩子结点：</strong></p>
<p>一个结点的直接后继结点称为该结点的孩子结点</p>
<p><strong>双亲结点(父结点)：</strong></p>
<p>一个结点的直接前驱称为该结点的双亲结点</p>
<p><strong>兄弟结点：</strong></p>
<p>同一双亲结点的孩子结点间互称兄弟结点</p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><h5 id="基本定义-1"><a href="#基本定义-1" class="headerlink" title="基本定义"></a>基本定义</h5><p>二叉树就是度不超过2的树(每个结点最多有两个子结点)</p>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p><strong>满二叉树：</strong></p>
<p>一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。</p>
<p><strong>完全二叉树：</strong></p>
<p>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p><strong>结点类：</strong></p>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>Node&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(Key key, Value value, Node left, Node right)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.public Node left:记录左子结点<br>2.public Node right:记录右子结点<br>3.public Key key:存储键<br>4.public Value value:存储值</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 结点类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;Key,Value&gt;&#123;</span><br><span class="line">      <span class="comment">//存储键</span></span><br><span class="line">      <span class="keyword">private</span> Key key;</span><br><span class="line">      <span class="comment">//存储值</span></span><br><span class="line">      <span class="keyword">private</span> Value value;</span><br><span class="line">      <span class="comment">//左结点</span></span><br><span class="line">      <span class="keyword">private</span> Node left;</span><br><span class="line">      <span class="comment">//右结点</span></span><br><span class="line">      <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 构造方法</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Key key, Value value, Node left, Node right)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.key = key;</span><br><span class="line">          <span class="built_in">this</span>.value = value;</span><br><span class="line">          <span class="built_in">this</span>.left = left;</span><br><span class="line">          <span class="built_in">this</span>.right = right;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉树API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>BinaryTree&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>BinaryTree()：创建BinaryTree对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node root:记录根结点<br>2.private int N:记录树中元素的个数</td>
</tr>
<tr>
<td>成员方法</td>
<td>1. public void put(Key key,Value value):向树中插入一个键值对<br>2.private Node put(Node x, Key key, Value val)：给指定树x上，添加键一个键值对，并返回添加后的新树<br>3.public Value get(Key key):根据key，从树中找出对应的值<br>4.private Value get(Node x, Key key):从指定的树x中，找出key对应的值<br>5.public void delete(Key key):根据key，删除树中对应的键值对<br>6.private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的新树<br>7.public int size():获取树中元素的个数</td>
</tr>
</tbody></table>
<p><strong>插入方法put实现思想：</strong></p>
<p>1.如果当前树中没有任何一个结点，则直接把新结点当做根结点使用</p>
<p>2.如果当前树不为空，则从根结点开始：</p>
<p> 2.1如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；</p>
<p> 2.2如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；</p>
<p> 2.3如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。</p>
<p><strong>查询方法get实现思想：</strong></p>
<p>从根节点开始：</p>
<p> 1.如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；</p>
<p> 2.如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；</p>
<p> 3.如果要查询的key等于当前结点的key，则树中返回当前结点的value。</p>
<p><strong>删除方法delete实现思想：</strong></p>
<p> 1.找到被删除结点；</p>
<p> 2.找到被删除结点右子树中的最小结点minNode</p>
<p> 3.删除右子树中的最小结点</p>
<p> 4.让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子</p>
<p>树</p>
<p> 5.让被删除结点的父节点指向最小结点minNode</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 二叉树实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span>&lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;,Value&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 树中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryTree</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向树中插入一个键值对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Key key,Value value)</span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给指定树x上，添加键一个键值对，并返回添加后的新树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">put</span><span class="params">(Node x, Key key, Value val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="literal">null</span>)&#123;</span><br><span class="line">            N++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key,val,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//新结点的key大于当前结点key，继续找当前结点的右子结点</span></span><br><span class="line">            x.right = put(x.right,key,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//新结点的key小于当前结点key，继续找当前结点的左子结点</span></span><br><span class="line">            x.left = put(x.left,key,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            x.value = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key，从树中找出对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Value <span class="title function_">get</span><span class="params">(Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从指定的树x中，找出key对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Value <span class="title function_">get</span><span class="params">(Node x,Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> get(x.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> get(x.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除树中对应的键值对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Key key)</span>&#123;</span><br><span class="line">        delete(root,key);</span><br><span class="line">        <span class="comment">//个数-1</span></span><br><span class="line">        N--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定树x上的键为key的键值对，并返回删除后的新树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">delete</span><span class="params">(Node x,Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            x.right = delete(x.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x.left = delete(x.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//新结点的key等于当前结点的key,当前x就是要删除的结点</span></span><br><span class="line">            <span class="comment">//1.如果当前结点的右子树不存在，则直接返回当前结点的左子结点</span></span><br><span class="line">            <span class="keyword">if</span> (x.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> x.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.如果当前结点的左子树不存在，则直接返回当前结点的右子结点</span></span><br><span class="line">            <span class="keyword">if</span> (x.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> x.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.当前结点的左右子树都存在</span></span><br><span class="line">            <span class="comment">//3.1找到右子树中最小的结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">minNode</span> <span class="operator">=</span> x.right;</span><br><span class="line">            <span class="keyword">while</span> (minNode.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                minNode = minNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.2删除右子树中最小的结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> x.right;</span><br><span class="line">            <span class="keyword">while</span> (n.left != <span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span> (n.left.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                   n.left = <span class="literal">null</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   n = n.left;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.3让被删除结点的左子树成为最小结点minNode的左子树，让被删除结点的右子树成为最小结点minNode的右子树</span></span><br><span class="line">            minNode.left = x.left;</span><br><span class="line">            minNode.right = x.right;</span><br><span class="line">            <span class="comment">//3.4让被删除结点的父节点指向最小结点minNode</span></span><br><span class="line">            x = minNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取树中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结点类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="comment">//存储键</span></span><br><span class="line">        <span class="keyword">private</span> Key key;</span><br><span class="line">        <span class="comment">//存储值</span></span><br><span class="line">        <span class="keyword">private</span> Value value;</span><br><span class="line">        <span class="comment">//左结点</span></span><br><span class="line">        <span class="keyword">private</span> Node left;</span><br><span class="line">        <span class="comment">//右结点</span></span><br><span class="line">        <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Key key, Value value, Node left, Node right)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找二叉树中的最小键</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找出整个树中最小的键</span></span><br><span class="line">   <span class="keyword">public</span> Key <span class="title function_">min</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> min(root).key;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//找出指定树x中最小的键所在的结点</span></span><br><span class="line">   <span class="keyword">public</span> Node <span class="title function_">min</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> min(x.left);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找二叉树中最大的键</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找出整个树中最大的键</span></span><br><span class="line">   <span class="keyword">public</span> Key <span class="title function_">max</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> max(root).key;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//找出指定树x中最小的键所在的结点</span></span><br><span class="line">   <span class="keyword">public</span> Node <span class="title function_">max</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> max(x.right);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h5><p><strong>前序遍历</strong></p>
<p>先访问根结点，然后再访问左子树，最后访问右子树</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用前序遍历，获取整个树中的所有键</span></span><br><span class="line">   <span class="keyword">public</span> QuenenLink&lt;Key&gt; <span class="title function_">preErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">       QuenenLink&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">       preErgodic(root,keys);</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用前序遍历，把指定树x中的所有键放入到keys队列中</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preErgodic</span><span class="params">(Node x,QuenenLink&lt;Key&gt; keys)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1.把当前结点的key放入到队列中;</span></span><br><span class="line">       keys.enqueue(x.key);</span><br><span class="line">       <span class="comment">//2.找到当前结点的左子树，如果不为空，递归遍历左子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           preErgodic(x.left,keys);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3.找到当前结点的右子树，如果不为空，递归遍历右子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">           preErgodic(x.right,keys);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>中序遍历</strong></p>
<p>先访问左子树，中间访问根节点，最后访问右子树</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用中序遍历，获取整个树中的所有键</span></span><br><span class="line">   <span class="keyword">public</span> QuenenLink&lt;Key&gt; <span class="title function_">midErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">       QuenenLink&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">       midErgodic(root,keys);</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用中序遍历，把指定树x中的所有键放入到keys队列中</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">midErgodic</span><span class="params">(Node x,QuenenLink&lt;Key&gt; keys)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1.找到当前结点的左子树，如果不为空，递归遍历左子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           midErgodic(x.left,keys);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2.把当前结点的key放入到队列中;</span></span><br><span class="line">       keys.enqueue(x.key);</span><br><span class="line">       <span class="comment">//3.找到当前结点的右子树，如果不为空，递归遍历右子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">           midErgodic(x.right,keys);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>后序遍历</strong></p>
<p>先访问左子树，再访问右子树，最后访问根节点</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用后序遍历，获取整个树中的所有键</span></span><br><span class="line">   <span class="keyword">public</span> QuenenLink&lt;Key&gt; <span class="title function_">afterErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">       QuenenLink&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">       afterErgodic(root,keys);</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用后序遍历，把指定树x中的所有键放入到keys队列中</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">afterErgodic</span><span class="params">(Node x,QuenenLink&lt;Key&gt; keys)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1.找到当前结点的左子树，如果不为空，递归遍历左子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           afterErgodic(x.left,keys);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2.找到当前结点的右子树，如果不为空，递归遍历右子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">           afterErgodic(x.right,keys);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3.把当前结点的key放入到队列中;</span></span><br><span class="line">       keys.enqueue(x.key);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>层序遍历</strong></p>
<p>所谓的层序遍历，就是从根节点（第一层）开始，依次向下，获取每一层所有结点的值</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用层序遍历得到树中所有的键</span></span><br><span class="line">   <span class="keyword">public</span> QuenenLink&lt;Key&gt; <span class="title function_">layerErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">       QuenenLink&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">       QuenenLink&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">       nodes.enqueue(root);</span><br><span class="line">       <span class="keyword">while</span> (!nodes.isEmpty())&#123;</span><br><span class="line">           <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nodes.dequeue();</span><br><span class="line">           keys.enqueue(node.key);</span><br><span class="line">           <span class="keyword">if</span> (node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">               nodes.enqueue(node.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">               nodes.enqueue(node.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="二叉树的最大深度问题"><a href="#二叉树的最大深度问题" class="headerlink" title="二叉树的最大深度问题"></a><strong>二叉树的最大深度问题</strong></h5><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算整个树的最大深度</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> maxDepth(root);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//计算指定树x的最大深度</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">       <span class="comment">//1.如果根结点为空，则最大深度为0；</span></span><br><span class="line">       <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//2.计算左子树的最大深度；</span></span><br><span class="line">       <span class="keyword">if</span> (x.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           maxL = maxDepth(x.left);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3.计算右子树的最大深度；</span></span><br><span class="line">       <span class="keyword">if</span> (x.right != <span class="literal">null</span>)&#123;</span><br><span class="line">           maxR = maxDepth(x.right);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4.当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1</span></span><br><span class="line">       max = maxL &gt; maxR ? maxL + <span class="number">1</span> : maxR + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h4><p>二叉查找树是最常用的一种二叉树，它支持快速插入、删除、查找操作，各个操作的时间复杂度跟树的高度成正比，最佳时间复杂度是 O(log­n)。</p>
<p>不过，由于二叉排序树本身为有序，当<strong>插入一个有序程度十分高的序列</strong>时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致<strong>最终的二叉排序树会退化为链表</strong>，从而使得二叉树的查询和插入效率恶化。**时间复杂度会退化到 O(n)**。</p>
<p>因此一般的<strong>二叉查找树不适用于数据经常变动（加入或删除）的情况</strong>。而是比较适合不会变动的数据，例如编程语言中的“保留字”等。</p>
<p>为了能够尽量降低查找所需要的时间，快速找到所要的键值，或者很快地知道当前的树中没有我们要的键值，必须让树的高度越小越好。要解决这个时间复杂度退化的问题，我们需要设计一种平衡二叉查找树。</p>
<h5 id="avl平衡树"><a href="#avl平衡树" class="headerlink" title="avl平衡树"></a>avl平衡树</h5><p>平衡二叉树（Balanced Binary Tree）又称 <strong>AVL</strong> 树（由 Adelse-Velskil 和 Landis 两个人发明），本身也是一棵二叉查找树，其产生是为了解决二叉排序树在插入时发生线性排列的现象。</p>
<p>平衡二叉树的严格定义是这样的：</p>
<ol>
<li>满足二叉查找树的性质，左子树所有值小于父节点，右子树所有值大于等于父节点。</li>
<li>作为一棵平衡二叉树，它需要满足任意一个节点的左右子树的高度相差不能大于 1。</li>
</ol>
<p>在平衡二叉树中，<strong>每次在插入数据和删除数据后，必要时就会对二叉树做一些高度的调整（左旋和右旋）</strong>，<strong>来让二叉查找树的高度随时维持平衡，将查找、插入、删除操作的时间复杂度保证在 O(log­n) 范围内</strong>。通常只有从那些插入点到根节点的路径上的节点的平衡性可能被改变，因为只有这些节点的子树可能变化。</p>
<p>平衡二叉树适用于动态数据，这就完成了哈希表不便完成的工作——动态性。所以：</p>
<ul>
<li>如果输入集合确定，所需要的就是查询，则可以考虑使用哈希表。</li>
<li>如果输入集合不确定，则考虑使用平衡二叉树&#x2F;红黑树，保证达到最大效率。</li>
</ul>
<p><strong>平衡二叉树主要优点集中在快速查找，</strong>频繁旋转会使插入和删除牺牲掉 O(log­n) 左右的时间，不过相对二叉查找树来说，时间上稳定了很多。<br><strong>Node结点类：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>Node&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(Key,Value)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.public K key:键<br>2.private V value:值<br>3.private Node left,right:左右结点<br>4.private int height:高度</td>
</tr>
</tbody></table>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>AvlTree&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>AvlTree()：创建AvlTree对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node root:记录根结点<br>2.private int N:记录树中元素的个数:</td>
</tr>
<tr>
<td>成员方法</td>
<td>1. public void put(Key key,Value value):向树中插入一个键值对<br>2.private Node put(Node x, Key key, Value val)：给指定树x上，添加键一个键值对，并返回添加后的新树<br>3.public Value get(Key key):根据key，从树中找出对应的值<br>4.private Value get(Node x, Key key):从指定的树x中，找出key对应的值<br>5.public void delete(Key key):根据key，删除树中对应的键值对<br>6.private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的新树<br>7.public int size():获取树中元素的个数<br>8.public Node rightRotate(Node x):右旋<br>9.public Node leftRotate(Node x):左旋</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: avl数实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AvlTree</span>&lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;,Value&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Key key;</span><br><span class="line">        <span class="keyword">private</span> Value value;</span><br><span class="line">        <span class="keyword">public</span> Node left,right;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Key key,Value value)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            left = <span class="literal">null</span>;</span><br><span class="line">            right = <span class="literal">null</span>;</span><br><span class="line">            height = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AvlTree</span><span class="params">()</span>&#123;</span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取树高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取平衡因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getBalanceFactor</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getHeight(node.left) - getHeight(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右旋</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">rightRotate</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="comment">//获取根结点的左子节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">left</span> <span class="operator">=</span> node.left;</span><br><span class="line">        <span class="comment">//获取左子节点的右子节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">lright</span> <span class="operator">=</span> left.right;</span><br><span class="line">        <span class="comment">//left为根结点，node为其右子节点，并lright调整为node的左子节点</span></span><br><span class="line">        left.right = node;</span><br><span class="line">        node.left = lright;</span><br><span class="line">        <span class="comment">//更新height</span></span><br><span class="line">        left.height = Math.max(getHeight(left.left),getHeight(left.right)) + <span class="number">1</span>;</span><br><span class="line">        node.height = Math.max(getHeight(node.left),getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左旋</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">leftRotate</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="comment">//获取根结点的右子节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> node.right;</span><br><span class="line">        <span class="comment">//获取右子节点的左子节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">rleft</span> <span class="operator">=</span> right.left;</span><br><span class="line">        <span class="comment">//right为根结点，node为其左子节点，并rleft调整为node的右子节点</span></span><br><span class="line">        right.left = node;</span><br><span class="line">        node.right = rleft;</span><br><span class="line">        <span class="comment">//更新height</span></span><br><span class="line">        right.height = Math.max(getHeight(right.left),getHeight(right.right)) + <span class="number">1</span>;</span><br><span class="line">        node.height = Math.max(getHeight(node.left),getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Key key,Value value)</span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">put</span><span class="params">(Node node,Key key,Value value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果为空，即空树添加结点</span></span><br><span class="line">            <span class="comment">//元素个数加1</span></span><br><span class="line">            N++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key,value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(node.key)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            node.left = put(node.left,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            node.right = put(node.right,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key)==<span class="number">0</span>)&#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新每个结点的height</span></span><br><span class="line">        node.height = Math.max(getHeight(node.left),getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//计算平衡因子</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">balanceFactor</span> <span class="operator">=</span> getBalanceFactor(node);</span><br><span class="line">        <span class="comment">//右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先左旋再右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.left = leftRotate(node.left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先右旋再左旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.right = rightRotate(node.right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据key，从树中找出对应的值</span></span><br><span class="line">    <span class="keyword">public</span> Value <span class="title function_">get</span><span class="params">(Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从指定的树x中，找出key对应的值</span></span><br><span class="line">    <span class="keyword">private</span> Value <span class="title function_">get</span><span class="params">(Node node,Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(node.key)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> get(node.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> get(node.right,key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据key，删除树中对应的键值对</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Key key)</span>&#123;</span><br><span class="line">        root = delete(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除指定树x上的键为key的键值对，并返回删除后的新树</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">delete</span><span class="params">(Node node,Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义新树</span></span><br><span class="line">        Node newNode;</span><br><span class="line">        <span class="comment">//找到key对应的位置</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.left = delete(node.left,key);</span><br><span class="line">            newNode = node;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.right = delete(node.right,key);</span><br><span class="line">            newNode = node;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//找到key的位置</span></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> node.right;</span><br><span class="line">                node.right = <span class="literal">null</span>;</span><br><span class="line">                N--;</span><br><span class="line">                newNode = rightNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> node.left;</span><br><span class="line">                node.left = <span class="literal">null</span>;</span><br><span class="line">                N--;</span><br><span class="line">                newNode = leftNode;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">                <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">minimum</span> <span class="operator">=</span> minimum(node.right);</span><br><span class="line">                minimum.right = delete(node.right,minimum.key);</span><br><span class="line">                minimum.left = node.left;</span><br><span class="line">                node.left = node.right = <span class="literal">null</span>;</span><br><span class="line">                newNode = minimum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新height</span></span><br><span class="line">        newNode.height = <span class="number">1</span> + Math.max(getHeight(newNode.left), getHeight(newNode.right));</span><br><span class="line">        <span class="comment">//计算平衡因子</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">balanceFactor</span> <span class="operator">=</span> getBalanceFactor(newNode);</span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(newNode.left) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rightRotate(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(newNode.right) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftRotate(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先左旋再右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(newNode.left) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            newNode.left = leftRotate(newNode.left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先右旋再左旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(newNode.right) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            newNode.right = rightRotate(newNode.right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根的二分搜索树的最小值所在的节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">minimum</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h5><p>为了保证查找树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个结点保存多个键。确切的说，我</p>
<p>们将一棵标准的二叉查找树中的结点称为2-结点(含有一个键和两条链)，而现在我们引入3-结点，它含有两个键和</p>
<p>三条链。2-结点和3-结点中的每条链都对应着其中保存的键所分割产生的一个区间。</p>
<p>一棵2-3查找树要么为空，要么满足满足下面两个要求：</p>
<p><strong>2-结点：</strong></p>
<p>含有一个键(及其对应的值)和两条链，左链接指向2-3树中的键都小于该结点，右链接指向的2-3树中的键都大</p>
<p>于该结点。</p>
<p><strong>3-结点：</strong></p>
<p>含有两个键(及其对应的值)和三条链，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都</p>
<p>位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。</p>
<p><strong>查找</strong></p>
<p>将二叉查找树的查找算法一般化我们就能够直接得到2-3树的查找算法。要判断一个键是否在树中，我们先将它和</p>
<p>根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的连</p>
<p>接，并在其指向的子树中递归地继续查找。如果这个是空链接，查找未命中。</p>
<p> <strong>插入</strong></p>
<p><strong>向2-结点中插入新键</strong></p>
<h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><p>红黑树是一种特殊的二叉查找树，每个结点都要储存位表示结点的颜色，或红或黑</p>
<p><strong>特点：</strong></p>
<ul>
<li>每个结点或红或黑</li>
<li>根结点是黑色</li>
<li>空叶子结点是黑色</li>
<li>如果一个几点是红色，那么他的子节点是黑色</li>
<li>从任意一个结点出发到空的叶子结点经过的黑色结点个数相同</li>
</ul>
<p><strong>Node结点类：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>Node&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(Key,Value)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.public K key:键<br>2.private V value:值<br>3.private Node left,right:左右结点<br>4.private boolean color:结点颜色</td>
</tr>
</tbody></table>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>RedBlackTree&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>RedBlackTree()：创建RedBlackTree对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node root:记录根结点<br>2.private int N:记录树中元素的个数:</td>
</tr>
<tr>
<td>成员方法</td>
<td>1. public void put(Key key,Value value):向树中插入一个键值对<br>2.private Node put(Node x, Key key, Value val)：给指定树x上，添加键一个键值对，并返回添加后的新树<br>3.public Value get(Key key):根据key，从树中找出对应的值<br>4.private Value get(Node x, Key key):从指定的树x中，找出key对应的值<br>5.public void delete(Key key):根据key，删除树中对应的键值对<br>6.private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的新树<br>7.public int size():获取树中元素的个数<br>8.public Node rightRotate(Node x):右旋<br>9.public Node leftRotate(Node x):左旋</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<h5 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h5><p><strong>特点</strong></p>
<p>B树中允许一个结点中包含多个key，可以是3个、4个、5个甚至更多，并不确定，需要看具体的实现。现在我们选</p>
<p>择一个参数M，来构造一个B树，我们可以把它称作是M阶的B树，那么该树会具有如下特点：</p>
<ul>
<li>每个结点最多有M-1个key，并且以升序排列；</li>
<li>每个结点最多能有M个子结点；</li>
<li>根结点至少有两个子结点</li>
</ul>
<p><strong>B树在磁盘文件中的应用</strong></p>
<p>​		在我们的程序中，不可避免的需要通过IO操作文件，而我们的文件是存储在磁盘上的。计算机操作磁盘上的文件是通过文件系统进行操作的，在文件系统中就使用到了B树这种数据结构。</p>
<p><strong>磁盘</strong></p>
<p>​		磁盘能够保存大量的数据，从GB一直到TB级，但是 他的读取速度比较慢，因为涉及到机器操作，读取速度为毫秒级 。磁盘由盘片构成,每个盘片有两面，又称为盘面 。盘片中央有一个可以旋转的主轴，他使得盘片以固定的旋转速率旋转，通常是5400rpm或者是7200rpm,一个磁盘中包含了多个这样的盘片并封装在一个密封的容器内 。盘片的每个表面是由一组称为磁道同心圆组成的 ，每个磁道被划分为了一组扇区 ，每个扇区包含相等数量的数据位，通常是512个子节，扇区之间由一些间隙隔开,这些间隙中不存储数据 。</p>
<p><strong>磁盘IO</strong></p>
<p>​		磁盘用磁头来读写存储在盘片表面的位，而磁头连接到一个移动臂上，移动臂沿着盘片半径前后移动，可以将磁头定位到任何磁道上，这称之为寻道操作。一旦定位到磁道后，盘片转动，磁道上的每个位经过磁头时，读写磁头就可以感知到该位的值，也可以修改值。对磁盘的访问时间分为 <strong>寻道时间</strong>，<strong>旋转时间</strong>，以及<strong>传送时间</strong>。</p>
<p>​		由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，因此为了提高效率，要尽量减少磁盘I&#x2F;O，减少读写操作。 为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此预读可以提高I&#x2F;O效率。,</p>
<p>​		页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（1024个字节或其整数倍），预读的长度一般为页的整倍数。主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<p>​		文件系统的设计者利用了磁盘预读原理，将一个结点的大小设为等于一个页（1024个字节或其整数倍），这样每个结点只需要一次I&#x2F;O就可以完全载入。那么3层的B树可以容纳1024<em>1024</em>1024差不多10亿个数据，如果换成二叉查找树，则需要30层！假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在10亿个数据中查找目标值，只需要小于3次硬盘读取就可以找到目标值，但红黑树需要小于30次，因此B树大大提高了IO的操作效率。</p>
<h5 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h5><p>B+树是对B树的一种变形树，它与B树的差异在于：</p>
<ul>
<li>非叶结点仅具有索引作用，也就是说，非叶子结点只存储key，不存储value；</li>
<li>树的所有叶结点构成一个有序链表，可以按照key排序的次序遍历全部数据。</li>
</ul>
<p><strong>B+树和B树的对比</strong></p>
<p><strong>B+</strong> <strong>树的优点在于：</strong></p>
<ul>
<li>由于B+树在非叶子结点上不包含真正的数据，只当做索引使用，因此在内存相同的情况下，能够存放更多的key。 </li>
<li>B+树的叶子结点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。</li>
</ul>
<p><strong>B树的优点在于：</strong></p>
<p>​		由于B树的每一个节点都包含key和value，因此我们根据key查找value时，只需要找到key所在的位置，就能找到value，但B+树只有叶子结点存储数据，索引每一次查找，都必须一次一次，一直找到树的最大深度处，也就是叶子结点的深度，才能找到value。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h4><p>堆是计算机科学中一类特殊的数据结构的统称，堆通常可以被看做是一棵完全二叉树的数组对象。</p>
<p><strong>堆的特性</strong></p>
<ul>
<li>它是完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求左满右不满。</li>
<li>它通常用数组来实现。如果一个结点的位置为k，则它的父结点的位置为[k&#x2F;2],而它的两个子结点的位置则分别为2k和2k+1。这样，在不使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动：从a[k]向上一层，就令k等于k&#x2F;2,向下一层就令k等于2k或2k+1。</li>
<li>每个结点都大于等于它的两个子结点。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的。</li>
</ul>
<h4 id="堆的API设计"><a href="#堆的API设计" class="headerlink" title="堆的API设计"></a>堆的API设计</h4><table>
<thead>
<tr>
<th>类名</th>
<th><strong>Heap</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Heap(int capacity)：创建容量为capacity的Heap对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br>2.private void exch(int i,int j):交换堆中i索引和j索引处的值<br>3.public T delMax():删除堆中最大的元素,并返回这个最大元素<br>4.public void insert(T t)：往堆中插入一个元素<br>5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br>6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] imtes : 用来存储元素的数组<br>2.private int N：记录堆中元素的个数</td>
</tr>
</tbody></table>
<h4 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a><strong>堆的实现</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.generic.IF_ACMPEQ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储堆中的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录堆中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j])&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换堆中i索引和j索引处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往堆中插入一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        <span class="comment">//上浮算法</span></span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除堆中最大的元素,并返回这个最大元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> items[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//交换索引1处和索引N处的值</span></span><br><span class="line">        exch(<span class="number">1</span>,N);</span><br><span class="line">        <span class="comment">//删除最后位置上的元素</span></span><br><span class="line">        items[N]=<span class="literal">null</span>;</span><br><span class="line">        N--;<span class="comment">//个数-1</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//如果已经到了根结点，就不需要循环了</span></span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//比较当前结点和其父节点</span></span><br><span class="line">            <span class="keyword">if</span> (less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">                <span class="comment">//父节点小于当前节点，则交换</span></span><br><span class="line">                exch(k/<span class="number">2</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//如果当前已经是最底层了，就不需要循环了</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k&lt;=N)&#123;</span><br><span class="line">            <span class="comment">//找到子节点中的较大者</span></span><br><span class="line">            <span class="type">int</span> max;</span><br><span class="line">            <span class="comment">//判断是否存在右结点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span>*k+<span class="number">1</span>&lt;=N)&#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span>*k,<span class="number">2</span>*k+<span class="number">1</span>))&#123;</span><br><span class="line">                    max = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    max = <span class="number">2</span>*k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                max = <span class="number">2</span>*k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较当前结点和子节点中较大者，如果当前结点不小，则结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (!less(k,max))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前结点小，则交换</span></span><br><span class="line">            exch(k,max);</span><br><span class="line">            k = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.generic.IF_ACMPEQ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储堆中的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录堆中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j])&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换堆中i索引和j索引处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往堆中插入一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        <span class="comment">//上浮算法</span></span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除堆中最大的元素,并返回这个最大元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> items[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//交换索引1处和索引N处的值</span></span><br><span class="line">        exch(<span class="number">1</span>,N);</span><br><span class="line">        <span class="comment">//删除最后位置上的元素</span></span><br><span class="line">        items[N]=<span class="literal">null</span>;</span><br><span class="line">        N--;<span class="comment">//个数-1</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//如果已经到了根结点，就不需要循环了</span></span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//比较当前结点和其父节点</span></span><br><span class="line">            <span class="keyword">if</span> (less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">                <span class="comment">//父节点小于当前节点，则交换</span></span><br><span class="line">                exch(k/<span class="number">2</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//如果当前已经是最底层了，就不需要循环了</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k&lt;=N)&#123;</span><br><span class="line">            <span class="comment">//找到子节点中的较大者</span></span><br><span class="line">            <span class="type">int</span> max;</span><br><span class="line">            <span class="comment">//判断是否存在右结点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span>*k+<span class="number">1</span>&lt;=N)&#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span>*k,<span class="number">2</span>*k+<span class="number">1</span>))&#123;</span><br><span class="line">                    max = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    max = <span class="number">2</span>*k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                max = <span class="number">2</span>*k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较当前结点和子节点中较大者，如果当前结点不小，则结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (!less(k,max))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前结点小，则交换</span></span><br><span class="line">            exch(k,max);</span><br><span class="line">            k = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><strong>AP设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>HeapSort</strong></th>
</tr>
</thead>
<tbody><tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] source)：对source数组中的数据从小到大排序<br>2.private static void createHeap(Comparable[] source, Comparable[] heap):根据原数组source，构造出堆heap<br>3.private static boolean less(Comparable[] heap, int i, int j)：判断heap堆中索引i处的元素是否小于索引j处的元素<br>4.private static void exch(Comparable[] heap, int i, int j):交换heap堆中i索引和j索引处的值<br>5.private static void sink(Comparable[] heap, int target, int range):在heap堆中，对target处的元素做下沉，范围是0~range。</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 堆排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对source数组中的数据从小到大排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] source)</span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个比原数组大1的数组</span></span><br><span class="line">        Comparable[] heap = <span class="keyword">new</span> <span class="title class_">Comparable</span>[source.length + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//2.构造堆</span></span><br><span class="line">        createHeap(source,heap);</span><br><span class="line">        <span class="comment">//3.堆排序</span></span><br><span class="line">        <span class="comment">//3.1定义一个变量，记录heap中未排序的所有元素中最大的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> heap.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (N != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//3.2交换heap中索引1处的元素和N处的元素</span></span><br><span class="line">            exch(heap,<span class="number">1</span>,N);</span><br><span class="line">            N--;</span><br><span class="line">            sink(heap,<span class="number">1</span>,N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.heap中的数据已经有序，拷贝到source中</span></span><br><span class="line">        System.arraycopy(heap,<span class="number">1</span>,source,<span class="number">0</span>,source.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据原数组source，构造出堆heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createHeap</span><span class="params">(Comparable[] source, Comparable[] heap)</span>&#123;</span><br><span class="line">        <span class="comment">//1.把source中的数据拷贝到heap中，从heap的1索引处开始填充</span></span><br><span class="line">        System.arraycopy(source,<span class="number">0</span>,heap,<span class="number">1</span>,source.length);</span><br><span class="line">        <span class="comment">//2.从heap索引的一半处开始倒叙遍历，对得到的每一个元素做下沉操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (heap.length-<span class="number">1</span>)/<span class="number">2</span>; i &gt; <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            sink(heap,i, heap.length-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断heap堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(Comparable[] heap, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap[i].compareTo(heap[j])&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换heap堆中i索引和j索引处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] heap, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable tmp=heap[i];</span><br><span class="line">        heap[i]=heap[j];</span><br><span class="line">        heap[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在heap堆中，对target处的元素做下沉，范围是0~range。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> range</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(Comparable[] heap, <span class="type">int</span> target, <span class="type">int</span> range)</span>&#123;</span><br><span class="line">        <span class="comment">//没有子结点了</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*target&lt;=range) &#123;</span><br><span class="line">            <span class="comment">//1.找出target结点的两个子结点中的较大值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">2</span> * target;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * target + <span class="number">1</span> &lt;= range) &#123;</span><br><span class="line">                <span class="comment">//存在右子结点</span></span><br><span class="line">                <span class="keyword">if</span> (less(heap, <span class="number">2</span> * target, <span class="number">2</span> * target + <span class="number">1</span>)) &#123;</span><br><span class="line">                    max = <span class="number">2</span> * target + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.如果当前结点的值小于子结点中的较大值，则交换</span></span><br><span class="line">            <span class="keyword">if</span> (less(heap, target, max)) &#123;</span><br><span class="line">                exch(heap, target, max);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.更新target的值</span></span><br><span class="line">            target = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;S&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;P&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        HeapSort.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>​		普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在某些情况下，我们可能需要找出队列中的最大值或者最小值，例如使用一个队列保存计算机的任务，一般情况下计算机的任务都是有优先级的，我们需要在这些计算机的任务中找出优先级最高的任务先执行，执行完毕后就需要把这个任务从队列中移除。普通的队列要完成这样的功能，需要每次遍历队列中的所有元素，比较并找出最大值，效率不是很高，这个时候，我们就可以使用一种特殊的队列来完成这种需求，优先队列。</p>
<h4 id="最大优先队列"><a href="#最大优先队列" class="headerlink" title="最大优先队列"></a><strong>最大优先队列</strong></h4><p><strong>最大优先队列API设计</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>MaxPriorityQueue</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>MaxPriorityQueue(int capacity)：创建容量为capacity的MaxPriorityQueue对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br>2.private void exch(int i,int j):交换堆中i索引和j索引处的值<br>3.public T delMax():删除队列中最大的元素,并返回这个最大元素<br>4.public void insert(T t)：往队列中插入一个元素<br>5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br>6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置<br>7.public int size():获取队列中元素的个数<br>8.public boolean isEmpty():判断队列是否为空</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] imtes : 用来存储元素的数组<br>2.private int N：记录堆中元素的个数</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.awt.geom.AreaOp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 最大优先队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-20</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPriorityQueue</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存储元素的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录堆中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxPriorityQueue</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换堆中i索引和j索引处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除队列中最大的元素,并返回这个最大元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> items[<span class="number">1</span>];</span><br><span class="line">        exch(<span class="number">1</span>,N);</span><br><span class="line">        items[N] = <span class="literal">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往队列中插入一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//比较当前节点与其父节点</span></span><br><span class="line">            <span class="keyword">if</span> (less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">                exch(k/<span class="number">2</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k&lt;=N)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= N)&#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span> * k,<span class="number">2</span> * k + <span class="number">1</span>))&#123;</span><br><span class="line">                    max = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!less(k,max))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(k,max);</span><br><span class="line">            k = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列中元素的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;S&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;P&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        MaxPriorityQueue&lt;String&gt; maxpq = <span class="keyword">new</span> <span class="title class_">MaxPriorityQueue</span>&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">            maxpq.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(maxpq.size());</span><br><span class="line">        String del;</span><br><span class="line">        <span class="keyword">while</span>(!maxpq.isEmpty())&#123;</span><br><span class="line">            del = maxpq.delMax();</span><br><span class="line">            System.out.print(del+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最小优先队列"><a href="#最小优先队列" class="headerlink" title="最小优先队列"></a>最小优先队列</h4><p>其实我们之前实现的堆可以把它叫做最大堆，我们可以用相反的思想实现最小堆，让堆中存放数据元素的数组满足</p>
<p>如下特性：</p>
<p>1.最小的元素放在数组的索引1处。</p>
<p>2.每个结点的数据总是小于等于它的两个子结点的数据。</p>
<p><strong>最小优先队列API设计</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>MinPriorityQueue</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>MinPriorityQueue(int capacity)：创建容量为capacity的MinPriorityQueue对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br>2.private void exch(int i,int j):交换堆中i索引和j索引处的值<br>3.public T delMax():删除队列中最大的元素,并返回这个最大元素<br>4.public void insert(T t)：往队列中插入一个元素<br>5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br>6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置<br>7.public int size():获取队列中元素的个数<br>8.public boolean isEmpty():判断队列是否为空</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] imtes : 用来存储元素的数组<br>2.private int N：记录堆中元素的个数</td>
</tr>
</tbody></table>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 最小优先队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-20</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinPriorityQueue</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存储元素的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录堆中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinPriorityQueue</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换堆中i索引和j索引处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除队列中最大的元素,并返回这个最大元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> items[<span class="number">1</span>];</span><br><span class="line">        exch(<span class="number">1</span>,N);</span><br><span class="line">        items[N] = <span class="literal">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往队列中插入一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//比较当前节点与其父节点</span></span><br><span class="line">            <span class="keyword">if</span> (less(k,k/<span class="number">2</span>))&#123;</span><br><span class="line">                exch(k/<span class="number">2</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k&lt;=N)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= N)&#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span> * k + <span class="number">1</span>,<span class="number">2</span> * k ))&#123;</span><br><span class="line">                    min = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (less(k,min))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(k,min);</span><br><span class="line">            k = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列中元素的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;S&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;P&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        MinPriorityQueue&lt;String&gt; maxpq = <span class="keyword">new</span> <span class="title class_">MinPriorityQueue</span>&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">            maxpq.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(maxpq.size());</span><br><span class="line">        String del;</span><br><span class="line">        <span class="keyword">while</span>(!maxpq.isEmpty())&#123;</span><br><span class="line">            del = maxpq.delMax();</span><br><span class="line">            System.out.print(del+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="索引优先队列"><a href="#索引优先队列" class="headerlink" title="索引优先队列"></a>索引优先队列</h4><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="图的定义及分类"><a href="#图的定义及分类" class="headerlink" title="图的定义及分类"></a>图的定义及分类</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h5><p>图是由一组顶点和一组能够将两个顶点相连的边组成的</p>
<h5 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a><strong>分类</strong></h5><p>按照连接两个顶点的边的不同，可以把图分为以下两种：</p>
<ul>
<li>无向图：边仅仅连接两个顶点，没有其他含义；</li>
<li>有向图：边不仅连接两个顶点，并且具有方向；</li>
</ul>
<h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><h5 id="图的相关术语"><a href="#图的相关术语" class="headerlink" title="图的相关术语"></a>图的相关术语</h5><p><strong>相邻顶点：</strong></p>
<p>当两个顶点通过一条边相连时，我们称这两个顶点是相邻的，并且称这条边依附于这两个顶点。</p>
<p><strong>度：</strong></p>
<p>某个顶点的度就是依附于该顶点的边的个数</p>
<p><strong>子图：</strong></p>
<p>是一幅图的所有边的子集(包含这些边依附的顶点)组成的图；</p>
<p><strong>路径：</strong></p>
<p>是由边顺序连接的一系列的顶点组成</p>
<p><strong>环：</strong></p>
<p>是一条至少含有一条边且终点和起点相同的路径</p>
<p><strong>连通图：</strong></p>
<p>如果图中任意一个顶点都存在一条路径到达另外一个顶点，那么这幅图就称之为连通图</p>
<p><strong>连通子图：</strong></p>
<p>一个非连通图由若干连通的部分组成，每一个连通的部分都可以称为该图的连通子图</p>
<h5 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a><strong>图的存储结构</strong></h5><p>要表示一幅图，只需要表示清楚以下两部分内容即可：</p>
<ol>
<li>图中所有的顶点；</li>
<li>所有连接顶点的边；</li>
</ol>
<p>常见的图的存储结构有两种：邻接矩阵和邻接表</p>
<p> <strong>邻接矩阵</strong></p>
<ol>
<li>使用一个V*V的二维数组int[V][V] adj,把索引的值看做是顶点；</li>
<li>如果顶点v和顶点w相连，我们只需要将adj[v][w]和adj[w][v]的值设置为1,否则设置为0即可。</li>
</ol>
<p>邻接矩阵这种存储方式的空间复杂度是V^2的，如果我们处理的问题规模比较大的话，内存空间极有可能不够用。</p>
<p><strong>邻接表</strong></p>
<ol>
<li>使用一个大小为V的数组 Queue[V] adj，把索引看做是顶点；</li>
<li>每个索引处adj[v]存储了一个队列，该队列中存储的是所有与该顶点相邻的其他顶点</li>
</ol>
<p>邻接表的空间并不是是线性级别的，采用邻接表这种存储形式来表示图</p>
<h5 id="图的实现"><a href="#图的实现" class="headerlink" title="图的实现"></a><strong>图的实现</strong></h5><p><strong>API设计</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>UndirectedGraph</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>UndirectedGraph(int V)：创建一个包含V个顶点但不包含边的图</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public int V():获取图中顶点的数量<br>2.public int E():获取图中边的数量<br>3.public void addEdge(int v,int w):向图中添加一条边 v-w<br>4.public Queue adj(int v)：获取和顶点v相邻的所有顶点</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private int V: 记录顶点数量<br>2.private int E: 记录边数量<br>3.private Queue[] adj: 邻接表</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.graph;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 无向图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-21</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UndirectedGraph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="comment">//边的数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> E;</span><br><span class="line">    <span class="comment">//邻接表</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt;[] adj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UndirectedGraph</span><span class="params">(<span class="type">int</span> V)</span>&#123;</span><br><span class="line">        <span class="comment">//初始化顶点数量</span></span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        <span class="comment">//初始化边的数量</span></span><br><span class="line">        <span class="built_in">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化邻接表</span></span><br><span class="line">        <span class="built_in">this</span>.adj = <span class="keyword">new</span> <span class="title class_">Queue</span>[V];</span><br><span class="line">        <span class="comment">//初始化邻接表中的空队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; adj.length; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> <span class="title class_">Queue</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取顶点数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">V</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取图中边的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">E</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向图中添加一条边 v-w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">        <span class="comment">//把w添加到v的链表中，这样顶点v就多了一个相邻点w</span></span><br><span class="line">        adj[v].enqueue(w);</span><br><span class="line">        <span class="comment">//把v添加到w的链表中，这样顶点w就多了一个相邻点v</span></span><br><span class="line">        adj[w].enqueue(v);</span><br><span class="line">        <span class="comment">//边的数目自增1</span></span><br><span class="line">        E++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取和顶点v相邻的所有顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">adj</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="图的搜索"><a href="#图的搜索" class="headerlink" title="图的搜索"></a>图的搜索</h5><p><strong>深度优先搜索</strong></p>
<p>​		所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找子结点，然后找兄弟结点。</p>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>DepthFirstSearch</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>DepthFirstSearch(UndirectedGraph G,int s)：构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相通顶点</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private void dfs(UndirectedGraph G, int v)：使用深度优先搜索找出G图中v顶点的所有相通顶点<br>2.public boolean marked(int w):判断w顶点与s顶点是否相通<br>3.public int count():获取与顶点s相通的所有顶点的总数</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索<br>2.private int count：记录有多少个顶点与s顶点相通</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 深度优先搜索</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepthFirstSearch</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索引代表顶点，值表示当前顶点是否已经被搜索</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录有多少个顶点与s顶点相通</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相通顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DepthFirstSearch(UndirectedGraph G,<span class="type">int</span> s)&#123;</span><br><span class="line">        <span class="comment">//创建一个和图的顶点数一样大小的布尔数组</span></span><br><span class="line">        marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[G.V()];</span><br><span class="line">        <span class="comment">//搜索G图中与顶点s相同的所有顶点</span></span><br><span class="line">        dfs(G,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用深度优先搜索找出G图中v顶点的所有相通顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(UndirectedGraph G, <span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="comment">//把当前顶点标记为已搜索</span></span><br><span class="line">        marked[v]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//遍历v顶点的邻接表，得到每一个顶点w</span></span><br><span class="line">        <span class="keyword">for</span> (Integer w : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked(w))&#123;</span><br><span class="line">                dfs(G,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//相通的顶点数量+1</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断w顶点与s顶点是否相通</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">marked</span><span class="params">(<span class="type">int</span> w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取与顶点s相通的所有顶点的总数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>广度优先搜索</strong></p>
<p>​		所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找兄弟结点，然后找子结点</p>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>BreadthFirstSearch</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>BreadthFirstSearch(UndirectedGraph G,int s)：构造广度优先搜索对象，使用广度优先搜索找出G图中s顶点的所有相通顶点</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private void dfs(UndirectedGraph G, int v)：使用深度优先搜索找出G图中v顶点的所有相通顶点<br>2.public boolean marked(int w):判断w顶点与s顶点是否相通<br>3.public int count():获取与顶点s相通的所有顶点的总数</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索<br>2.private int count：记录有多少个顶点与s顶点相通<br>3.private Queue waitSearch: 用来存储待搜索邻接表的点</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gxl.datastructure.line.QuenenLink;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 广度优先搜索</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BreadthFirstSearch</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索引代表顶点，值表示当前顶点是否已经被搜索</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录有多少个顶点与s顶点相通</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存储待搜索邻接表的点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> QuenenLink&lt;Integer&gt; waitSearch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造广度优先搜索对象，使用深广优先搜索找出G图中s顶点的所有相通顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BreadthFirstSearch(UndirectedGraph G, <span class="type">int</span> s)&#123;</span><br><span class="line">        <span class="comment">//创建一个和图的顶点数一样大小的布尔数组</span></span><br><span class="line">        marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[G.V()];</span><br><span class="line">        <span class="comment">//初始化待搜索顶点的队列</span></span><br><span class="line">        waitSearch = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//搜索G图中与顶点s相同的所有顶点</span></span><br><span class="line">        dfs(G,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用广度优先搜索找出G图中v顶点的所有相通顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(UndirectedGraph G, <span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="comment">//把当前顶点标记为已搜索</span></span><br><span class="line">        marked[v]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//把当前顶点v放入到队列中，等待搜索它的邻接表</span></span><br><span class="line">        waitSearch.enqueue(v);</span><br><span class="line">        <span class="comment">//使用while循环从队列中拿出待搜索的顶点wait，进行搜索邻接表</span></span><br><span class="line">        <span class="keyword">while</span> (!waitSearch.isEmpty())&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">wait</span> <span class="operator">=</span> waitSearch.dequeue();</span><br><span class="line">            <span class="keyword">for</span> (Integer w : G.adj(wait)) &#123;</span><br><span class="line">                <span class="comment">//如果当前顶点w没有被搜索过，则递归搜索与w顶点相通的其他顶点</span></span><br><span class="line">                <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                    dfs(G, w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//相通的顶点数量+1</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断w顶点与s顶点是否相通</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">marked</span><span class="params">(<span class="type">int</span> w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取与顶点s相通的所有顶点的总数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>路径查找</strong></p>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>DepthFirstPaths</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>DepthFirstPaths(UndirectedGraph G,int s)：构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相通顶点</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private void dfs(UndirectedGraph G, int v)：使用深度优先搜索找出G图中v顶点的所有相通顶点<br>2.public boolean hasPathTo(int v):判断v顶点与s顶点是否存在路径<br>3.public Stack pathTo(int v):找出从起点s到顶点v的路径(就是该路径经过的顶点)</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索<br>2.private int s：起点<br>3.private int[] edgeTo: 索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gxl.datastructure.line.StackLink;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 路径查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepthFirstPaths</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索引代表顶点，值表示当前顶点是否已经被搜索</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> s;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] edgeTo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造深度优先搜索对象，使用深度优先搜索找出G图中起点为s的所有路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DepthFirstPaths</span><span class="params">(UndirectedGraph G, <span class="type">int</span> s)</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个和图的顶点数一样大小的布尔数组</span></span><br><span class="line">        marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[G.V()];</span><br><span class="line">        <span class="comment">//创建一个和图顶点数一样大小的整型数组</span></span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="title class_">int</span>[G.V()];</span><br><span class="line">        <span class="comment">//初始化顶点</span></span><br><span class="line">        <span class="built_in">this</span>.s=s;</span><br><span class="line">        <span class="comment">//搜索G图中起点为s的所有路径</span></span><br><span class="line">        dfs(G,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用深度优先搜索找出G图中v顶点的所有相通顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(UndirectedGraph G, <span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="comment">//把当前顶点标记为已搜素</span></span><br><span class="line">        marked[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//遍历v顶点的邻接表，得到每个顶点w</span></span><br><span class="line">        <span class="keyword">for</span> (Integer w : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[w])&#123;</span><br><span class="line">                <span class="comment">//如果当前顶点w没有被搜索过，则将edgeTo[w]设置为v,表示w的前一个顶点为v，并递归搜索与w顶点相通的其他顶点</span></span><br><span class="line">                edgeTo[w] = v;</span><br><span class="line">                dfs(G,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v顶点与s顶点是否存在路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathTo</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找出从起点s到顶点v的路径(就是该路径经过的顶点)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> StackLink&lt;Integer&gt; <span class="title function_">pathTo</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="comment">//当前v顶点与s顶点不连通，所以直接返回null，没有路径</span></span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建路径中经过的顶点的容器</span></span><br><span class="line">        StackLink&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">StackLink</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//第一次把当前顶点存进去，然后将x变换为到达当前顶点的前一个顶点edgeTo[x],在把前一个顶点存进去，继续将x变化为到达前一个顶点的前一个顶点，继续存，一直到x的值为s为止，相当于逆推法，最后把s放进去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> v; x != s ; x=edgeTo[x]) &#123;</span><br><span class="line">            <span class="comment">//把当前顶点放入容器</span></span><br><span class="line">            path.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        path.push(s);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h4><p><strong>有向图的定义及相关术语</strong></p>
<p><strong>定义：</strong></p>
<p>有向图是一副具有方向性的图，是由一组顶点和一组有方向的边组成的，每条方向的边都连着一对有序的顶点。</p>
<p><strong>出度：</strong></p>
<p>由某个顶点指出的边的个数称为该顶点的出度。</p>
<p><strong>入度：</strong></p>
<p>指向某个顶点的边的个数称为该顶点的入度。</p>
<p><strong>有向路径：</strong></p>
<p>由一系列顶点组成，对于其中的每个顶点都存在一条有向边，从它指向序列中的下一个顶点。</p>
<p><strong>有向环：</strong></p>
<p>一条至少含有一条边，且起点和终点相同的有向路径。</p>
<p><strong>API设计</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Digraph</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Digraph(int V)：创建一个包含V个顶点但不包含边的有向图</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public int V():获取图中顶点的数量<br>2.public int E():获取图中边的数量<br>3.public void addEdge(int v,int w):向有向图中添加一条边 v-&gt;w<br>4.public QueueList adj(int v)：获取由v指出的边所连接的所有顶点<br>5.private Digraph reverse():该图的反向图</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private int V: 记录顶点数量<br>2.private int E: 记录边数量<br>3.private QueueList[] adj: 邻接表</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gxl.datastructure.line.QuenenLink;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 有向图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Digraph</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录顶点数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录边数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> E;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 邻接表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> QuenenLink&lt;Integer&gt;[] adj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法：创建一个包含V个顶点但不包含边的有向图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> V</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Digraph</span><span class="params">(<span class="type">int</span> V)</span>&#123;</span><br><span class="line">        <span class="comment">//初始化顶点数量</span></span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        <span class="comment">//初始化边的数量</span></span><br><span class="line">        <span class="built_in">this</span>.E=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化邻接表</span></span><br><span class="line">        <span class="built_in">this</span>.adj = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>[V];</span><br><span class="line">        <span class="comment">//初始化邻接表中的空队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; adj.length; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取图中顶点的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">V</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取图中边的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">E</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向有向图中添加一条边 v-&gt;w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">        <span class="comment">//由于有向图中边是有向的，v-&gt;w 边，只需要让w出现在v的邻接表中，而不需要让v出现在w的邻接表中</span></span><br><span class="line">        adj[v].enqueue(w);</span><br><span class="line">        E++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取由v指出的边所连接的所有顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> QuenenLink&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该图的反向图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Digraph <span class="title function_">reverse</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//创建新的有向图对象</span></span><br><span class="line">        <span class="type">Digraph</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Digraph</span>(V);</span><br><span class="line">        <span class="comment">//遍历0~V-1所有顶点,拿到每一个顶点v</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            <span class="comment">//得到原图中的v顶点对应的邻接表,原图中的边为 v-&gt;w,则反向图中边为w-&gt;v;</span></span><br><span class="line">            <span class="keyword">for</span> (Integer w : adj[v]) &#123;</span><br><span class="line">                r.addEdge(w,v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><strong>排序原理：</strong></p>
<ol>
<li><p>比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置</p>
</li>
<li><p>对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大</p>
<p>值。</p>
</li>
</ol>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Bubble</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Bubble()：创建Bubble对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序 <br>2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w<br>3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bubble</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组内的元素进行排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (greater(a[j],a[j+<span class="number">1</span>]))&#123;</span><br><span class="line">                    exch(a,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v是否大于w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v,Comparable w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换a数组中，索引i和索引j处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] a = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Bubble.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>冒泡排序的时间复杂度O(N^2)</strong></p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><strong>排序原理：</strong></p>
<p> 1.每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引	处的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引</p>
<p> 2.交换第一个索引处和最小值所在的索引处的值</p>
<p><strong>选择排序API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Selection</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Selection()：创建Selection对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序 <br>2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w<br>3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 选择排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-24</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Selection</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组内的元素进行排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span> &#123;</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= a.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//默认第一个位最小值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">//从i的下一位开始遍历，比较找到最小值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (greater(a[i], a[j])) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换i和minIndex</span></span><br><span class="line">            exch(a, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v是否大于w</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v, Comparable w)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换a数组中，索引i和索引j处的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] a = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Selection.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p><strong>排序原理：</strong></p>
<p>1.把所有的元素分为两组，已经排序的和未排序的；</p>
<p>2.找到未排序的组中的第一个元素，向已经排序的组中进行插入；</p>
<p>3.倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待      	插入元素放到这个位置，其他的元素向后移动一位；</p>
<p><strong>插入排序API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Insertion</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Insertion()：创建Insertion对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序 <br>2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w<br>3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 插入排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-24</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Insertion</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组内的元素进行排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (greater(a[j-<span class="number">1</span>],a[j]))&#123;</span><br><span class="line">                    exch(a,j-<span class="number">1</span>,j);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v是否大于w</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v, Comparable w)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换a数组中，索引i和索引j处的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] a = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Insertion.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p><strong>排序原理：</strong></p>
<ol>
<li>选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组；</li>
<li>对分好组的每一组数据完成插入排序；</li>
<li>减小增长量，最小减为1，重复第二步操作。</li>
</ol>
<p><strong>希尔排序的API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Shell</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Shell()：创建Shell对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序 <br>2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w<br>3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 希尔排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-24</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shell</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组内的元素进行排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="comment">//确定增长量h的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (h&lt;N/<span class="number">2</span>)&#123;</span><br><span class="line">            h=h*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当增量小于1，排序结束</span></span><br><span class="line">        <span class="keyword">while</span> (h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//找到待插入的元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="comment">//a[i]就是待插入的元素</span></span><br><span class="line">                <span class="comment">//把a[i]插入到a[i-h],a[i-2h],a[i-3h]...序列中</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= h; j-=h) &#123;</span><br><span class="line">                    <span class="comment">//a[j]就是待插入元素，依次和a[j-h],a[j-2h],a[j-3h]进行比较，如果a[j]小，那么交换位置，如果不小于，a[j]大，则插入完成。</span></span><br><span class="line">                    <span class="keyword">if</span> (greater(a[j-h],a[j]))&#123;</span><br><span class="line">                        exch(a,j,j-h);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            h/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v是否大于w</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v, Comparable w)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换a数组中，索引i和索引j处的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] a = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Shell.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><strong>排序原理：</strong></p>
<ol>
<li>尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止。</li>
<li>将相邻的两个子组进行合并成一个有序的大组；</li>
<li>不断的重复步骤2，直到最终只有一个组为止。</li>
</ol>
<p><strong>归并排序API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Merge</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Merge()：创建Merge对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序 <br>2.private static void sort(Comparable[] a, int lo, int hi)：对数组a中从索引lo到索引hi之间的元素进行排序<br>3.private static void merge(Comparable[] a, int lo, int mid, int hi):从索引lo到索引mid为一个子组，从索引mid+1到索引hi为另一个子组，把数组a中的这两个子组的数据合并成一个有序的大组（从索引lo到索引hi）<br>4.private static boolean less(Comparable v,Comparable w):判断v是否小于w<br>5.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private static Comparable[] assist：完成归并操作需要的辅助数组</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
