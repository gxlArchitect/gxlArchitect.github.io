<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dubbo</title>
    <url>/2023/03/31/Dubbo/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Nacos</title>
    <url>/2023/03/02/Nacos/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SpringCloud Consul</title>
    <url>/2023/03/02/SpringCloud-Consul/</url>
    <content><![CDATA[<h2 id="Consul介绍"><a href="#Consul介绍" class="headerlink" title="Consul介绍"></a>Consul介绍</h2><p>​		Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其它分布式服务注册与发现的方案，Consul 的方案更“一站式”，内置了服务注册与发现框 架、分布一致性协议实现、健康检查、Key&#x2F;Value 存储、多数据中心方案，不再需要依赖其它工具（比如 ZooKeeper 等）。使用起来也较 为简单。Consul 使用 Go 语言编写，因此具有天然可移植性(支持Linux、windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署，与Docker 等轻量级容器可无缝配合。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>服务发现</li>
<li>健康检查</li>
<li>Key&#x2F;Value 存储</li>
<li>多数据中心</li>
<li>社区活跃</li>
</ul>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>使用 Raft 算法来保证一致性, 比复杂的 Paxos 算法更直接. 相比较而言,zookeeper 采用的是 Paxos, 而 etcd 使用的则是 Raft。</li>
<li>支持多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障,而其部署则需要考虑网络延迟,分片等情况等。 zookeeper 和 etcd 均不提供多数据中心功能的支持。</li>
<li>支持健康检查。 etcd 不提供此功能。</li>
<li>支持 http 和 dns 协议接口。 zookeeper 的集成较为复杂, etcd 只支持http 协议</li>
<li>官方提供 web 管理界面, etcd 无此功能。</li>
<li>综合比较, Consul 作为服务注册和配置管理的新星, 比较值得关注和研究</li>
<li>提供了rest api 便于集成：<a href="https://www.consul.io/api-docs/index">https://www.consul.io/api-docs/index</a></li>
</ul>
<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul>
<li>client: 客户端, 无状态, 将 HTTP 和 DNS 接口请求转发给局域网内的服务端集群。</li>
<li>server: 服务端, 保存配置信息, 高可用集群, 在局域网内与本地客户端通讯, 通过广域网与其它数据中心通讯。 每个数据中心的 server 数量推荐为 3 个或是 5 个。</li>
</ul>
<p>Consul 客户端、服务端还支持夸中心的使用，更加提高了它的高可用性。</p>
<h2 id="Consul-基础架构"><a href="#Consul-基础架构" class="headerlink" title="Consul 基础架构"></a>Consul 基础架构</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li><p>agent</p>
<p>​		组成 consul 集群的每个成员上都要运行一个 agent，可以通过 consul agent 命令来启动。agent可以运行在 server 状态或者 client 状态。自然运行在 server 状态的节点被称为 server 节点；运行在 client 状态的节点被称为 client 节点</p>
</li>
<li><p>server 节点</p>
<p>​		负责组成 cluster 的复杂工作（选举server 自行选举一个 leader、状态维护、转发请求到 leader），以及 consul 提供的服务（响应RPC 请求），以及存放和复制数据。考虑到容错和收敛，一般部署 3 ~ 5 个比较合适。</p>
</li>
<li><p>client 节点</p>
<p>​		负责转发所有的 RPC 到 server 节点。本身无状态，且轻量级，因此，可以部署大量的client 节点。</p>
</li>
<li><p>数据中心</p>
<p>​		虽然数据中心的定义似乎很明显，但仍有一些细微的细节必须考虑。我们将一个数据中心定义为一个私有、低延迟和高带宽的网络环境。这不包括通过公共互联网的通信，但是为了我们的目的，单个EC2 区域内的多个可用区域将被视为单个数据中心的一部分。</p>
</li>
</ul>
<p>另外：</p>
<p>​		server 自行选举一个 leader。虽然 Consul 可以运行在一台 server ，但是建议使用 3 到 5 台来避免失败情况下数据的丢失。每个数据中心建议配置一个server 集群。</p>
<p>​		在基础设施中需要发现其他服务的组件可以查询任何一个 Consul 的server 或者agent，Agent 会自动转发请求到 server。</p>
<p>​		每个数据中心运行了一个 Consul server 集群。当一个跨数据中心的服务发现和配置请求创建时，本地 Consul Server 转发请求到远程的数据中心并返回结果。</p>
<h3 id="如何实现服务注册和发现"><a href="#如何实现服务注册和发现" class="headerlink" title="如何实现服务注册和发现"></a><strong>如何实现服务注册和发现</strong></h3><p><img src="/.com//1677740195077.jpg" alt="1677740195077"></p>
<p>工作原理：</p>
<ol>
<li>当Producer启动的时候，会向Consul发送一个post请求，并向Consul传输自己的IP和Port。</li>
<li>Consul 接收到Producer的注册后，每隔10s（默认）会向Producer发送一个健康检查的请求，检验Producer是否健康。</li>
<li>当Consumer以Http的方式向Producer发起请求，会先从Consul中拿到一个存储服务IP和Port的临时表，从表中拿到Producer的IP和Port后再发送请求。</li>
<li>该临时表每隔10s会更新，只包含有通过了健康检查的Producer。</li>
</ol>
<h2 id="Consul安装"><a href="#Consul安装" class="headerlink" title="Consul安装"></a>Consul安装</h2><p><strong>下载consul服务</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 从官网下载最新版本的Consul服务</span></span></span><br><span class="line">wget https://releases.hashicorp.com/consul/1.10.3/consul_1.10.3_linux_amd64.zip </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#使用unzip命令解压</span></span></span><br><span class="line">unzip consul_1.10.3_linux_amd64.zip </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#将解压好的consul可执行命令移动到/usr/local/bin目录下</span></span></span><br><span class="line">mv consul /usr/local/bin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#测试一下</span></span></span><br><span class="line">consul --version</span><br></pre></td></tr></table></figure>

<p><strong>启动consul服务</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// ip1</span><br><span class="line">consul agent -server -ui -bootstrap-expect=3 -data-dir=/data/consul -node=agent-1 -client=0.0.0.0 -bind=ip1 -datacenter=dc1</span><br><span class="line"> </span><br><span class="line">// ip2</span><br><span class="line">consul agent -server -ui -bootstrap-expect=3 -data-dir=/data/consul -node=agent-2 -client=0.0.0.0 -bind=ip2 -datacenter=dc1 -join ip1</span><br><span class="line"> </span><br><span class="line">// ip3</span><br><span class="line">consul agent -server -ui -bootstrap-expect=3 -data-dir=/data/consul -node=agent-3 -client=0.0.0.0 -bind=ip3 -datacenter=dc1 -join ip1</span><br></pre></td></tr></table></figure>

<p>​	<strong>参数解释：</strong></p>
<ul>
<li>-bootstrap-expect:集群期望的节点数，只有节点数量达到这个值才会选举leader。</li>
<li>-server： 运行在server模式</li>
<li>-client：consul服务侦听地址，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1所以不对外提供服务，如果你要对外提供服务改成0.0.0.0</li>
<li>-data-dir：指定数据目录，其他的节点对于这个目录必须有读的权限</li>
<li>-node：指定节点的名称</li>
<li>-bind：为该节点绑定一个地址</li>
<li>-config-dir：指定配置文件，定义服务的，默认所有一.json结尾的文件都会读</li>
<li>-enable-script-checks&#x3D;true：设置检查服务为可用</li>
<li>-datacenter: 数据中心名称</li>
</ul>
<p>-join：加入到已有的集群中</p>
<p> <strong>其他命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看集群成员</span></span><br><span class="line">consul members</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看集群状态</span></span><br><span class="line">consul info</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新加载配置文件</span></span><br><span class="line">consul reload</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">帮助</span></span><br><span class="line">consul agent -h</span><br></pre></td></tr></table></figure>

<p><strong>Consul 的 WebUI 控制台</strong></p>
<p><a href="http://ip1:8500/">http://ip1:8500</a></p>
]]></content>
      <categories>
        <category>Consul</category>
      </categories>
      <tags>
        <tag>Consul</tag>
        <tag>注册中心</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper入门篇</title>
    <url>/2023/02/02/Zookeeper%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>Zookeeper 是 Apache Hadoop 项目下的一个子项目，是一个树形目录服务。</li>
<li>Zookeeper 翻译过来就是 动物园管理员，他是用来管 Hadoop（大象）、Hive(蜜蜂)、Pig(小 猪)的管理员。简称zk。</li>
<li>Zookeeper 是一个分布式的、开源的分布式应用程序的协调服务。</li>
<li>Zookeeper 提供的主要功能包括：配置管理、分布式锁、集群管理</li>
</ul>
<h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>ZooKeeper服务器是用Java创建的，它运行在JVM之上。需要安装JDK 7或更高版本。</p>
<h4 id="上传安装包"><a href="#上传安装包" class="headerlink" title="上传安装包"></a>上传安装包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打开 opt目录</span></span><br><span class="line">cd /opt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建zooKeeper目录</span></span><br><span class="line">mkdir  zooKeeper</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将zookeeper安装包上传到当前目录</span></span><br></pre></td></tr></table></figure>

<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><p>将tar包解压到&#x2F;opt&#x2F;zookeeper目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-ZooKeeper-3.5.6-bin.tar.gz </span><br></pre></td></tr></table></figure>

<h3 id="配置启动"><a href="#配置启动" class="headerlink" title="配置启动"></a>配置启动</h3><h4 id="配置zoo-cfg"><a href="#配置zoo-cfg" class="headerlink" title="配置zoo.cfg"></a>配置zoo.cfg</h4><p>进入到conf目录拷贝一个zoo_sample.cfg并完成配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入到conf目录</span></span><br><span class="line">cd /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/conf/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拷贝</span></span><br><span class="line">cp  zoo_sample.cfg  zoo.cfg</span><br></pre></td></tr></table></figure>

<p>修改zoo.cfg</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打开目录</span></span><br><span class="line">cd /opt/zooKeeper/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建zooKeeper存储目录</span></span><br><span class="line">mkdir  zkdata</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改zoo.cfg</span></span><br><span class="line">vim /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/conf/zoo.cfg</span><br></pre></td></tr></table></figure>

<p><img src="/.com//1577548250377.png" alt="1577548250377"></p>
<p>修改存储目录：dataDir&#x3D;&#x2F;opt&#x2F;zookeeper&#x2F;zkdata</p>
<h4 id="启动ZooKeeper"><a href="#启动ZooKeeper" class="headerlink" title="启动ZooKeeper"></a>启动ZooKeeper</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/bin/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动</span></span><br><span class="line">./zkServer.sh  start</span><br></pre></td></tr></table></figure>

<p><img src="/.com//1577548052037.png" alt="1577548052037"></p>
<p>看到上图表示ZooKeeper成功启动</p>
<h2 id="ZooKeeper-命令操作"><a href="#ZooKeeper-命令操作" class="headerlink" title="ZooKeeper 命令操作"></a>ZooKeeper 命令操作</h2><h3 id="Zookeeper命令操作数据模型"><a href="#Zookeeper命令操作数据模型" class="headerlink" title="Zookeeper命令操作数据模型"></a>Zookeeper命令操作数据模型</h3><ul>
<li><p>ZooKeeper 是一个树形目录服务,其数据模型和Unix的文件系统目录树很类似，拥有一个层次化结构。</p>
</li>
<li><p>这里面的每一个节点都被称为： ZNode，每个节点上都会保存自己的数据和节点信息。 </p>
</li>
<li><p>节点可以拥有子节点，同时也允许少量（1MB）数据存储在该节点之下。</p>
</li>
<li><p>节点可以分为四大类：</p>
<ol>
<li><p>PERSISTENT 持久化节点 </p>
</li>
<li><p>EPHEMERAL 临时节点 ：-e</p>
</li>
<li><p>PERSISTENT_SEQUENTIAL 持久化顺序节点 ：-s</p>
</li>
<li><p>EPHEMERAL_SEQUENTIAL 临时顺序节点  ：-es</p>
</li>
</ol>
</li>
</ul>
<p><img src="/.com//1592054828485.png" alt="1592054828485"></p>
<p><img src="/.com//1592054844023.png" alt="1592054844023"></p>
<h3 id="Zookeeper命令操作服务端命令"><a href="#Zookeeper命令操作服务端命令" class="headerlink" title="Zookeeper命令操作服务端命令"></a>Zookeeper命令操作服务端命令</h3><ul>
<li><p>启动 ZooKeeper 服务: .&#x2F;zkServer.sh start</p>
</li>
<li><p>查看 ZooKeeper 服务状态: .&#x2F;zkServer.sh status</p>
</li>
<li><p>停止 ZooKeeper 服务: .&#x2F;zkServer.sh stop </p>
</li>
<li><p>重启 ZooKeeper 服务: .&#x2F;zkServer.sh restart</p>
</li>
</ul>
<h3 id="Zookeeper客户端常用命令"><a href="#Zookeeper客户端常用命令" class="headerlink" title="Zookeeper客户端常用命令"></a>Zookeeper客户端常用命令</h3><ul>
<li>连接ZooKeeper服务端</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./zkCli.sh –server ip:port</span><br></pre></td></tr></table></figure>

<ul>
<li>断开连接</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure>

<ul>
<li>查看命令帮助</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">help</span><br></pre></td></tr></table></figure>

<ul>
<li>显示指定目录下节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls 目录</span><br></pre></td></tr></table></figure>

<ul>
<li>创建节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create /节点path value</span><br></pre></td></tr></table></figure>

<ul>
<li>获取节点值</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">get /节点path</span><br></pre></td></tr></table></figure>

<ul>
<li>设置节点值</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set /节点path value</span><br></pre></td></tr></table></figure>

<ul>
<li>删除单个节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">delete /节点path</span><br></pre></td></tr></table></figure>

<ul>
<li>删除带有子节点的节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deleteall /节点path</span><br></pre></td></tr></table></figure>

<h3 id="客户端命令-创建临时有序节点"><a href="#客户端命令-创建临时有序节点" class="headerlink" title="客户端命令-创建临时有序节点"></a>客户端命令-创建临时有序节点</h3><ul>
<li>创建临时节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create -e /节点path value</span><br></pre></td></tr></table></figure>

<ul>
<li>创建顺序节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create -s /节点path value</span><br></pre></td></tr></table></figure>

<ul>
<li>查询节点详细信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls –s /节点path </span><br></pre></td></tr></table></figure>

<ol>
<li><p>czxid：节点被创建的事务ID </p>
</li>
<li><p>ctime: 创建时间 </p>
</li>
<li><p>mzxid: 最后一次被更新的事务ID </p>
</li>
<li><p>mtime: 修改时间 </p>
</li>
<li><p>pzxid：子节点列表最后一次被更新的事务ID</p>
</li>
<li><p>cversion：子节点的版本号 </p>
</li>
<li><p>dataversion：数据版本号 </p>
</li>
<li><p>aclversion：权限版本号 </p>
</li>
<li><p>ephemeralOwner：用于临时节点，代表临时节点的事务ID，如果为持久节点则为0 </p>
</li>
<li><p>dataLength：节点存储的数据的长度 </p>
</li>
<li><p>numChildren：当前节点的子节点个数</p>
</li>
</ol>
<h2 id="ZooKeeper-JavaAPI-操作"><a href="#ZooKeeper-JavaAPI-操作" class="headerlink" title="ZooKeeper JavaAPI 操作"></a>ZooKeeper JavaAPI 操作</h2><h3 id="urator介绍"><a href="#urator介绍" class="headerlink" title="urator介绍"></a>urator介绍</h3><p>•Curator 是 Apache ZooKeeper 的Java客户端库。</p>
<p>•常见的ZooKeeper Java API ：</p>
<p>•原生Java API</p>
<p>•ZkClient</p>
<p>•Curator</p>
<p>•Curator 项目的目标是简化 ZooKeeper 客户端的使用。</p>
<p>•Curator 最初是 Netfix 研发的,后来捐献了 Apache 基金会,目前是 Apache 的顶级项目。</p>
<p>•官网：<a href="http://curator.apache.org/">http://curator.apache.org/</a></p>
<h3 id="JavaAPI操作建立连接"><a href="#JavaAPI操作建立连接" class="headerlink" title="JavaAPI操作建立连接"></a>JavaAPI操作建立连接</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnect</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//重试策略</span></span><br><span class="line">    <span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">3000</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//2.第二种方式</span></span><br><span class="line">    <span class="comment">//CuratorFrameworkFactory.builder();</span></span><br><span class="line">    client = CuratorFrameworkFactory.builder()</span><br><span class="line">        .connectString(<span class="string">&quot;192.168.200.130:2181&quot;</span>)</span><br><span class="line">        .sessionTimeoutMs(<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">        .connectionTimeoutMs(<span class="number">15</span> * <span class="number">1000</span>)</span><br><span class="line">        .retryPolicy(retryPolicy)</span><br><span class="line">        .namespace(<span class="string">&quot;itheima&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">//开启连接</span></span><br><span class="line">    client.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper-JavaAPI操作-创建节点"><a href="#Zookeeper-JavaAPI操作-创建节点" class="headerlink" title="Zookeeper JavaAPI操作-创建节点"></a>Zookeeper JavaAPI操作-创建节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建节点：create 持久 临时 顺序 数据</span></span><br><span class="line"><span class="comment">* 1. 基本创建 ：create().forPath(&quot;&quot;)</span></span><br><span class="line"><span class="comment">* 2. 创建节点 带有数据:create().forPath(&quot;&quot;,data)</span></span><br><span class="line"><span class="comment">* 3. 设置节点的类型：create().withMode().forPath(&quot;&quot;,data)</span></span><br><span class="line"><span class="comment">* 4. 创建多级节点  /app1/p1 ：create().creatingParentsIfNeeded().forPath(&quot;&quot;,data)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreate</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//2. 创建节点 带有数据</span></span><br><span class="line">    <span class="comment">//如果创建节点，没有指定数据，则默认将当前客户端的ip作为数据存储</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> client.create().forPath(<span class="string">&quot;/app2&quot;</span>, <span class="string">&quot;hehe&quot;</span>.getBytes());</span><br><span class="line">    System.out.println(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreate2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1. 基本创建</span></span><br><span class="line">    <span class="comment">//如果创建节点，没有指定数据，则默认将当前客户端的ip作为数据存储</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> client.create().forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">    System.out.println(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreate3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//3. 设置节点的类型</span></span><br><span class="line">    <span class="comment">//默认类型：持久化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> client.create().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">&quot;/app3&quot;</span>);</span><br><span class="line">    System.out.println(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreate4</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//4. 创建多级节点  /app1/p1</span></span><br><span class="line">    <span class="comment">//creatingParentsIfNeeded():如果父节点不存在，则创建父节点</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> client.create().creatingParentsIfNeeded().forPath(<span class="string">&quot;/app4/p1&quot;</span>);</span><br><span class="line">    System.out.println(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZookeeperJavaAPI操作-查询节点"><a href="#ZookeeperJavaAPI操作-查询节点" class="headerlink" title="ZookeeperJavaAPI操作-查询节点"></a>ZookeeperJavaAPI操作-查询节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查询节点：</span></span><br><span class="line"><span class="comment">* 1. 查询数据：get: getData().forPath()</span></span><br><span class="line"><span class="comment">* 2. 查询子节点： ls: getChildren().forPath()</span></span><br><span class="line"><span class="comment">* 3. 查询节点状态信息：ls -s:getData().storingStatIn(状态对象).forPath()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGet1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1. 查询数据：get</span></span><br><span class="line">    <span class="type">byte</span>[] data = client.getData().forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGet2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 2. 查询子节点： ls</span></span><br><span class="line">    List&lt;String&gt; path = client.getChildren().forPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    System.out.println(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGet3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Stat</span> <span class="variable">status</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line">    System.out.println(status);</span><br><span class="line">    <span class="comment">//3. 查询节点状态信息：ls -s</span></span><br><span class="line">    client.getData().storingStatIn(status).forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">    System.out.println(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper-JavaAPI操作-修改节点"><a href="#Zookeeper-JavaAPI操作-修改节点" class="headerlink" title="Zookeeper JavaAPI操作-修改节点"></a>Zookeeper JavaAPI操作-修改节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 修改数据</span></span><br><span class="line"><span class="comment">* 1. 基本修改数据：setData().forPath()</span></span><br><span class="line"><span class="comment">* 2. 根据版本修改: setData().withVersion().forPath()</span></span><br><span class="line"><span class="comment">* * version 是通过查询出来的。目的就是为了让其他客户端或者线程不干扰我。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	client.setData().forPath(<span class="string">&quot;/app1&quot;</span>, <span class="string">&quot;itcast&quot;</span>.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSetForVersion</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Stat</span> <span class="variable">status</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line">    <span class="comment">//3. 查询节点状态信息：ls -s</span></span><br><span class="line">    client.getData().storingStatIn(status).forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">version</span> <span class="operator">=</span> status.getVersion();<span class="comment">//查询出来的 3</span></span><br><span class="line">    System.out.println(version);</span><br><span class="line">    client.setData().withVersion(version).forPath(<span class="string">&quot;/app1&quot;</span>, <span class="string">&quot;hehe&quot;</span>.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper-JavaAPI操作-删除节点"><a href="#Zookeeper-JavaAPI操作-删除节点" class="headerlink" title="Zookeeper JavaAPI操作-删除节点"></a>Zookeeper JavaAPI操作-删除节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除节点： delete deleteall</span></span><br><span class="line"><span class="comment">* 1. 删除单个节点:delete().forPath(&quot;/app1&quot;);</span></span><br><span class="line"><span class="comment">* 2. 删除带有子节点的节点:delete().deletingChildrenIfNeeded().forPath(&quot;/app1&quot;);</span></span><br><span class="line"><span class="comment">* 3. 必须成功的删除:为了防止网络抖动。本质就是重试。  client.delete().guaranteed().forPath(&quot;/app2&quot;);</span></span><br><span class="line"><span class="comment">* 4. 回调：inBackground</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 删除单个节点</span></span><br><span class="line">    client.delete().forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//2. 删除带有子节点的节点</span></span><br><span class="line">    client.delete().deletingChildrenIfNeeded().forPath(<span class="string">&quot;/app4&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//3. 必须成功的删除</span></span><br><span class="line">    client.delete().guaranteed().forPath(<span class="string">&quot;/app2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete4</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//4. 回调</span></span><br><span class="line">    client.delete().guaranteed().inBackground(<span class="keyword">new</span> <span class="title class_">BackgroundCallback</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processResult</span><span class="params">(CuratorFramework client, CuratorEvent event)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我被删除了~&quot;</span>);</span><br><span class="line">            System.out.println(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper-JavaAPI操作-Watch监听概述"><a href="#Zookeeper-JavaAPI操作-Watch监听概述" class="headerlink" title="Zookeeper JavaAPI操作-Watch监听概述"></a>Zookeeper JavaAPI操作-Watch监听概述</h3><ol>
<li>ZooKeeper 允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</li>
<li>ZooKeeper 中引入了Watcher机制来实现了发布&#x2F;订阅功能能，能够让多个订阅者同时监听某一个对象，当一个对象自身状态变化时，会通知所有订阅者。</li>
<li>ZooKeeper 原生支持通过注册Watcher来进行事件监听，但是其使用并不是特别方便需要开发人员自己反复注册Watcher，比较繁琐。</li>
<li>Curator引入了 Cache 来实现对 ZooKeeper 服务端事件的监听。</li>
<li>ZooKeeper提供了三种Watcher：</li>
</ol>
<ul>
<li>NodeCache : 只是监听某一个特定的节点</li>
<li>PathChildrenCache : 监控一个ZNode的子节点</li>
<li>TreeCache : 可以监控整个树上的所有节点，类似于PathChildrenCache和NodeCache的组合</li>
</ul>
<h3 id="Zookeeper-JavaAPI操作-Watch监听-NodeCache"><a href="#Zookeeper-JavaAPI操作-Watch监听-NodeCache" class="headerlink" title="Zookeeper JavaAPI操作-Watch监听-NodeCache"></a>Zookeeper JavaAPI操作-Watch监听-NodeCache</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 演示 NodeCache：给指定一个节点注册监听器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testNodeCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1. 创建NodeCache对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">NodeCache</span> <span class="variable">nodeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeCache</span>(client,<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">    <span class="comment">//2. 注册监听</span></span><br><span class="line">   	nodeCache.getListenable().addListener(<span class="keyword">new</span> <span class="title class_">NodeCacheListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;节点变化了~&quot;</span>);</span><br><span class="line">            <span class="comment">//获取修改节点后的数据</span></span><br><span class="line">            <span class="type">byte</span>[] data = nodeCache.getCurrentData().getData();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    	<span class="comment">//3. 开启监听.如果设置为true，则开启监听是，加载缓冲数据</span></span><br><span class="line">    	nodeCache.start(<span class="literal">true</span>);</span><br><span class="line">    	<span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper-JavaAPI操作-Watch监听-PathChildrenCache"><a href="#Zookeeper-JavaAPI操作-Watch监听-PathChildrenCache" class="headerlink" title="Zookeeper JavaAPI操作-Watch监听-PathChildrenCache"></a>Zookeeper JavaAPI操作-Watch监听-PathChildrenCache</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPathChildrenCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1.创建监听对象</span></span><br><span class="line">    <span class="type">PathChildrenCache</span> <span class="variable">pathChildrenCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathChildrenCache</span>(client,<span class="string">&quot;/app2&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//2. 绑定监听器</span></span><br><span class="line">    pathChildrenCache.getListenable().addListener(<span class="keyword">new</span> <span class="title class_">PathChildrenCacheListener</span>() &#123;    			<span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子节点变化了~&quot;</span>);</span><br><span class="line">            System.out.println(event);</span><br><span class="line">            <span class="comment">//监听子节点的数据变更，并且拿到变更后的数据</span></span><br><span class="line">            <span class="comment">//1.获取类型</span></span><br><span class="line">            PathChildrenCacheEvent.<span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> event.getType();</span><br><span class="line">            <span class="comment">//2.判断类型是否是update</span></span><br><span class="line">            <span class="keyword">if</span>(type.equals(PathChildrenCacheEvent.Type.CHILD_UPDATED))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数据变了！！！&quot;</span>);</span><br><span class="line">                <span class="type">byte</span>[] data = event.getData().getData();</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//3. 开启</span></span><br><span class="line">    pathChildrenCache.start();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper-JavaAPI操作-Watch监听-TreeCache"><a href="#Zookeeper-JavaAPI操作-Watch监听-TreeCache" class="headerlink" title="Zookeeper JavaAPI操作-Watch监听-TreeCache"></a>Zookeeper JavaAPI操作-Watch监听-TreeCache</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 演示 TreeCache：监听某个节点自己和所有子节点们</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTreeCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1. 创建监听器</span></span><br><span class="line">    <span class="type">TreeCache</span> <span class="variable">treeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeCache</span>(client,<span class="string">&quot;/app2&quot;</span>);</span><br><span class="line">    <span class="comment">//2. 注册监听</span></span><br><span class="line">    treeCache.getListenable().addListener(<span class="keyword">new</span> <span class="title class_">TreeCacheListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">childEvent</span><span class="params">(CuratorFramework client, TreeCacheEvent event)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;节点变化了&quot;</span>);</span><br><span class="line">            System.out.println(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//3. 开启</span></span><br><span class="line">    treeCache.start();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper分布式锁-概念"><a href="#Zookeeper分布式锁-概念" class="headerlink" title="Zookeeper分布式锁-概念"></a>Zookeeper分布式锁-概念</h3><ul>
<li>在我们进行单机应用开发，涉及并发同步的时候，我们往往采用synchronized或者Lock的方式来解决多线程间的代码同步问题，这时多线程的运行都是在同一个JVM之下，没有任何问题。</li>
<li>但当我们的应用是分布式集群工作的情况下，属于多JVM下的工作环境，跨JVM之间已经无法通过多线程的锁解决同步问题。</li>
<li>那么就需要一种更加高级的锁机制，来处理种跨机器的进程之间的数据同步问题——这就是分布式锁。</li>
</ul>
<h3 id="Zookeeper分布式锁-zookeeper分布式锁原理"><a href="#Zookeeper分布式锁-zookeeper分布式锁原理" class="headerlink" title="Zookeeper分布式锁-zookeeper分布式锁原理"></a>Zookeeper分布式锁-zookeeper分布式锁原理</h3><p>核心思想：当客户端要获取锁，则创建节点，使用完锁，则删除该节点</p>
<p>客户端获取锁时，在lock节点下创建临时顺序节点。</p>
<p>然后获取lock下面的所有子节点，客户端获取到所有的子节点之后，如果发现自己创建的子节点序号最小，那么就认为该客户端获取到了锁。使用完锁后，将该节点删除。</p>
<p>如果发现自己创建的节点并非lock所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，同时对其注册事件监听器，监听删除事件。</p>
<h3 id="Zookeeper-分布式锁-Curator实现分布式锁API"><a href="#Zookeeper-分布式锁-Curator实现分布式锁API" class="headerlink" title="Zookeeper 分布式锁-Curator实现分布式锁API"></a>Zookeeper 分布式锁-Curator实现分布式锁API</h3><p>在Curator中有五种锁方案：</p>
<ul>
<li>InterProcessSemaphoreMutex：分布式排它锁（非可重入锁）</li>
<li>InterProcessMutex：分布式可重入排它锁</li>
<li>InterProcessReadWriteLock：分布式读写锁</li>
<li>InterProcessMultiLock：将多个锁作为单个实体管理的容器</li>
<li>InterProcessSemaphoreV2：共享信号量</li>
</ul>
<h2 id="ZooKeeper-集群搭建"><a href="#ZooKeeper-集群搭建" class="headerlink" title="ZooKeeper 集群搭建"></a>ZooKeeper 集群搭建</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li><p>三台服务器</p>
</li>
<li><p>安装JDK</p>
</li>
<li><p>上传zookeeper安装包至三台服务器</p>
</li>
<li><p>将Zookeeper解压 ，建立&#x2F;usr&#x2F;local&#x2F;zookeeper-cluster目录，将解压后的Zookeeper复制该目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /usr/local/zookeeper</span><br><span class="line">tar -zxvf apache-zookeeper-3.5.6-bin.tar.gz</span><br><span class="line">mv apache-zookeeper-3.5.6-bin /usr/local/zookeeper</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建data目录 ，并且将 conf下zoo_sample.cfg 文件改名为 zoo.cfg</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /usr/local/zookeeper/data</span><br><span class="line">mv  /usr/local/zookeeper/conf/zoo_sample.cfg  /usr/local/zookeeper/conf/zoo.cfg</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置dataDir 为创建的data目录和 指定的clientPort </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/zookeeper/conf/zoo.cfg</span><br><span class="line"></span><br><span class="line">clientPort=2181</span><br><span class="line">dataDir=/usr/local/zookeeper/data</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果定义集群，使用结点名访问，配置hostname</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname zookeeper1</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h3><ol>
<li><p>在zookeeper的 data 目录下创建一个 myid 文件，内容分别是1、2、3 。这个文件就是记录每个服务器的ID</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1 &gt;/usr/local/zookeeper/data/myid</span><br></pre></td></tr></table></figure>
</li>
<li><p>在每一个zookeeper 的 zoo.cfg配置客户端访问端口（clientPort）和集群服务器IP列表。集群服务器IP列表如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/zookeeper/conf/zoo.cfg</span><br><span class="line"></span><br><span class="line">server.1=ip:2881:3881</span><br><span class="line">server.2=ip:2882:3882</span><br><span class="line">server.3=ip:2883:3883</span><br></pre></td></tr></table></figure>

<p>解释：server.服务器ID&#x3D;服务器IP地址：服务器之间通信端口：服务器之间投票选举端口</p>
</li>
</ol>
<h3 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h3><p>分别在三台服务器上启动zookeeper</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/zookeeper/bin/zkServer.sh start</span><br></pre></td></tr></table></figure>

<p>启动后我们查询一下每个实例的运行状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/zookeeper/bin/zkServer.sh status</span><br></pre></td></tr></table></figure>

<p>如果存在一个leader和两个follower，说明集群启动成功</p>
<h4 id="Zookeepe集群角色"><a href="#Zookeepe集群角色" class="headerlink" title="Zookeepe集群角色"></a>Zookeepe集群角色</h4><p>在ZooKeeper集群服中务中有三个角色：</p>
<ul>
<li><p>Leader 领导者 ：</p>
<p>处理事务请求</p>
<p>集群内部各服务器的调度者</p>
</li>
<li><p>Follower 跟随者 ：</p>
<p>处理客户端非事务请求，转发事务请求给Leader服务器</p>
<p>参与Leader选举投票</p>
</li>
<li><p>Observer 观察者：</p>
<p>处理客户端非事务请求，转发事务请求给Leader服务器</p>
</li>
</ul>
<p><img src="/.com//1592058451822.png"></p>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC框架</title>
    <url>/2023/02/02/RPC%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>RPC 的主要功能目标是让构建分布式计算（应用）更容易，是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议规范，简单的来说就是像调用本地服务一样调用远程服务，对开发者而言是透明的。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1、RPC框架一般使用长链接，不必每次通信都要3次握手，减少网络开销</p>
<p>2、RPC框架一般都有注册中心，有丰富的监控管理</p>
<p>3、发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作</p>
<p>4、协议私密，安全性较高</p>
<p>5、rpc 能做到协议更简单内容更小，效率更高</p>
<p>6、rpc是面向服务的更高级的抽象，支持服务注册发现，负载均衡，超时重试，熔断降级等高级特性</p>
<h2 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h2><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>在高可用的生产环境中，服务一般都以集群方式提供服务，集群里面的IP等重要参数信息可能随时会发生变化，节点也可能会动态扩缩容，客户端需要能够及时感知服务端的变化，获取集群最新服务节点的连接信息，而这些变化要求是要对调用方应用无感知的。</p>
<p>常用的注册中心：<strong>Zookeeper</strong>，<strong>Consul</strong>，<strong>Nacos</strong></p>
<h3 id="代理技术"><a href="#代理技术" class="headerlink" title="代理技术"></a>代理技术</h3><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">在运行期动态的创建代理类，它是通过接口生成代理类的，与静态代理相比更加灵活，但是也有一定的限制，第一是代理对象必须实现一个接口，否则会报异常。第二是有性能问题，因为是通过反射来实现调用的，所以比正常的直接调用来得慢，并且通过生成类文件也会多消耗部分方法区空间，可能引起Full GC。</span><br></pre></td></tr></table></figure>

<p><strong>代码实现：</strong></p>
<p>1、定义一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、编写实现类，并定义一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.jdk;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、编写一个代理方法处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: jdk动态代理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JdkProxy</span><span class="params">(Object object)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> method.invoke(object, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉打豆豆&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、生成代理对象测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dogProxy</span> <span class="operator">=</span> (Animal) Proxy.newProxyInstance(animal.getClass().getClassLoader(), animal.getClass().getInterfaces(), <span class="keyword">new</span> <span class="title class_">JdkProxy</span>(animal));</span><br><span class="line">        dogProxy.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现原理：</strong></p>
<p>JDK动态代理是指：代理类实例在程序运行时，由JVM根据反射机制动态的生成。也就是说代理类不是用户自己定义的，而是由JVM生成的。</p>
<p><strong>1.1 InvocationHandler接口</strong></p>
<p>​		代理实例的调用处理器需要实现InvocationHandler接口，并且每个代理实例都有一个关联的调用处理器。当一个方法在代理实例上被调用时，这个方法调用将被编码并分派到其调用处理器的invoke方法上。</p>
<p>​		也就是说，我们创建的每一个代理实例都要有一个关联的InvocationHandler，并且在调用代理实例的方法时，会被转到InvocationHandler的invoke方法上。</p>
<p>publicObject invoke(Object proxy, Method method, Object[] args) throws Throwable；该invoke方法的作用是：处理代理实例上的方法调用并返回结果。</p>
<p>其有三个参数，分别为：</p>
<ul>
<li><strong>proxy</strong>：是调用该方法的代理实例。</li>
<li><strong>method</strong>：是在代理实例上调用的接口方法对应的Method实例。</li>
<li><strong>args</strong>：一个Object数组，是在代理实例上的方法调用中传递的参数值。如果接口方法为无参，则该值为null。</li>
<li>其返回值为：调用代理实例上的方法的返回值</li>
</ul>
<p><strong>1.2 Proxy类</strong></p>
<p>Proxy类提供了创建动态代理类及其实例的静态方法，该类也是动态代理类的超类。</p>
<p>代理类具有以下属性：</p>
<ul>
<li>代理类的名称以 “$Proxy” 开头，后面跟着一个数字序号。</li>
<li>代理类继承了Proxy类。</li>
<li>代理类实现了创建时指定的接口（JDK动态代理是面向接口的）。</li>
<li>每个代理类都有一个公共构造函数，它接受一个参数，即接口InvocationHandler的实现，用于设置代理实例的调用处理器。</li>
</ul>
<p>Proxy提供了两个静态方法，用于获取代理对象。</p>
<p><strong>1.2.1 getProxyClass</strong></p>
<p>用于获取代理类的Class对象，再通过调用构造函数创建代理实例。</p>
<p>该方法有两个参数：</p>
<ul>
<li><strong>loader</strong>：为类加载器。</li>
<li><strong>intefaces</strong>：为接口的Class对象数组。</li>
</ul>
<p>返回值为动态代理类的Class对象。</p>
<p><strong>1.2.2 newProxyInstance</strong></p>
<p>用于创建一个代理实例。</p>
<p>该方法有三个参数：</p>
<ul>
<li><strong>loader</strong>：为类加载器。</li>
<li><strong>interfaces</strong>：为接口的Class对象数组。</li>
<li><strong>h</strong>：指定的调用处理器。</li>
</ul>
<p>返回值为指定接口的代理类的实例。</p>
<p><strong>生成代理类：</strong></p>
<ul>
<li>代理类继承了Proxy类，其主要目的是为了传递InvocationHandler</li>
<li>代理类实现了被代理的接口，这也是为什么代理类可以直接强转成接口的原因。</li>
<li>有一个公开的构造函数，参数为指定的InvocationHandler，并将参数传递到父类Proxy中。</li>
<li>每一个实现的方法，都会调用InvocationHandler中的invoke方法，并将代理类本身、Method实例、入参三个参数进行传递。这也是为什么调用代理类中的方法时，总会分派到InvocationHandler中的invoke方法的原因。</li>
</ul>
<p><strong>代理生成过程：</strong></p>
<ol>
<li><p>调用<strong>getProxyClass 和 newProxyInstance</strong>方法，底层逻辑都会调用<strong>getProxyClass0</strong>方法</p>
</li>
<li><p>代理接口的最多不能超过65535个，会先从缓存<strong>WeakCache</strong>中获取代理类，则没有再通过<strong>ProxyClassFactory</strong>创建代理类。</p>
</li>
<li><p>ProxyClassFactory是Proxy类的一个静态内部类，该类用于生成代理类。</p>
<p>1）代理类的名称就是在这里定义的，其前缀是$Proxy，后缀是一个数字。</p>
<p>2）调用ProxyGenerator.generateProxyClass生成文件流。</p>
<p>3）defineClass0方法是一个native方法，负责字节码加载的实现，并返回对应的Class对象。</p>
</li>
</ol>
<h4 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">ASM 是一个 Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为（也就是生成的代码可以覆盖原来的类也可以是原始类的子类）。不过ASM在创建class字节码的过程中，操纵的是底层JVM的汇编指令级别，这要求ASM使用者要对class组织结构和JVM汇编指令有一定的了解</span><br></pre></td></tr></table></figure>

<h4 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">CGLIB(Code Generation Library)是一个基于ASM的字节码生成库。其原理是动态生成一个要代理类的子类，子类重写要代理的类的所有不是final的方法，在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用java反射的JDK动态代理要快</span><br></pre></td></tr></table></figure>

<p><strong>代码实现：</strong></p>
<p>1、创建一个测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.cglib;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-28</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、实现MethodInterceptor接口，自定义拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-28</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、通过Enhancer创建代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.cglib;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; clazz)</span>&#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">CglibProxy</span>());</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.cglib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-28</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">proxy</span> <span class="operator">=</span> (Student) CglibProxyFactory.createProxy(Student.class);</span><br><span class="line">        proxy.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现原理：</strong></p>
<p>动态生成一个要代理类的子类，子类重写要代理的类的所有不是 final 的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。</p>
<p>采用ASM字节码生成框架，使用字节码技术生成代理类，比使用 Java 反射效率要高。</p>
<p><strong>代理字节码文件：</strong></p>
<ul>
<li>生成的动态代理类继承了父类 Student，并且实现了接口 Factory</li>
<li>动态代理类持有 MethodInterceptor</li>
<li>动态代理类会重写父类 Student 的非 final、private 方法；也会构建自己的方法（cglib 方法），构建方式：CGLIB”+“$父类方法名$</li>
<li>cglib 方法的方法体：super.方法名，直接调用父类；重写方法：它会调用拦截器中的 intercept() 方法</li>
<li>methodProxy.invokeSuper() 方法会调用动态代理类中的 cglib 方法；methodProxy.invoke() 方法会调用动态代理类中的重写方法</li>
</ul>
<h4 id="bytebuddy"><a href="#bytebuddy" class="headerlink" title="bytebuddy"></a>bytebuddy</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Byte Buddy本身也是基于 ASM API 实现的，是一个较高层级的抽象的字节码操作工具，通过使用 Byte Buddy ，任何熟悉 Java 编程语言的人都有望非常容易地进行字节码操作。</span><br></pre></td></tr></table></figure>

<p>增强案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.bytebuddy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.ByteBuddy;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.implementation.FixedValue;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.matcher.ElementMatcher;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.matcher.ElementMatchers;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 入门案例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteBuddy</span>()</span><br><span class="line">                <span class="comment">//指定父类</span></span><br><span class="line">                .subclass(Object.class)</span><br><span class="line">                <span class="comment">//指定生成的类名</span></span><br><span class="line">                .name(<span class="string">&quot;User&quot;</span>)</span><br><span class="line">                <span class="comment">//按名称拦截类的 toString</span></span><br><span class="line">                .method(ElementMatchers.named(<span class="string">&quot;toString&quot;</span>))</span><br><span class="line">                <span class="comment">//拦截方法调用 返回固定值</span></span><br><span class="line">                .intercept(FixedValue.value(<span class="string">&quot;HelloWorld&quot;</span>))</span><br><span class="line">                <span class="comment">//生成字节码</span></span><br><span class="line">                .make()</span><br><span class="line">                <span class="comment">//classloader 加载字节码到内存</span></span><br><span class="line">                .load(ByteBuddy.class.getClassLoader())</span><br><span class="line">                <span class="comment">//获得Class对象</span></span><br><span class="line">                .getLoaded()</span><br><span class="line">                .newInstance()</span><br><span class="line">                .toString();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>subclass(Object.class)</strong> ：创建一个Object的子类</li>
<li><strong>name(“ExampleClass”) :</strong> 新建的类名叫做“ExampleClass” ,暂时没有用到</li>
<li><strong>method()</strong> ：要拦截“ExampleClass”中的方法</li>
<li><strong>ElementMatchers.named(“toString”)</strong> ：拦截条件，拦截toString()这个方法, 没有条件，表示所有的方法</li>
<li><strong>intercept()</strong> ：指定了拦截到的方法要修改成什么样子，是不是和 Spring AOP有点像了</li>
<li><strong>make()</strong> ：创建上面生成的这个类型</li>
<li><strong>load()</strong> ：加载这个生成的类</li>
<li><strong>newInstance()</strong> ：Java 反射的API，创建实例</li>
</ul>
<p>在Byte buddy中默认提供了一个 dynamicType.saveIn() 方法，可以保存编译后的Class文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.proxy.bytebuddy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.ByteBuddy;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.dynamic.DynamicType;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.implementation.FixedValue;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.matcher.ElementMatchers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 保存class文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LookUpClassFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        DynamicType.Unloaded&lt;Object&gt; dynamicType = <span class="keyword">new</span> <span class="title class_">ByteBuddy</span>()</span><br><span class="line">                <span class="comment">// 指定父类</span></span><br><span class="line">                .subclass(Object.class)</span><br><span class="line">                <span class="comment">// 指定生成类的名称</span></span><br><span class="line">                .name(<span class="string">&quot;User&quot;</span>)</span><br><span class="line">                <span class="comment">// 按名称 拦截该类的 toString()</span></span><br><span class="line">                .method(ElementMatchers.named(<span class="string">&quot;toString&quot;</span>))</span><br><span class="line">                <span class="comment">// 拦截方法调用 返回固定值</span></span><br><span class="line">                .intercept(FixedValue.value(<span class="string">&quot;Hello World!!&quot;</span>))</span><br><span class="line">                <span class="comment">// 产生字节码</span></span><br><span class="line">                .make();</span><br><span class="line">        DynamicType.Loaded&lt;Object&gt; loaded = dynamicType.load(ByteBuddy.class.getClassLoader());</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(HelloWorld.class.getResource(<span class="string">&quot;./&quot;</span>).getPath());</span><br><span class="line">        dynamicType.saveIn(file);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> loaded.getLoaded().newInstance().toString();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其他API</strong></p>
<ul>
<li><p>defineMethod(“main”, String.class, Modifier.PUBLIC + Modifier.STATIC)，</p>
<p>定义方法；名称、返回类型、属性<em>public static void</em></p>
<p>Modifier.PUBLIC + Modifier.STATIC，这是一个是二进制相加，每一个类型都在二进制中占有一位。例如 1 2 4 8 … 对应的二进制占位 1111。既可以执行相加运算，并又能保留原有单元的属性。</p>
</li>
<li><p>withParameter(String[].class, “args”)，</p>
<p>定义参数；参数类型、参数名称</p>
</li>
<li><p>intercept(FixedValue.value(“Hello World!”))，</p>
<p>拦截设置返回值，但此时还能满足我们的要求。</p>
</li>
<li><p>defineField() 方法：创建字段。</p>
</li>
<li><p>implement() 方法：实现接口。</p>
</li>
</ul>
<h4 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Javassist 使操作Java字节码变得简单，一个可以用于编辑Java字节码的类库，提供了两种级别的API：源码级别和字节码级别。如果用户使用源码级API，他们可以在不需要过多了解Java字节码规范的前提下使用它提供的基于java语言的API来编辑字节码文件。如果使用字节码级API则允许用户直接编辑字节码文件。Javassist在复杂的字节码级操作上提供了更高级别的抽象层。另外Javassist使用了反射机制，这使得它在运行时比ASM慢。</span><br></pre></td></tr></table></figure>

<p><strong>类</strong></p>
<ul>
<li>ClassPool：javassist的类池，使用ClassPool 类可以跟踪和控制所操作的类，它的工作方式与 JVM 类装载器非常相似</li>
<li>CtClass： CtClass提供了类的操作，如在类中动态添加新字段、方法和构造函数、以及改变类、父类和接口的方法。</li>
<li>CtField：类的属性，通过它可以给类创建新的属性，还可以修改已有的属性的类型，访问修饰符等</li>
<li>CtMethod：类中的方法，通过它可以给类创建新的方法，还可以修改返回类型，访问修饰符等， 甚至还可以修改方法体内容代码</li>
<li>CtConstructor：与CtMethod类</li>
</ul>
<p><strong>API</strong></p>
<p>ClassPool</p>
<ul>
<li>ClassPool pool &#x3D; ClassPool.getDefault(); 类库, jvm中所加载的class</li>
<li>CtClass ctClass &#x3D; pool.get(“com.itheima.Student”); 加载一个已知的类, 注：参数必须为全量类名</li>
<li>CtClass tClass &#x3D; pool.makeClass(“com.itheima.Calculator”); 创建一个新的类, 类名必须为全量类名</li>
</ul>
<p>CtField</p>
<ul>
<li>CtField ctField &#x3D; ctClass.getDeclaredField(“name”); 获取已知类的属性</li>
<li>CtField ctFieldNew &#x3D; new CtField(CtClass.intType,“age”,ctClass); 构建新的类的成员变量</li>
<li>ctFieldNew.setModifiers(Modifier.PUBLIC); 设置类的访问修饰符为public</li>
<li>ctClass.addField(ctFieldNew); 将属性添加到类中</li>
</ul>
<p>CtMethod</p>
<ul>
<li><p>CtMethod ctMethod &#x3D; ctClass.getDeclaredMethod(“sayHello”); 获取已有方法</p>
</li>
<li><p>CtMethod ctMethod &#x3D; new CtMethod(CtClass.intType, “calc”, new CtClass[]{CtClass.intType,CtClass.intType}, tClass);创建新的方法, 参数1:方法的返回类型，参数2：名称，参数3：方法的参数，参数4：方法所属的类</p>
</li>
<li><p>ctMethod.setModifiers(Modifier.PUBLIC); 设置方法的访问修饰</p>
</li>
<li><p>ctClass.addMethod(ctMethod); 将新建的方法添加到类中</p>
</li>
<li><p>ctMethod.setBody(“return $1 + $2;”); 方法体内容代码 $1代表第一个参数，$2代表第二个参数</p>
</li>
<li><p>CtMethod getMethod &#x3D; CtNewMethod.make(“public int getAge() { return this.age;}”, ctClass); </p>
<p>CtMethod setMethod &#x3D; CtNewMethod.make(“public void setAge(int age) { this.age &#x3D; age;}”, ctClass);ctClass.addMethod(getMethod);ctClass.addMethod(setMethod);  直接创建方法</p>
</li>
</ul>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="jdk序列化"><a href="#jdk序列化" class="headerlink" title="jdk序列化"></a>jdk序列化</h4><p>被序列化的对象需要实现java.io.Serializable接口</p>
<h5 id="serialVersionUID的作用"><a href="#serialVersionUID的作用" class="headerlink" title="serialVersionUID的作用"></a>serialVersionUID的作用</h5><p>一句话：其目的是序列化对象版本控制，有关各版本反序列化时是否兼容。如果在新版本中这个值修改了，新版本就不兼容旧版本，反序列化时会抛出InvalidClassException异常。如果修改较小，比如仅仅是增加了一个属性，我们希望向下兼容，老版本的数据都能保留，那就不用修改；如果我们删除了一个属性，或者更改了类的继承关系，必然不兼容旧数据，这时就应该手动更新版本号，即SerialVersionUid。</p>
<p>serialVersionUID有两种显示的生成方式：</p>
<ul>
<li>一是默认的1L，比如：private static final long serialVersionUID &#x3D; 1L;</li>
<li>二是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，</li>
</ul>
<h5 id="静态变量的序列化"><a href="#静态变量的序列化" class="headerlink" title="静态变量的序列化"></a>静态变量的序列化</h5><p>静态变量不会被序列化。因为静态变量在全局区,本来流里面就没有写入静态变量,我打印静态变量当然会去全局区查找</p>
<h5 id="Transient-关键字作用"><a href="#Transient-关键字作用" class="headerlink" title="Transient 关键字作用"></a>Transient 关键字作用</h5><p>Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol>
<li>Java序列化只是针对对象的状态进行保存，至于对象中的方法，序列化不关心</li>
<li>当一个父类实现了序列化，那么子类会自动实现序列化，不需要显示实现序列化接口</li>
<li>当一个对象的实例变量引用了其他对象，序列化这个对象的时候会自动把引用的对象也进行序列化（实现深度克隆）</li>
<li>当某个字段被申明为transient后，默认的序列化机制会忽略这个字段</li>
<li>被申明为transient的字段，如果需要序列化，可以添加两个私有方法：writeObject和readObject</li>
</ol>
<h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><p>XML序列化的好处在于可读性好，方便阅读和调试。但是序列化以后的字节码文件比较大，而且效率不高，适用于对性能不高，而且QPS较低的企业级内部系统之间的数据交换的场景，同时XML又具有语言无关性，所以还可以用于异构系统之间的数据交换和协议。比如我们熟知的Webservice，就是采用XML格式对数据进行序列化的。XML序列化&#x2F;反序列化的实现方式有很多，熟知的方式有XStream和Java自带的XML序列化和反序列化两种。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.serialize.xml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gxl.serialize.jdk.User;</span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.XStream;</span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.io.xml.DomDriver;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLSerializer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;Mic&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        String xml=serialize(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化完成：&quot;</span>+xml);</span><br><span class="line">        User nuser=deserialize(xml);</span><br><span class="line">        System.out.println(nuser);    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">serialize</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XStream</span>(<span class="keyword">new</span> <span class="title class_">DomDriver</span>()).toXML(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User <span class="title function_">deserialize</span><span class="params">(String xml)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (User)<span class="keyword">new</span> <span class="title class_">XStream</span>(<span class="keyword">new</span> <span class="title class_">DomDriver</span>()).fromXML(xml);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，相对于XML来说，JSON的字节流更小，而且可读性也非常好。现在JSON数据格式在企业运用是最普遍的</p>
<p>JSON序列化常用的开源工具有很多</p>
<ol>
<li>Jackson （<a href="javascript:void(0)">https://github.com/FasterXML/jackson）</a></li>
<li>阿里开源的FastJson （<a href="javascript:void(0)">https://github.com/alibaba/fastjon）</a></li>
<li>Google的GSON (<a href="javascript:void(0)">https://github.com/google/gson</a>)</li>
</ol>
<p>这几种json序列化工具中，Jackson与fastjson要比GSON的性能要好，但是Jackson、GSON的稳定性要比Fastjson好。而fastjson的优势在于提供的api非常容易使用	</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.serialize.json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.gxl.serialize.jdk.User;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonSerializer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;Mic&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> serializer(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化完成：&quot;</span> + json);</span><br><span class="line">        <span class="type">User</span> <span class="variable">nuser</span> <span class="operator">=</span> deserializer(json);</span><br><span class="line">        System.out.println(nuser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">serializer</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User <span class="title function_">deserializer</span><span class="params">(String json)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (User) JSON.parseObject(json, User.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a><strong>Hessian</strong></h4><p>Hessian是一个支持跨语言传输的二进制序列化协议，相对于Java默认的序列化机制来说，Hessian具有更好的性能和易用性，而且支持多种不同的语言</p>
<p>实际上Dubbo采用的就是Hessian序列化来实现，只不过Dubbo对Hessian进行了重构，性能更高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.serialize.hessian;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.caucho.hessian.io.HessianInput;</span><br><span class="line"><span class="keyword">import</span> com.caucho.hessian.io.HessianOutput;</span><br><span class="line"><span class="keyword">import</span> com.gxl.serialize.jdk.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HessianSerializer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;Mic&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes = serializer(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化完成&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">nuser</span> <span class="operator">=</span> deserializer(bytes);</span><br><span class="line">        System.out.println(nuser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] serializer(User user) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>(); <span class="comment">//表示输出到内存的实现</span></span><br><span class="line">        <span class="type">HessianOutput</span> <span class="variable">ho</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianOutput</span>(bos);</span><br><span class="line">        ho.writeObject(user);</span><br><span class="line">        <span class="keyword">return</span> bos.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User <span class="title function_">deserializer</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(data);</span><br><span class="line">        <span class="type">HessianInput</span> <span class="variable">hi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianInput</span>(bis);</span><br><span class="line">        <span class="keyword">return</span> (User) hi.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Protobuf序列化"><a href="#Protobuf序列化" class="headerlink" title="Protobuf序列化"></a>Protobuf序列化</h4><p>Protobuf是Google的一种数据交换格式，它独立于语言、独立于平台。Google提供了多种语言来实现，比如Java、C、Go、Python，每一种实现都包含了相应语言的编译器和库文件，Protobuf是一个纯粹的表示层协议，可以和各种传输层协议一起使用。</p>
<p>Protobuf使用比较广泛，主要是空间开销小和性能比较好，非常适合用于公司内部对性能要求高的RPC调用。 另外由于解析性能比较高，序列化以后数据量相对较少，所以也可以应用在对象的持久化场景中</p>
<p>但是要使用Protobuf会相对来说麻烦些，因为他有自己的语法，有自己的编译器，如果需要用到的话必须要去投入成本在这个技术的学习中</p>
<blockquote>
<p>protobuf有个缺点就是要传输的每一个类的结构都要生成对应的proto文件，如果某个类发生修改，还得重新生成该类对应的proto文件</p>
</blockquote>
<p>使用protobuf开发的一般步骤是</p>
<ol>
<li>配置开发环境，安装protocol compiler代码编译器</li>
<li>编写.proto文件，定义序列化对象的数据结构</li>
<li>基于编写的.proto文件，使用protocol compiler编译器生成对应的序列化&#x2F;反序列化工具类</li>
<li>基于自动生成的代码，编写自己的序列化应用</li>
</ol>
<h5 id="安装protobuf编译工具"><a href="#安装protobuf编译工具" class="headerlink" title="安装protobuf编译工具"></a>安装protobuf编译工具</h5><p>下载对应操作系统使用的protobuf包</p>
<p>编写proto文件</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;com.gxl.serialize.protobuf&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;UserProtos&quot;</span>;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span> &#123;  </span><br><span class="line">  <span class="keyword">required</span> <span class="type">int32</span>  age = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据类型说明如下：</p>
<ul>
<li><p>enum 枚举类</p>
</li>
<li><p>string &#x2F; bytes &#x2F; bool &#x2F; int32（4个字节）&#x2F;int64&#x2F;float&#x2F;double</p>
</li>
<li><p>message 自定义类</p>
</li>
<li><p>修饰符</p>
<ul>
<li>required 表示必填字段</li>
<li>optional 表示可选字段</li>
<li>repeated 可重复，表示集合</li>
<li>1，2，3，4需要在当前范围内是唯一的，表示顺序</li>
</ul>
</li>
<li><p>生成实例类，在cmd中运行如下命令</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc.exe --java_out=./ ./User.proto</span><br></pre></td></tr></table></figure>

<p>将生成的java文件拷贝到指定目录中</p>
<p><strong>测试代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.serialize.protobuf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.protobuf.ByteString;</span><br><span class="line"><span class="keyword">import</span> com.google.protobuf.InvalidProtocolBufferException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-03-31</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtobufSerializer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvalidProtocolBufferException &#123;</span><br><span class="line">        UserProtos.<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> UserProtos.User.newBuilder().setName(<span class="string">&quot;Mic&quot;</span>).setAge(<span class="number">18</span>).build();</span><br><span class="line">        <span class="type">ByteString</span> <span class="variable">bytes</span> <span class="operator">=</span> user.toByteString();</span><br><span class="line">        System.out.println(bytes.toByteArray().length);</span><br><span class="line">        UserProtos.<span class="type">User</span> <span class="variable">nUser</span> <span class="operator">=</span> UserProtos.User.parseFrom(bytes);</span><br><span class="line">        System.out.println(nUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Protobuf序列化原理解析"><a href="#Protobuf序列化原理解析" class="headerlink" title="Protobuf序列化原理解析"></a>Protobuf序列化原理解析</h5><p>正常来说，要达到最小的序列化结果，一定会用到压缩的技术，而protobuf里面用到了两种压缩算法，一种是varint，另一种是zigzag</p>
<p>先说第一种，我们先来看【Mic】是怎么被压缩的“Mic”这个字符，需要根据ASCII对照表转化为数字。M &#x3D;77、i&#x3D;105、c&#x3D;99，所以结果为 77 105 99</p>
<p>varint是对字节码做压缩，但是如果这个数字的二进制只需要一个字节表示的时候，其实最终编码出来的结果是不会变化的。 如果出现需要大于一个字节的方式来表示，则需要进行压缩。</p>
<p>采用T - L - V 的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑</p>
]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper进阶篇</title>
    <url>/2023/03/02/Zookeeper%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>netty</title>
    <url>/2023/03/09/netty/</url>
    <content><![CDATA[<h2 id="JAVA-IO-模型"><a href="#JAVA-IO-模型" class="headerlink" title="JAVA IO 模型"></a>JAVA IO 模型</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>阻塞&#x2F;非阻塞：没有数据传过来时，读会阻塞直到有数据；缓冲区满时，写操作也会阻塞。非阻塞遇到这种情况直接返回</li>
<li>同步IO&#x2F;异步IO：数据就绪后需要自己去读是同步；数据就绪后系统直接读好回调给程序是异步</li>
</ul>
<h3 id="JAVA-BIO"><a href="#JAVA-BIO" class="headerlink" title="JAVA BIO"></a>JAVA BIO</h3><ol>
<li>BIO是blocking I&#x2F;O的简称，它是同步阻塞型IO，其相关的类和接口在java.io下</li>
<li>BIO模型简单来讲，就是服务端为每一个请求都分配一个线程进行处理，I&#x2F;O操作都是基于流Stream的操作</li>
</ol>
<h4 id="弊端："><a href="#弊端：" class="headerlink" title="弊端："></a>弊端：</h4><ul>
<li><strong>线程开销：</strong>客户端的的并发数和后端的并发数成1:1比例，线程的创建、销毁是非常消耗系统资源的，随着并发量增大，服务端性能显著下降，甚至会出现线程堆栈溢出等错误</li>
<li><strong>线程阻塞：</strong>当连接创建后如果该线程没有操作时，会进行阻塞操作，这样极大的浪费了服务器资源</li>
</ul>
<h3 id="JAVA-NIO-模型"><a href="#JAVA-NIO-模型" class="headerlink" title="JAVA NIO 模型"></a>JAVA NIO 模型</h3><ul>
<li>NIO，称之为New IO 或是 non-block IO （非阻塞IO），这两种说法都可以，其实称之为非阻塞IO更恰当一些</li>
<li>NIO的三大核心组件：<strong>Buffer（缓冲区）、Channel（通道）、Selector（选择器&#x2F;多路复用器）</strong></li>
</ul>
<h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p><strong>Buffer（缓冲区）：</strong></p>
<ul>
<li>Buffer是一个对象，包含一些要写入或者读出的数据，体现了与原I&#x2F;O的一个重要区别。在面向流的I&#x2F;O中，数据的读写是直接进入到stream中；在NIO中，所有数据都是用缓冲区处理的，读数据直接从缓冲区读，写数据直接写入到缓冲区。</li>
<li>缓冲区的本质是一个数组，通常是一个字节数组（ByteBuffer），也可以使用其他类型，但缓冲区又不仅仅是一个数组，它还提供了对数据结构化访问以及维护读写位置等操作。</li>
</ul>
<p><strong>Channel（通道）：</strong></p>
<ul>
<li>Channel 是一个通道，管道，网络数据通过Channel读取和写入，Channel和流Stream的不同之处在于Channel是双向的，流只在一个方向上移动（InputStream&#x2F;OutputStream），而Channel可以用于读写同时进行，即Channel是全双工的。</li>
</ul>
<p><strong>Selector（选择器&#x2F;多路复用器）：</strong></p>
<ul>
<li>Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，即该Channel处于就绪状态，它就会被Selector轮询出来，然后通过selectedKeys可以获取就绪Channel的集合，进行后续的I&#x2F;O操作。</li>
</ul>
<h3 id="JAVA-AIO模型"><a href="#JAVA-AIO模型" class="headerlink" title="JAVA AIO模型"></a>JAVA AIO模型</h3><p>AIO是asynchronous I&#x2F;O的简称，是异步IO，该异步IO是需要依赖于操作系统底层的异步IO实现。</p>
<p><strong>AIO的基本流程</strong>：用户线程通过系统调用，告知kernel内核启动某个IO操作，用户线程返回。kernel内核在整个IO操作（包括数据准备、数据复制）完成后，通知用户程序，用户执行后续的业务操作。</p>
<h2 id="Reactor-线程模型"><a href="#Reactor-线程模型" class="headerlink" title="Reactor 线程模型"></a>Reactor 线程模型</h2><p>Reactor线程模型不是Java专属，也不是Netty专属，它其实是一种并发编程模型，是一种思想，具有指导意义</p>
<p>Reactor模型中定义了三种角色：</p>
<ul>
<li><strong>Reactor</strong>：负责监听和分配事件，将I&#x2F;O事件分派给对应的Handler。新的事件包含连接建立就绪、读就绪、写就绪等。</li>
<li><strong>Acceptor</strong>：处理客户端新连接，并分派请求到处理器链中。</li>
<li><strong>Handler</strong>：将自身与事件绑定，执行非阻塞读&#x2F;写任务，完成channel的读入，完成处理业务逻辑后，负责</li>
<li>将结果写出channel</li>
</ul>
<h3 id="单Reactor-单线程"><a href="#单Reactor-单线程" class="headerlink" title="单Reactor-单线程"></a><strong>单Reactor-单线程</strong></h3><p>所有的接收连接，处理数据的相关操作都在一个线程中来完成，性能上有瓶颈</p>
<h3 id="单Reactor-多线程"><a href="#单Reactor-多线程" class="headerlink" title="单Reactor-多线程"></a><strong>单Reactor-多线程</strong></h3><p>把比较耗时的数据的编解码运算操作放入线程池中来执行，提升了性能但还不是最好的方式</p>
<h3 id="主从Reactor-多线程"><a href="#主从Reactor-多线程" class="headerlink" title="主从Reactor-多线程"></a><strong>主从Reactor-多线程</strong></h3><p>主从多线程，对于服务器来说，接收客户端的连接是比较重要的，因此将这部分操作单独用线程去操作</p>
<h4 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h4><ol>
<li>Reactor 主线程 MainReactor 对象通过 select 监听客户端连接事件，收到事件后，通过 Acceptor 处理客户端连接事件。</li>
<li>当 Acceptor 处理完客户端连接事件之后（与客户端建立好 Socket 连接），MainReactor 将连接分配给SubReactor。（即：MainReactor 只负责监听客户端连接请求，和客户端建立连接之后将连接交由SubReactor 监听后面的 IO 事件。）</li>
<li>SubReactor 将连接加入到自己的连接队列进行监听，并创建 Handler 对各种事件进行处理。</li>
<li>当连接上有新事件发生的时候，SubReactor 就会调用对应的 Handler 处理。</li>
<li>Handler 通过 read 从连接上读取请求数据，将请求数据分发给 Worker 线程池进行业务处理。</li>
<li>Worker 线程池会分配独立线程来完成真正的业务处理，并将处理结果返回给 Handler。Handler 通过send 向客户端发送响应数据</li>
<li>一个 MainReactor 可以对应多个 SubReactor，即一个 MainReactor 线程可以对应多个 SubReactor 线程</li>
</ol>
<h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><ul>
<li>MainReactor 线程与 SubReactor 线程的数据交互简单职责明确，MainReactor 线程只需要接收新连接，SubReactor 线程完成后续的业务处理。</li>
<li>MainReactor 线程与 SubReactor 线程的数据交互简单， MainReactor 线程只需要把新连接传给SubReactor 线程，SubReactor 线程无需返回数据。</li>
<li>多个 SubReactor 线程能够应对更高的并发请求。</li>
<li>这种模式的缺点是编程复杂度较高。但是由于其优点明显，在许多项目中被广泛使用，包括 Nginx、Memcached、Netty 等。</li>
<li>这种模式也被叫做服务器的 1+M+N 线程模式，即使用该模式开发的服务器包含一个（或多个，1 只是表示相对较少）连接建立线程+M 个 IO 线程+N 个业务处理线程。这是业界成熟的服务器程序设计模式。</li>
</ul>
<h2 id="Netty概述"><a href="#Netty概述" class="headerlink" title="Netty概述"></a>Netty概述</h2><ul>
<li>Netty是由JBOSS提供的一个java开源框架，现为 Github上的独立项目。Netty提供非阻塞的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。</li>
</ul>
<h3 id="Netty中的Reactor实现"><a href="#Netty中的Reactor实现" class="headerlink" title="Netty中的Reactor实现"></a>Netty中的Reactor实现</h3><p>Netty线程模型是基于Reactor模型实现的，对Reactor三种模式都有非常好的支持，并做了一定的改进，也非常的灵活，一般情况，在服务端会采用主从架构模型。</p>
<p><strong>工作流程：</strong></p>
<ol>
<li><p>Netty 抽象出两组线程池：BossGroup 和 WorkerGroup，每个线程池中都有EventLoop 线程（可以OIO,NIO,AIO）。BossGroup中的线程专门负责和客户端建立连接，WorkerGroup 中的线程专门负责处理连接上的读写, EventLoopGroup 相当于一个事件循环组，这个组中含有多个事件循环。</p>
</li>
<li><p>EventLoop 表示一个不断循环的执行事件处理的线程，每个EventLoop 都包含一个 Selector，用于监听注册在其上的 Socket 网络连接（Channel）。</p>
</li>
<li><p>每个 BossEventLoop 中循环执行以下三个步骤：</p>
<p>1）select：轮训注册在其上的 ServerSocketChannel 的 accept 事件（OP_ACCEPT 事件）</p>
<p>2）processSelectedKeys：处理 accept 事件，与客户端建立连接，生成一个SocketChannel，并将其注册到某个 WorkerEventLoop 上的 Selector 上</p>
<p>3）runAllTasks：再去以此循环处理任务队列中的其他任务</p>
</li>
<li><p>每个 Worker EventLoop 中循环执行以下三个步骤：</p>
<p>1）select：轮训注册在其上的SocketChannel 的 read&#x2F;write 事件（OP_READ&#x2F;OP_WRITE 事件）</p>
<p>2）processSelectedKeys：在对应的SocketChannel 上处理 read&#x2F;write 事件</p>
<p>3）runAllTasks：再去以此循环处理任务队列中的其他任务</p>
</li>
<li><p>在以上两个processSelectedKeys步骤中，会使用 Pipeline（管道），Pipeline 中引用了 Channel，即通过Pipeline 可以获取到对应的 Channel，Pipeline 中维护了很多的处理器（拦截处理器、过滤处理器、自定义处理器等）。</p>
</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li>Netty 的线程模型基于主从多Reactor模型。通常由一个线程负责处理OP_ACCEPT事件，拥有 CPU 核数的两倍的IO线程处理读写事件</li>
<li>一个通道的IO操作会绑定在一个IO线程中，而一个IO线程可以注册多个通道</li>
<li>在一个网络通信中通常会包含网络数据读写，编码、解码、业务处理。默认情况下网络数据读写，编码、解码等操作会在IO线程中运行，但也可以指定其他线程池。</li>
<li>通常业务处理会单独开启业务线程池（看业务类型），但也可以进一步细化，例如心跳包可以直接在IO线程中处理，而需要再转发给业务线程池，避免线程切换</li>
<li>在一个IO线程中所有通道的事件是串行处理的。</li>
<li>通常业务操作会专门开辟一个线程池，那业务处理完成之后，如何将响应结果通过 IO 线程写入到网卡中呢？业务线程调用 Channel对象的 write 方法并不会立即写入网络，只是将数据放入一个待写入缓存区，然后IO线程每次执行事件选择后，会从待写入缓存区中获取写入任务，将数据真正写入到网络中</li>
</ul>
<h2 id="Pipeline-和-Handler"><a href="#Pipeline-和-Handler" class="headerlink" title="Pipeline 和 Handler"></a>Pipeline 和 Handler</h2><h3 id="ChannelPipeline-amp-ChannelHandler"><a href="#ChannelPipeline-amp-ChannelHandler" class="headerlink" title="ChannelPipeline &amp; ChannelHandler"></a>ChannelPipeline &amp; ChannelHandler</h3><ul>
<li>ChannelPipeline 提供了 ChannelHandler 链的容器。以服务端程序为例，客户端发送过来的数据要接收，读取处理，我们称数据是入站的，需要经过一系列Handler处理后；如果服务器想向客户端写回数据，也需要经过一系列Handler处理，我们称数据是出站的。</li>
</ul>
<h3 id="ChannelHandler-分类"><a href="#ChannelHandler-分类" class="headerlink" title="ChannelHandler 分类"></a>ChannelHandler 分类</h3><p>对于数据的出站和入站，有着不同的ChannelHandler类型与之对应：</p>
<ol>
<li>ChannelInboundHandler 入站事件处理器</li>
<li>ChannelOutBoundHandler 出站事件处理器</li>
<li>ChannelHandlerAdapter提供了一些方法的默认实现，可减少用户对于ChannelHandler的编写</li>
<li>ChannelDuplexHandler：混合型，既能处理入站事件又能处理出站事件</li>
</ol>
<h3 id="ChannelHandler-体系结构"><a href="#ChannelHandler-体系结构" class="headerlink" title="ChannelHandler 体系结构"></a>ChannelHandler 体系结构</h3><ol>
<li>inbound入站事件处理顺序（方向）是由链表的头到链表尾，outbound事件的处理顺序是由链表尾到链表头。</li>
<li>inbound入站事件由netty内部触发，最终由netty外部的代码消费。</li>
<li>outbound事件由netty外部的代码触发，最终由netty内部消费。</li>
</ol>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><ul>
<li>InboundHandler是按照Pipleline的加载顺序(addLast)，<strong>顺序</strong>执行</li>
<li>OutboundHandler是按照Pipeline的加载顺序(addLast)，<strong>逆序</strong>执行</li>
</ul>
<h3 id="回写数据事件流转规则"><a href="#回写数据事件流转规则" class="headerlink" title="回写数据事件流转规则"></a>回写数据事件流转规则</h3><ul>
<li>如果是通过Channel对象进行数据回写，事件会从pipeline尾部流向头部</li>
<li>如果是通过ChannelHandlerContext对象进行数据回写，事件会从当前handler流向头部</li>
<li>问题：OutboundHandler和InboundHandler的先后顺序是否有要求？才能保证所有outboundHandler能被执行</li>
</ul>
<h2 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h2><ul>
<li><p>Bootstrap是引导的意思，它的作用是配置整个Netty程序，将各个组件都串起来，最后绑定端口、启动Netty服务</p>
</li>
<li><p>Netty中提供了2种类型的引导类，一种用于客户端(Bootstrap)，而另一种(ServerBootstrap)用于服务器，区别在于：</p>
<p>1、ServerBootstrap 将绑定到一个端口，因为服务器必须要监听连接，而 Bootstrap 则是由想要连接到远程	  节点的客户端应用程序所使用的</p>
<p>2、引导一个客户端只需要一个EventLoopGroup，但是一个ServerBootstrap则需要两个</p>
</li>
</ul>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul>
<li>Netty中的Channel是与网络套接字相关的，可以理解为是socket连接，在客户端与服务端连接的时候就会建立一个Channel，它负责基本的IO操作，比如：bind()、connect()，read()，write() 等</li>
</ul>
<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ol>
<li>通过Channel可获得当前网络连接的通道状态。</li>
<li>通过Channel可获得网络连接的配置参数（缓冲区大小等）。</li>
<li>Channel提供异步的网络I&#x2F;O操作，比如连接的建立、数据的读写、端口的绑定等。</li>
</ol>
<p>不同协议、不同的I&#x2F;O类型的连接都有不同的 Channel 类型与之对应</p>
<h2 id="EventLoopGroup-amp-EventLoop"><a href="#EventLoopGroup-amp-EventLoop" class="headerlink" title="EventLoopGroup&amp;EventLoop"></a>EventLoopGroup&amp;EventLoop</h2><ul>
<li>Netty是基于事件驱动的，比如：连接注册，连接激活；数据读取；异常事件等等，有了事件，就需要一个组件去监控事件的产生和事件的协调处理，这个组件就是EventLoop（事件循环&#x2F;EventExecutor），在Netty 中每个Channel 都会被分配到一个 EventLoop。一个 EventLoop 可以服务于多个 Channel。每个EventLoop 会占用一个 Thread，同时这个 Thread 会处理 EventLoop 上面发生的所有 IO 操作和事件。</li>
<li>EventLoopGroup 是用来生成 EventLoop 的，包含了一组EventLoop（可以初步理解成Netty线程池）</li>
</ul>
<h2 id="ChannelHandler-amp-amp-ChannelHandlerContext-amp-amp-ChannelPipeline"><a href="#ChannelHandler-amp-amp-ChannelHandlerContext-amp-amp-ChannelPipeline" class="headerlink" title="ChannelHandler&amp;&amp;ChannelHandlerContext&amp;&amp;ChannelPipeline"></a>ChannelHandler&amp;&amp;ChannelHandlerContext&amp;&amp;ChannelPipeline</h2><ul>
<li><strong>@Sharable</strong> 可以被复用，至于线程安全问题需要开发者自行保证</li>
<li>继承SimpleChannelInboundHandler需要重写channelRead0方法，且可以通过泛型指定msg类型</li>
<li>SimpleChannelInboundHandler在接收到数据后会自动release掉数据占用的Bytebuffer资源</li>
<li>注意事项：服务端异步处理数据，服务端想把客户端发送来的数据再写回等等场景下最好不要继承SimpleChannelInboundHandler</li>
<li>客户端推荐使用SimpleChannelInboundHandler，服务端看场景</li>
</ul>
<h2 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h2><h3 id="概念和作用"><a href="#概念和作用" class="headerlink" title="概念和作用"></a>概念和作用</h3><ul>
<li>Java NIO 提供了ByteBuffer 作为它的字节容器，但是这个类使用起来过于复杂，而且也有些繁琐。Netty使用ByteBuf来替代ByteBuffer，它是一个强大的实现，既解决了JDK API 的局限性， 又为网络应用程序的开发者提供了更好的API</li>
<li>从结构上来说，ByteBuf 由一串字节数组构成。数组中每个字节用来存放信息，ByteBuf提供了两个索引，一个用于读取数据（readerIndex ），一个用于写入数据（writerIndex）。这两个索引通过在字节数组中移动，来定位需要读或者写信息的位置。而JDK的ByteBuffer只有一个索引，因此需要使用flip方法进行读写切换</li>
</ul>
<h3 id="ByteBuf的三个指针"><a href="#ByteBuf的三个指针" class="headerlink" title="ByteBuf的三个指针"></a>ByteBuf的三个指针</h3><ul>
<li>readerIndex：指示读取的起始位置， 每读取一个字节， readerIndex自增累加1。 如果readerIndex 与writerIndex 相等，ByteBuf 不可读。</li>
<li>writerIndex：指示写入的起始位置， 每写入一个字节， writeIndex自增累加1。如果增加到 writerIndex 与capacity（） 容量相等，表示 ByteBuf 已经不可写，但是这个时候，并不代表不能往 ByteBuf 中写数据了， 如果发现往ByteBuf 中写数据写不进去的话，Netty 会自动扩容 ByteBuf，直到扩容到底层的内存大小为 maxCapacity</li>
<li>maxCapacity：指示ByteBuf 可以扩容的最大容量， 如果向ByteBuf写入数据时， 容量不足， 可以进行扩容的最大容量</li>
</ul>
<h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><ul>
<li><p>capacity()：表示 ByteBuf 底层占用了多少字节的内存（包括丢弃的字节、可读字节、可写字节），不同的底层实现机制有不同的计算方式。</p>
</li>
<li><p>maxCapacity()： ByteBuf 底层最大能够占用多少字节的内存，当向 ByteBuf 中写数据的时候，如果发现容量不足，则进行扩容，直到扩容到 maxCapacity，超过这个数，就抛异常。</p>
</li>
<li><p>readableBytes() 与 isReadable()：readableBytes() 表示 ByteBuf 当前可读的字节数，它的值等于writerIndex-readerIndex，如果两者相等，则不可读，isReadable() 方法返回 false</p>
</li>
<li><p>writableBytes()、 isWritable() 、maxWritableBytes()：writableBytes() 表示 ByteBuf 当前可写的字节数，它的值等于 capacity()-writerIndex，如果两者相等，则表示不可写，isWritable() 返回 false，但是这个时候，并不代表不能往 ByteBuf 中写数据了， 如果发现往ByteBuf 中写数据写不进去的话，Netty 会自动扩容 ByteBuf，直到扩容到底层的内存大小为 maxCapacity，而 maxWritableBytes() 就表示可写的最大字节数，它的值等于maxCapacity-writerIndex。</p>
</li>
<li><p>readerIndex() 与 readerIndex(int readerIndex)：前者表示返回当前的读指针 readerIndex, 后者表示设置读指针</p>
</li>
<li><p>writeIndex() 与 writeIndex(int writerIndex)：前者表示返回当前的写指针 writerIndex, 后者表示设置写指针</p>
</li>
<li><p>markReaderIndex() 与markWriterIndex()：表示把当前的读指针&#x2F;写指针保存起来，操作形式为：markedReaderIndex &#x3D; readerIndex &#x2F; markedWriterIndex &#x3D; writerIndex;</p>
</li>
<li><p>writeBytes(byte[] src)： 表示把字节数组 src 里面的数据全部写到 ByteBuf，src字节数组大小的长度通常小于等于writableBytes()</p>
</li>
<li><p>readBytes(byte[] dst)：把 ByteBuf 里面的数据全部读取到 dst，dst 字节数组的大小通常等于 readableBytes()</p>
</li>
<li><p>writeByte(int value)、readByte()：writeByte() 表示往 ByteBuf 中写一个字节，而 readByte() 表示从 ByteBuf 中读取一个字节，类似的 API 还有 writeBoolean()、writeChar()、writeShort()、writeInt()、writeLong()、writeFloat()、writeDouble() 与 readBoolean()、readChar()、readShort()、readInt()、readLong()、readFloat()、readDouble() 等等</p>
</li>
<li><p>discardReadBytes()： 丢弃已读取的字节空间，可写空间变多</p>
</li>
<li><p>clear()：重置readerIndex 、 writerIndex 为0，需要注意的是，重置并没有删除真正的内容</p>
</li>
<li><p>release()：真正去释放bytebuf中的数据，</p>
</li>
<li><p>ReferenceCountUtil.release(buf)：工具方法，内部还是调用release()</p>
</li>
</ul>
<h3 id="ByteBuf三类使用模式"><a href="#ByteBuf三类使用模式" class="headerlink" title="ByteBuf三类使用模式"></a>ByteBuf三类使用模式</h3><ul>
<li>堆缓冲区（HeapByteBuf）：内存分配在jvm堆，分配和回收速度比较快，可以被JVM自动回收，缺点是，如果进行socket的IO读写，需要额外做一次内存复制，将堆内存对应的缓冲区复制到内核Channel中，性能会有一定程度的下降。由于在堆上被 JVM 管理，在不被使用时可以快速释放。可以通过 ByteBuf.array() 来获取 byte[] 数据。</li>
<li>直接缓冲区（DirectByteBuf）：内存分配的是堆外内存（系统内存），相比堆内存，它的分配和回收速度会慢一些，但是将它写入或从Socket Channel中读取时，由于减少了一次内存拷贝，速度比堆内存块。</li>
<li>复合缓冲区（CompositeByteBuf）：顾名思义就是将两个不同的缓冲区从逻辑上合并，让使用更加方便。</li>
<li>Netty默认使用的是DirectByteBuf，如果需要使用HeapByteBuf模式，则需要进行系统参数的设置</li>
</ul>
<h3 id="ByteBuf-的分配器"><a href="#ByteBuf-的分配器" class="headerlink" title="ByteBuf 的分配器"></a>ByteBuf 的分配器</h3><p><strong>BufAllocator：</strong></p>
<p>Netty 提供了两种 ByteBufAllocator 的实现，分别是：</p>
<ul>
<li><p>PooledByteBufAllocator：实现了 ByteBuf 的对象的池化，提高性能减少并最大限度地减少内存碎片，池化思想通过预先申请一块专用内存地址作为<strong>内存池</strong>进行管理，从而不需要每次都进行分配和释放</p>
</li>
<li><p>UnpooledByteBufAllocator：没有实现对象的池化，每次会生成新的对象实例</p>
</li>
<li><p>对于Pooled类型的ByteBuf，不管是PooledDirectByteBuf还是PooledHeapByteBuf都只能由Netty内部自己使用（构造是私有和受保护的），开发者可以使用Unpooled类型的ByteBuf。</p>
</li>
<li><p>Netty提供Unpooled工具类创建的ByteBuf都是unpooled类型，默认采用的Allocator是direct类型；当然用户可以自己选择创建UnpooledDirectByteBuf和UnpooledHeapByteBuf</p>
</li>
</ul>
<h3 id="ByteBuf-的释放"><a href="#ByteBuf-的释放" class="headerlink" title="ByteBuf 的释放"></a>ByteBuf 的释放</h3><ul>
<li><p>ByteBuf如果采用的是堆缓冲区模式的话，可以由GC回收，但是如果采用的是直接缓冲区，就不受GC的管理，就得手动释放，否则会发生内存泄露，Netty自身引入了引用计数，提供了ReferenceCounted接口，当对象的引用计数&gt;0时要保证对象不被释放，当为0时需要被释放</p>
</li>
<li><p>手动释放，就是在使用完成后，调用ReferenceCountUtil.release(byteBuf); 进行释放，这种方式的弊端就是一旦忘记释放就可能会造成内存泄露</p>
</li>
<li><p>自动释放有三种方式，分别是：</p>
<p>1）入站的TailHandler（TailContext）、继SimpleChannelInboundHandler、HeadHandler（HeadContext）的出站释放</p>
<p>2）TailContext：Inbound流水线的末端，如果前面的handler都把消息向后传递最终由TailContext释放该消息，需要注意的是，如果没有进行向下传递，是不会进行释放操作的</p>
<p>3）SimpleChannelInboundHandler：自定义的InboundHandler继承自SimpleChannelInboundHandler，在SimpleChannelInboundHandler中自动释放</p>
<p>4）HeadContext：outbound流水线的末端，出站消息一般是由应用所申请，到达最后一站时，经过一轮复杂的调用，在flush完成后终将被release掉</p>
</li>
</ul>
<p><strong>对于入站消息：</strong></p>
<ul>
<li>对原消息不做处理，依次调用 ctx.fireChannelRead(msg)把原消息往下传，如果能到TailContext，那不用做什么释放，它会自动释放</li>
<li>将原消息转化为新的消息并调用 ctx.fireChannelRead(newMsg)往下传，那需要将原消息release掉</li>
<li>如果已经不再调用ctx.fireChannelRead(msg)传递任何消息，需要把原消息release掉。</li>
</ul>
<p><strong>对于出站消息</strong>：则无需用户关心，消息最终都会走到HeadContext，flush之后会自动释放。</p>
<h2 id="Future-amp-Promise"><a href="#Future-amp-Promise" class="headerlink" title="Future &amp; Promise"></a>Future &amp; Promise</h2><p><strong>Netty的异步编程模型</strong></p>
<ul>
<li>future和promise，目的是将值（future）与其计算方式（promise）分离，从而允许更灵活地进行计算，特别是通过并行化。Future 表示目标计算的返回值，Promise 表示计算的方式，这个模型将返回结果和计算逻辑分离，目的是为了让计算逻辑不影响返回结果，从而抽象出一套异步编程模型。而计算逻辑与结果关联的纽带就是 callback。</li>
<li>Netty中有非常多的异步调用，譬如：client&#x2F;server的启动，连接，数据的读写等操作都是支持异步的。</li>
</ul>
<h3 id="Netty-ChannelFuture"><a href="#Netty-ChannelFuture" class="headerlink" title="Netty ChannelFuture"></a>Netty ChannelFuture</h3><p>ChannelFuture：跟Channel的操作有关，Netty中的Handler处理都是异步IO，通过ChannelFuture添加事件监听，可获取Channel异步IO操作的结果；当然也可等待获取，但最好不要在handler中通过future的sync或await来获取异步操作的结果。</p>
<h3 id="Netty-ChannelPromise"><a href="#Netty-ChannelPromise" class="headerlink" title="Netty ChannelPromise"></a>Netty ChannelPromise</h3><p>1、Promise机制</p>
<ul>
<li>Netty的Future，只是增加了监听器。整个异步的状态，是不能进行设置和修改的，于是Netty的 Promise接口扩展了Netty的Future接口，可以设置异步执行的结果。在IO操作过程，如果顺利完成、或者发生异常，都可以设置Promise的结果，并且通知Promise的Listener们。</li>
</ul>
<p>2、ChannelPromise接口，则继承扩展了Promise和ChannelFuture。所以，ChannelPromise既绑定了  Channel，又具备了设置监听回调的功能，还可以设置IO操作的结果，是Netty实际编程使用的最多的接口。</p>
<h2 id="Netty-消息编解码器"><a href="#Netty-消息编解码器" class="headerlink" title="Netty 消息编解码器"></a>Netty 消息编解码器</h2><h3 id="一次编解码"><a href="#一次编解码" class="headerlink" title="一次编解码"></a>一次编解码</h3><p>主要解决TCP粘包，半包问题</p>
<p>主要分为三种：</p>
<ol>
<li>固定长度（FixedLengthFrameDecoder）</li>
<li>分隔符（DelimiterBasedFrameDecoder）</li>
<li>固定长度字段存消息长度 （LengthFieldBasedFrameDecoder）（推荐使用）</li>
</ol>
<h3 id="二次编解码"><a href="#二次编解码" class="headerlink" title="二次编解码"></a>二次编解码</h3><ul>
<li>我们把解决半包粘包问题的常用三种解码器叫一次解码器，其作用是将原始数据流(可能会出现粘包和半包的数据流)转换为用户数据(ByteBuf中存储)，但仍然是字节数据，所以我们需要二次解码器将字节数组转换为java对象，或者将将一种格式转化为另一种格式，方便上层应用程序使用。</li>
<li>一次解码器继承自：ByteToMessageDecoder；二次解码器继承自：MessageToMessageDecoder；但他们的本质都是继承ChannelInboundHandlerAdapter</li>
</ul>
<h4 id="二次编解码方式"><a href="#二次编解码方式" class="headerlink" title="二次编解码方式"></a><strong>二次编解码方式</strong></h4><p>用户数据(ByteBuf )和 Java Object之间的转换，或者将将一种格式转化为另一种格式（譬如将应用数据转化成某种协议数据）。</p>
<ul>
<li>Java 序列化：不推荐使用，占用空间大，也只有java语言能用</li>
<li>Marshaling：比java序列化稍好</li>
<li>XML ：可读性好，但是占用空间大</li>
<li>JSON ：可读性也好，空间较小</li>
<li>MessagePack ：占用空间比JSON小，可读性不如JSON，但也还行</li>
<li>Protobuf ：性能高，体积小，但是可读性差</li>
<li>hessian ：跨语言、高效的二进制序列化协议，整体性能和protobuf差不多。</li>
<li>其他</li>
</ul>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2022/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">线性结构分为两种数据存储方式，一种是顺序存储，一种链式存储</span><br></pre></td></tr></table></figure>

<h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><p><strong>API设计</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>SequenceList</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>SequenceList(int capacity)：创建容量为capacity的SequenceList对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public void clear()：空置对象<br>2.public boolean isEmpty()：判断线性表是否为空，是返回true，否返回false<br>3.public int length():获取线性表中元素的个数<br>4.public T get(int i):读取并返回线性表中的第i个元素的值<br>5.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。<br>6.public void insert(T t):向线性表中添加一个元素t<br>7.public T remove(int i):删除并返回线性表中第i个数据元素。<br>8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回1</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] eles：存储元素的数组<br>2.private int N:当前线性表的长度</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 顺序数据结果实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-12-18</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequenceList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> T[] eles;</span><br><span class="line">    <span class="comment">//当前线性表长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SequenceList</span><span class="params">(<span class="type">int</span> capcity)</span>&#123;</span><br><span class="line">        eles = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capcity];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空置对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断线性表是否为空，是返回true，否返回false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取线性表中元素的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取并返回线性表中的第i个元素的值</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;当前元素不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eles[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在线性表的第i个元素之前插入一个值为t的数据元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> i,T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;插入位置不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(N== eles.length)&#123;</span><br><span class="line">            resize(<span class="number">2</span>*N);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把i位置空出来，i位置及其后面元素一次后移一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N;index&gt;i;index--)&#123;</span><br><span class="line">            eles[index] = eles[index-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把i位置赋值</span></span><br><span class="line">        eles[i] = t;</span><br><span class="line">        <span class="comment">//数量加1</span></span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向线性表中添加一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N== eles.length)&#123;</span><br><span class="line">            resize(<span class="number">2</span>*N);</span><br><span class="line">        &#125;</span><br><span class="line">        eles[N++] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除并返回线性表中第i个数据元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">remove</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;插入位置不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录i位置元素</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> eles[i];</span><br><span class="line">        <span class="comment">//i位置后面的元素都向前一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> index=i;index&lt;N-<span class="number">1</span>;index++)&#123;</span><br><span class="line">            eles[index] = eles[index+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前元素数量-1</span></span><br><span class="line">        N--;</span><br><span class="line">        <span class="comment">//当元素已经不足数组大小的1/4,则重置数组的大小</span></span><br><span class="line">        <span class="keyword">if</span> (N&gt;<span class="number">0</span>&amp;&amp;N&lt; eles.length/<span class="number">4</span>)&#123;</span><br><span class="line">            resize(eles.length/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;查找元素不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eles[i].equals(t))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> cur;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SIterator</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.cur=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cur&lt;N;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> eles[cur++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现扩容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newSize)</span>&#123;</span><br><span class="line">        T[] temp = eles;</span><br><span class="line">        eles = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[newSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            eles[i]=temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取数组长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> eles.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h5 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h5><p>单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据，</p>
<p>指针域用来指向其后继结点。链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。</p>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>LinkList</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>LinkList()：创建LinkList对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public void clear()：空置链表 <br>2.public boolean isEmpty()：判断线性表是否为空，是返回true，否返回false<br>3.public int length():获取线性表中元素的个数<br>4.public T get(int i):读取并返回线性表中的第i个元素的值<br>5.public void insert(T t)：往线性表中添加一个元素；<br>6.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。<br>7.public T remove(int i):删除并返回线性表中第i个数据元素。<br>8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1</td>
</tr>
<tr>
<td>成员内部类</td>
<td>private class Node:结点类</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node head:记录首结点<br>2.private int N:记录链表的长度</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.dc.pr.PRError;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 单向链表API实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-12-29</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkList</span><span class="params">()</span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空置链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">        head.next=<span class="literal">null</span>;</span><br><span class="line">        head.item=<span class="literal">null</span>;</span><br><span class="line">        N=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断线性表是否为空，是返回true，否返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N==<span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取线性表中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;位置不合法！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往线性表中添加一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//找到最后一个结点</span></span><br><span class="line">        <span class="keyword">while</span> (n.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建新结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t,<span class="literal">null</span>);</span><br><span class="line">        n.next = newNode;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在线性表的第i个元素之前插入一个值为t的数据元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> i,T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;位置不合法！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到i结点的上一个结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">//创建新结点并把next结点赋值为i结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t,temp);</span><br><span class="line">        <span class="comment">//将上个结点的next指向新结点</span></span><br><span class="line">        node.next = newNode;</span><br><span class="line">        <span class="comment">//数量加1</span></span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除并返回线性表中第i个数据元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">remove</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;位置不合法！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到i结点的上一个结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> node.next;</span><br><span class="line">        node.next=cur.next;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> cur.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; node.next!=<span class="literal">null</span>; i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="keyword">if</span> (t.equals(cur.item))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Node node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LIterator</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.node=head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node.next!=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            <span class="keyword">return</span> node.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结点类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T item;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T item, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = item;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><p>双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用</p>
<p>来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存</p>
<p>储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。</p>
<p><strong>结点API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Node</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(T t,Node pre,Node next)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>T item:存储数据<br>Node next：指向下一个结点<br>Node pre:指向上一个结点</td>
</tr>
</tbody></table>
<p><strong>双向链表API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>TwoWayLinkList</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>TwoWayLinkList()：创建TwoWayLinkList对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public void clear()：空置链表 <br>2.public boolean isEmpty()：判断线性表是否为空，是返回true，否返回false<br>3.public int length():获取线性表中元素的个数<br>4.public T get(int i):读取并返回线性表中的第i个元素的值<br>5.public void insert(T t)：往线性表中添加一个元素；<br>6.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。<br>7.public T remove(int i):删除并返回线性表中第i个数据元素。<br>8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1<br>9.public T getFirst():获取第一个元素<br>10.public T getLast():获取最后一个元素</td>
</tr>
<tr>
<td>成员内部类</td>
<td>private class Node:结点类</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node head:记录首结点<br>2.private Node last:记录尾结点<br>3.private int N:记录链表的长度</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 双向链表API实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-12-30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoWayLinkList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录首结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录尾结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录链表的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TwoWayLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空置链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">        head.next = last;</span><br><span class="line">        head.pre = <span class="literal">null</span>;</span><br><span class="line">        head.item = <span class="literal">null</span>;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断线性表是否为空，是返回true，否返回false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取线性表中元素的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取并返回线性表中的第i个元素的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;查找位置不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往线性表中添加一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (last==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果当前链表为空</span></span><br><span class="line">            <span class="comment">//直接将尾结点赋值，并将head和last连接</span></span><br><span class="line">            last = <span class="keyword">new</span> <span class="title class_">Node</span>(t,head,<span class="literal">null</span>);</span><br><span class="line">            head.next = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果链表尾结点存在值，创建新的结点连接到原尾结点，并将新结点赋值给尾结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">oldLastNode</span> <span class="operator">=</span> last;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t,oldLastNode,<span class="literal">null</span>);</span><br><span class="line">            oldLastNode.next = node;</span><br><span class="line">            last = node;</span><br><span class="line">        &#125;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在线性表的第i个元素之前插入一个值为t的数据元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> i,T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;查找位置不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先找到i结点前置结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到i结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="comment">//创建新结点，前置结点为原前置结点，后置结点为原i位置结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t,pre,cur);</span><br><span class="line">        <span class="comment">//原前置结点next指向新结点</span></span><br><span class="line">        pre.next = n;</span><br><span class="line">        <span class="comment">//原i结点前置指向n</span></span><br><span class="line">        cur.pre = n;</span><br><span class="line">        <span class="comment">//数量加1</span></span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除并返回线性表中第i个数据元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">remove</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;N)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;查找位置不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先找到i结点前置结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到i结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="comment">//找到i结点的后置结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        <span class="comment">//将前置结点和后置结点连接</span></span><br><span class="line">        pre.next = next;</span><br><span class="line">        next.pre = pre;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> cur.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; node.next!=<span class="literal">null</span> ; i++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            <span class="keyword">if</span> (node.item.equals(t))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取第一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取最后一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n.next!=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">            <span class="keyword">return</span> n.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 存储数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> T item;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 指向下一个结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Node pre;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 指向上一个结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T t,Node pre,Node next)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.item = t;</span><br><span class="line">            <span class="built_in">this</span>.pre = pre;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h5><p>使用递归方式实现链表的反转</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (N==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="comment">//当前列表为空，不需要反转</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       reverse(head.next);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Node <span class="title function_">reverse</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node.next==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="comment">//说明已经到最后一个结点，将头结点指向当前结点</span></span><br><span class="line">           head.next = node;</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//递归调用2反转方法</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> reverse(node.next);</span><br><span class="line">       <span class="comment">//将返回结点后置结点指向当前结点</span></span><br><span class="line">       pre.next = node;</span><br><span class="line">       <span class="comment">//当前结点后置结点置为null</span></span><br><span class="line">       node.next = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h5><p>快慢指针指的是定义两个指针，这两个指针的移动速度一块一慢，以此来制造出自己想要的差值，这个差值可以然</p>
<p>我们找到链表上相应的结点。一般情况下，快指针的移动步长为慢指针的两倍</p>
<p><strong>中间值问题</strong></p>
<p>定义一个链表，想获取中间值</p>
<p>使用快慢指针解决，定义两个指针，一个指针的步长为另一个指针的步长的二倍，当快指针到达尾部，慢指针停在的位置即为中间位置</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getMid</span><span class="params">(Node&lt;String&gt; first)</span>&#123;</span><br><span class="line">       Node&lt;String&gt; slow = first;</span><br><span class="line">       Node&lt;String&gt; fast = first;</span><br><span class="line">       <span class="keyword">while</span> (slow.next!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">           fast = fast.next.next;</span><br><span class="line">           slow = slow.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> slow.item;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>单向链表是否有环问题</strong></p>
<p>使用快慢指针，如果一个环状链表，两个速度有差异的指针一定会相遇</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCircle</span><span class="params">(Node&lt;String&gt; first)</span>&#123;</span><br><span class="line">    Node&lt;String&gt; slow = first;</span><br><span class="line">    Node&lt;String&gt; fast = first;</span><br><span class="line">    <span class="keyword">while</span> (slow.next!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        fast = first.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast.equals(slow))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>有环链表入口问题</strong></p>
<p>当快慢指针相遇时，我们可以判断到链表中有环，这时重新设定一个新指针指向链表的起点，且步长与慢指针一样</p>
<p>为1，则慢指针与“新”指针相遇的地方就是环的入口</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Node&lt;String&gt; <span class="title function_">getEntrance</span><span class="params">(Node&lt;String&gt; first)</span> &#123;</span><br><span class="line">    Node&lt;String&gt; slow = first;</span><br><span class="line">    Node&lt;String&gt; fast = first;</span><br><span class="line">    Node&lt;String&gt; temp = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">null</span> &amp;&amp; fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast.equals(slow))&#123;</span><br><span class="line">            temp = first;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp!=<span class="literal">null</span>)&#123;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">            <span class="keyword">if</span> (temp.equals(slow))&#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h5><p>循环链表，顾名思义，链表整体要形成一个圆环状。在单向链表中，最后一个节点的指针为null，不指向任何结</p>
<p>点，因为没有下一个元素了。要实现循环链表，我们只需要让单向链表的最后一个节点的指针指向头结点即可。</p>
<h5 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h5><p><strong>问题描述：</strong></p>
<p>传说有这样一个故事，在罗马人占领乔塔帕特后，39 个犹太人与约瑟夫及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，第一个人从1开始报数，依次后，如果有人报数到3，那么这个人就必须自杀，然后再由他的下一个人重新从1开始报数，直到所有人都自杀身亡为止。然而约瑟夫和他的朋友并不想遵从。于是，约瑟夫要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，从而逃过了这场死亡游戏 。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 约瑟夫经典问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-02</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Joseph</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//构建循环链表</span></span><br><span class="line">        Node&lt;Integer&gt; first = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//记录前一个结点</span></span><br><span class="line">        Node&lt;Integer&gt; pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">41</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//第一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">1</span>)&#123;</span><br><span class="line">                first = <span class="keyword">new</span> <span class="title class_">Node</span>(i,<span class="literal">null</span>);</span><br><span class="line">                pre = first;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Node&lt;Integer&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(i,<span class="literal">null</span>);</span><br><span class="line">            pre.next = node;</span><br><span class="line">            pre = node;</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">41</span>)&#123;</span><br><span class="line">                <span class="comment">//让最后一个结点指向第一个结点</span></span><br><span class="line">                pre.next = first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用count记录当前的报数值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历链表，没循环一次count++</span></span><br><span class="line">        Node&lt;Integer&gt; n = first;</span><br><span class="line">        Node&lt;Integer&gt; before = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (n!=n.next)&#123;</span><br><span class="line">            <span class="comment">//判断count的值，如果是3，则从链表中删除这个结点并打印，把count重置为0</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="comment">//删除当前结点</span></span><br><span class="line">                before.next = n.next;</span><br><span class="line">                System.out.println(n.item);</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                n = n.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                before = n;</span><br><span class="line">                n = n.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(n.item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈是一种基于先进后出(FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出</p>
<p>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一</p>
<p>个数据被第一个读出来）。</p>
<p><strong>链表实现栈API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>StackLink</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>StackLink()：创建StackLink对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false<br>2.public int size():获取栈中元素的个数<br>3.public T pop():弹出栈顶元素<br>4.public void push(T t)：向栈中压入元素t</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node head:记录首结点<br>2.private int N:记录链表的长度</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 栈API实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackLink</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录首结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前栈的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StackLink</span><span class="params">()</span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断栈是否为空，是返回true，否返回false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取栈中元素的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出栈顶元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">oldNode</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">if</span> (oldNode==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = head.next.next;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> oldNode.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向栈中压入元素t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">oldNode</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t,oldNode);</span><br><span class="line">        head.next = node;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StackIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">StackIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n.next!=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> n.next;</span><br><span class="line">            n = n.next;</span><br><span class="line">            <span class="keyword">return</span> node.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> T item;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T item, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = item;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组实现栈API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>StackArray</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>StackArray()：创建StackArray对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false<br>2.public int size():获取栈中元素的个数<br>3.public T pop():弹出栈顶元素<br>4.public void push(T t)：向栈中压入元素t</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] data:存储数据的顺序表<br>2.private int N:记录链表的长度</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 栈结构API数组实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-03</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackArray</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T[] data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StackArray</span><span class="params">(<span class="type">int</span> capcity)</span>&#123;</span><br><span class="line">        data = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capcity];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N&gt;=data.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈已满&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[N++] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> data[N-<span class="number">1</span>];</span><br><span class="line">        data[N-<span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StackIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> cur;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cur&lt;N;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data[cur++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两栈共享</strong></p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p><strong>括号匹配问题</strong></p>
<p><strong>问题描述：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">给定一个字符串，里边可能包含&quot;()&quot;小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。</span><br><span class="line">例如：</span><br><span class="line"><span class="code">    &quot;(上海)(长安)&quot;：正确匹配</span></span><br><span class="line"><span class="code">    &quot;上海((长安))&quot;：正确匹配</span></span><br><span class="line"><span class="code">    &quot;上海(长安(北京)(深圳)南京)&quot;:正确匹配</span></span><br><span class="line"><span class="code">    &quot;上海(长安))&quot;：错误匹配</span></span><br><span class="line"><span class="code">    &quot;((上海)长安&quot;：错误匹配</span></span><br></pre></td></tr></table></figure>

<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断str中的括号是否匹配</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> str 括号组成的字符串</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 如果匹配，返回true，如果不匹配，返回false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String str)</span>&#123;</span><br><span class="line">      StackLink&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">StackLink</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> String.valueOf(str.charAt(i));</span><br><span class="line">          <span class="keyword">if</span> (<span class="string">&quot;(&quot;</span>.equals(c))&#123;</span><br><span class="line">              stack.push(c);</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;)&quot;</span>.equals(c))&#123;</span><br><span class="line">              <span class="type">String</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">              <span class="keyword">if</span> (pop==<span class="literal">null</span>||<span class="string">&quot;&quot;</span>.equals(pop))&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (stack.size()==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>逆波兰表达式求值问题</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> notaion 逆波兰表达式的数组表示方式</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 逆波兰表达式的计算结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">caculate</span><span class="params">(String[] notaion)</span>&#123;</span><br><span class="line">       StackLink&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">StackLink</span>&lt;&gt;();</span><br><span class="line">       Integer o1;</span><br><span class="line">       Integer o2;</span><br><span class="line">       Integer result;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; notaion.length; i++) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">curr</span> <span class="operator">=</span> notaion[i];</span><br><span class="line">           <span class="keyword">switch</span> (curr)&#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                   o1 = stack.pop();</span><br><span class="line">                   o2 = stack.pop();</span><br><span class="line">                   result = o1 + o2;</span><br><span class="line">                   stack.push(result);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                   o1 = stack.pop();</span><br><span class="line">                   o2 = stack.pop();</span><br><span class="line">                   result = o2 - o1;</span><br><span class="line">                   stack.push(result);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                   o1 = stack.pop();</span><br><span class="line">                   o2 = stack.pop();</span><br><span class="line">                   result = o1 * o2;</span><br><span class="line">                   stack.push(result);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                   o1 = stack.pop();</span><br><span class="line">                   o2 = stack.pop();</span><br><span class="line">                   result = o2 / o1;</span><br><span class="line">                   stack.push(result);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   stack.push(Integer.valueOf(curr));</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       result = stack.pop();</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列是一种基于先进先出(FIFO)的数据结构，是一种只能在一端进行插入,在另一端进行删除操作的特殊线性表，它</p>
<p>按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。</p>
<h5 id="数组实现队列"><a href="#数组实现队列" class="headerlink" title="数组实现队列"></a>数组实现队列</h5><p>1、入队列，在队列增加元素；出队列，在队头弹出数据，同时数据整体向队头移动，保证队头有数据</p>
<p>2、由于每次移动数据，增加时间复杂度。于是增加队头队尾指针，通过移动指针来操作队列数据，但是不能重复利用数组空间</p>
<p>3、为了能重复利用，引出循环队列概念，当队尾指针最大后，再移动到队头开始，当front和rear相等，有可能是队列为空也有可能是队列满了</p>
<p>4、进而将rear指针定义为队尾的下一位置，从而得出结论front&#x3D;rear说明队列为空，(front+1)%quenenSize&#x3D;front，说明队列已满；并得出队列长度公式：(rear-front+quenenSize)%quenenSize</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用数组实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-05</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuenenArray</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] data;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队头指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队尾下一个结点指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuenenArray</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        data = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpety</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//头指针和尾指针相等</span></span><br><span class="line">        <span class="keyword">return</span> front==rear;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear-front+capacity)%capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向队列添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((rear+<span class="number">1</span>)%capacity==front)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列已满&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[rear] = t;</span><br><span class="line">        rear = (rear+<span class="number">1</span>)%capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rear==front)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> data[front];</span><br><span class="line">        front = (front+<span class="number">1</span>)%capacity;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showDatas</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T t : data) &#123;</span><br><span class="line">            System.out.print(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a>链表实现队列</h5><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 链表实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuenenLink</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//记录首结点</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">//记录最后一个结点</span></span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="comment">//记录队列中元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuenenLink</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回队列中元素的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向队列中插入元素t</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>) &#123;</span><br><span class="line">            last = <span class="keyword">new</span> <span class="title class_">Node</span>(t, <span class="literal">null</span>);</span><br><span class="line">            head.next = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">oldLast</span> <span class="operator">=</span> last;</span><br><span class="line">            last = <span class="keyword">new</span> <span class="title class_">Node</span>(t, <span class="literal">null</span>);</span><br><span class="line">            oldLast.next = last;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//个数+1</span></span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中拿出一个元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">oldFirst</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = oldFirst.next;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            last = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldFirst.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">QIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">QIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n.next != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> n.next;</span><br><span class="line">            n = n.next;</span><br><span class="line">            <span class="keyword">return</span> node.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> T item;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T item, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = item;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h3><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><p>树是由n（n&gt;&#x3D;1）个有限结点组成一个具有层次关系的集合。</p>
<p>树具有以下特点：</p>
<p> 1.每个结点有零个或多个子结点；</p>
<p> 2.没有父结点的结点为根结点；</p>
<p> 3.每一个非根结点只有一个父结点；</p>
<p> 4.每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树；</p>
<h4 id="树的相关概念"><a href="#树的相关概念" class="headerlink" title="树的相关概念"></a>树的相关概念</h4><p><strong>结点的度：</strong></p>
<p>一个结点含有的子树的个数称为该结点的度；</p>
<p><strong>叶结点：</strong></p>
<p>度为0的结点称为叶结点，也可以叫做终端结点</p>
<p><strong>分支结点：</strong></p>
<p>度不为0的结点称为分支结点，也可以叫做非终端结点</p>
<p><strong>结点的层次：</strong></p>
<p>从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推</p>
<p><strong>结点的层序编号：</strong></p>
<p>将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。</p>
<p><strong>树的度：</strong></p>
<p>树中所有结点的度的最大值</p>
<p><strong>树的高度(深度)：</strong></p>
<p>树中结点的最大层次</p>
<p><strong>森林：</strong></p>
<p> m（m&gt;&#x3D;0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根</p>
<p>结点，森林就变成一棵</p>
<p><strong>孩子结点：</strong></p>
<p>一个结点的直接后继结点称为该结点的孩子结点</p>
<p><strong>双亲结点(父结点)：</strong></p>
<p>一个结点的直接前驱称为该结点的双亲结点</p>
<p><strong>兄弟结点：</strong></p>
<p>同一双亲结点的孩子结点间互称兄弟结点</p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><h5 id="基本定义-1"><a href="#基本定义-1" class="headerlink" title="基本定义"></a>基本定义</h5><p>二叉树就是度不超过2的树(每个结点最多有两个子结点)</p>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p><strong>满二叉树：</strong></p>
<p>一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。</p>
<p><strong>完全二叉树：</strong></p>
<p>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p><strong>结点类：</strong></p>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>Node&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(Key key, Value value, Node left, Node right)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.public Node left:记录左子结点<br>2.public Node right:记录右子结点<br>3.public Key key:存储键<br>4.public Value value:存储值</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 结点类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;Key,Value&gt;&#123;</span><br><span class="line">      <span class="comment">//存储键</span></span><br><span class="line">      <span class="keyword">private</span> Key key;</span><br><span class="line">      <span class="comment">//存储值</span></span><br><span class="line">      <span class="keyword">private</span> Value value;</span><br><span class="line">      <span class="comment">//左结点</span></span><br><span class="line">      <span class="keyword">private</span> Node left;</span><br><span class="line">      <span class="comment">//右结点</span></span><br><span class="line">      <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 构造方法</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Key key, Value value, Node left, Node right)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.key = key;</span><br><span class="line">          <span class="built_in">this</span>.value = value;</span><br><span class="line">          <span class="built_in">this</span>.left = left;</span><br><span class="line">          <span class="built_in">this</span>.right = right;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉树API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>BinaryTree&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>BinaryTree()：创建BinaryTree对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node root:记录根结点<br>2.private int N:记录树中元素的个数</td>
</tr>
<tr>
<td>成员方法</td>
<td>1. public void put(Key key,Value value):向树中插入一个键值对<br>2.private Node put(Node x, Key key, Value val)：给指定树x上，添加键一个键值对，并返回添加后的新树<br>3.public Value get(Key key):根据key，从树中找出对应的值<br>4.private Value get(Node x, Key key):从指定的树x中，找出key对应的值<br>5.public void delete(Key key):根据key，删除树中对应的键值对<br>6.private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的新树<br>7.public int size():获取树中元素的个数</td>
</tr>
</tbody></table>
<p><strong>插入方法put实现思想：</strong></p>
<p>1.如果当前树中没有任何一个结点，则直接把新结点当做根结点使用</p>
<p>2.如果当前树不为空，则从根结点开始：</p>
<p> 2.1如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；</p>
<p> 2.2如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；</p>
<p> 2.3如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。</p>
<p><strong>查询方法get实现思想：</strong></p>
<p>从根节点开始：</p>
<p> 1.如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；</p>
<p> 2.如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；</p>
<p> 3.如果要查询的key等于当前结点的key，则树中返回当前结点的value。</p>
<p><strong>删除方法delete实现思想：</strong></p>
<p> 1.找到被删除结点；</p>
<p> 2.找到被删除结点右子树中的最小结点minNode</p>
<p> 3.删除右子树中的最小结点</p>
<p> 4.让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子</p>
<p>树</p>
<p> 5.让被删除结点的父节点指向最小结点minNode</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 二叉树实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span>&lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;,Value&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 树中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryTree</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向树中插入一个键值对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Key key,Value value)</span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给指定树x上，添加键一个键值对，并返回添加后的新树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">put</span><span class="params">(Node x, Key key, Value val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="literal">null</span>)&#123;</span><br><span class="line">            N++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key,val,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//新结点的key大于当前结点key，继续找当前结点的右子结点</span></span><br><span class="line">            x.right = put(x.right,key,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//新结点的key小于当前结点key，继续找当前结点的左子结点</span></span><br><span class="line">            x.left = put(x.left,key,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            x.value = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key，从树中找出对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Value <span class="title function_">get</span><span class="params">(Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从指定的树x中，找出key对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Value <span class="title function_">get</span><span class="params">(Node x,Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> get(x.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> get(x.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除树中对应的键值对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Key key)</span>&#123;</span><br><span class="line">        delete(root,key);</span><br><span class="line">        <span class="comment">//个数-1</span></span><br><span class="line">        N--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定树x上的键为key的键值对，并返回删除后的新树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">delete</span><span class="params">(Node x,Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            x.right = delete(x.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x.left = delete(x.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//新结点的key等于当前结点的key,当前x就是要删除的结点</span></span><br><span class="line">            <span class="comment">//1.如果当前结点的右子树不存在，则直接返回当前结点的左子结点</span></span><br><span class="line">            <span class="keyword">if</span> (x.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> x.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.如果当前结点的左子树不存在，则直接返回当前结点的右子结点</span></span><br><span class="line">            <span class="keyword">if</span> (x.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> x.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.当前结点的左右子树都存在</span></span><br><span class="line">            <span class="comment">//3.1找到右子树中最小的结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">minNode</span> <span class="operator">=</span> x.right;</span><br><span class="line">            <span class="keyword">while</span> (minNode.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                minNode = minNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.2删除右子树中最小的结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> x.right;</span><br><span class="line">            <span class="keyword">while</span> (n.left != <span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span> (n.left.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                   n.left = <span class="literal">null</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   n = n.left;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.3让被删除结点的左子树成为最小结点minNode的左子树，让被删除结点的右子树成为最小结点minNode的右子树</span></span><br><span class="line">            minNode.left = x.left;</span><br><span class="line">            minNode.right = x.right;</span><br><span class="line">            <span class="comment">//3.4让被删除结点的父节点指向最小结点minNode</span></span><br><span class="line">            x = minNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取树中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结点类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="comment">//存储键</span></span><br><span class="line">        <span class="keyword">private</span> Key key;</span><br><span class="line">        <span class="comment">//存储值</span></span><br><span class="line">        <span class="keyword">private</span> Value value;</span><br><span class="line">        <span class="comment">//左结点</span></span><br><span class="line">        <span class="keyword">private</span> Node left;</span><br><span class="line">        <span class="comment">//右结点</span></span><br><span class="line">        <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Key key, Value value, Node left, Node right)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找二叉树中的最小键</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找出整个树中最小的键</span></span><br><span class="line">   <span class="keyword">public</span> Key <span class="title function_">min</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> min(root).key;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//找出指定树x中最小的键所在的结点</span></span><br><span class="line">   <span class="keyword">public</span> Node <span class="title function_">min</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> min(x.left);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找二叉树中最大的键</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找出整个树中最大的键</span></span><br><span class="line">   <span class="keyword">public</span> Key <span class="title function_">max</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> max(root).key;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//找出指定树x中最小的键所在的结点</span></span><br><span class="line">   <span class="keyword">public</span> Node <span class="title function_">max</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> max(x.right);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h5><p><strong>前序遍历</strong></p>
<p>先访问根结点，然后再访问左子树，最后访问右子树</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用前序遍历，获取整个树中的所有键</span></span><br><span class="line">   <span class="keyword">public</span> QuenenLink&lt;Key&gt; <span class="title function_">preErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">       QuenenLink&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">       preErgodic(root,keys);</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用前序遍历，把指定树x中的所有键放入到keys队列中</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preErgodic</span><span class="params">(Node x,QuenenLink&lt;Key&gt; keys)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1.把当前结点的key放入到队列中;</span></span><br><span class="line">       keys.enqueue(x.key);</span><br><span class="line">       <span class="comment">//2.找到当前结点的左子树，如果不为空，递归遍历左子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           preErgodic(x.left,keys);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3.找到当前结点的右子树，如果不为空，递归遍历右子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">           preErgodic(x.right,keys);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>中序遍历</strong></p>
<p>先访问左子树，中间访问根节点，最后访问右子树</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用中序遍历，获取整个树中的所有键</span></span><br><span class="line">   <span class="keyword">public</span> QuenenLink&lt;Key&gt; <span class="title function_">midErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">       QuenenLink&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">       midErgodic(root,keys);</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用中序遍历，把指定树x中的所有键放入到keys队列中</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">midErgodic</span><span class="params">(Node x,QuenenLink&lt;Key&gt; keys)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1.找到当前结点的左子树，如果不为空，递归遍历左子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           midErgodic(x.left,keys);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2.把当前结点的key放入到队列中;</span></span><br><span class="line">       keys.enqueue(x.key);</span><br><span class="line">       <span class="comment">//3.找到当前结点的右子树，如果不为空，递归遍历右子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">           midErgodic(x.right,keys);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>后序遍历</strong></p>
<p>先访问左子树，再访问右子树，最后访问根节点</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用后序遍历，获取整个树中的所有键</span></span><br><span class="line">   <span class="keyword">public</span> QuenenLink&lt;Key&gt; <span class="title function_">afterErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">       QuenenLink&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">       afterErgodic(root,keys);</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用后序遍历，把指定树x中的所有键放入到keys队列中</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">afterErgodic</span><span class="params">(Node x,QuenenLink&lt;Key&gt; keys)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1.找到当前结点的左子树，如果不为空，递归遍历左子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           afterErgodic(x.left,keys);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2.找到当前结点的右子树，如果不为空，递归遍历右子树</span></span><br><span class="line">       <span class="keyword">if</span> (x.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">           afterErgodic(x.right,keys);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3.把当前结点的key放入到队列中;</span></span><br><span class="line">       keys.enqueue(x.key);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>层序遍历</strong></p>
<p>所谓的层序遍历，就是从根节点（第一层）开始，依次向下，获取每一层所有结点的值</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用层序遍历得到树中所有的键</span></span><br><span class="line">   <span class="keyword">public</span> QuenenLink&lt;Key&gt; <span class="title function_">layerErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">       QuenenLink&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">       QuenenLink&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">       nodes.enqueue(root);</span><br><span class="line">       <span class="keyword">while</span> (!nodes.isEmpty())&#123;</span><br><span class="line">           <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nodes.dequeue();</span><br><span class="line">           keys.enqueue(node.key);</span><br><span class="line">           <span class="keyword">if</span> (node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">               nodes.enqueue(node.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">               nodes.enqueue(node.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="二叉树的最大深度问题"><a href="#二叉树的最大深度问题" class="headerlink" title="二叉树的最大深度问题"></a><strong>二叉树的最大深度问题</strong></h5><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算整个树的最大深度</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> maxDepth(root);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//计算指定树x的最大深度</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">       <span class="comment">//1.如果根结点为空，则最大深度为0；</span></span><br><span class="line">       <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//2.计算左子树的最大深度；</span></span><br><span class="line">       <span class="keyword">if</span> (x.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           maxL = maxDepth(x.left);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3.计算右子树的最大深度；</span></span><br><span class="line">       <span class="keyword">if</span> (x.right != <span class="literal">null</span>)&#123;</span><br><span class="line">           maxR = maxDepth(x.right);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4.当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1</span></span><br><span class="line">       max = maxL &gt; maxR ? maxL + <span class="number">1</span> : maxR + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h4><p>二叉查找树是最常用的一种二叉树，它支持快速插入、删除、查找操作，各个操作的时间复杂度跟树的高度成正比，最佳时间复杂度是 O(log­n)。</p>
<p>不过，由于二叉排序树本身为有序，当<strong>插入一个有序程度十分高的序列</strong>时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致<strong>最终的二叉排序树会退化为链表</strong>，从而使得二叉树的查询和插入效率恶化。**时间复杂度会退化到 O(n)**。</p>
<p>因此一般的<strong>二叉查找树不适用于数据经常变动（加入或删除）的情况</strong>。而是比较适合不会变动的数据，例如编程语言中的“保留字”等。</p>
<p>为了能够尽量降低查找所需要的时间，快速找到所要的键值，或者很快地知道当前的树中没有我们要的键值，必须让树的高度越小越好。要解决这个时间复杂度退化的问题，我们需要设计一种平衡二叉查找树。</p>
<h5 id="avl平衡树"><a href="#avl平衡树" class="headerlink" title="avl平衡树"></a>avl平衡树</h5><p>平衡二叉树（Balanced Binary Tree）又称 <strong>AVL</strong> 树（由 Adelse-Velskil 和 Landis 两个人发明），本身也是一棵二叉查找树，其产生是为了解决二叉排序树在插入时发生线性排列的现象。</p>
<p>平衡二叉树的严格定义是这样的：</p>
<ol>
<li>满足二叉查找树的性质，左子树所有值小于父节点，右子树所有值大于等于父节点。</li>
<li>作为一棵平衡二叉树，它需要满足任意一个节点的左右子树的高度相差不能大于 1。</li>
</ol>
<p>在平衡二叉树中，<strong>每次在插入数据和删除数据后，必要时就会对二叉树做一些高度的调整（左旋和右旋）</strong>，<strong>来让二叉查找树的高度随时维持平衡，将查找、插入、删除操作的时间复杂度保证在 O(log­n) 范围内</strong>。通常只有从那些插入点到根节点的路径上的节点的平衡性可能被改变，因为只有这些节点的子树可能变化。</p>
<p>平衡二叉树适用于动态数据，这就完成了哈希表不便完成的工作——动态性。所以：</p>
<ul>
<li>如果输入集合确定，所需要的就是查询，则可以考虑使用哈希表。</li>
<li>如果输入集合不确定，则考虑使用平衡二叉树&#x2F;红黑树，保证达到最大效率。</li>
</ul>
<p><strong>平衡二叉树主要优点集中在快速查找，</strong>频繁旋转会使插入和删除牺牲掉 O(log­n) 左右的时间，不过相对二叉查找树来说，时间上稳定了很多。<br><strong>Node结点类：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>Node&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(Key,Value)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.public K key:键<br>2.private V value:值<br>3.private Node left,right:左右结点<br>4.private int height:高度</td>
</tr>
</tbody></table>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>AvlTree&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>AvlTree()：创建AvlTree对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node root:记录根结点<br>2.private int N:记录树中元素的个数:</td>
</tr>
<tr>
<td>成员方法</td>
<td>1. public void put(Key key,Value value):向树中插入一个键值对<br>2.private Node put(Node x, Key key, Value val)：给指定树x上，添加键一个键值对，并返回添加后的新树<br>3.public Value get(Key key):根据key，从树中找出对应的值<br>4.private Value get(Node x, Key key):从指定的树x中，找出key对应的值<br>5.public void delete(Key key):根据key，删除树中对应的键值对<br>6.private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的新树<br>7.public int size():获取树中元素的个数<br>8.public Node rightRotate(Node x):右旋<br>9.public Node leftRotate(Node x):左旋</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: avl数实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-01-13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AvlTree</span>&lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;,Value&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Key key;</span><br><span class="line">        <span class="keyword">private</span> Value value;</span><br><span class="line">        <span class="keyword">public</span> Node left,right;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Key key,Value value)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            left = <span class="literal">null</span>;</span><br><span class="line">            right = <span class="literal">null</span>;</span><br><span class="line">            height = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AvlTree</span><span class="params">()</span>&#123;</span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取树高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取平衡因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getBalanceFactor</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getHeight(node.left) - getHeight(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右旋</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">rightRotate</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="comment">//获取根结点的左子节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">left</span> <span class="operator">=</span> node.left;</span><br><span class="line">        <span class="comment">//获取左子节点的右子节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">lright</span> <span class="operator">=</span> left.right;</span><br><span class="line">        <span class="comment">//left为根结点，node为其右子节点，并lright调整为node的左子节点</span></span><br><span class="line">        left.right = node;</span><br><span class="line">        node.left = lright;</span><br><span class="line">        <span class="comment">//更新height</span></span><br><span class="line">        left.height = Math.max(getHeight(left.left),getHeight(left.right)) + <span class="number">1</span>;</span><br><span class="line">        node.height = Math.max(getHeight(node.left),getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左旋</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">leftRotate</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="comment">//获取根结点的右子节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> node.right;</span><br><span class="line">        <span class="comment">//获取右子节点的左子节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">rleft</span> <span class="operator">=</span> right.left;</span><br><span class="line">        <span class="comment">//right为根结点，node为其左子节点，并rleft调整为node的右子节点</span></span><br><span class="line">        right.left = node;</span><br><span class="line">        node.right = rleft;</span><br><span class="line">        <span class="comment">//更新height</span></span><br><span class="line">        right.height = Math.max(getHeight(right.left),getHeight(right.right)) + <span class="number">1</span>;</span><br><span class="line">        node.height = Math.max(getHeight(node.left),getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Key key,Value value)</span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">put</span><span class="params">(Node node,Key key,Value value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果为空，即空树添加结点</span></span><br><span class="line">            <span class="comment">//元素个数加1</span></span><br><span class="line">            N++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key,value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(node.key)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            node.left = put(node.left,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            node.right = put(node.right,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key)==<span class="number">0</span>)&#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新每个结点的height</span></span><br><span class="line">        node.height = Math.max(getHeight(node.left),getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//计算平衡因子</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">balanceFactor</span> <span class="operator">=</span> getBalanceFactor(node);</span><br><span class="line">        <span class="comment">//右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先左旋再右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.left = leftRotate(node.left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先右旋再左旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.right = rightRotate(node.right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据key，从树中找出对应的值</span></span><br><span class="line">    <span class="keyword">public</span> Value <span class="title function_">get</span><span class="params">(Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从指定的树x中，找出key对应的值</span></span><br><span class="line">    <span class="keyword">private</span> Value <span class="title function_">get</span><span class="params">(Node node,Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(node.key)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> get(node.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> get(node.right,key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据key，删除树中对应的键值对</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Key key)</span>&#123;</span><br><span class="line">        root = delete(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除指定树x上的键为key的键值对，并返回删除后的新树</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">delete</span><span class="params">(Node node,Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义新树</span></span><br><span class="line">        Node newNode;</span><br><span class="line">        <span class="comment">//找到key对应的位置</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.left = delete(node.left,key);</span><br><span class="line">            newNode = node;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            node.right = delete(node.right,key);</span><br><span class="line">            newNode = node;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//找到key的位置</span></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> node.right;</span><br><span class="line">                node.right = <span class="literal">null</span>;</span><br><span class="line">                N--;</span><br><span class="line">                newNode = rightNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> node.left;</span><br><span class="line">                node.left = <span class="literal">null</span>;</span><br><span class="line">                N--;</span><br><span class="line">                newNode = leftNode;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">                <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">minimum</span> <span class="operator">=</span> minimum(node.right);</span><br><span class="line">                minimum.right = delete(node.right,minimum.key);</span><br><span class="line">                minimum.left = node.left;</span><br><span class="line">                node.left = node.right = <span class="literal">null</span>;</span><br><span class="line">                newNode = minimum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新height</span></span><br><span class="line">        newNode.height = <span class="number">1</span> + Math.max(getHeight(newNode.left), getHeight(newNode.right));</span><br><span class="line">        <span class="comment">//计算平衡因子</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">balanceFactor</span> <span class="operator">=</span> getBalanceFactor(newNode);</span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(newNode.left) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rightRotate(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(newNode.right) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftRotate(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先左旋再右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(newNode.left) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            newNode.left = leftRotate(newNode.left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先右旋再左旋</span></span><br><span class="line">        <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(newNode.right) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            newNode.right = rightRotate(newNode.right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根的二分搜索树的最小值所在的节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">minimum</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h5><p>为了保证查找树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个结点保存多个键。确切的说，我</p>
<p>们将一棵标准的二叉查找树中的结点称为2-结点(含有一个键和两条链)，而现在我们引入3-结点，它含有两个键和</p>
<p>三条链。2-结点和3-结点中的每条链都对应着其中保存的键所分割产生的一个区间。</p>
<p>一棵2-3查找树要么为空，要么满足满足下面两个要求：</p>
<p><strong>2-结点：</strong></p>
<p>含有一个键(及其对应的值)和两条链，左链接指向2-3树中的键都小于该结点，右链接指向的2-3树中的键都大</p>
<p>于该结点。</p>
<p><strong>3-结点：</strong></p>
<p>含有两个键(及其对应的值)和三条链，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都</p>
<p>位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。</p>
<p><strong>查找</strong></p>
<p>将二叉查找树的查找算法一般化我们就能够直接得到2-3树的查找算法。要判断一个键是否在树中，我们先将它和</p>
<p>根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的连</p>
<p>接，并在其指向的子树中递归地继续查找。如果这个是空链接，查找未命中。</p>
<p> <strong>插入</strong></p>
<p><strong>向2-结点中插入新键</strong></p>
<h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><p>红黑树是一种特殊的二叉查找树，每个结点都要储存位表示结点的颜色，或红或黑</p>
<p><strong>特点：</strong></p>
<ul>
<li>每个结点或红或黑</li>
<li>根结点是黑色</li>
<li>空叶子结点是黑色</li>
<li>如果一个几点是红色，那么他的子节点是黑色</li>
<li>从任意一个结点出发到空的叶子结点经过的黑色结点个数相同</li>
</ul>
<p><strong>Node结点类：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>Node&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(Key,Value)：创建Node对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.public K key:键<br>2.private V value:值<br>3.private Node left,right:左右结点<br>4.private boolean color:结点颜色</td>
</tr>
</tbody></table>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>RedBlackTree&lt;Key,Value&gt;</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>RedBlackTree()：创建RedBlackTree对象</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private Node root:记录根结点<br>2.private int N:记录树中元素的个数:</td>
</tr>
<tr>
<td>成员方法</td>
<td>1. public void put(Key key,Value value):向树中插入一个键值对<br>2.private Node put(Node x, Key key, Value val)：给指定树x上，添加键一个键值对，并返回添加后的新树<br>3.public Value get(Key key):根据key，从树中找出对应的值<br>4.private Value get(Node x, Key key):从指定的树x中，找出key对应的值<br>5.public void delete(Key key):根据key，删除树中对应的键值对<br>6.private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的新树<br>7.public int size():获取树中元素的个数<br>8.public Node rightRotate(Node x):右旋<br>9.public Node leftRotate(Node x):左旋</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<h5 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h5><p><strong>特点</strong></p>
<p>B树中允许一个结点中包含多个key，可以是3个、4个、5个甚至更多，并不确定，需要看具体的实现。现在我们选</p>
<p>择一个参数M，来构造一个B树，我们可以把它称作是M阶的B树，那么该树会具有如下特点：</p>
<ul>
<li>每个结点最多有M-1个key，并且以升序排列；</li>
<li>每个结点最多能有M个子结点；</li>
<li>根结点至少有两个子结点</li>
</ul>
<p><strong>B树在磁盘文件中的应用</strong></p>
<p>​		在我们的程序中，不可避免的需要通过IO操作文件，而我们的文件是存储在磁盘上的。计算机操作磁盘上的文件是通过文件系统进行操作的，在文件系统中就使用到了B树这种数据结构。</p>
<p><strong>磁盘</strong></p>
<p>​		磁盘能够保存大量的数据，从GB一直到TB级，但是 他的读取速度比较慢，因为涉及到机器操作，读取速度为毫秒级 。磁盘由盘片构成,每个盘片有两面，又称为盘面 。盘片中央有一个可以旋转的主轴，他使得盘片以固定的旋转速率旋转，通常是5400rpm或者是7200rpm,一个磁盘中包含了多个这样的盘片并封装在一个密封的容器内 。盘片的每个表面是由一组称为磁道同心圆组成的 ，每个磁道被划分为了一组扇区 ，每个扇区包含相等数量的数据位，通常是512个子节，扇区之间由一些间隙隔开,这些间隙中不存储数据 。</p>
<p><strong>磁盘IO</strong></p>
<p>​		磁盘用磁头来读写存储在盘片表面的位，而磁头连接到一个移动臂上，移动臂沿着盘片半径前后移动，可以将磁头定位到任何磁道上，这称之为寻道操作。一旦定位到磁道后，盘片转动，磁道上的每个位经过磁头时，读写磁头就可以感知到该位的值，也可以修改值。对磁盘的访问时间分为 <strong>寻道时间</strong>，<strong>旋转时间</strong>，以及<strong>传送时间</strong>。</p>
<p>​		由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，因此为了提高效率，要尽量减少磁盘I&#x2F;O，减少读写操作。 为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此预读可以提高I&#x2F;O效率。,</p>
<p>​		页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（1024个字节或其整数倍），预读的长度一般为页的整倍数。主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<p>​		文件系统的设计者利用了磁盘预读原理，将一个结点的大小设为等于一个页（1024个字节或其整数倍），这样每个结点只需要一次I&#x2F;O就可以完全载入。那么3层的B树可以容纳1024<em>1024</em>1024差不多10亿个数据，如果换成二叉查找树，则需要30层！假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在10亿个数据中查找目标值，只需要小于3次硬盘读取就可以找到目标值，但红黑树需要小于30次，因此B树大大提高了IO的操作效率。</p>
<h5 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h5><p>B+树是对B树的一种变形树，它与B树的差异在于：</p>
<ul>
<li>非叶结点仅具有索引作用，也就是说，非叶子结点只存储key，不存储value；</li>
<li>树的所有叶结点构成一个有序链表，可以按照key排序的次序遍历全部数据。</li>
</ul>
<p><strong>B+树和B树的对比</strong></p>
<p><strong>B+</strong> <strong>树的优点在于：</strong></p>
<ul>
<li>由于B+树在非叶子结点上不包含真正的数据，只当做索引使用，因此在内存相同的情况下，能够存放更多的key。 </li>
<li>B+树的叶子结点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。</li>
</ul>
<p><strong>B树的优点在于：</strong></p>
<p>​		由于B树的每一个节点都包含key和value，因此我们根据key查找value时，只需要找到key所在的位置，就能找到value，但B+树只有叶子结点存储数据，索引每一次查找，都必须一次一次，一直找到树的最大深度处，也就是叶子结点的深度，才能找到value。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h4><p>堆是计算机科学中一类特殊的数据结构的统称，堆通常可以被看做是一棵完全二叉树的数组对象。</p>
<p><strong>堆的特性</strong></p>
<ul>
<li>它是完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求左满右不满。</li>
<li>它通常用数组来实现。如果一个结点的位置为k，则它的父结点的位置为[k&#x2F;2],而它的两个子结点的位置则分别为2k和2k+1。这样，在不使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动：从a[k]向上一层，就令k等于k&#x2F;2,向下一层就令k等于2k或2k+1。</li>
<li>每个结点都大于等于它的两个子结点。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的。</li>
</ul>
<h4 id="堆的API设计"><a href="#堆的API设计" class="headerlink" title="堆的API设计"></a>堆的API设计</h4><table>
<thead>
<tr>
<th>类名</th>
<th><strong>Heap</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Heap(int capacity)：创建容量为capacity的Heap对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br>2.private void exch(int i,int j):交换堆中i索引和j索引处的值<br>3.public T delMax():删除堆中最大的元素,并返回这个最大元素<br>4.public void insert(T t)：往堆中插入一个元素<br>5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br>6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] imtes : 用来存储元素的数组<br>2.private int N：记录堆中元素的个数</td>
</tr>
</tbody></table>
<h4 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a><strong>堆的实现</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.generic.IF_ACMPEQ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储堆中的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录堆中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j])&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换堆中i索引和j索引处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往堆中插入一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        <span class="comment">//上浮算法</span></span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除堆中最大的元素,并返回这个最大元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> items[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//交换索引1处和索引N处的值</span></span><br><span class="line">        exch(<span class="number">1</span>,N);</span><br><span class="line">        <span class="comment">//删除最后位置上的元素</span></span><br><span class="line">        items[N]=<span class="literal">null</span>;</span><br><span class="line">        N--;<span class="comment">//个数-1</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//如果已经到了根结点，就不需要循环了</span></span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//比较当前结点和其父节点</span></span><br><span class="line">            <span class="keyword">if</span> (less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">                <span class="comment">//父节点小于当前节点，则交换</span></span><br><span class="line">                exch(k/<span class="number">2</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//如果当前已经是最底层了，就不需要循环了</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k&lt;=N)&#123;</span><br><span class="line">            <span class="comment">//找到子节点中的较大者</span></span><br><span class="line">            <span class="type">int</span> max;</span><br><span class="line">            <span class="comment">//判断是否存在右结点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span>*k+<span class="number">1</span>&lt;=N)&#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span>*k,<span class="number">2</span>*k+<span class="number">1</span>))&#123;</span><br><span class="line">                    max = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    max = <span class="number">2</span>*k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                max = <span class="number">2</span>*k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较当前结点和子节点中较大者，如果当前结点不小，则结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (!less(k,max))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前结点小，则交换</span></span><br><span class="line">            exch(k,max);</span><br><span class="line">            k = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.generic.IF_ACMPEQ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储堆中的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录堆中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j])&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换堆中i索引和j索引处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往堆中插入一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        <span class="comment">//上浮算法</span></span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除堆中最大的元素,并返回这个最大元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> items[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//交换索引1处和索引N处的值</span></span><br><span class="line">        exch(<span class="number">1</span>,N);</span><br><span class="line">        <span class="comment">//删除最后位置上的元素</span></span><br><span class="line">        items[N]=<span class="literal">null</span>;</span><br><span class="line">        N--;<span class="comment">//个数-1</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//如果已经到了根结点，就不需要循环了</span></span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//比较当前结点和其父节点</span></span><br><span class="line">            <span class="keyword">if</span> (less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">                <span class="comment">//父节点小于当前节点，则交换</span></span><br><span class="line">                exch(k/<span class="number">2</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//如果当前已经是最底层了，就不需要循环了</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k&lt;=N)&#123;</span><br><span class="line">            <span class="comment">//找到子节点中的较大者</span></span><br><span class="line">            <span class="type">int</span> max;</span><br><span class="line">            <span class="comment">//判断是否存在右结点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span>*k+<span class="number">1</span>&lt;=N)&#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span>*k,<span class="number">2</span>*k+<span class="number">1</span>))&#123;</span><br><span class="line">                    max = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    max = <span class="number">2</span>*k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                max = <span class="number">2</span>*k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较当前结点和子节点中较大者，如果当前结点不小，则结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (!less(k,max))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前结点小，则交换</span></span><br><span class="line">            exch(k,max);</span><br><span class="line">            k = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><strong>AP设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>HeapSort</strong></th>
</tr>
</thead>
<tbody><tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] source)：对source数组中的数据从小到大排序<br>2.private static void createHeap(Comparable[] source, Comparable[] heap):根据原数组source，构造出堆heap<br>3.private static boolean less(Comparable[] heap, int i, int j)：判断heap堆中索引i处的元素是否小于索引j处的元素<br>4.private static void exch(Comparable[] heap, int i, int j):交换heap堆中i索引和j索引处的值<br>5.private static void sink(Comparable[] heap, int target, int range):在heap堆中，对target处的元素做下沉，范围是0~range。</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 堆排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对source数组中的数据从小到大排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] source)</span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个比原数组大1的数组</span></span><br><span class="line">        Comparable[] heap = <span class="keyword">new</span> <span class="title class_">Comparable</span>[source.length + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//2.构造堆</span></span><br><span class="line">        createHeap(source,heap);</span><br><span class="line">        <span class="comment">//3.堆排序</span></span><br><span class="line">        <span class="comment">//3.1定义一个变量，记录heap中未排序的所有元素中最大的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> heap.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (N != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//3.2交换heap中索引1处的元素和N处的元素</span></span><br><span class="line">            exch(heap,<span class="number">1</span>,N);</span><br><span class="line">            N--;</span><br><span class="line">            sink(heap,<span class="number">1</span>,N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.heap中的数据已经有序，拷贝到source中</span></span><br><span class="line">        System.arraycopy(heap,<span class="number">1</span>,source,<span class="number">0</span>,source.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据原数组source，构造出堆heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createHeap</span><span class="params">(Comparable[] source, Comparable[] heap)</span>&#123;</span><br><span class="line">        <span class="comment">//1.把source中的数据拷贝到heap中，从heap的1索引处开始填充</span></span><br><span class="line">        System.arraycopy(source,<span class="number">0</span>,heap,<span class="number">1</span>,source.length);</span><br><span class="line">        <span class="comment">//2.从heap索引的一半处开始倒叙遍历，对得到的每一个元素做下沉操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (heap.length-<span class="number">1</span>)/<span class="number">2</span>; i &gt; <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            sink(heap,i, heap.length-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断heap堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(Comparable[] heap, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap[i].compareTo(heap[j])&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换heap堆中i索引和j索引处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] heap, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable tmp=heap[i];</span><br><span class="line">        heap[i]=heap[j];</span><br><span class="line">        heap[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在heap堆中，对target处的元素做下沉，范围是0~range。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> range</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(Comparable[] heap, <span class="type">int</span> target, <span class="type">int</span> range)</span>&#123;</span><br><span class="line">        <span class="comment">//没有子结点了</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*target&lt;=range) &#123;</span><br><span class="line">            <span class="comment">//1.找出target结点的两个子结点中的较大值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">2</span> * target;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * target + <span class="number">1</span> &lt;= range) &#123;</span><br><span class="line">                <span class="comment">//存在右子结点</span></span><br><span class="line">                <span class="keyword">if</span> (less(heap, <span class="number">2</span> * target, <span class="number">2</span> * target + <span class="number">1</span>)) &#123;</span><br><span class="line">                    max = <span class="number">2</span> * target + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.如果当前结点的值小于子结点中的较大值，则交换</span></span><br><span class="line">            <span class="keyword">if</span> (less(heap, target, max)) &#123;</span><br><span class="line">                exch(heap, target, max);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.更新target的值</span></span><br><span class="line">            target = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;S&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;P&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        HeapSort.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>​		普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在某些情况下，我们可能需要找出队列中的最大值或者最小值，例如使用一个队列保存计算机的任务，一般情况下计算机的任务都是有优先级的，我们需要在这些计算机的任务中找出优先级最高的任务先执行，执行完毕后就需要把这个任务从队列中移除。普通的队列要完成这样的功能，需要每次遍历队列中的所有元素，比较并找出最大值，效率不是很高，这个时候，我们就可以使用一种特殊的队列来完成这种需求，优先队列。</p>
<h4 id="最大优先队列"><a href="#最大优先队列" class="headerlink" title="最大优先队列"></a><strong>最大优先队列</strong></h4><p><strong>最大优先队列API设计</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>MaxPriorityQueue</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>MaxPriorityQueue(int capacity)：创建容量为capacity的MaxPriorityQueue对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br>2.private void exch(int i,int j):交换堆中i索引和j索引处的值<br>3.public T delMax():删除队列中最大的元素,并返回这个最大元素<br>4.public void insert(T t)：往队列中插入一个元素<br>5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br>6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置<br>7.public int size():获取队列中元素的个数<br>8.public boolean isEmpty():判断队列是否为空</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] imtes : 用来存储元素的数组<br>2.private int N：记录堆中元素的个数</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.awt.geom.AreaOp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 最大优先队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-20</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPriorityQueue</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存储元素的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录堆中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxPriorityQueue</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换堆中i索引和j索引处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除队列中最大的元素,并返回这个最大元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> items[<span class="number">1</span>];</span><br><span class="line">        exch(<span class="number">1</span>,N);</span><br><span class="line">        items[N] = <span class="literal">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往队列中插入一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//比较当前节点与其父节点</span></span><br><span class="line">            <span class="keyword">if</span> (less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">                exch(k/<span class="number">2</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k&lt;=N)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= N)&#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span> * k,<span class="number">2</span> * k + <span class="number">1</span>))&#123;</span><br><span class="line">                    max = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!less(k,max))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(k,max);</span><br><span class="line">            k = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列中元素的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;S&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;P&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        MaxPriorityQueue&lt;String&gt; maxpq = <span class="keyword">new</span> <span class="title class_">MaxPriorityQueue</span>&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">            maxpq.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(maxpq.size());</span><br><span class="line">        String del;</span><br><span class="line">        <span class="keyword">while</span>(!maxpq.isEmpty())&#123;</span><br><span class="line">            del = maxpq.delMax();</span><br><span class="line">            System.out.print(del+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最小优先队列"><a href="#最小优先队列" class="headerlink" title="最小优先队列"></a>最小优先队列</h4><p>其实我们之前实现的堆可以把它叫做最大堆，我们可以用相反的思想实现最小堆，让堆中存放数据元素的数组满足</p>
<p>如下特性：</p>
<p>1.最小的元素放在数组的索引1处。</p>
<p>2.每个结点的数据总是小于等于它的两个子结点的数据。</p>
<p><strong>最小优先队列API设计</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th><strong>MinPriorityQueue</strong></th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>MinPriorityQueue(int capacity)：创建容量为capacity的MinPriorityQueue对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br>2.private void exch(int i,int j):交换堆中i索引和j索引处的值<br>3.public T delMax():删除队列中最大的元素,并返回这个最大元素<br>4.public void insert(T t)：往队列中插入一个元素<br>5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br>6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置<br>7.public int size():获取队列中元素的个数<br>8.public boolean isEmpty():判断队列是否为空</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private T[] imtes : 用来存储元素的数组<br>2.private int N：记录堆中元素的个数</td>
</tr>
</tbody></table>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 最小优先队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-20</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinPriorityQueue</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存储元素的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录堆中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinPriorityQueue</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换堆中i索引和j索引处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除队列中最大的元素,并返回这个最大元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> items[<span class="number">1</span>];</span><br><span class="line">        exch(<span class="number">1</span>,N);</span><br><span class="line">        items[N] = <span class="literal">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往队列中插入一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        items[++N] = t;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//比较当前节点与其父节点</span></span><br><span class="line">            <span class="keyword">if</span> (less(k,k/<span class="number">2</span>))&#123;</span><br><span class="line">                exch(k/<span class="number">2</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k&lt;=N)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= N)&#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span> * k + <span class="number">1</span>,<span class="number">2</span> * k ))&#123;</span><br><span class="line">                    min = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (less(k,min))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(k,min);</span><br><span class="line">            k = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列中元素的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;S&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;P&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        MinPriorityQueue&lt;String&gt; maxpq = <span class="keyword">new</span> <span class="title class_">MinPriorityQueue</span>&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">            maxpq.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(maxpq.size());</span><br><span class="line">        String del;</span><br><span class="line">        <span class="keyword">while</span>(!maxpq.isEmpty())&#123;</span><br><span class="line">            del = maxpq.delMax();</span><br><span class="line">            System.out.print(del+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="索引优先队列"><a href="#索引优先队列" class="headerlink" title="索引优先队列"></a>索引优先队列</h4><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="图的定义及分类"><a href="#图的定义及分类" class="headerlink" title="图的定义及分类"></a>图的定义及分类</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h5><p>图是由一组顶点和一组能够将两个顶点相连的边组成的</p>
<h5 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a><strong>分类</strong></h5><p>按照连接两个顶点的边的不同，可以把图分为以下两种：</p>
<ul>
<li>无向图：边仅仅连接两个顶点，没有其他含义；</li>
<li>有向图：边不仅连接两个顶点，并且具有方向；</li>
</ul>
<h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><h5 id="图的相关术语"><a href="#图的相关术语" class="headerlink" title="图的相关术语"></a>图的相关术语</h5><p><strong>相邻顶点：</strong></p>
<p>当两个顶点通过一条边相连时，我们称这两个顶点是相邻的，并且称这条边依附于这两个顶点。</p>
<p><strong>度：</strong></p>
<p>某个顶点的度就是依附于该顶点的边的个数</p>
<p><strong>子图：</strong></p>
<p>是一幅图的所有边的子集(包含这些边依附的顶点)组成的图；</p>
<p><strong>路径：</strong></p>
<p>是由边顺序连接的一系列的顶点组成</p>
<p><strong>环：</strong></p>
<p>是一条至少含有一条边且终点和起点相同的路径</p>
<p><strong>连通图：</strong></p>
<p>如果图中任意一个顶点都存在一条路径到达另外一个顶点，那么这幅图就称之为连通图</p>
<p><strong>连通子图：</strong></p>
<p>一个非连通图由若干连通的部分组成，每一个连通的部分都可以称为该图的连通子图</p>
<h5 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a><strong>图的存储结构</strong></h5><p>要表示一幅图，只需要表示清楚以下两部分内容即可：</p>
<ol>
<li>图中所有的顶点；</li>
<li>所有连接顶点的边；</li>
</ol>
<p>常见的图的存储结构有两种：邻接矩阵和邻接表</p>
<p> <strong>邻接矩阵</strong></p>
<ol>
<li>使用一个V*V的二维数组int[V][V] adj,把索引的值看做是顶点；</li>
<li>如果顶点v和顶点w相连，我们只需要将adj[v][w]和adj[w][v]的值设置为1,否则设置为0即可。</li>
</ol>
<p>邻接矩阵这种存储方式的空间复杂度是V^2的，如果我们处理的问题规模比较大的话，内存空间极有可能不够用。</p>
<p><strong>邻接表</strong></p>
<ol>
<li>使用一个大小为V的数组 Queue[V] adj，把索引看做是顶点；</li>
<li>每个索引处adj[v]存储了一个队列，该队列中存储的是所有与该顶点相邻的其他顶点</li>
</ol>
<p>邻接表的空间并不是是线性级别的，采用邻接表这种存储形式来表示图</p>
<h5 id="图的实现"><a href="#图的实现" class="headerlink" title="图的实现"></a><strong>图的实现</strong></h5><p><strong>API设计</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>UndirectedGraph</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>UndirectedGraph(int V)：创建一个包含V个顶点但不包含边的图</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public int V():获取图中顶点的数量<br>2.public int E():获取图中边的数量<br>3.public void addEdge(int v,int w):向图中添加一条边 v-w<br>4.public Queue adj(int v)：获取和顶点v相邻的所有顶点</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private int V: 记录顶点数量<br>2.private int E: 记录边数量<br>3.private Queue[] adj: 邻接表</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.graph;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 无向图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-21</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UndirectedGraph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="comment">//边的数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> E;</span><br><span class="line">    <span class="comment">//邻接表</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt;[] adj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UndirectedGraph</span><span class="params">(<span class="type">int</span> V)</span>&#123;</span><br><span class="line">        <span class="comment">//初始化顶点数量</span></span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        <span class="comment">//初始化边的数量</span></span><br><span class="line">        <span class="built_in">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化邻接表</span></span><br><span class="line">        <span class="built_in">this</span>.adj = <span class="keyword">new</span> <span class="title class_">Queue</span>[V];</span><br><span class="line">        <span class="comment">//初始化邻接表中的空队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; adj.length; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> <span class="title class_">Queue</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取顶点数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">V</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取图中边的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">E</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向图中添加一条边 v-w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">        <span class="comment">//把w添加到v的链表中，这样顶点v就多了一个相邻点w</span></span><br><span class="line">        adj[v].enqueue(w);</span><br><span class="line">        <span class="comment">//把v添加到w的链表中，这样顶点w就多了一个相邻点v</span></span><br><span class="line">        adj[w].enqueue(v);</span><br><span class="line">        <span class="comment">//边的数目自增1</span></span><br><span class="line">        E++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取和顶点v相邻的所有顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">adj</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="图的搜索"><a href="#图的搜索" class="headerlink" title="图的搜索"></a>图的搜索</h5><p><strong>深度优先搜索</strong></p>
<p>​		所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找子结点，然后找兄弟结点。</p>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>DepthFirstSearch</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>DepthFirstSearch(UndirectedGraph G,int s)：构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相通顶点</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private void dfs(UndirectedGraph G, int v)：使用深度优先搜索找出G图中v顶点的所有相通顶点<br>2.public boolean marked(int w):判断w顶点与s顶点是否相通<br>3.public int count():获取与顶点s相通的所有顶点的总数</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索<br>2.private int count：记录有多少个顶点与s顶点相通</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 深度优先搜索</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepthFirstSearch</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索引代表顶点，值表示当前顶点是否已经被搜索</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录有多少个顶点与s顶点相通</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相通顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DepthFirstSearch(UndirectedGraph G,<span class="type">int</span> s)&#123;</span><br><span class="line">        <span class="comment">//创建一个和图的顶点数一样大小的布尔数组</span></span><br><span class="line">        marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[G.V()];</span><br><span class="line">        <span class="comment">//搜索G图中与顶点s相同的所有顶点</span></span><br><span class="line">        dfs(G,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用深度优先搜索找出G图中v顶点的所有相通顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(UndirectedGraph G, <span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="comment">//把当前顶点标记为已搜索</span></span><br><span class="line">        marked[v]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//遍历v顶点的邻接表，得到每一个顶点w</span></span><br><span class="line">        <span class="keyword">for</span> (Integer w : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked(w))&#123;</span><br><span class="line">                dfs(G,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//相通的顶点数量+1</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断w顶点与s顶点是否相通</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">marked</span><span class="params">(<span class="type">int</span> w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取与顶点s相通的所有顶点的总数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>广度优先搜索</strong></p>
<p>​		所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找兄弟结点，然后找子结点</p>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>BreadthFirstSearch</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>BreadthFirstSearch(UndirectedGraph G,int s)：构造广度优先搜索对象，使用广度优先搜索找出G图中s顶点的所有相通顶点</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private void dfs(UndirectedGraph G, int v)：使用深度优先搜索找出G图中v顶点的所有相通顶点<br>2.public boolean marked(int w):判断w顶点与s顶点是否相通<br>3.public int count():获取与顶点s相通的所有顶点的总数</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索<br>2.private int count：记录有多少个顶点与s顶点相通<br>3.private Queue waitSearch: 用来存储待搜索邻接表的点</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gxl.datastructure.line.QuenenLink;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 广度优先搜索</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BreadthFirstSearch</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索引代表顶点，值表示当前顶点是否已经被搜索</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录有多少个顶点与s顶点相通</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存储待搜索邻接表的点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> QuenenLink&lt;Integer&gt; waitSearch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造广度优先搜索对象，使用深广优先搜索找出G图中s顶点的所有相通顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BreadthFirstSearch(UndirectedGraph G, <span class="type">int</span> s)&#123;</span><br><span class="line">        <span class="comment">//创建一个和图的顶点数一样大小的布尔数组</span></span><br><span class="line">        marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[G.V()];</span><br><span class="line">        <span class="comment">//初始化待搜索顶点的队列</span></span><br><span class="line">        waitSearch = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//搜索G图中与顶点s相同的所有顶点</span></span><br><span class="line">        dfs(G,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用广度优先搜索找出G图中v顶点的所有相通顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(UndirectedGraph G, <span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="comment">//把当前顶点标记为已搜索</span></span><br><span class="line">        marked[v]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//把当前顶点v放入到队列中，等待搜索它的邻接表</span></span><br><span class="line">        waitSearch.enqueue(v);</span><br><span class="line">        <span class="comment">//使用while循环从队列中拿出待搜索的顶点wait，进行搜索邻接表</span></span><br><span class="line">        <span class="keyword">while</span> (!waitSearch.isEmpty())&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">wait</span> <span class="operator">=</span> waitSearch.dequeue();</span><br><span class="line">            <span class="keyword">for</span> (Integer w : G.adj(wait)) &#123;</span><br><span class="line">                <span class="comment">//如果当前顶点w没有被搜索过，则递归搜索与w顶点相通的其他顶点</span></span><br><span class="line">                <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                    dfs(G, w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//相通的顶点数量+1</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断w顶点与s顶点是否相通</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">marked</span><span class="params">(<span class="type">int</span> w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取与顶点s相通的所有顶点的总数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>路径查找</strong></p>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>DepthFirstPaths</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>DepthFirstPaths(UndirectedGraph G,int s)：构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相通顶点</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.private void dfs(UndirectedGraph G, int v)：使用深度优先搜索找出G图中v顶点的所有相通顶点<br>2.public boolean hasPathTo(int v):判断v顶点与s顶点是否存在路径<br>3.public Stack pathTo(int v):找出从起点s到顶点v的路径(就是该路径经过的顶点)</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索<br>2.private int s：起点<br>3.private int[] edgeTo: 索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点</td>
</tr>
</tbody></table>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gxl.datastructure.line.StackLink;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 路径查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepthFirstPaths</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索引代表顶点，值表示当前顶点是否已经被搜索</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> s;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] edgeTo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造深度优先搜索对象，使用深度优先搜索找出G图中起点为s的所有路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DepthFirstPaths</span><span class="params">(UndirectedGraph G, <span class="type">int</span> s)</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个和图的顶点数一样大小的布尔数组</span></span><br><span class="line">        marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[G.V()];</span><br><span class="line">        <span class="comment">//创建一个和图顶点数一样大小的整型数组</span></span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="title class_">int</span>[G.V()];</span><br><span class="line">        <span class="comment">//初始化顶点</span></span><br><span class="line">        <span class="built_in">this</span>.s=s;</span><br><span class="line">        <span class="comment">//搜索G图中起点为s的所有路径</span></span><br><span class="line">        dfs(G,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用深度优先搜索找出G图中v顶点的所有相通顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(UndirectedGraph G, <span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="comment">//把当前顶点标记为已搜素</span></span><br><span class="line">        marked[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//遍历v顶点的邻接表，得到每个顶点w</span></span><br><span class="line">        <span class="keyword">for</span> (Integer w : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[w])&#123;</span><br><span class="line">                <span class="comment">//如果当前顶点w没有被搜索过，则将edgeTo[w]设置为v,表示w的前一个顶点为v，并递归搜索与w顶点相通的其他顶点</span></span><br><span class="line">                edgeTo[w] = v;</span><br><span class="line">                dfs(G,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v顶点与s顶点是否存在路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathTo</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找出从起点s到顶点v的路径(就是该路径经过的顶点)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> StackLink&lt;Integer&gt; <span class="title function_">pathTo</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="comment">//当前v顶点与s顶点不连通，所以直接返回null，没有路径</span></span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建路径中经过的顶点的容器</span></span><br><span class="line">        StackLink&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">StackLink</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//第一次把当前顶点存进去，然后将x变换为到达当前顶点的前一个顶点edgeTo[x],在把前一个顶点存进去，继续将x变化为到达前一个顶点的前一个顶点，继续存，一直到x的值为s为止，相当于逆推法，最后把s放进去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> v; x != s ; x=edgeTo[x]) &#123;</span><br><span class="line">            <span class="comment">//把当前顶点放入容器</span></span><br><span class="line">            path.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        path.push(s);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h4><p><strong>有向图的定义及相关术语</strong></p>
<p><strong>定义：</strong></p>
<p>有向图是一副具有方向性的图，是由一组顶点和一组有方向的边组成的，每条方向的边都连着一对有序的顶点。</p>
<p><strong>出度：</strong></p>
<p>由某个顶点指出的边的个数称为该顶点的出度。</p>
<p><strong>入度：</strong></p>
<p>指向某个顶点的边的个数称为该顶点的入度。</p>
<p><strong>有向路径：</strong></p>
<p>由一系列顶点组成，对于其中的每个顶点都存在一条有向边，从它指向序列中的下一个顶点。</p>
<p><strong>有向环：</strong></p>
<p>一条至少含有一条边，且起点和终点相同的有向路径。</p>
<p><strong>API设计</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Digraph</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Digraph(int V)：创建一个包含V个顶点但不包含边的有向图</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public int V():获取图中顶点的数量<br>2.public int E():获取图中边的数量<br>3.public void addEdge(int v,int w):向有向图中添加一条边 v-&gt;w<br>4.public QueueList adj(int v)：获取由v指出的边所连接的所有顶点<br>5.private Digraph reverse():该图的反向图</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private int V: 记录顶点数量<br>2.private int E: 记录边数量<br>3.private QueueList[] adj: 邻接表</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.datastructure.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gxl.datastructure.line.QuenenLink;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 有向图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Digraph</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录顶点数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录边数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> E;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 邻接表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> QuenenLink&lt;Integer&gt;[] adj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法：创建一个包含V个顶点但不包含边的有向图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> V</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Digraph</span><span class="params">(<span class="type">int</span> V)</span>&#123;</span><br><span class="line">        <span class="comment">//初始化顶点数量</span></span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        <span class="comment">//初始化边的数量</span></span><br><span class="line">        <span class="built_in">this</span>.E=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化邻接表</span></span><br><span class="line">        <span class="built_in">this</span>.adj = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>[V];</span><br><span class="line">        <span class="comment">//初始化邻接表中的空队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; adj.length; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> <span class="title class_">QuenenLink</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取图中顶点的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">V</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取图中边的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">E</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向有向图中添加一条边 v-&gt;w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">        <span class="comment">//由于有向图中边是有向的，v-&gt;w 边，只需要让w出现在v的邻接表中，而不需要让v出现在w的邻接表中</span></span><br><span class="line">        adj[v].enqueue(w);</span><br><span class="line">        E++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取由v指出的边所连接的所有顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> QuenenLink&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该图的反向图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Digraph <span class="title function_">reverse</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//创建新的有向图对象</span></span><br><span class="line">        <span class="type">Digraph</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Digraph</span>(V);</span><br><span class="line">        <span class="comment">//遍历0~V-1所有顶点,拿到每一个顶点v</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            <span class="comment">//得到原图中的v顶点对应的邻接表,原图中的边为 v-&gt;w,则反向图中边为w-&gt;v;</span></span><br><span class="line">            <span class="keyword">for</span> (Integer w : adj[v]) &#123;</span><br><span class="line">                r.addEdge(w,v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><strong>排序原理：</strong></p>
<ol>
<li><p>比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置</p>
</li>
<li><p>对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大</p>
<p>值。</p>
</li>
</ol>
<p><strong>API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Bubble</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Bubble()：创建Bubble对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序 <br>2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w<br>3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bubble</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组内的元素进行排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (greater(a[j],a[j+<span class="number">1</span>]))&#123;</span><br><span class="line">                    exch(a,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v是否大于w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v,Comparable w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换a数组中，索引i和索引j处的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] a = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Bubble.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>冒泡排序的时间复杂度O(N^2)</strong></p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><strong>排序原理：</strong></p>
<p> 1.每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引	处的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引</p>
<p> 2.交换第一个索引处和最小值所在的索引处的值</p>
<p><strong>选择排序API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Selection</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Selection()：创建Selection对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序 <br>2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w<br>3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 选择排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-24</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Selection</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组内的元素进行排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span> &#123;</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= a.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//默认第一个位最小值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">//从i的下一位开始遍历，比较找到最小值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (greater(a[i], a[j])) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换i和minIndex</span></span><br><span class="line">            exch(a, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v是否大于w</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v, Comparable w)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换a数组中，索引i和索引j处的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] a = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Selection.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p><strong>排序原理：</strong></p>
<p>1.把所有的元素分为两组，已经排序的和未排序的；</p>
<p>2.找到未排序的组中的第一个元素，向已经排序的组中进行插入；</p>
<p>3.倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待      	插入元素放到这个位置，其他的元素向后移动一位；</p>
<p><strong>插入排序API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Insertion</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Insertion()：创建Insertion对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序 <br>2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w<br>3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 插入排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-24</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Insertion</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组内的元素进行排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (greater(a[j-<span class="number">1</span>],a[j]))&#123;</span><br><span class="line">                    exch(a,j-<span class="number">1</span>,j);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v是否大于w</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v, Comparable w)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换a数组中，索引i和索引j处的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] a = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Insertion.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p><strong>排序原理：</strong></p>
<ol>
<li>选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组；</li>
<li>对分好组的每一组数据完成插入排序；</li>
<li>减小增长量，最小减为1，重复第二步操作。</li>
</ol>
<p><strong>希尔排序的API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Shell</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Shell()：创建Shell对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序 <br>2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w<br>3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gxl.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 希尔排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guoxueliang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2023-02-24</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shell</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组内的元素进行排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="comment">//确定增长量h的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (h&lt;N/<span class="number">2</span>)&#123;</span><br><span class="line">            h=h*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当增量小于1，排序结束</span></span><br><span class="line">        <span class="keyword">while</span> (h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//找到待插入的元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="comment">//a[i]就是待插入的元素</span></span><br><span class="line">                <span class="comment">//把a[i]插入到a[i-h],a[i-2h],a[i-3h]...序列中</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= h; j-=h) &#123;</span><br><span class="line">                    <span class="comment">//a[j]就是待插入元素，依次和a[j-h],a[j-2h],a[j-3h]进行比较，如果a[j]小，那么交换位置，如果不小于，a[j]大，则插入完成。</span></span><br><span class="line">                    <span class="keyword">if</span> (greater(a[j-h],a[j]))&#123;</span><br><span class="line">                        exch(a,j,j-h);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            h/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断v是否大于w</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v, Comparable w)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换a数组中，索引i和索引j处的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] a = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Shell.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><strong>排序原理：</strong></p>
<ol>
<li>尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止。</li>
<li>将相邻的两个子组进行合并成一个有序的大组；</li>
<li>不断的重复步骤2，直到最终只有一个组为止。</li>
</ol>
<p><strong>归并排序API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Merge</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Merge()：创建Merge对象</td>
</tr>
<tr>
<td>成员方法</td>
<td>1.public static void sort(Comparable[] a)：对数组内的元素进行排序 <br>2.private static void sort(Comparable[] a, int lo, int hi)：对数组a中从索引lo到索引hi之间的元素进行排序<br>3.private static void merge(Comparable[] a, int lo, int mid, int hi):从索引lo到索引mid为一个子组，从索引mid+1到索引hi为另一个子组，把数组a中的这两个子组的数据合并成一个有序的大组（从索引lo到索引hi）<br>4.private static boolean less(Comparable v,Comparable w):判断v是否小于w<br>5.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
<tr>
<td>成员变量</td>
<td>1.private static Comparable[] assist：完成归并操作需要的辅助数组</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
